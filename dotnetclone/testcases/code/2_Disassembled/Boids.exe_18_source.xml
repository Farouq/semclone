<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Settings.Designer.cs" startline="25" endline="27"><![CDATA[
             {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Settings.Designer.cs" startline="20" endline="30"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
 
         public static Settings Default
         {
             get
             {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="37" endline="70"><![CDATA[
         public Boid(Tuple<Color,Color> colors)
         {
             if (colors == null) throw new ArgumentNullException("colors");
 
             // Store the colors
             _colors = colors;
             _materialBrush = new SolidColorBrush(colors.Item1);
             _backmaterialBrush = new SolidColorBrush(colors.Item2);
 
             // Set up the boid's model
             base.Content = new GeometryModel3D()
             {
                 Material = new DiffuseMaterial(_materialBrush),
                 BackMaterial = new DiffuseMaterial(_backmaterialBrush),
                 Geometry = new MeshGeometry3D()
                 {
                     // Two perpendicular triangles pointing up
                     Positions = Point3DCollection.Parse("0 1 0  1 -1 0  -1 -1 0  0 1 0  0 -1 1  0 -1 -1"), 
                     Normals = Vector3DCollection.Parse("0 0 -1  1 0 0"),
                     TriangleIndices = Int32Collection.Parse("0 1 2  3 4 5")
                 }
             };
 
             // Initialize its rotation and translation
             _rotation = new AxisAngleRotation3D(UNIT_Y, 0);
             _translation = new TranslateTransform3D(new Vector3D());
 
             // Add all of the necessary transforms
             var t = new Transform3DGroup();
             t.Children.Add(new ScaleTransform3D(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE));
             t.Children.Add(new RotateTransform3D(_rotation));
             t.Children.Add(_translation);
             base.Transform = t;
         }
 
         /// <summary>Gets or sets the boid's velocity.</summary>
         public Vector3D Velocity { get; set; }
         /// <summary>Gets or sets the boid's position.</summary>
         public Vector3D Position { get; set; }
 
         /// <summary>Gets the boid's previous velocity.</summary>
         public Vector3D PreviousVelocity { get; private set; }
         /// <summary>Gets the boid's previous position.</summary>
         public Vector3D PreviousPosition { get; private set; }
 
         /// <summary>Stores the current position and velocity into the previous.</summary>
         public void StorePositionAndVelocityIntoPrevious()
         {
             PreviousVelocity = Velocity;
             PreviousPosition = Position;
         }
 
         /// <summary>Sets the boid's rotation and translation for the scene.</summary>
         public void TransformByPositionAndVelocity()
         {
             var direction = Velocity;
             direction.Normalize();
 
             _rotation.Axis = Vector3D.CrossProduct(UNIT_Y, direction);
             _rotation.Angle = Math.Acos(Vector3D.DotProduct(UNIT_Y, direction) / (UNIT_Y.Length * direction.Length)) * (180 / Math.PI);
 
             var pos = Position;
             _translation.OffsetX = pos.X;
             _translation.OffsetY = pos.Y;
             _translation.OffsetZ = pos.Z;
         }
 
         public void ToggleTranslucency()
         {
             _materialBrush.Color = Color.FromArgb(
                 _materialBrush.Color.A < 255 ? (byte)255 
                 _materialBrush.Color.R,
                 _materialBrush.Color.G,
                 _materialBrush.Color.B);
             _backmaterialBrush.Color = Color.FromArgb(
                 _backmaterialBrush.Color.A < 255 ? (byte)255 
                 _backmaterialBrush.Color.R,
                 _backmaterialBrush.Color.G,
                 _backmaterialBrush.Color.B);
         }
 
         /// <summary>Computes the angle between two boids based on the current boid's direction.</summary>
         /// <param name="other">The other boid.</param>
         /// <returns>The angle.</returns>
         public double ComputeAngle(Boid other)
         {
             if (other == null) throw new ArgumentNullException("comparisonBoid");
             return Math.Acos(
                 Vector3D.DotProduct(this.PreviousVelocity, other.PreviousPosition - this.PreviousPosition) /
                     (this.PreviousVelocity.Length * (other.PreviousPosition - this.PreviousPosition).Length))
                 * (180 / Math.PI);
         }
 
         MeshGeometry3D GenerateSphere(Point3D center, double radius, int slices, int stacks)
         {
             // Create the MeshGeometry3D.
             MeshGeometry3D mesh = new MeshGeometry3D();
 
             // Fill the Position, Normals, and TextureCoordinates collections.
             for (int stack = 0; stack <= stacks; stack++)
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             if (colors == null) throw new ArgumentNullException("colors");
 
             // Store the colors
             _colors = colors;
             _materialBrush = new SolidColorBrush(colors.Item1);
             _backmaterialBrush = new SolidColorBrush(colors.Item2);
 
             // Set up the boid's model
             base.Content = new GeometryModel3D()
             {
                 Material = new DiffuseMaterial(_materialBrush),
                 BackMaterial = new DiffuseMaterial(_backmaterialBrush),
                 Geometry = new MeshGeometry3D()
                 {
                     // Two perpendicular triangles pointing up
                     Positions = Point3DCollection.Parse("0 1 0  1 -1 0  -1 -1 0  0 1 0  0 -1 1  0 -1 -1"), 
                     Normals = Vector3DCollection.Parse("0 0 -1  1 0 0"),
                     TriangleIndices = Int32Collection.Parse("0 1 2  3 4 5")
                 }
             };
 
             // Initialize its rotation and translation
             _rotation = new AxisAngleRotation3D(UNIT_Y, 0);
             _translation = new TranslateTransform3D(new Vector3D());
 
             // Add all of the necessary transforms
             var t = new Transform3DGroup();
             t.Children.Add(new ScaleTransform3D(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE));
             t.Children.Add(new RotateTransform3D(_rotation));
             t.Children.Add(_translation);
             base.Transform = t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="71" endline="87"><![CDATA[
 
         /// <summary>Gets or sets the boid's velocity.</summary>
         public Vector3D Velocity { get; set; }
         /// <summary>Gets or sets the boid's position.</summary>
         public Vector3D Position { get; set; }
 
         /// <summary>Gets the boid's previous velocity.</summary>
         public Vector3D PreviousVelocity { get; private set; }
         /// <summary>Gets the boid's previous position.</summary>
         public Vector3D PreviousPosition { get; private set; }
 
         /// <summary>Stores the current position and velocity into the previous.</summary>
         public void StorePositionAndVelocityIntoPrevious()
         {
             PreviousVelocity = Velocity;
             PreviousPosition = Position;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="88" endline="102"><![CDATA[
 
         /// <summary>Sets the boid's rotation and translation for the scene.</summary>
         public void TransformByPositionAndVelocity()
         {
             var direction = Velocity;
             direction.Normalize();
 
             _rotation.Axis = Vector3D.CrossProduct(UNIT_Y, direction);
             _rotation.Angle = Math.Acos(Vector3D.DotProduct(UNIT_Y, direction) / (UNIT_Y.Length * direction.Length)) * (180 / Math.PI);
 
             var pos = Position;
             _translation.OffsetX = pos.X;
             _translation.OffsetY = pos.Y;
             _translation.OffsetZ = pos.Z;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="103" endline="116"><![CDATA[
 
         public void ToggleTranslucency()
         {
             _materialBrush.Color = Color.FromArgb(
                 _materialBrush.Color.A < 255 ? (byte)255 
                 _materialBrush.Color.R,
                 _materialBrush.Color.G,
                 _materialBrush.Color.B);
             _backmaterialBrush.Color = Color.FromArgb(
                 _backmaterialBrush.Color.A < 255 ? (byte)255 
                 _backmaterialBrush.Color.R,
                 _backmaterialBrush.Color.G,
                 _backmaterialBrush.Color.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="117" endline="128"><![CDATA[
 
         /// <summary>Computes the angle between two boids based on the current boid's direction.</summary>
         /// <param name="other">The other boid.</param>
         /// <returns>The angle.</returns>
         public double ComputeAngle(Boid other)
         {
             if (other == null) throw new ArgumentNullException("comparisonBoid");
             return Math.Acos(
                 Vector3D.DotProduct(this.PreviousVelocity, other.PreviousPosition - this.PreviousPosition) /
                     (this.PreviousVelocity.Length * (other.PreviousPosition - this.PreviousPosition).Length))
                 * (180 / Math.PI);
         }
 
         MeshGeometry3D GenerateSphere(Point3D center, double radius, int slices, int stacks)
         {
             // Create the MeshGeometry3D.
             MeshGeometry3D mesh = new MeshGeometry3D();
 
             // Fill the Position, Normals, and TextureCoordinates collections.
             for (int stack = 0; stack <= stacks; stack++)
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             if (other == null) throw new ArgumentNullException("comparisonBoid");
             return Math.Acos(
                 Vector3D.DotProduct(this.PreviousVelocity, other.PreviousPosition - this.PreviousPosition) /
                     (this.PreviousVelocity.Length * (other.PreviousPosition - this.PreviousPosition).Length))
                 * (180 / Math.PI);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="129" endline="177"><![CDATA[
 
         MeshGeometry3D GenerateSphere(Point3D center, double radius, int slices, int stacks)
         {
             // Create the MeshGeometry3D.
             MeshGeometry3D mesh = new MeshGeometry3D();
 
             // Fill the Position, Normals, and TextureCoordinates collections.
             for (int stack = 0; stack <= stacks; stack++)
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             }
             for (int stack = 0; stack <= stacks; stack++)
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             }
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
             return mesh;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Boid.cs" startline="20" endline="179"><![CDATA[
         private static readonly Vector3D UNIT_Y = new Vector3D(0, 1, 0);
         /// <summary>Multiplicative factor to control the size of a boid.</summary>
         private const int MODEL_SCALE = 3;
 
         /// <summary>Rotation of the boid.</summary>
         private AxisAngleRotation3D _rotation;
         /// <summary>Translation of the boid.</summary>
         private TranslateTransform3D _translation;
         /// <summary>The boid's colors.</summary>
         private Tuple<Color, Color> _colors;
         /// <summary>The brush for the material.</summary>
         private SolidColorBrush _materialBrush;
         /// <summary>The brush for the backmaterial.</summary>
         private SolidColorBrush _backmaterialBrush;
 
         /// <summary>Initializes the boid.</summary>
         /// <param name="colors">The boids color's, Item1 for Material and Item2 for BackMaterial.</param>
         public Boid(Tuple<Color,Color> colors)
         {
             if (colors == null) throw new ArgumentNullException("colors");
 
             // Store the colors
             _colors = colors;
             _materialBrush = new SolidColorBrush(colors.Item1);
             _backmaterialBrush = new SolidColorBrush(colors.Item2);
 
             // Set up the boid's model
             base.Content = new GeometryModel3D()
             {
                 Material = new DiffuseMaterial(_materialBrush),
                 BackMaterial = new DiffuseMaterial(_backmaterialBrush),
                 Geometry = new MeshGeometry3D()
                 {
                     // Two perpendicular triangles pointing up
                     Positions = Point3DCollection.Parse("0 1 0  1 -1 0  -1 -1 0  0 1 0  0 -1 1  0 -1 -1"), 
                     Normals = Vector3DCollection.Parse("0 0 -1  1 0 0"),
                     TriangleIndices = Int32Collection.Parse("0 1 2  3 4 5")
                 }
             };
 
             // Initialize its rotation and translation
             _rotation = new AxisAngleRotation3D(UNIT_Y, 0);
             _translation = new TranslateTransform3D(new Vector3D());
 
             // Add all of the necessary transforms
             var t = new Transform3DGroup();
             t.Children.Add(new ScaleTransform3D(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE));
             t.Children.Add(new RotateTransform3D(_rotation));
             t.Children.Add(_translation);
             base.Transform = t;
         }
 
         /// <summary>Gets or sets the boid's velocity.</summary>
         public Vector3D Velocity { get; set; }
         /// <summary>Gets or sets the boid's position.</summary>
         public Vector3D Position { get; set; }
 
         /// <summary>Gets the boid's previous velocity.</summary>
         public Vector3D PreviousVelocity { get; private set; }
         /// <summary>Gets the boid's previous position.</summary>
         public Vector3D PreviousPosition { get; private set; }
 
         /// <summary>Stores the current position and velocity into the previous.</summary>
         public void StorePositionAndVelocityIntoPrevious()
         {
             PreviousVelocity = Velocity;
             PreviousPosition = Position;
         }
 
         /// <summary>Sets the boid's rotation and translation for the scene.</summary>
         public void TransformByPositionAndVelocity()
         {
             var direction = Velocity;
             direction.Normalize();
 
             _rotation.Axis = Vector3D.CrossProduct(UNIT_Y, direction);
             _rotation.Angle = Math.Acos(Vector3D.DotProduct(UNIT_Y, direction) / (UNIT_Y.Length * direction.Length)) * (180 / Math.PI);
 
             var pos = Position;
             _translation.OffsetX = pos.X;
             _translation.OffsetY = pos.Y;
             _translation.OffsetZ = pos.Z;
         }
 
         public void ToggleTranslucency()
         {
             _materialBrush.Color = Color.FromArgb(
                 _materialBrush.Color.A < 255 ? (byte)255 
                 _materialBrush.Color.R,
                 _materialBrush.Color.G,
                 _materialBrush.Color.B);
             _backmaterialBrush.Color = Color.FromArgb(
                 _backmaterialBrush.Color.A < 255 ? (byte)255 
                 _backmaterialBrush.Color.R,
                 _backmaterialBrush.Color.G,
                 _backmaterialBrush.Color.B);
         }
 
         /// <summary>Computes the angle between two boids based on the current boid's direction.</summary>
         /// <param name="other">The other boid.</param>
         /// <returns>The angle.</returns>
         public double ComputeAngle(Boid other)
         {
             if (other == null) throw new ArgumentNullException("comparisonBoid");
             return Math.Acos(
                 Vector3D.DotProduct(this.PreviousVelocity, other.PreviousPosition - this.PreviousPosition) /
                     (this.PreviousVelocity.Length * (other.PreviousPosition - this.PreviousPosition).Length))
                 * (180 / Math.PI);
         }
 
         MeshGeometry3D GenerateSphere(Point3D center, double radius, int slices, int stacks)
         {
             // Create the MeshGeometry3D.
             MeshGeometry3D mesh = new MeshGeometry3D();
 
             // Fill the Position, Normals, and TextureCoordinates collections.
             for (int stack = 0; stack <= stacks; stack++)
             {
                 double phi = Math.PI / 2 - stack * Math.PI / stacks;
                 double y = radius * Math.Sin(phi);
                 double scale = -radius * Math.Cos(phi);
 
                 for (int slice = 0; slice <= slices; slice++)
                 {
                     double theta = slice * 2 * Math.PI / slices;
                     double x = scale * Math.Sin(theta);
                     double z = scale * Math.Cos(theta);
 
                     Vector3D normal = new Vector3D(x, y, z);
                     mesh.Normals.Add(normal);
                     mesh.Positions.Add(normal + center);
                     mesh.TextureCoordinates.Add(new Point((double)slice / slices, (double)stack / stacks));
                 }
             }
 
             // Fill the TriangleIndices collection.
             for (int stack = 0; stack < stacks; stack++)
             {
                 for (int slice = 0; slice < slices; slice++)
                 {
                     int n = slices + 1; // Keep the line length down.
 
                     if (stack != 0)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                     }
                     if (stack != stacks - 1)
                     {
                         mesh.TriangleIndices.Add((stack + 0) * n + slice + 1);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice);
                         mesh.TriangleIndices.Add((stack + 1) * n + slice + 1);
                     }
                 }
             }
             return mesh;
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Resources.Designer.cs" startline="32" endline="35"><![CDATA[
         [global
         internal Resources()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Resources.Designer.cs" startline="36" endline="51"><![CDATA[
 
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 if ((resourceMan == null))
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
             set
             {
                 resourceCulture = value;
             }
         }
     }
 }
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Resources.Designer.cs" startline="52" endline="64"><![CDATA[
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\Properties\Resources.Designer.cs" startline="65" endline="68"><![CDATA[
             set
             {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\obj\Debug\App.g.cs" startline="47" endline="4"><![CDATA[
         public void InitializeComponent() {
              StartupUri="MainWindow.xaml">
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\obj\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\obj\Debug\App.g.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="40" endline="94"><![CDATA[
         private double m_speedLimit = 10.0;
         /// <summary>Multiplicative factor used when determining how much to move a boid towards the average position of boids in its neighborhood.</summary>
         private const double PERCENTAGE_TO_MOVE_TOWARDS_AVERAGE_POSITION = .01 * GLOBAL_MODIFICATION_RATE;
         /// <summary>Multiplicative factor used when determining how much to move a boid towards the average velocity of boids in its neighborhood.</summary>
         private const double PERCENTAGE_TO_MOVE_TOWARDS_AVERAGE_VELOCITY = .01 * GLOBAL_MODIFICATION_RATE;
         /// <summary>Multiplicative factor used when determining how much to move a boid towards staying in bounds if it's currently out of bounds.</summary>
         private const double PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS = .2 * GLOBAL_MODIFICATION_RATE;
         /// <summary>Multiplicative factor used when determining how much to move a boid towards its "home" position.</summary>
         private const double PERCENTAGE_TO_MOVE_TOWARDS_HOME = .01 * GLOBAL_MODIFICATION_RATE;
         /// <summary>Multiplicative factor included in all velocity-modifying rates.</summary>
         private const double GLOBAL_MODIFICATION_RATE = 1.0;
         /// <summary>Base weight to use for rule #1
         private double m_rule1Weight = 1.0;
         /// <summary>Base weight to use for rule #2
         private double m_rule2Weight = 1.1;
         /// <summary>Base weight to use for rule #3
         private double m_rule3Weight = 1.0;
         /// <summary>Base weight to use for rule #4
         private double m_rule4Weight = 0.9;
         /// <summary>Base weight to use for rule #5
         private double m_rule5Weight = 0.8;
         #endregion
 
         #region Member Variables
         /// <summary>The boids.</summary>
         private Boid[] m_boidModels;
         /// <summary>The bounds of the aviary in which the boids fly.</summary>
         private Rect3D m_aviary;
         /// <summary>The "home" position boids tend towards.</summary>
         private Vector3D m_home;
         /// <summary>Parallel options to use for parallelized loops.</summary>
         private ParallelOptions m_parallelOptions = new ParallelOptions() { MaxDegreeOfParallelism = 1 };
         /// <summary>Whether to move the camera automatically to keep boids in view.</summary>
         private bool m_autoPanCamera = true;
         /// <summary>Timer used to control scattering behavior when boids get spooked.</summary>
         private Timer m_scatterTimer;
         /// <summary>Timer used to control the rendering signal.</summary>
         private System.Timers.Timer m_renderTimer;
         /// <summary>Event used to signal the background processing thread that it should compute a new frame.</summary>
         private AutoResetEvent m_renderSignal = new AutoResetEvent(false);
         /// <summary>Stopwatch used to time how long it takes to compute a frame.</summary>
         private Stopwatch m_frameStopwatch = new Stopwatch();
         /// <summary>The number of frames rendered since the last time the value was displayed to the user.</summary>
         private int m_numRendersSinceLastUserPresentation = 0;
         /// <summary>The total time spent rendering since the last time the value was displayed to the user.</summary>
         private long m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
         /// <summary>The next time the sec/frame value should be displayed to the user.</summary>
         private DateTimeOffset m_nextUserPresentation = DateTimeOffset.Now;
         /// <summary>The last mouse position while it was down.</summary>
         private Point _lastMousePosition;
         #endregion
 
         #region Initialization
         /// <summary>Initializes the window.</summary>
         public MainWindow() { InitializeComponent(); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="95" endline="130"><![CDATA[
 
         /// <summary>Initialize the scene.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs</param>
         private void Window_Loaded(object sender, RoutedEventArgs e)
         {
             this.Cursor = Cursors.Hand;
 
             // Set up the aviary.  This should match the size of the grass geometry configured in the XAML.
             m_aviary = new Rect3D(-300, 0, -400, 600, 180, 800);
             m_home = new Vector3D(0, 15, 0); // home is close to 0,0,0, just a bit off the ground
 
             // The color combinations to use for boids.  At least one combination is necessary,
             // but more can be added to get more variations.
             var colorCombinations = new Tuple<Color, Color>[]
             {
                 Tuple.Create(Colors.SeaGreen, Colors.Silver),
                 Tuple.Create(Colors.Pink, Colors.Purple),
                 Tuple.Create(Colors.Yellow, Colors.Gold)
             };
 
             // Generate all of the boids, with random color, position, and velocity assignments.  Then add them to the scene.
             var rand = new Random();
             m_boidModels = Enumerable.Range(0, NUM_BOIDS).Select(_ => new Boid(colorCombinations[rand.Next(0, colorCombinations.Length)])).ToArray();
             RandomizeBoidPositionsAndVelocities(rand);
             foreach (var boidModel in m_boidModels) viewport3D.Children.Add(boidModel);
 
             // Configure and start the rendering timer.  A System.Timers.Timer is used to make it easy to turn on and off.
             var renderTimerPeriod = (int)(1000.0 / FRAMES_PER_SECOND);
             m_renderTimer = new System.Timers.Timer(renderTimerPeriod);
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
         {
             this.Cursor = Cursors.Hand;
 
             // Set up the aviary.  This should match the size of the grass geometry configured in the XAML.
             m_aviary = new Rect3D(-300, 0, -400, 600, 180, 800);
             m_home = new Vector3D(0, 15, 0); // home is close to 0,0,0, just a bit off the ground
 
             // The color combinations to use for boids.  At least one combination is necessary,
             // but more can be added to get more variations.
             var colorCombinations = new Tuple<Color, Color>[]
             {
                 Tuple.Create(Colors.SeaGreen, Colors.Silver),
                 Tuple.Create(Colors.Pink, Colors.Purple),
                 Tuple.Create(Colors.Yellow, Colors.Gold)
             };
 
             // Generate all of the boids, with random color, position, and velocity assignments.  Then add them to the scene.
             var rand = new Random();
             m_boidModels = Enumerable.Range(0, NUM_BOIDS).Select(_ => new Boid(colorCombinations[rand.Next(0, colorCombinations.Length)])).ToArray();
             RandomizeBoidPositionsAndVelocities(rand);
             foreach (var boidModel in m_boidModels) viewport3D.Children.Add(boidModel);
 
             // Configure and start the rendering timer.  A System.Timers.Timer is used to make it easy to turn on and off.
             var renderTimerPeriod = (int)(1000.0 / FRAMES_PER_SECOND);
             m_renderTimer = new System.Timers.Timer(renderTimerPeriod);
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boidModel in m_boidModels) viewport3D.Children.Add(boidModel);
 
             // Configure and start the rendering timer.  A System.Timers.Timer is used to make it easy to turn on and off.
             var renderTimerPeriod = (int)(1000.0 / FRAMES_PER_SECOND);
             m_renderTimer = new System.Timers.Timer(renderTimerPeriod);
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boidModel in m_boidModels) viewport3D.Children.Add(boidModel);
 
             // Configure and start the rendering timer.  A System.Timers.Timer is used to make it easy to turn on and off.
             var renderTimerPeriod = (int)(1000.0 / FRAMES_PER_SECOND);
             m_renderTimer = new System.Timers.Timer(renderTimerPeriod);
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             var renderTimerPeriod = (int)(1000.0 / FRAMES_PER_SECOND);
             m_renderTimer = new System.Timers.Timer(renderTimerPeriod);
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="131" endline="148"><![CDATA[
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="149" endline="224"><![CDATA[
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="225" endline="233"><![CDATA[
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="234" endline="250"><![CDATA[
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="251" endline="278"><![CDATA[
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 Scatter();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="279" endline="318"><![CDATA[
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="319" endline="346"><![CDATA[
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="347" endline="354"><![CDATA[
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="355" endline="541"><![CDATA[
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="384" endline="402"><![CDATA[
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="403" endline="443"><![CDATA[
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="444" endline="492"><![CDATA[
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="493" endline="520"><![CDATA[
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="521" endline="528"><![CDATA[
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="529" endline="538"><![CDATA[
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\obj\Debug\MainWindow.g.cs" startline="1" endline="1"><![CDATA[
 ?<!--
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\obj\Debug\MainWindow.g.cs" startline="9" endline="9"><![CDATA[
         MouseWheel="Window_MouseWheel" MouseDoubleClick="Window_MouseDoubleClick" KeyDown="Window_KeyDown" MouseDown="Window_MouseDown" MouseMove="Window_MouseMove" Loaded="Window_Loaded">
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="125" endline="541"><![CDATA[
             m_renderTimer.Elapsed += (_, __) => m_renderSignal.Set();
             m_renderTimer.Enabled = true;
 
             // Start the rendering loop on a background thread
             Task.Factory.StartNew(RenderUpdateLoop);
         }
 
         /// <summary>Move the boids to random positions and velocities.</summary>
         /// <param name="rand">The random number generator to use.</param>
         private void RandomizeBoidPositionsAndVelocities(Random rand = null)
         {
             if (rand == null) rand = new Random();
             foreach (var boid in m_boidModels)
             {
                 boid.Position = new Vector3D(
                            rand.Next((int)m_aviary.X, (int)(m_aviary.X + m_aviary.SizeX)),
                            rand.Next((int)m_aviary.Y, (int)(m_aviary.Y + m_aviary.SizeY)),
                            rand.Next((int)m_aviary.Z, (int)(m_aviary.Z + m_aviary.SizeZ)));
                 boid.Velocity = new Vector3D(
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1,
                            rand.NextDouble() * 2 - 1);
             }
         }
         #endregion
 
         #region Window Interaction Controls
         /// <summary>Handle keydown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_KeyDown(object sender, KeyEventArgs e)
         {
             // If escape is pressed, normalize the window size
             if (e.Key == Key.Escape)
             {
                 Topmost = false;
                 WindowStyle = WindowStyle.ThreeDBorderWindow;
                 WindowState = WindowState.Normal;
             }
 
                 // If 'P' is pressed, switch back and forth between serial and parallel
             else if (e.Key == Key.P)
             {
                 int procCount = Environment.ProcessorCount;
                 m_parallelOptions.MaxDegreeOfParallelism = m_parallelOptions.MaxDegreeOfParallelism == 1 ? procCount 
             }
 
                 // If 'b' is pressed, break/pause the scene until 'b' is pressed again
             else if (e.Key == Key.B)
             {
                 m_renderTimer.Enabled = !m_renderTimer.Enabled;
             }
 
                 // If 't' is pressed, toggle translucency to enable following just one boid
             else if (e.Key == Key.T)
             {
                 for (int i = 1; i < m_boidModels.Length; i++) m_boidModels[i].ToggleTranslucency();
             }
 
                 // If 'a' is pressed, turn auto-panning/zoom of the camera on/off
             else if (e.Key == Key.A)
             {
                 m_autoPanCamera = !m_autoPanCamera;
             }
 
                 // If up or down is pressed and we're in auto-pan mode, 
             else if ((e.Key == Key.Up || e.Key == Key.Down) && !m_autoPanCamera)
             {
                 Zoom(e.Key == Key.Up ? 1 
             }
 
                 // If 'r' is pressed, reset all of the boids to random positions and velocities
             else if (e.Key == Key.R)
             {
                 RandomizeBoidPositionsAndVelocities();
             }
 
                 // If 'h', display usage instructions to the user
             else if (e.Key == Key.H)
             {
                 string instructions =
                     "** Window Controls **" + Environment.NewLine +
                     "Auto-Camera Positioning
                     "Pan
                     "Zoom In / Out
                     "Full Screen
                     "Restore to Normal Window Size
                     "Pause
                     "Translucency
                     Environment.NewLine +
                     "** Boid Controls **" + Environment.NewLine +
                     "Scatter
                     "Change Max Speed
                     "Randomize
                     Environment.NewLine +
                     "** Parallelism Controls **" + Environment.NewLine +
                     "Go Parallel
                 MessageBox.Show(this, instructions, "Instructions", MessageBoxButton.OK, MessageBoxImage.Information);
             }
         }
 
         /// <summary>Handle mousedown events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDown(object sender, MouseButtonEventArgs e)
         {
             // Log the last mouse position
             _lastMousePosition = e.GetPosition(this);
         }
 
         /// <summary>Handle mousewheel events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseWheel(object sender, MouseWheelEventArgs e)
         {
             // If ctrl is pressed, change the max bird speed based on the number of mousewheel turns
             if ((Keyboard.Modifiers & ModifierKeys.Control) != 0)
             {
                 const int MIN_SPEED = 2, MAX_SPEED = 10;
                 if (e.Delta > 0 && m_speedLimit < MAX_SPEED) m_speedLimit++;
                 else if (e.Delta < 0 && m_speedLimit > MIN_SPEED) m_speedLimit--;
             }
                 // Otherwise, as long as we're not in auto-panning/zooming mode,
                 // zoom in or out based on the number of mousewheel turns
             else if (!m_autoPanCamera) Zoom(e.Delta / Mouse.MouseWheelDeltaForOneLine); 
         }
 
         /// <summary>Handle mousedoubleclick events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseDoubleClick(object sender, MouseButtonEventArgs e)
         {
             // If the right mouse button is double clicked, alternate between maximized and normal view
             if (e.ChangedButton == MouseButton.Right)
             {
                 if (WindowState == WindowState.Maximized)
                 {
                     Topmost = false;
                     WindowStyle = WindowStyle.ThreeDBorderWindow;
                     WindowState = WindowState.Normal;
                 }
                 else
                 {
                     Topmost = true;
                     WindowStyle = WindowStyle.None;
                     WindowState = WindowState.Maximized;
                 }
             }
                 // If the left mouse button is double clicked, scatter the boids
             else if (e.ChangedButton == MouseButton.Left)
             {
                 Scatter();
             }
         }
 
         /// <summary>Scatter the boids.</summary>
         private void Scatter()
         {
             // Start scatterring if a scatter isn't already in process
             if (m_scatterTimer == null)
             {
                 // Ka'boom.  Something scares the boids.
                 SystemSounds.Hand.Play();
 
                 // Store original settings
                 var origHome = m_home;
                 var origRule1Weight = m_rule1Weight;
                 var origRule2Weight = m_rule2Weight;
                 var origRule4Weight = m_rule4Weight;
                 var origRule5Weight = m_rule5Weight;
 
                 // Create new scatter settings
                 m_home = new Vector3D(0, 0, 0);
                 m_rule1Weight = origRule1Weight * -5;
                 m_rule2Weight = origRule2Weight * 2;
                 m_rule4Weight = 0;
                 m_rule5Weight = origRule5Weight * -5;
 
                 // Start a timer to restore the original settings
                 m_scatterTimer = new Timer(_ =>
                 {
                     // Restore the original settings
                     m_home = origHome;
                     m_rule1Weight = origRule1Weight;
                     m_rule2Weight = origRule2Weight;
                     m_rule4Weight = origRule4Weight;
                     m_rule5Weight = origRule5Weight;
 
                     // Clean up the timer
                     m_scatterTimer.Dispose();
                     m_scatterTimer = null;
                 }, null, SCATTER_TIME, -1);
             }
         }
 
         /// <summary>Handle mousemove events.</summary>
         /// <param name="sender">The sender.</param>
         /// <param name="e">The eventargs.</param>
         private void Window_MouseMove(object sender, MouseEventArgs e)
         {
             // If we're not auto-panning
             if (!m_autoPanCamera)
             {
                 // Get the new mouse position and compute the difference from the previous
                 var newPosition = e.GetPosition(this);
                 var diff = _lastMousePosition - newPosition;
 
                 // If the left mouse position was pressed, pan based on the x/y differences
                 if (e.LeftButton == MouseButtonState.Pressed)
                 {
                     camMain.Position = new Point3D(camMain.Position.X + diff.X * .4, camMain.Position.Y - diff.Y * .4, camMain.Position.Z);
                 }
                     // If the middle button was pressed, zoom based on the y difference
                 else if (e.MiddleButton == MouseButtonState.Pressed)
                 {
                     Zoom((int)diff.Y);
                 }
 
                 // Store the new position
                 _lastMousePosition = newPosition;
             }
         }
 
         /// <summary>Zoom in or out based on the specified degree of zoom.</summary>
         /// <param name="amountOfChange">Amount to zoom in (positive) or out (negative).</param>
         private void Zoom(int amountOfChange)
         {
             const int ZOOM_FACTOR = 3;
             camMain.Position = Point3D.Add(camMain.Position, camMain.LookDirection * amountOfChange * ZOOM_FACTOR);
         }
         #endregion
 
         #region Step and Render
         /// <summary>Runs the rendering loop.</summary>
         private void RenderUpdateLoop()
         {
             // Loop forever...
             while (true)
             {
                 // Wait to receive a signal that we should render another frame
                 m_renderSignal.WaitOne();
 
                 // Start timing.
                 m_frameStopwatch.Restart();
 
                 // Update the positions and velocities of all of the boids.
                 StepBoids();
 
                 // Update our rendering stats for display to the user
                 m_totalRenderingMillisecondsSinceLastUserPresentation += m_frameStopwatch.ElapsedMilliseconds;
                 m_numRendersSinceLastUserPresentation++;
 
                 // Render the boids to the UI
                 Dispatcher.Invoke((Action)RenderBoids, DispatcherPriority.Send, null);
             }
         }
 
         /// <summary>Step the boids one step, updating their velocities and positions.</summary>
         private void StepBoids()
         {
             // Store the current velocities and positions so that we can operate on an immutable copy
             foreach (var boid in m_boidModels) boid.StorePositionAndVelocityIntoPrevious();
 
             // For each boid, analyze how the various boid rules influence its velocity and position,
             // then store this new information.  After this step, we'll be able to render the boids.
             Parallel.ForEach(m_boidModels, m_parallelOptions, boid =>
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Boids\Boids_CSharp\MainWindow.xaml.cs" startline="391" endline="541"><![CDATA[
             {
                 var v1_2_3 = PrimaryRules_1_2_3(boid); // weights factored in already in PrimaryRules
                 var v4 = m_rule4Weight * Rule4_EncourageStayingWithinAviary(boid);
                 var v5 = m_rule5Weight * Rule5_TendendcyTowardsHome(boid);
 
                 boid.Velocity = BoundVelocity(boid.PreviousVelocity + v1_2_3 + v4 + v5, m_speedLimit);
                 boid.Velocity.Normalize();
 
                 var tmpPosition = boid.PreviousPosition + boid.Velocity;
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
                 if (tmpPosition.Y >= 0) boid.Position = tmpPosition;
             });
         }
 
         /// <summary>Render the boids.</summary>
         private void RenderBoids()
         {
             // Make sure the boids are all positioned and pointing correctly
             foreach (var boid in m_boidModels) boid.TransformByPositionAndVelocity();
 
             // Every once in a while, update the user-displayed stats on timings
             var now = DateTimeOffset.Now;
             if (now >= m_nextUserPresentation)
             {
                 Title = string.Format("Procs
                     m_numRendersSinceLastUserPresentation > 0 ? 
                     m_totalRenderingMillisecondsSinceLastUserPresentation / (double)m_numRendersSinceLastUserPresentation 
                     0);
                 m_nextUserPresentation = now.AddSeconds(1);
                 m_numRendersSinceLastUserPresentation = 0;
                 m_totalRenderingMillisecondsSinceLastUserPresentation = 0;
             }
 
             // If we're in auto-panning mode, move the camera appropriately
             if (m_autoPanCamera)
             {
                 // Compute the maximum Z value of all of the boids and the center of their mass
                 double maxZ = double.MinValue;
                 Vector3D totalPos = new Vector3D();
                 foreach (var boid in m_boidModels)
                 {
                     if (boid.Position.Z > maxZ) maxZ = boid.Position.Z;
                     totalPos += boid.Position;
                 }
                 var newCameraPos = totalPos / m_boidModels.Length;
                 
                 // Move the camera to point at the center of the boids, a ways back from the max boid's Z
                 const int CAMERA_DISTANCE_FROM_MAXZ = 100;
                 const double CAMERA_SPEED_LIMIT = .01;
                 var newPos = new Point3D(newCameraPos.X, newCameraPos.Y, maxZ + CAMERA_DISTANCE_FROM_MAXZ);
                 var cameraVelocity = newPos - camMain.Position;
                 camMain.Position = camMain.Position + (cameraVelocity * CAMERA_SPEED_LIMIT);
             }
         }
         #endregion
 
         #region Boid Rules
         /// <summary>Run the three primary rules of boidom.</summary>
         /// <param name="boid">The boid to process.</param>
         /// <returns>The velocity vector resulting from the three primary rules and their associated weights.</returns>
         private Vector3D PrimaryRules_1_2_3(Boid boid)
         {
             int numNearby = 0;
             Vector3D summedPosition = new Vector3D();
             Vector3D summedVelocity = new Vector3D();
             Vector3D summedSeparation = new Vector3D();
 
             // For rule #1, we want the boid to fly towards the center of all of those in its neighborhood.
             // We find all of those boids, average their positions, and create a velocity vector to move the
             // boid a bit of the way there.
 
             // For rule #2, we want the boid to move away from each other boid it's a bit too close to.
             // Find all of those boids in its immediate vicinity, and push it away.
 
             // For rule #3, we want the boid to match velocities with those boids in its neighborhood.
             // Sum their velocities, find the average, and move this boid's velocity a bit in that direction.
 
             foreach (var other in m_boidModels)
             {
                 if (other != boid && 
                     (other.PreviousPosition - boid.PreviousPosition).Length <= NEIGHBORHOOD_SIZE &&
                     boid.ComputeAngle(other) <= 135)
                 {
                     summedPosition += other.PreviousPosition;
                     summedVelocity += other.PreviousVelocity;
                     numNearby++;
 
                     if ((other.PreviousPosition - boid.PreviousPosition).Length < MIN_DISTANCE_FROM_NEIGHBOR)
                     {
                         summedSeparation -= (other.PreviousPosition - boid.PreviousPosition);
                     }
                 }
             }
 
             var rule1_flyTowardsCenter = (numNearby > 0 ? (summedPosition - boid.PreviousPosition) / numNearby 
             var rule2_separateFromNearby = summedSeparation;
             var rule3_matchVelocities = (numNearby > 0 ? (summedVelocity - boid.PreviousVelocity) / numNearby 
 
             return
                 (m_rule1Weight * rule1_flyTowardsCenter) +
                 (m_rule2Weight * rule2_separateFromNearby) +
                 (m_rule3Weight * rule3_matchVelocities);
         }
 
         /// <summary>Encourage a boid to stay within its aviary.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay within its bounds.</returns>
         private Vector3D Rule4_EncourageStayingWithinAviary(Boid boid)
         {
             var v = new Vector3D();
 
             // X
             if (boid.PreviousPosition.X < m_aviary.X)
                 v.X = m_aviary.X - boid.PreviousPosition.X;
             else if (boid.PreviousPosition.X > m_aviary.X + m_aviary.SizeX)
                 v.X = (m_aviary.X + m_aviary.SizeX) - boid.PreviousPosition.X;
 
             // Y
             if (boid.PreviousPosition.Y < m_aviary.Y)
                 v.Y = m_speedLimit;
             else if (boid.PreviousPosition.Y > m_aviary.Y + m_aviary.SizeY)
                 v.Y = (m_aviary.Y + m_aviary.SizeY) - boid.PreviousPosition.Y;
 
             // Z
             if (boid.PreviousPosition.Z < m_aviary.Z)
                 v.Z = m_aviary.Z - boid.PreviousPosition.Z;
             else if (boid.PreviousPosition.Z > m_aviary.Z + m_aviary.SizeZ)
                 v.Z = (m_aviary.Z + m_aviary.SizeZ) - boid.PreviousPosition.Z;
 
             return v * PERCENTAGE_TO_MOVE_TOWARDS_INBOUNDS;
         }
 
         /// <summary>Encourage a boid to stay close to its home position.</summary>
         /// <param name="boid">The boid.</param>
         /// <returns>The velocity vector encouraging a boid to stay at home.</returns>
         private Vector3D Rule5_TendendcyTowardsHome(Boid boid)
         {
             return (m_home - boid.PreviousPosition) * PERCENTAGE_TO_MOVE_TOWARDS_HOME;
         }
 
         /// <summary>Bound a velocity to the max speed limit.</summary>
         /// <param name="velocity">The velocity to bound.</param>
         /// <returns>The bounded velocity.</returns>
         private static Vector3D BoundVelocity(Vector3D velocity, double speedLimit)
         {
             return (velocity.Length > speedLimit) ?
                 (velocity / velocity.Length) * speedLimit 
                 velocity;
         }
         #endregion
     }
 }
]]></source>
</source_elements></project>
