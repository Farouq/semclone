<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             this.btnSequential = new System.Windows.Forms.Button();
             this.btnParallel = new System.Windows.Forms.Button();
             this.lblTime = new System.Windows.Forms.Label();
             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
             this.pbInput1 = new System.Windows.Forms.PictureBox();
             this.splitContainer2 = new System.Windows.Forms.SplitContainer();
             this.pbInput2 = new System.Windows.Forms.PictureBox();
             this.pbOutput = new System.Windows.Forms.PictureBox();
             this.lblSpeedup = new System.Windows.Forms.Label();
             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
             this.splitContainer1.Panel1.SuspendLayout();
             this.splitContainer1.Panel2.SuspendLayout();
             this.splitContainer1.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbInput1)).BeginInit();
             this.splitContainer2.Panel1.SuspendLayout();
             this.splitContainer2.Panel2.SuspendLayout();
             this.splitContainer2.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbInput2)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.pbOutput)).BeginInit();
             this.SuspendLayout();
             // 
             // btnSequential
             // 
             this.btnSequential.Enabled = false;
             this.btnSequential.Location = new System.Drawing.Point(12, 12);
             this.btnSequential.Name = "btnSequential";
             this.btnSequential.Size = new System.Drawing.Size(75, 23);
             this.btnSequential.TabIndex = 0;
             this.btnSequential.Text = "Sequential";
             this.btnSequential.UseVisualStyleBackColor = true;
             this.btnSequential.Click += new System.EventHandler(this.btnBlendImages_Click);
             // 
             // btnParallel
             // 
             this.btnParallel.Enabled = false;
             this.btnParallel.Location = new System.Drawing.Point(93, 12);
             this.btnParallel.Name = "btnParallel";
             this.btnParallel.Size = new System.Drawing.Size(75, 23);
             this.btnParallel.TabIndex = 1;
             this.btnParallel.Text = "Parallel";
             this.btnParallel.UseVisualStyleBackColor = true;
             this.btnParallel.Click += new System.EventHandler(this.btnBlendImages_Click);
             // 
             // lblTime
             // 
             this.lblTime.AutoSize = true;
             this.lblTime.Location = new System.Drawing.Point(174, 17);
             this.lblTime.Name = "lblTime";
             this.lblTime.Size = new System.Drawing.Size(0, 13);
             this.lblTime.TabIndex = 2;
             // 
             // splitContainer1
             // 
             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.splitContainer1.Location = new System.Drawing.Point(12, 41);
             this.splitContainer1.Name = "splitContainer1";
             // 
             // splitContainer1.Panel1
             // 
             this.splitContainer1.Panel1.Controls.Add(this.pbInput1);
             // 
             // splitContainer1.Panel2
             // 
             this.splitContainer1.Panel2.Controls.Add(this.splitContainer2);
             this.splitContainer1.Size = new System.Drawing.Size(860, 269);
             this.splitContainer1.SplitterDistance = 286;
             this.splitContainer1.TabIndex = 3;
             // 
             // pbInput1
             // 
             this.pbInput1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInput1.Cursor = System.Windows.Forms.Cursors.Hand;
             this.pbInput1.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbInput1.Location = new System.Drawing.Point(0, 0);
             this.pbInput1.Name = "pbInput1";
             this.pbInput1.Size = new System.Drawing.Size(286, 269);
             this.pbInput1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInput1.TabIndex = 0;
             this.pbInput1.TabStop = false;
             this.toolTip1.SetToolTip(this.pbInput1, "Double-click to load new image");
             this.pbInput1.DoubleClick += new System.EventHandler(this.pbInput_DoubleClick);
             // 
             // splitContainer2
             // 
             this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
             this.splitContainer2.Location = new System.Drawing.Point(0, 0);
             this.splitContainer2.Name = "splitContainer2";
             // 
             // splitContainer2.Panel1
             // 
             this.splitContainer2.Panel1.Controls.Add(this.pbInput2);
             // 
             // splitContainer2.Panel2
             // 
             this.splitContainer2.Panel2.Controls.Add(this.pbOutput);
             this.splitContainer2.Size = new System.Drawing.Size(570, 269);
             this.splitContainer2.SplitterDistance = 285;
             this.splitContainer2.TabIndex = 0;
             // 
             // pbInput2
             // 
             this.pbInput2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInput2.Cursor = System.Windows.Forms.Cursors.Hand;
             this.pbInput2.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbInput2.Location = new System.Drawing.Point(0, 0);
             this.pbInput2.Name = "pbInput2";
             this.pbInput2.Size = new System.Drawing.Size(285, 269);
             this.pbInput2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInput2.TabIndex = 1;
             this.pbInput2.TabStop = false;
             this.toolTip1.SetToolTip(this.pbInput2, "Double-click to load new image");
             this.pbInput2.DoubleClick += new System.EventHandler(this.pbInput_DoubleClick);
             // 
             // pbOutput
             // 
             this.pbOutput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbOutput.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbOutput.Location = new System.Drawing.Point(0, 0);
             this.pbOutput.Name = "pbOutput";
             this.pbOutput.Size = new System.Drawing.Size(281, 269);
             this.pbOutput.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbOutput.TabIndex = 1;
             this.pbOutput.TabStop = false;
             this.pbOutput.DoubleClick += new System.EventHandler(this.pbOutput_DoubleClick);
             // 
             // lblSpeedup
             // 
             this.lblSpeedup.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lblSpeedup.AutoSize = true;
             this.lblSpeedup.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lblSpeedup.ForeColor = System.Drawing.Color.Green;
             this.lblSpeedup.Location = new System.Drawing.Point(869, 17);
             this.lblSpeedup.Name = "lblSpeedup";
             this.lblSpeedup.Size = new System.Drawing.Size(0, 13);
             this.lblSpeedup.TabIndex = 4;
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(884, 322);
             this.Controls.Add(this.lblSpeedup);
             this.Controls.Add(this.splitContainer1);
             this.Controls.Add(this.lblTime);
             this.Controls.Add(this.btnParallel);
             this.Controls.Add(this.btnSequential);
             this.Name = "MainForm";
             this.Text = "Blend Images";
             this.splitContainer1.Panel1.ResumeLayout(false);
             this.splitContainer1.Panel2.ResumeLayout(false);
             this.splitContainer1.ResumeLayout(false);
             ((System.ComponentModel.ISupportInitialize)(this.pbInput1)).EndInit();
             this.splitContainer2.Panel1.ResumeLayout(false);
             this.splitContainer2.Panel2.ResumeLayout(false);
             this.splitContainer2.ResumeLayout(false);
             ((System.ComponentModel.ISupportInitialize)(this.pbInput2)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.pbOutput)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
 
         #endregion
 
         private System.Windows.Forms.Button btnSequential;
         private System.Windows.Forms.Button btnParallel;
         private System.Windows.Forms.Label lblTime;
         private System.Windows.Forms.SplitContainer splitContainer1;
         private System.Windows.Forms.PictureBox pbInput1;
         private System.Windows.Forms.SplitContainer splitContainer2;
         private System.Windows.Forms.PictureBox pbInput2;
         private System.Windows.Forms.PictureBox pbOutput;
         private System.Windows.Forms.Label lblSpeedup;
         private System.Windows.Forms.ToolTip toolTip1;
     }
 }
 
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.Designer.cs" startline="22" endline="194"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             this.btnSequential = new System.Windows.Forms.Button();
             this.btnParallel = new System.Windows.Forms.Button();
             this.lblTime = new System.Windows.Forms.Label();
             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
             this.pbInput1 = new System.Windows.Forms.PictureBox();
             this.splitContainer2 = new System.Windows.Forms.SplitContainer();
             this.pbInput2 = new System.Windows.Forms.PictureBox();
             this.pbOutput = new System.Windows.Forms.PictureBox();
             this.lblSpeedup = new System.Windows.Forms.Label();
             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
             this.splitContainer1.Panel1.SuspendLayout();
             this.splitContainer1.Panel2.SuspendLayout();
             this.splitContainer1.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbInput1)).BeginInit();
             this.splitContainer2.Panel1.SuspendLayout();
             this.splitContainer2.Panel2.SuspendLayout();
             this.splitContainer2.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbInput2)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.pbOutput)).BeginInit();
             this.SuspendLayout();
             // 
             // btnSequential
             // 
             this.btnSequential.Enabled = false;
             this.btnSequential.Location = new System.Drawing.Point(12, 12);
             this.btnSequential.Name = "btnSequential";
             this.btnSequential.Size = new System.Drawing.Size(75, 23);
             this.btnSequential.TabIndex = 0;
             this.btnSequential.Text = "Sequential";
             this.btnSequential.UseVisualStyleBackColor = true;
             this.btnSequential.Click += new System.EventHandler(this.btnBlendImages_Click);
             // 
             // btnParallel
             // 
             this.btnParallel.Enabled = false;
             this.btnParallel.Location = new System.Drawing.Point(93, 12);
             this.btnParallel.Name = "btnParallel";
             this.btnParallel.Size = new System.Drawing.Size(75, 23);
             this.btnParallel.TabIndex = 1;
             this.btnParallel.Text = "Parallel";
             this.btnParallel.UseVisualStyleBackColor = true;
             this.btnParallel.Click += new System.EventHandler(this.btnBlendImages_Click);
             // 
             // lblTime
             // 
             this.lblTime.AutoSize = true;
             this.lblTime.Location = new System.Drawing.Point(174, 17);
             this.lblTime.Name = "lblTime";
             this.lblTime.Size = new System.Drawing.Size(0, 13);
             this.lblTime.TabIndex = 2;
             // 
             // splitContainer1
             // 
             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.splitContainer1.Location = new System.Drawing.Point(12, 41);
             this.splitContainer1.Name = "splitContainer1";
             // 
             // splitContainer1.Panel1
             // 
             this.splitContainer1.Panel1.Controls.Add(this.pbInput1);
             // 
             // splitContainer1.Panel2
             // 
             this.splitContainer1.Panel2.Controls.Add(this.splitContainer2);
             this.splitContainer1.Size = new System.Drawing.Size(860, 269);
             this.splitContainer1.SplitterDistance = 286;
             this.splitContainer1.TabIndex = 3;
             // 
             // pbInput1
             // 
             this.pbInput1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInput1.Cursor = System.Windows.Forms.Cursors.Hand;
             this.pbInput1.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbInput1.Location = new System.Drawing.Point(0, 0);
             this.pbInput1.Name = "pbInput1";
             this.pbInput1.Size = new System.Drawing.Size(286, 269);
             this.pbInput1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInput1.TabIndex = 0;
             this.pbInput1.TabStop = false;
             this.toolTip1.SetToolTip(this.pbInput1, "Double-click to load new image");
             this.pbInput1.DoubleClick += new System.EventHandler(this.pbInput_DoubleClick);
             // 
             // splitContainer2
             // 
             this.splitContainer2.Dock = System.Windows.Forms.DockStyle.Fill;
             this.splitContainer2.Location = new System.Drawing.Point(0, 0);
             this.splitContainer2.Name = "splitContainer2";
             // 
             // splitContainer2.Panel1
             // 
             this.splitContainer2.Panel1.Controls.Add(this.pbInput2);
             // 
             // splitContainer2.Panel2
             // 
             this.splitContainer2.Panel2.Controls.Add(this.pbOutput);
             this.splitContainer2.Size = new System.Drawing.Size(570, 269);
             this.splitContainer2.SplitterDistance = 285;
             this.splitContainer2.TabIndex = 0;
             // 
             // pbInput2
             // 
             this.pbInput2.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbInput2.Cursor = System.Windows.Forms.Cursors.Hand;
             this.pbInput2.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbInput2.Location = new System.Drawing.Point(0, 0);
             this.pbInput2.Name = "pbInput2";
             this.pbInput2.Size = new System.Drawing.Size(285, 269);
             this.pbInput2.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbInput2.TabIndex = 1;
             this.pbInput2.TabStop = false;
             this.toolTip1.SetToolTip(this.pbInput2, "Double-click to load new image");
             this.pbInput2.DoubleClick += new System.EventHandler(this.pbInput_DoubleClick);
             // 
             // pbOutput
             // 
             this.pbOutput.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
             this.pbOutput.Dock = System.Windows.Forms.DockStyle.Fill;
             this.pbOutput.Location = new System.Drawing.Point(0, 0);
             this.pbOutput.Name = "pbOutput";
             this.pbOutput.Size = new System.Drawing.Size(281, 269);
             this.pbOutput.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
             this.pbOutput.TabIndex = 1;
             this.pbOutput.TabStop = false;
             this.pbOutput.DoubleClick += new System.EventHandler(this.pbOutput_DoubleClick);
             // 
             // lblSpeedup
             // 
             this.lblSpeedup.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lblSpeedup.AutoSize = true;
             this.lblSpeedup.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lblSpeedup.ForeColor = System.Drawing.Color.Green;
             this.lblSpeedup.Location = new System.Drawing.Point(869, 17);
             this.lblSpeedup.Name = "lblSpeedup";
             this.lblSpeedup.Size = new System.Drawing.Size(0, 13);
             this.lblSpeedup.TabIndex = 4;
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(884, 322);
             this.Controls.Add(this.lblSpeedup);
             this.Controls.Add(this.splitContainer1);
             this.Controls.Add(this.lblTime);
             this.Controls.Add(this.btnParallel);
             this.Controls.Add(this.btnSequential);
             this.Name = "MainForm";
             this.Text = "Blend Images";
             this.splitContainer1.Panel1.ResumeLayout(false);
             this.splitContainer1.Panel2.ResumeLayout(false);
             this.splitContainer1.ResumeLayout(false);
             ((System.ComponentModel.ISupportInitialize)(this.pbInput1)).EndInit();
             this.splitContainer2.Panel1.ResumeLayout(false);
             this.splitContainer2.Panel2.ResumeLayout(false);
             this.splitContainer2.ResumeLayout(false);
             ((System.ComponentModel.ISupportInitialize)(this.pbInput2)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.pbOutput)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="8" endline="24"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public MainForm() { InitializeComponent(); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="25" endline="48"><![CDATA[
 
         private void pbInput_DoubleClick(object sender, EventArgs e)
         {
             // Get the PictureBox that caused this event
             PictureBox pb = sender as PictureBox;
             if (pb == null) return;
 
             // Open a dialog to let the user select an image
             using (var ofd = new OpenFileDialog())
             {
                 if (ofd.ShowDialog() == DialogResult.OK)
                 {
                     // Store the new image into the PictureBox
                     Image newImage = new Bitmap(ofd.FileName);
                     Image oldImage = pb.Image;
                     pb.Image = newImage;
                     if (oldImage != null) oldImage.Dispose();
                 }
             }
 
             // Make sure the btns are enabled if they should be
             _lastSequentialTime = _lastParallelTime = null;
             btnSequential.Enabled = btnParallel.Enabled = (pbInput1.Image != null && pbInput2.Image != null);
         }
 
         private void pbOutput_DoubleClick(object sender, EventArgs e)
         {
             if (pbOutput.Image != null)
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             if (pb == null) return;
 
             // Open a dialog to let the user select an image
             using (var ofd = new OpenFileDialog())
             {
                 if (ofd.ShowDialog() == DialogResult.OK)
                 {
                     // Store the new image into the PictureBox
                     Image newImage = new Bitmap(ofd.FileName);
                     Image oldImage = pb.Image;
                     pb.Image = newImage;
                     if (oldImage != null) oldImage.Dispose();
                 }
             }
 
             // Make sure the btns are enabled if they should be
             _lastSequentialTime = _lastParallelTime = null;
             btnSequential.Enabled = btnParallel.Enabled = (pbInput1.Image != null && pbInput2.Image != null);
         }
 
         private void pbOutput_DoubleClick(object sender, EventArgs e)
         {
             if (pbOutput.Image != null)
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 {
                     // Store the new image into the PictureBox
                     Image newImage = new Bitmap(ofd.FileName);
                     Image oldImage = pb.Image;
                     pb.Image = newImage;
                     if (oldImage != null) oldImage.Dispose();
                 }
             }
 
             // Make sure the btns are enabled if they should be
             _lastSequentialTime = _lastParallelTime = null;
             btnSequential.Enabled = btnParallel.Enabled = (pbInput1.Image != null && pbInput2.Image != null);
         }
 
         private void pbOutput_DoubleClick(object sender, EventArgs e)
         {
             if (pbOutput.Image != null)
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                     if (oldImage != null) oldImage.Dispose();
                 }
             }
 
             // Make sure the btns are enabled if they should be
             _lastSequentialTime = _lastParallelTime = null;
             btnSequential.Enabled = btnParallel.Enabled = (pbInput1.Image != null && pbInput2.Image != null);
         }
 
         private void pbOutput_DoubleClick(object sender, EventArgs e)
         {
             if (pbOutput.Image != null)
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             _lastSequentialTime = _lastParallelTime = null;
             btnSequential.Enabled = btnParallel.Enabled = (pbInput1.Image != null && pbInput2.Image != null);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="49" endline="65"><![CDATA[
 
         private void pbOutput_DoubleClick(object sender, EventArgs e)
         {
             if (pbOutput.Image != null)
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             {
                 // Open a dialog to let the user select an output path
                 using (var sfd = new SaveFileDialog())
                 {
                     sfd.Filter = "Bitmap Images|*.bmp";
                     if (sfd.ShowDialog(this) == DialogResult.OK)
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                     {
                         // Save the image as a bitmap to the selected location
                         pbOutput.Image.Save(sfd.FileName, ImageFormat.Bmp);
                     }
                 }
             }
         }
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="66" endline="123"><![CDATA[
 
         private void btnBlendImages_Click(object sender, EventArgs e)
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
         {
             // Determine whether to run sequentially or in parallel based on the
             // button click that got us here
             bool isParallel = sender == btnParallel;
 
             // Get the images
             Bitmap bmp1 = (Bitmap)pbInput1.Image;
             Bitmap bmp2 = (Bitmap)pbInput2.Image;
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             if (bmp1 == null || bmp2 == null) return;
 
             // Clear the output image
             Image oldOutput = pbOutput.Image;
             pbOutput.Image = null;
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             if (oldOutput != null) oldOutput.Dispose();
 
             // Resize the second image's size to match that of the first
             if (bmp1.Size != bmp2.Size)
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             {
                 Bitmap newBmp2 = new Bitmap(bmp1.Width, bmp1.Height);
                 using (var g = Graphics.FromImage(newBmp2)) g.DrawImage(bmp2, 0, 0, newBmp2.Width, newBmp2.Height);
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 pbInput2.Image = newBmp2;
                 bmp2.Dispose();
                 bmp2 = newBmp2;
             }
 
             // Disable the form to prevent user interaction while merging
             EnableOrDisableFormControls(false);
             lblSpeedup.Text = string.Empty;
             lblTime.Text = string.Empty;
 
             // Do the work in the background
             var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
             Task.Factory.StartNew(delegate
             {
                 // Blend the images (and time the operation)
                 TimeSpan time;
                 Bitmap output = BlendImages(bmp1, bmp2, .5, isParallel, out time);
 
                 // Update our stats
                 if (isParallel) _lastParallelTime = time;
                 else _lastSequentialTime = time;
                 string speedup = (_lastSequentialTime != null && _lastParallelTime != null) ?
                     string.Format("Speedup
                     string.Empty;
 
                 // Pass results to the UI
                 return new { output, time, speedup };
             }).ContinueWith(t =>
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="124" endline="196"><![CDATA[
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                     }
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
             time = sw.Elapsed;
             return output;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="197" endline="203"><![CDATA[
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\MainForm.cs" startline="116" endline="205"><![CDATA[
             {
                 EnableOrDisableFormControls(true);
                 pbOutput.Image = t.Result.output;
                 lblTime.Text = "Time
                 lblSpeedup.Text = t.Result.speedup;
                 lblSpeedup.Location = new Point(splitContainer1.Right - lblSpeedup.Width, lblSpeedup.Location.Y);
             }, uiScheduler);
         }
 
         internal unsafe static Bitmap BlendImages(Bitmap start, Bitmap end, double blend, bool parallel, out TimeSpan time)
         {
             // Validate parameters
             if (start.Width != end.Width || start.Height != end.Height) 
                 throw new ArgumentException("The sizes of images do not match.");
             if (blend < 0 || blend > 1) 
                 throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
 
             // Create the output image
             int width = start.Width, height = start.Height;
             Bitmap output = new Bitmap(width, height);
             var sw = new Stopwatch();
 
             // Blend the input images into the output
             using (FastBitmap fastOut = new FastBitmap(output))
             using (FastBitmap fastStart = new FastBitmap(start))
             using (FastBitmap fastEnd = new FastBitmap(end))
             {
                 if (parallel)
                 {
                     // Blend the images in parallel
                     sw.Restart();
                     Parallel.For(0, height, j =>
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     });
                     sw.Stop();
                 }
                 else
                 {
                     // Blend the images sequentially
                     sw.Restart();
                     for(int j=0; j<height; j++)
                     {
                         PixelData* outPixel = fastOut.GetInitialPixelForRow(j);
                         PixelData* startPixel = fastStart.GetInitialPixelForRow(j);
                         PixelData* endPixel = fastEnd.GetInitialPixelForRow(j);
 
                         for (int i = 0; i < width; i++)
                         {
                             // Blend the input pixels into the output pixel
                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
 
                             outPixel++;
                             startPixel++;
                             endPixel++;
                         }
                     }
                     sw.Stop();
                 }
             }
 
             // Return the new image
             time = sw.Elapsed;
             return output;
         }
 
         private void EnableOrDisableFormControls(bool enable)
         {
             btnParallel.Enabled = enable;
             btnSequential.Enabled = enable;
             splitContainer1.Enabled = enable;
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Program.cs" startline="21" endline="25"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="34" endline="47"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
             set {
                 resourceCulture = value;
             }
         }
     }
 }
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="48" endline="58"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="59" endline="61"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\BlendImages\BlendImages_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
