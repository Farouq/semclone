
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern FSharp.Core
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly Raytracer_FSharp
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute::.ctor(int32,
                                                                                                      int32,
                                                                                                      int32) = ( 01 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 01 01 00 00 00 00 ) 

  .hash algorithm 0x00008004
  .ver 0:0:0:0
}
.mresource public FSharpSignatureData.Raytracer_FSharp
{
  // Offset: 0x00000000 Length: 0x00002D42
}
.mresource public FSharpOptimizationData.Raytracer_FSharp
{
  // Offset: 0x00002D48 Length: 0x0000093C
}
.module Raytracer_FSharp.exe
// MVID: {4F779472-8213-EA67-A745-03837294774F}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x005A0000


// =============== CLASS MEMBERS DECLARATION ===================

.class public abstract auto ansi sealed Harness
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public ObjectPool`1<a>
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!a> valueSelector
    .field assembly class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!a> objects
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!a> valueSelector) cil managed
    {
      // Code size       33 (0x21)
      .maxstack  4
      .language '{AB4F38C9-B6E6-43BA-BE3B-58080B2CCCE3}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_FSharp\harness.fs' 
//000051: type ObjectPool<'a>(valueSelector : unit -> 'a) = 
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!0> class Harness/ObjectPool`1<!a>::valueSelector
//000052:     let objects = new ConcurrentQueue<'a>() :> IProducerConsumerCollection<'a>
      IL_0010:  ldarg.0
      IL_0011:  newobj     instance void class [mscorlib]System.Collections.Concurrent.ConcurrentQueue`1<!a>::.ctor()
      IL_0016:  unbox.any  class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!a>
      IL_001b:  stfld      class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!0> class Harness/ObjectPool`1<!a>::objects
//000051: type ObjectPool<'a>(valueSelector : unit -> 'a) = 
      IL_0020:  ret
    } // end of method ObjectPool`1::.ctor

    .method public instance !a  GetObject() cil managed
    {
      // Code size       69 (0x45)
      .maxstack  4
      .locals init ([0] class [mscorlib]System.Tuple`2<bool,!a> V_0,
               [1] !a V_1,
               [2] !a V_2,
               [3] !a item,
               [4] bool b)
//000052:     let objects = new ConcurrentQueue<'a>() :> IProducerConsumerCollection<'a>
//000053:     member pool.GetObject () = 
//000054:         let b, item = objects.TryTake()
      IL_0000:  nop
      IL_0001:  ldloca.s   V_2
      IL_0003:  initobj    !a
      IL_0009:  ldloc.2
      IL_000a:  stloc.1
      IL_000b:  ldarg.0
      IL_000c:  ldfld      class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!0> class Harness/ObjectPool`1<!a>::objects
      IL_0011:  ldloca.s   V_1
      IL_0013:  callvirt   instance bool class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!a>::TryTake(!0&)
      IL_0018:  ldloc.1
      IL_0019:  newobj     instance void class [mscorlib]System.Tuple`2<bool,!a>::.ctor(!0,
                                                                                        !1)
      IL_001e:  stloc.0
      IL_001f:  ldloc.0
      IL_0020:  call       instance !1 class [mscorlib]System.Tuple`2<bool,!a>::get_Item2()
      IL_0025:  stloc.3
      IL_0026:  ldloc.0
      IL_0027:  call       instance !0 class [mscorlib]System.Tuple`2<bool,!a>::get_Item1()
      IL_002c:  stloc.s    b
//000055:         if b then item else valueSelector ()
      IL_002e:  ldloc.s    b
      IL_0030:  brfalse.s  IL_0034

      IL_0032:  br.s       IL_0036

      IL_0034:  br.s       IL_0038

      IL_0036:  ldloc.3
      IL_0037:  ret

      IL_0038:  ldarg.0
      IL_0039:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!0> class Harness/ObjectPool`1<!a>::valueSelector
      IL_003e:  ldnull
      IL_003f:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!a>::Invoke(!0)
      IL_0044:  ret
    } // end of method ObjectPool`1::GetObject

    .method public instance void  PutObject(!a o) cil managed
    {
      // Code size       17 (0x11)
      .maxstack  4
      .locals init ([0] bool V_0,
               [1] bool V_1)
//000056:     member pool.PutObject o = 
//000057:         objects.TryAdd(o) |> ignore
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!0> class Harness/ObjectPool`1<!a>::objects
      IL_0007:  ldarg.1
      IL_0008:  callvirt   instance bool class [mscorlib]System.Collections.Concurrent.IProducerConsumerCollection`1<!a>::TryAdd(!0)
      IL_000d:  stloc.0
      IL_000e:  ldloc.0
      IL_000f:  stloc.1
      IL_0010:  ret
    } // end of method ObjectPool`1::PutObject

  } // end of class ObjectPool`1

  .class auto ansi serializable nested public RayTracerForm
         extends [System.Windows.Forms]System.Windows.Forms.Form
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> this
    .field assembly class [System.Drawing]System.Drawing.Bitmap bitmap
    .field assembly class Harness/ObjectPool`1<int32[]> buffers
    .field assembly valuetype [System.Drawing]System.Drawing.Rectangle rect
    .field assembly class [mscorlib]System.Threading.Tasks.Task renderTask
    .field assembly bool isParallel
    .field assembly bool showThreads
    .field assembly int32 degreeOfParallelism
    .field assembly class [mscorlib]System.Threading.CancellationTokenSource cancellation
    .field assembly class [System.Windows.Forms]System.Windows.Forms.PictureBox pictureBox
    .field assembly int32 init@59
    .method public specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       1238 (0x4d6)
      .maxstack  9
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> this,
               [1] class [System.Windows.Forms]System.Windows.Forms.Form V_1,
               [2] class [System.Windows.Forms]System.Windows.Forms.PictureBox V_2,
               [3] class [System.Windows.Forms]System.Windows.Forms.Button startStopButton,
               [4] class [System.Windows.Forms]System.Windows.Forms.Button V_4,
               [5] class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox,
               [6] class [System.Windows.Forms]System.Windows.Forms.CheckBox V_6,
               [7] class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox,
               [8] class [System.Windows.Forms]System.Windows.Forms.CheckBox V_8,
               [9] class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel,
               [10] class [System.Windows.Forms]System.Windows.Forms.Label V_10,
               [11] int32 V_11,
               [12] object V_12,
               [13] class [mscorlib]System.IFormattable V_13,
               [14] class [mscorlib]System.IFormattable V_14,
               [15] object V_15,
               [16] class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar,
               [17] class [System.Windows.Forms]System.Windows.Forms.TrackBar V_17,
               [18] class [System.Windows.Forms]System.Windows.Forms.CheckBox V_18,
               [19] class [System.Windows.Forms]System.Windows.Forms.TrackBar V_19,
               [20] class [System.Windows.Forms]System.Windows.Forms.Button V_20)
//000058: 
//000059: type RayTracerForm() as this = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  newobj     instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::.ctor(!0)
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_0013:  stloc.0
//000060:     inherit Form(ClientSize = new Size(width + 95, height + 59),
      IL_0014:  ldarg.0
      IL_0015:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
      IL_001a:  ldarg.0
      IL_001b:  stloc.1
      IL_001c:  ldloc.1
      IL_001d:  call       int32 Harness::get_width()
      IL_0022:  ldc.i4.s   95
      IL_0024:  add
      IL_0025:  call       int32 Harness::get_height()
      IL_002a:  ldc.i4.s   59
      IL_002c:  add
      IL_002d:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_0032:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
      IL_0037:  ldloc.1
      IL_0038:  ldstr      "RayTracer"
      IL_003d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_0042:  ldloc.1
      IL_0043:  pop
//000059: type RayTracerForm() as this = 
      IL_0044:  ldarg.0
      IL_0045:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_004a:  ldarg.0
      IL_004b:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::set_contents(!0)
//000060:     inherit Form(ClientSize = new Size(width + 95, height + 59),
//000061:                  Text = "RayTracer")
//000062:     let mutable bitmap = new Bitmap(width, height, PixelFormat.Format32bppRgb)
      IL_0050:  ldarg.0
      IL_0051:  call       int32 Harness::get_width()
      IL_0056:  call       int32 Harness::get_height()
      IL_005b:  ldc.i4     0x22009
      IL_0060:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                      int32,
                                                                                      valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_0065:  stfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
//000063:     let mutable buffers = ObjectPool(fun () -> Array.create (width * height) 0)
      IL_006a:  ldarg.0
      IL_006b:  newobj     instance void Harness/'-ctor@63'::.ctor()
      IL_0070:  newobj     instance void class Harness/ObjectPool`1<int32[]>::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!0>)
      IL_0075:  stfld      class Harness/ObjectPool`1<int32[]> Harness/RayTracerForm::buffers
//000064:     let mutable rect = Rectangle(0,0,width,height)
      IL_007a:  ldarg.0
      IL_007b:  ldc.i4.0
      IL_007c:  ldc.i4.0
      IL_007d:  call       int32 Harness::get_width()
      IL_0082:  call       int32 Harness::get_height()
      IL_0087:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                         int32,
                                                                                         int32,
                                                                                         int32)
      IL_008c:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle Harness/RayTracerForm::rect
//000065:     let mutable renderTask : Task = null
      IL_0091:  ldarg.0
      IL_0092:  ldnull
      IL_0093:  stfld      class [mscorlib]System.Threading.Tasks.Task Harness/RayTracerForm::renderTask
//000066:     let mutable isParallel = false
      IL_0098:  ldarg.0
      IL_0099:  ldc.i4.0
      IL_009a:  stfld      bool Harness/RayTracerForm::isParallel
//000067:     let mutable showThreads = false
      IL_009f:  ldarg.0
      IL_00a0:  ldc.i4.0
      IL_00a1:  stfld      bool Harness/RayTracerForm::showThreads
//000068:     let mutable degreeOfParallelism = Environment.ProcessorCount 
      IL_00a6:  ldarg.0
      IL_00a7:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
      IL_00ac:  stfld      int32 Harness/RayTracerForm::degreeOfParallelism
//000069:     let mutable cancellation : CancellationTokenSource = null
      IL_00b1:  ldarg.0
      IL_00b2:  ldnull
      IL_00b3:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Harness/RayTracerForm::cancellation
//000070:     
//000071:     let pictureBox = 
      IL_00b8:  ldarg.0
      IL_00b9:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
      IL_00be:  stloc.2
      IL_00bf:  ldloc.2
      IL_00c0:  ldc.i4.s   13
      IL_00c2:  ldc.i4.s   15
      IL_00c4:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_00c9:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_00ce:  ldloc.2
      IL_00cf:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
      IL_00d4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
      IL_00d9:  ldloc.2
      IL_00da:  ldc.i4.2
      IL_00db:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
      IL_00e0:  ldloc.2
      IL_00e1:  call       int32 Harness::get_width()
      IL_00e6:  ldc.i4.s   69
      IL_00e8:  add
      IL_00e9:  call       int32 Harness::get_height()
      IL_00ee:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_00f3:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_00f8:  ldloc.2
      IL_00f9:  ldc.i4.3
      IL_00fa:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
      IL_00ff:  ldloc.2
      IL_0100:  ldc.i4.s   13
      IL_0102:  ldc.i4.2
      IL_0103:  or
      IL_0104:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_0109:  ldloc.2
      IL_010a:  ldarg.0
      IL_010b:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0110:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_0115:  ldloc.2
      IL_0116:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
//000072:         new PictureBox(Location = Point(13,15), 
//000073:                        BackColor = Color.Black,
//000074:                        BorderStyle = BorderStyle.Fixed3D,
//000075:                        Size = Size(width+69, height),
//000076:                        SizeMode = PictureBoxSizeMode.CenterImage,
//000077:                        Anchor = (AnchorStyles.Left ||| AnchorStyles.Right ||| AnchorStyles.Top ||| AnchorStyles.Bottom),
//000078:                        Image = bitmap )
//000079:     let startStopButton = 
      IL_011b:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
      IL_0120:  stloc.s    V_4
      IL_0122:  ldloc.s    V_4
      IL_0124:  ldstr      "Start"
      IL_0129:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_012e:  ldloc.s    V_4
      IL_0130:  ldc.i4.s   14
      IL_0132:  call       int32 Harness::get_height()
      IL_0137:  ldc.i4.s   21
      IL_0139:  add
      IL_013a:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_013f:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_0144:  ldloc.s    V_4
      IL_0146:  ldc.i4.4
      IL_0147:  ldc.i4.2
      IL_0148:  or
      IL_0149:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_014e:  ldloc.s    V_4
      IL_0150:  ldc.i4.s   88
      IL_0152:  ldc.i4.s   23
      IL_0154:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_0159:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_015e:  ldloc.s    V_4
      IL_0160:  stloc.3
//000080:         new Button(Text = "Start",
//000081:                    Location = Point(14,height + 21),
//000082:                    Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000083:                    Size = Size(88,23))
//000084:     let isParallelCheckBox = 
      IL_0161:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::.ctor()
      IL_0166:  stloc.s    V_6
      IL_0168:  ldloc.s    V_6
      IL_016a:  ldstr      "Parallel"
      IL_016f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_0174:  ldloc.s    V_6
      IL_0176:  ldc.i4.1
      IL_0177:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
      IL_017c:  ldloc.s    V_6
      IL_017e:  ldc.i4.4
      IL_017f:  ldc.i4.2
      IL_0180:  or
      IL_0181:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_0186:  ldloc.s    V_6
      IL_0188:  ldc.i4.s   108
      IL_018a:  call       int32 Harness::get_height()
      IL_018f:  ldc.i4.s   26
      IL_0191:  add
      IL_0192:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_0197:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_019c:  ldloc.s    V_6
      IL_019e:  ldc.i4.1
      IL_019f:  call       instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
      IL_01a4:  ldloc.s    V_6
      IL_01a6:  ldc.i4.s   60
      IL_01a8:  ldc.i4.s   17
      IL_01aa:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_01af:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_01b4:  ldloc.s    V_6
      IL_01b6:  stloc.s    isParallelCheckBox
//000085:         new CheckBox(Text = "Parallel",
//000086:                      AutoSize = true,
//000087:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000088:                      Location = Point(108, height + 26),
//000089:                      UseVisualStyleBackColor = true,
//000090:                      Size = Size(60,17))
//000091:     let showThreadsCheckbox = 
      IL_01b8:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::.ctor()
      IL_01bd:  stloc.s    V_8
      IL_01bf:  ldloc.s    V_8
      IL_01c1:  ldstr      "Show Threads"
      IL_01c6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_01cb:  ldloc.s    V_8
      IL_01cd:  ldc.i4.1
      IL_01ce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
      IL_01d3:  ldloc.s    V_8
      IL_01d5:  ldc.i4.0
      IL_01d6:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_01db:  ldloc.s    V_8
      IL_01dd:  ldc.i4.4
      IL_01de:  ldc.i4.2
      IL_01df:  or
      IL_01e0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_01e5:  ldloc.s    V_8
      IL_01e7:  ldc.i4     0xae
      IL_01ec:  call       int32 Harness::get_height()
      IL_01f1:  ldc.i4.s   26
      IL_01f3:  add
      IL_01f4:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_01f9:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_01fe:  ldloc.s    V_8
      IL_0200:  ldc.i4.s   95
      IL_0202:  ldc.i4.s   17
      IL_0204:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_0209:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_020e:  ldloc.s    V_8
      IL_0210:  stloc.s    showThreadsCheckbox
//000092:         new CheckBox(Text = "Show Threads",
//000093:                      AutoSize = true,
//000094:                      Enabled = false,
//000095:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000096:                      Location = Point(174, height + 26),
//000097:                      Size = Size(95,17))
//000098:     let numProcsLabel = 
      IL_0212:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
      IL_0217:  stloc.s    V_10
      IL_0219:  ldloc.s    V_10
      IL_021b:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
      IL_0220:  stloc.s    V_11
      IL_0222:  ldloc.s    V_11
      IL_0224:  box        [mscorlib]System.Int32
      IL_0229:  stloc.s    V_12
      IL_022b:  ldloc.s    V_12
      IL_022d:  brfalse.s  IL_0240

      IL_022f:  ldloc.s    V_12
      IL_0231:  isinst     [mscorlib]System.IFormattable
      IL_0236:  stloc.s    V_13
      IL_0238:  ldloc.s    V_13
      IL_023a:  brfalse.s  IL_023e

      IL_023c:  br.s       IL_0248

      IL_023e:  br.s       IL_0261

//000099:         new Label(Text = string Environment.ProcessorCount,
//000100:                   Enabled = false,
//000101:                   Font = new Font("Microsoft Sans Serif", 8.25F, FontStyle.Bold, GraphicsUnit.Point, 0uy),
//000102:                   Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000103:                   Location = Point(295, height + 31),
//000104:                   Size = Size(14,13))
//000105:     let numProcsTrackBar = 
//000106:         new TrackBar(Value = Environment.ProcessorCount,
//000107:                      Maximum = Environment.ProcessorCount,
//000108:                      Minimum = 1,
//000109:                      Enabled = false,
//000110:                      Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000111:                      Location = Point(304, height + 21),
//000112:                      Size = Size(178,45))
//000113:     
//000114:     let sceneAtTime elapsedSecs = 
//000115:         let dy2 = 0.8 * abs (sin ((float elapsedSecs) * Math.PI / 3000.0))
//000116:         let sphere = Sphere( Vector(-0.5,0.5+dy2,1.5), 0.5, Surfaces.MatteShiny)
//000117:         { baseScene with Things = sphere :: baseScene.Things  }
//000118:         
//000119:     let configureImage () =
//000120:         if bitmap = null || (bitmap.Width <> pictureBox.Width) || (bitmap.Height <> pictureBox.Height)    
//000121:         then
//000122:             if bitmap <> null
//000123:             then
//000124:                 pictureBox.Image <- null
//000125:                 bitmap.Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_0240:  ldstr      ""
      IL_0245:  nop
      IL_0246:  br.s       IL_026d

      IL_0248:  ldloc.s    V_13
      IL_024a:  stloc.s    V_14
      IL_024c:  ldloc.s    V_14
      IL_024e:  ldnull
      IL_024f:  call       class [mscorlib]System.Globalization.CultureInfo [mscorlib]System.Globalization.CultureInfo::get_InvariantCulture()
      IL_0254:  unbox.any  [mscorlib]System.IFormatProvider
      IL_0259:  callvirt   instance string [mscorlib]System.IFormattable::ToString(string,
                                                                                   class [mscorlib]System.IFormatProvider)
      IL_025e:  nop
      IL_025f:  br.s       IL_026d

      IL_0261:  ldloc.s    V_12
      IL_0263:  stloc.s    V_15
      IL_0265:  ldloc.s    V_15
      IL_0267:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_026c:  nop
      IL_026d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_0272:  ldloc.s    V_10
      IL_0274:  ldc.i4.0
      IL_0275:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_027a:  ldloc.s    V_10
      IL_027c:  ldstr      "Microsoft Sans Serif"
      IL_0281:  ldc.r4     8.25
      IL_0286:  ldc.i4.1
      IL_0287:  ldc.i4.3
      IL_0288:  ldc.i4.0
      IL_0289:  newobj     instance void [System.Drawing]System.Drawing.Font::.ctor(string,
                                                                                    float32,
                                                                                    valuetype [System.Drawing]System.Drawing.FontStyle,
                                                                                    valuetype [System.Drawing]System.Drawing.GraphicsUnit,
                                                                                    uint8)
      IL_028e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Font(class [System.Drawing]System.Drawing.Font)
      IL_0293:  ldloc.s    V_10
      IL_0295:  ldc.i4.8
      IL_0296:  ldc.i4.2
      IL_0297:  or
      IL_0298:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_029d:  ldloc.s    V_10
      IL_029f:  ldc.i4     0x127
      IL_02a4:  call       int32 Harness::get_height()
      IL_02a9:  ldc.i4.s   31
      IL_02ab:  add
      IL_02ac:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_02b1:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_02b6:  ldloc.s    V_10
      IL_02b8:  ldc.i4.s   14
      IL_02ba:  ldc.i4.s   13
      IL_02bc:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_02c1:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_02c6:  ldloc.s    V_10
      IL_02c8:  stloc.s    numProcsLabel
//000105:     let numProcsTrackBar = 
      IL_02ca:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
      IL_02cf:  stloc.s    V_17
      IL_02d1:  ldloc.s    V_17
      IL_02d3:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
      IL_02d8:  call       instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
      IL_02dd:  ldloc.s    V_17
      IL_02df:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
      IL_02e4:  call       instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
      IL_02e9:  ldloc.s    V_17
      IL_02eb:  ldc.i4.1
      IL_02ec:  call       instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
      IL_02f1:  ldloc.s    V_17
      IL_02f3:  ldc.i4.0
      IL_02f4:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_02f9:  ldloc.s    V_17
      IL_02fb:  ldc.i4.8
      IL_02fc:  ldc.i4.2
      IL_02fd:  or
      IL_02fe:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
      IL_0303:  ldloc.s    V_17
      IL_0305:  ldc.i4     0x130
      IL_030a:  call       int32 Harness::get_height()
      IL_030f:  ldc.i4.s   21
      IL_0311:  add
      IL_0312:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                     int32)
      IL_0317:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
      IL_031c:  ldloc.s    V_17
      IL_031e:  ldc.i4     0xb2
      IL_0323:  ldc.i4.s   45
      IL_0325:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_032a:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
      IL_032f:  ldloc.s    V_17
      IL_0331:  stloc.s    numProcsTrackBar
//000059: type RayTracerForm() as this = 
      IL_0333:  ldarg.0
      IL_0334:  ldc.i4.1
      IL_0335:  stfld      int32 Harness/RayTracerForm::init@59
//000060:     inherit Form(ClientSize = new Size(width + 95, height + 59),
//000061:                  Text = "RayTracer")
//000062:     let mutable bitmap = new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000063:     let mutable buffers = ObjectPool(fun () -> Array.create (width * height) 0)
//000064:     let mutable rect = Rectangle(0,0,width,height)
//000065:     let mutable renderTask : Task = null
//000066:     let mutable isParallel = false
//000067:     let mutable showThreads = false
//000068:     let mutable degreeOfParallelism = Environment.ProcessorCount 
//000069:     let mutable cancellation : CancellationTokenSource = null
//000070:     
//000071:     let pictureBox = 
//000072:         new PictureBox(Location = Point(13,15), 
//000073:                        BackColor = Color.Black,
//000074:                        BorderStyle = BorderStyle.Fixed3D,
//000075:                        Size = Size(width+69, height),
//000076:                        SizeMode = PictureBoxSizeMode.CenterImage,
//000077:                        Anchor = (AnchorStyles.Left ||| AnchorStyles.Right ||| AnchorStyles.Top ||| AnchorStyles.Bottom),
//000078:                        Image = bitmap )
//000079:     let startStopButton = 
//000080:         new Button(Text = "Start",
//000081:                    Location = Point(14,height + 21),
//000082:                    Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000083:                    Size = Size(88,23))
//000084:     let isParallelCheckBox = 
//000085:         new CheckBox(Text = "Parallel",
//000086:                      AutoSize = true,
//000087:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000088:                      Location = Point(108, height + 26),
//000089:                      UseVisualStyleBackColor = true,
//000090:                      Size = Size(60,17))
//000091:     let showThreadsCheckbox = 
//000092:         new CheckBox(Text = "Show Threads",
//000093:                      AutoSize = true,
//000094:                      Enabled = false,
//000095:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000096:                      Location = Point(174, height + 26),
//000097:                      Size = Size(95,17))
//000098:     let numProcsLabel = 
//000099:         new Label(Text = string Environment.ProcessorCount,
//000100:                   Enabled = false,
//000101:                   Font = new Font("Microsoft Sans Serif", 8.25F, FontStyle.Bold, GraphicsUnit.Point, 0uy),
//000102:                   Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000103:                   Location = Point(295, height + 31),
//000104:                   Size = Size(14,13))
//000105:     let numProcsTrackBar = 
//000106:         new TrackBar(Value = Environment.ProcessorCount,
//000107:                      Maximum = Environment.ProcessorCount,
//000108:                      Minimum = 1,
//000109:                      Enabled = false,
//000110:                      Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000111:                      Location = Point(304, height + 21),
//000112:                      Size = Size(178,45))
//000113:     
//000114:     let sceneAtTime elapsedSecs = 
//000115:         let dy2 = 0.8 * abs (sin ((float elapsedSecs) * Math.PI / 3000.0))
//000116:         let sphere = Sphere( Vector(-0.5,0.5+dy2,1.5), 0.5, Surfaces.MatteShiny)
//000117:         { baseScene with Things = sphere :: baseScene.Things  }
//000118:         
//000119:     let configureImage () =
//000120:         if bitmap = null || (bitmap.Width <> pictureBox.Width) || (bitmap.Height <> pictureBox.Height)    
//000121:         then
//000122:             if bitmap <> null
//000123:             then
//000124:                 pictureBox.Image <- null
//000125:                 bitmap.Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
      IL_033a:  ldloc.s    isParallelCheckBox
      IL_033c:  stloc.s    V_18
      IL_033e:  ldloc.s    V_18
      IL_0340:  newobj     instance void Harness/'-ctor@167-1'::.ctor(class [System.Windows.Forms]System.Windows.Forms.CheckBox)
      IL_0345:  ldloc.s    V_18
      IL_0347:  newobj     instance void Harness/'-ctor@167-2'::.ctor(class [System.Windows.Forms]System.Windows.Forms.CheckBox)
      IL_034c:  newobj     instance void Harness/'-ctor@167-3'::.ctor()
      IL_0351:  call       class [FSharp.Core]Microsoft.FSharp.Control.IEvent`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers::CreateEvent<class [mscorlib]System.EventHandler,class [mscorlib]System.EventArgs>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!1,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,!!0>)
      IL_0356:  ldarg.0
      IL_0357:  ldloc.s    isParallelCheckBox
      IL_0359:  ldloc.s    showThreadsCheckbox
      IL_035b:  ldloc.s    numProcsLabel
      IL_035d:  ldloc.s    numProcsTrackBar
      IL_035f:  newobj     instance void Harness/'-ctor@167-5'::.ctor(class Harness/RayTracerForm,
                                                                      class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                      class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                      class [System.Windows.Forms]System.Windows.Forms.Label,
                                                                      class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_0364:  call       void [FSharp.Core]Microsoft.FSharp.Control.CommonExtensions::AddToObservable<class [mscorlib]System.EventArgs>(class [mscorlib]System.IObservable`1<!!0>,
                                                                                                                                          class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>)
      IL_0369:  nop
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
      IL_036a:  ldloc.s    numProcsTrackBar
      IL_036c:  stloc.s    V_19
      IL_036e:  ldloc.s    V_19
      IL_0370:  newobj     instance void Harness/'-ctor@174-6'::.ctor(class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_0375:  ldloc.s    V_19
      IL_0377:  newobj     instance void Harness/'-ctor@174-7'::.ctor(class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_037c:  newobj     instance void Harness/'-ctor@174-8'::.ctor()
      IL_0381:  call       class [FSharp.Core]Microsoft.FSharp.Control.IEvent`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers::CreateEvent<class [mscorlib]System.EventHandler,class [mscorlib]System.EventArgs>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!1,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,!!0>)
      IL_0386:  ldarg.0
      IL_0387:  ldloc.s    numProcsLabel
      IL_0389:  ldloc.s    numProcsTrackBar
      IL_038b:  newobj     instance void Harness/'-ctor@174-10'::.ctor(class Harness/RayTracerForm,
                                                                       class [System.Windows.Forms]System.Windows.Forms.Label,
                                                                       class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_0390:  call       void [FSharp.Core]Microsoft.FSharp.Control.CommonExtensions::AddToObservable<class [mscorlib]System.EventArgs>(class [mscorlib]System.IObservable`1<!!0>,
                                                                                                                                          class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>)
      IL_0395:  nop
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
      IL_0396:  ldloc.3
      IL_0397:  stloc.s    V_20
      IL_0399:  ldloc.s    V_20
      IL_039b:  newobj     instance void Harness/'-ctor@179-11'::.ctor(class [System.Windows.Forms]System.Windows.Forms.Button)
      IL_03a0:  ldloc.s    V_20
      IL_03a2:  newobj     instance void Harness/'-ctor@179-12'::.ctor(class [System.Windows.Forms]System.Windows.Forms.Button)
      IL_03a7:  newobj     instance void Harness/'-ctor@179-13'::.ctor()
      IL_03ac:  call       class [FSharp.Core]Microsoft.FSharp.Control.IEvent`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers::CreateEvent<class [mscorlib]System.EventHandler,class [mscorlib]System.EventArgs>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!1,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,!!0>)
      IL_03b1:  ldarg.0
      IL_03b2:  ldloc.3
      IL_03b3:  ldloc.s    isParallelCheckBox
      IL_03b5:  ldloc.s    showThreadsCheckbox
      IL_03b7:  ldloc.s    numProcsLabel
      IL_03b9:  ldloc.s    numProcsTrackBar
      IL_03bb:  newobj     instance void Harness/'-ctor@179-15'::.ctor(class Harness/RayTracerForm,
                                                                       class [System.Windows.Forms]System.Windows.Forms.Button,
                                                                       class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                       class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                       class [System.Windows.Forms]System.Windows.Forms.Label,
                                                                       class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_03c0:  call       void [FSharp.Core]Microsoft.FSharp.Control.CommonExtensions::AddToObservable<class [mscorlib]System.EventArgs>(class [mscorlib]System.IObservable`1<!!0>,
                                                                                                                                          class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>)
      IL_03c5:  nop
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
      IL_03c6:  ldarg.0
      IL_03c7:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_03cc:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_03d1:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_03d6:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
      IL_03db:  ldarg.0
      IL_03dc:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_03e1:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_03e6:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_03eb:  ldc.r4     6.
      IL_03f0:  ldc.r4     13.
      IL_03f5:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                     float32)
      IL_03fa:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
      IL_03ff:  ldarg.0
      IL_0400:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_0405:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_040a:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_040f:  ldc.i4.1
      IL_0410:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
//000209:     do this.Controls.Add(pictureBox)
      IL_0415:  ldarg.0
      IL_0416:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_041b:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_0420:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0425:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_042a:  ldarg.0
      IL_042b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_0430:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000210:     do this.Controls.Add(startStopButton)
      IL_0435:  ldarg.0
      IL_0436:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_043b:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_0440:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0445:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_044a:  ldloc.3
      IL_044b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000211:     do this.Controls.Add(isParallelCheckBox)
      IL_0450:  ldarg.0
      IL_0451:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_0456:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_045b:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0460:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_0465:  ldloc.s    isParallelCheckBox
      IL_0467:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000212:     do this.Controls.Add(showThreadsCheckbox)
      IL_046c:  ldarg.0
      IL_046d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_0472:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_0477:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_047c:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_0481:  ldloc.s    showThreadsCheckbox
      IL_0483:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000213:     do this.Controls.Add(numProcsLabel)
      IL_0488:  ldarg.0
      IL_0489:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_048e:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_0493:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0498:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_049d:  ldloc.s    numProcsLabel
      IL_049f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000214:     do this.Controls.Add(numProcsTrackBar)
      IL_04a4:  ldarg.0
      IL_04a5:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_04aa:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_04af:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_04b4:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
      IL_04b9:  ldloc.s    numProcsTrackBar
      IL_04bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
//000215:     do this.ResumeLayout()
      IL_04c0:  ldarg.0
      IL_04c1:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_04c6:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_04cb:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_04d0:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout()
//000059: type RayTracerForm() as this = 
      IL_04d5:  ret
    } // end of method RayTracerForm::.ctor

    .method assembly instance class Raytracer_FSharp/Scene 
            sceneAtTime(int64 elapsedSecs) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       152 (0x98)
      .maxstack  5
      .locals init ([0] float64 dy2,
               [1] float64 V_1,
               [2] float64 V_2,
               [3] float64 V_3,
               [4] float64 V_4,
               [5] class Raytracer_FSharp/SceneObject sphere,
               [6] class Raytracer_FSharp/Scene V_6)
//000060:     inherit Form(ClientSize = new Size(width + 95, height + 59),
//000061:                  Text = "RayTracer")
//000062:     let mutable bitmap = new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000063:     let mutable buffers = ObjectPool(fun () -> Array.create (width * height) 0)
//000064:     let mutable rect = Rectangle(0,0,width,height)
//000065:     let mutable renderTask : Task = null
//000066:     let mutable isParallel = false
//000067:     let mutable showThreads = false
//000068:     let mutable degreeOfParallelism = Environment.ProcessorCount 
//000069:     let mutable cancellation : CancellationTokenSource = null
//000070:     
//000071:     let pictureBox = 
//000072:         new PictureBox(Location = Point(13,15), 
//000073:                        BackColor = Color.Black,
//000074:                        BorderStyle = BorderStyle.Fixed3D,
//000075:                        Size = Size(width+69, height),
//000076:                        SizeMode = PictureBoxSizeMode.CenterImage,
//000077:                        Anchor = (AnchorStyles.Left ||| AnchorStyles.Right ||| AnchorStyles.Top ||| AnchorStyles.Bottom),
//000078:                        Image = bitmap )
//000079:     let startStopButton = 
//000080:         new Button(Text = "Start",
//000081:                    Location = Point(14,height + 21),
//000082:                    Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000083:                    Size = Size(88,23))
//000084:     let isParallelCheckBox = 
//000085:         new CheckBox(Text = "Parallel",
//000086:                      AutoSize = true,
//000087:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000088:                      Location = Point(108, height + 26),
//000089:                      UseVisualStyleBackColor = true,
//000090:                      Size = Size(60,17))
//000091:     let showThreadsCheckbox = 
//000092:         new CheckBox(Text = "Show Threads",
//000093:                      AutoSize = true,
//000094:                      Enabled = false,
//000095:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000096:                      Location = Point(174, height + 26),
//000097:                      Size = Size(95,17))
//000098:     let numProcsLabel = 
//000099:         new Label(Text = string Environment.ProcessorCount,
//000100:                   Enabled = false,
//000101:                   Font = new Font("Microsoft Sans Serif", 8.25F, FontStyle.Bold, GraphicsUnit.Point, 0uy),
//000102:                   Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000103:                   Location = Point(295, height + 31),
//000104:                   Size = Size(14,13))
//000105:     let numProcsTrackBar = 
//000106:         new TrackBar(Value = Environment.ProcessorCount,
//000107:                      Maximum = Environment.ProcessorCount,
//000108:                      Minimum = 1,
//000109:                      Enabled = false,
//000110:                      Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000111:                      Location = Point(304, height + 21),
//000112:                      Size = Size(178,45))
//000113:     
//000114:     let sceneAtTime elapsedSecs = 
//000115:         let dy2 = 0.8 * abs (sin ((float elapsedSecs) * Math.PI / 3000.0))
      IL_0000:  nop
      IL_0001:  ldc.r8     0.80000000000000004
      IL_000a:  ldarg.1
      IL_000b:  conv.r8
      IL_000c:  ldc.r8     3.1415926535897931
      IL_0015:  mul
      IL_0016:  ldc.r8     3000.
      IL_001f:  div
      IL_0020:  stloc.2
      IL_0021:  ldloc.2
      IL_0022:  stloc.3
      IL_0023:  ldloc.2
      IL_0024:  call       float64 [mscorlib]System.Math::Sin(float64)
      IL_0029:  stloc.1
      IL_002a:  ldloc.1
      IL_002b:  stloc.s    V_4
      IL_002d:  ldloc.1
      IL_002e:  call       float64 [mscorlib]System.Math::Abs(float64)
      IL_0033:  mul
      IL_0034:  stloc.0
//000116:         let sphere = Sphere( Vector(-0.5,0.5+dy2,1.5), 0.5, Surfaces.MatteShiny)
      IL_0035:  ldc.r8     -0.5
      IL_003e:  ldc.r8     0.5
      IL_0047:  ldloc.0
      IL_0048:  add
      IL_0049:  ldc.r8     1.5
      IL_0052:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_0057:  ldc.r8     0.5
      IL_0060:  call       class Raytracer_FSharp/Surface Harness/Surfaces::get_MatteShiny()
      IL_0065:  call       class Raytracer_FSharp/SceneObject Raytracer_FSharp::Sphere(class Raytracer_FSharp/Vector,
                                                                                       float64,
                                                                                       class Raytracer_FSharp/Surface)
      IL_006a:  stloc.s    sphere
//000117:         { baseScene with Things = sphere :: baseScene.Things  }
      IL_006c:  call       class Raytracer_FSharp/Scene Harness::get_baseScene()
      IL_0071:  stloc.s    V_6
      IL_0073:  ldloc.s    sphere
      IL_0075:  call       class Raytracer_FSharp/Scene Harness::get_baseScene()
      IL_007a:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_007f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::Cons(!0,
                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
      IL_0084:  ldloc.s    V_6
      IL_0086:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_008b:  ldloc.s    V_6
      IL_008d:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0092:  newobj     instance void Raytracer_FSharp/Scene::.ctor(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>,
                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>,
                                                                       class Raytracer_FSharp/Camera)
      IL_0097:  ret
    } // end of method RayTracerForm::sceneAtTime

    .method assembly instance void  configureImage() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       288 (0x120)
      .maxstack  7
      .locals init ([0] int32 V_0,
               [1] int32 V_1,
               [2] int32 V_2,
               [3] int32 V_3,
               [4] class [System.Drawing]System.Drawing.Bitmap V_4,
               [5] class [System.Drawing]System.Drawing.Bitmap V_5)
//000118:         
//000119:     let configureImage () =
//000120:         if bitmap = null || (bitmap.Width <> pictureBox.Width) || (bitmap.Height <> pictureBox.Height)    
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0007:  ldnull
      IL_0008:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [System.Drawing]System.Drawing.Bitmap>(!!0,
                                                                                                                                                                         !!0)
      IL_000d:  brfalse.s  IL_0011

      IL_000f:  br.s       IL_0013

      IL_0011:  br.s       IL_0017

//000121:         then
//000122:             if bitmap <> null
//000123:             then
//000124:                 pictureBox.Image <- null
//000125:                 bitmap.Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_0013:  ldc.i4.1
      IL_0014:  nop
      IL_0015:  br.s       IL_0037

      IL_0017:  ldarg.0
      IL_0018:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_001d:  call       instance int32 [System.Drawing]System.Drawing.Image::get_Width()
      IL_0022:  stloc.0
      IL_0023:  ldarg.0
      IL_0024:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_0029:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
      IL_002e:  stloc.1
      IL_002f:  ldloc.0
      IL_0030:  ldloc.1
      IL_0031:  ceq
      IL_0033:  ldc.i4.0
      IL_0034:  ceq
      IL_0036:  nop
      IL_0037:  brfalse.s  IL_003b

      IL_0039:  br.s       IL_003d

      IL_003b:  br.s       IL_0041

      IL_003d:  ldc.i4.1
      IL_003e:  nop
      IL_003f:  br.s       IL_0061

      IL_0041:  ldarg.0
      IL_0042:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0047:  call       instance int32 [System.Drawing]System.Drawing.Image::get_Height()
      IL_004c:  stloc.2
      IL_004d:  ldarg.0
      IL_004e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_0053:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
      IL_0058:  stloc.3
      IL_0059:  ldloc.2
      IL_005a:  ldloc.3
      IL_005b:  ceq
      IL_005d:  ldc.i4.0
      IL_005e:  ceq
      IL_0060:  nop
      IL_0061:  brfalse.s  IL_0065

      IL_0063:  br.s       IL_006a

      IL_0065:  br         IL_011f

//000122:             if bitmap <> null
      IL_006a:  ldarg.0
      IL_006b:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0070:  stloc.s    V_4
      IL_0072:  ldnull
      IL_0073:  stloc.s    V_5
      IL_0075:  ldloc.s    V_4
      IL_0077:  ldloc.s    V_5
      IL_0079:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [System.Drawing]System.Drawing.Bitmap>(!!0,
                                                                                                                                                                         !!0)
      IL_007e:  ldc.i4.0
      IL_007f:  ceq
      IL_0081:  brfalse.s  IL_0085

      IL_0083:  br.s       IL_0087

      IL_0085:  br.s       IL_00a1

//000123:             then
//000124:                 pictureBox.Image <- null
      IL_0087:  ldarg.0
      IL_0088:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_008d:  ldnull
      IL_008e:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
//000125:                 bitmap.Dispose()
      IL_0093:  ldarg.0
      IL_0094:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0099:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_009e:  nop
      IL_009f:  br.s       IL_00a2

      IL_00a1:  nop
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
      IL_00a2:  ldarg.0
      IL_00a3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_00a8:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
      IL_00ad:  ldarg.0
      IL_00ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_00b3:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
      IL_00b8:  call       int32 [mscorlib]System.Math::Min(int32,
                                                            int32)
      IL_00bd:  call       void Harness::set_width(int32)
//000127:             height <- width
      IL_00c2:  call       int32 Harness::get_width()
      IL_00c7:  call       void Harness::set_height(int32)
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
      IL_00cc:  ldarg.0
      IL_00cd:  newobj     instance void Harness/'clo@128-2'::.ctor()
      IL_00d2:  newobj     instance void class Harness/ObjectPool`1<int32[]>::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!0>)
      IL_00d7:  stfld      class Harness/ObjectPool`1<int32[]> Harness/RayTracerForm::buffers
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
      IL_00dc:  ldarg.0
      IL_00dd:  call       int32 Harness::get_width()
      IL_00e2:  call       int32 Harness::get_height()
      IL_00e7:  ldc.i4     0x22009
      IL_00ec:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                      int32,
                                                                                      valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_00f1:  stfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
//000130:             rect <- Rectangle(0,0,width,height)
      IL_00f6:  ldarg.0
      IL_00f7:  ldc.i4.0
      IL_00f8:  ldc.i4.0
      IL_00f9:  call       int32 Harness::get_width()
      IL_00fe:  call       int32 Harness::get_height()
      IL_0103:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                         int32,
                                                                                         int32,
                                                                                         int32)
      IL_0108:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle Harness/RayTracerForm::rect
//000131:             pictureBox.Image <- bitmap
      IL_010d:  ldarg.0
      IL_010e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_0113:  ldarg.0
      IL_0114:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0119:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_011e:  ret

//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_011f:  ret
    } // end of method RayTracerForm::configureImage

    .method assembly instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            renderLoop() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       21 (0x15)
      .maxstack  5
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@)
//000133:     let renderLoop () = async { 
      IL_0000:  nop
      IL_0001:  call       class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::get_DefaultAsyncBuilder()
      IL_0006:  stloc.0
      IL_0007:  ldloc.0
      IL_0008:  ldarg.0
      IL_0009:  ldloc.0
      IL_000a:  newobj     instance void Harness/'clo@134-3'::.ctor(class Harness/RayTracerForm,
                                                                    class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder)
      IL_000f:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_0014:  ret
    } // end of method RayTracerForm::renderLoop

  } // end of class RayTracerForm

  .class auto ansi serializable nested assembly beforefieldinit '-ctor@63'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,int32[]>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,int32[]>::.ctor()
      IL_0006:  ret
    } // end of method '-ctor@63'::.ctor

    .method public strict virtual instance int32[] 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar0) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000063:     let mutable buffers = ObjectPool(fun () -> Array.create (width * height) 0)
      IL_0000:  nop
      IL_0001:  call       int32 Harness::get_width()
      IL_0006:  call       int32 Harness::get_height()
      IL_000b:  mul
      IL_000c:  ldc.i4.0
      IL_000d:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Create<int32>(int32,
                                                                                                      !!0)
      IL_0012:  ret
    } // end of method '-ctor@63'::Invoke

  } // end of class '-ctor@63'

  .class auto ansi nested assembly beforefieldinit '-ctor@167-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.CheckBox eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-1'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@167-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
//000064:     let mutable rect = Rectangle(0,0,width,height)
//000065:     let mutable renderTask : Task = null
//000066:     let mutable isParallel = false
//000067:     let mutable showThreads = false
//000068:     let mutable degreeOfParallelism = Environment.ProcessorCount 
//000069:     let mutable cancellation : CancellationTokenSource = null
//000070:     
//000071:     let pictureBox = 
//000072:         new PictureBox(Location = Point(13,15), 
//000073:                        BackColor = Color.Black,
//000074:                        BorderStyle = BorderStyle.Fixed3D,
//000075:                        Size = Size(width+69, height),
//000076:                        SizeMode = PictureBoxSizeMode.CenterImage,
//000077:                        Anchor = (AnchorStyles.Left ||| AnchorStyles.Right ||| AnchorStyles.Top ||| AnchorStyles.Bottom),
//000078:                        Image = bitmap )
//000079:     let startStopButton = 
//000080:         new Button(Text = "Start",
//000081:                    Location = Point(14,height + 21),
//000082:                    Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000083:                    Size = Size(88,23))
//000084:     let isParallelCheckBox = 
//000085:         new CheckBox(Text = "Parallel",
//000086:                      AutoSize = true,
//000087:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000088:                      Location = Point(108, height + 26),
//000089:                      UseVisualStyleBackColor = true,
//000090:                      Size = Size(60,17))
//000091:     let showThreadsCheckbox = 
//000092:         new CheckBox(Text = "Show Threads",
//000093:                      AutoSize = true,
//000094:                      Enabled = false,
//000095:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000096:                      Location = Point(174, height + 26),
//000097:                      Size = Size(95,17))
//000098:     let numProcsLabel = 
//000099:         new Label(Text = string Environment.ProcessorCount,
//000100:                   Enabled = false,
//000101:                   Font = new Font("Microsoft Sans Serif", 8.25F, FontStyle.Bold, GraphicsUnit.Point, 0uy),
//000102:                   Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000103:                   Location = Point(295, height + 31),
//000104:                   Size = Size(14,13))
//000105:     let numProcsTrackBar = 
//000106:         new TrackBar(Value = Environment.ProcessorCount,
//000107:                      Maximum = Environment.ProcessorCount,
//000108:                      Minimum = 1,
//000109:                      Enabled = false,
//000110:                      Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000111:                      Location = Point(304, height + 21),
//000112:                      Size = Size(178,45))
//000113:     
//000114:     let sceneAtTime elapsedSecs = 
//000115:         let dy2 = 0.8 * abs (sin ((float elapsedSecs) * Math.PI / 3000.0))
//000116:         let sphere = Sphere( Vector(-0.5,0.5+dy2,1.5), 0.5, Surfaces.MatteShiny)
//000117:         { baseScene with Things = sphere :: baseScene.Things  }
//000118:         
//000119:     let configureImage () =
//000120:         if bitmap = null || (bitmap.Width <> pictureBox.Width) || (bitmap.Height <> pictureBox.Height)    
//000121:         then
//000122:             if bitmap <> null
//000123:             then
//000124:                 pictureBox.Image <- null
//000125:                 bitmap.Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-1'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::add_CheckedChanged(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@167-1'::Invoke

  } // end of class '-ctor@167-1'

  .class auto ansi nested assembly beforefieldinit '-ctor@167-2'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.CheckBox eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-2'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@167-2'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-2'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::remove_CheckedChanged(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@167-2'::Invoke

  } // end of class '-ctor@167-2'

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname '-ctor@167-4'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@167-4'::callback
      IL_0007:  ldarg.0
      IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
      IL_000d:  ret
    } // end of method '-ctor@167-4'::.ctor

    .method assembly instance void  Invoke(object sender,
                                           class [mscorlib]System.EventArgs e) cil managed
    {
      // Code size       16 (0x10)
      .maxstack  7
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@167-4'::callback
      IL_0007:  ldarg.1
      IL_0008:  ldarg.2
      IL_0009:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [mscorlib]System.EventArgs>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                         !0,
                                                                                                                                                                                         !1)
      IL_000e:  pop
      IL_000f:  ret
    } // end of method '-ctor@167-4'::Invoke

  } // end of class '-ctor@167-4'

  .class auto ansi serializable nested assembly beforefieldinit '-ctor@167-3'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>::.ctor()
      IL_0006:  ret
    } // end of method '-ctor@167-3'::.ctor

    .method public strict virtual instance class [mscorlib]System.EventHandler 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  newobj     instance void Harness/'-ctor@167-4'::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>)
      IL_0007:  ldftn      instance void Harness/'-ctor@167-4'::Invoke(object,
                                                                       class [mscorlib]System.EventArgs)
      IL_000d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                              native int)
      IL_0012:  ret
    } // end of method '-ctor@167-3'::Invoke

  } // end of class '-ctor@167-3'

  .class auto ansi nested assembly beforefieldinit '-ctor@167-5'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox
    .field public class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox,
                                 class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel,
                                 class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'-ctor@167-5'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::isParallelCheckBox
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::showThreadsCheckbox
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    numProcsLabel
      IL_001e:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@167-5'::numProcsLabel
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    numProcsTrackBar
      IL_0026:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@167-5'::numProcsTrackBar
      IL_002b:  ret
    } // end of method '-ctor@167-5'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventArgs _arg1) cil managed
    {
      // Code size       93 (0x5d)
      .maxstack  6
      .locals init ([0] class [mscorlib]System.EventArgs V_0)
//000168:         isParallel <- isParallelCheckBox.Checked
      IL_0000:  ldarg.1
      IL_0001:  stloc.0
      IL_0002:  nop
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Harness/RayTracerForm Harness/'-ctor@167-5'::this
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::isParallelCheckBox
      IL_000f:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_0014:  stfld      bool Harness/RayTracerForm::isParallel
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
      IL_0019:  ldarg.0
      IL_001a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@167-5'::numProcsLabel
      IL_001f:  ldarg.0
      IL_0020:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::isParallelCheckBox
      IL_0025:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_002a:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@167-5'::numProcsTrackBar
      IL_0035:  ldarg.0
      IL_0036:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::isParallelCheckBox
      IL_003b:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_0040:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
      IL_0045:  ldarg.0
      IL_0046:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::showThreadsCheckbox
      IL_004b:  ldarg.0
      IL_004c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@167-5'::isParallelCheckBox
      IL_0051:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_0056:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_005b:  ldnull
      IL_005c:  ret
    } // end of method '-ctor@167-5'::Invoke

  } // end of class '-ctor@167-5'

  .class auto ansi nested assembly beforefieldinit '-ctor@174-6'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.TrackBar eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-6'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@174-6'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-6'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@174-6'::Invoke

  } // end of class '-ctor@174-6'

  .class auto ansi nested assembly beforefieldinit '-ctor@174-7'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.TrackBar eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-7'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@174-7'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-7'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::remove_ValueChanged(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@174-7'::Invoke

  } // end of class '-ctor@174-7'

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname '-ctor@174-9'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@174-9'::callback
      IL_0007:  ldarg.0
      IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
      IL_000d:  ret
    } // end of method '-ctor@174-9'::.ctor

    .method assembly instance void  Invoke(object sender,
                                           class [mscorlib]System.EventArgs e) cil managed
    {
      // Code size       16 (0x10)
      .maxstack  7
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@174-9'::callback
      IL_0007:  ldarg.1
      IL_0008:  ldarg.2
      IL_0009:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [mscorlib]System.EventArgs>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                         !0,
                                                                                                                                                                                         !1)
      IL_000e:  pop
      IL_000f:  ret
    } // end of method '-ctor@174-9'::Invoke

  } // end of class '-ctor@174-9'

  .class auto ansi serializable nested assembly beforefieldinit '-ctor@174-8'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>::.ctor()
      IL_0006:  ret
    } // end of method '-ctor@174-8'::.ctor

    .method public strict virtual instance class [mscorlib]System.EventHandler 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  newobj     instance void Harness/'-ctor@174-9'::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>)
      IL_0007:  ldftn      instance void Harness/'-ctor@174-9'::Invoke(object,
                                                                       class [mscorlib]System.EventArgs)
      IL_000d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                              native int)
      IL_0012:  ret
    } // end of method '-ctor@174-8'::Invoke

  } // end of class '-ctor@174-8'

  .class auto ansi nested assembly beforefieldinit '-ctor@174-10'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel,
                                 class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'-ctor@174-10'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@174-10'::numProcsLabel
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-10'::numProcsTrackBar
      IL_001b:  ret
    } // end of method '-ctor@174-10'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventArgs _arg2) cil managed
    {
      // Code size       117 (0x75)
      .maxstack  8
      .locals init ([0] class [mscorlib]System.EventArgs V_0,
               [1] int32 V_1,
               [2] object V_2,
               [3] class [mscorlib]System.IFormattable V_3,
               [4] class [mscorlib]System.IFormattable V_4,
               [5] object V_5)
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
      IL_0000:  ldarg.1
      IL_0001:  stloc.0
      IL_0002:  nop
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@174-10'::numProcsLabel
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-10'::numProcsTrackBar
      IL_000f:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
      IL_0014:  stloc.1
      IL_0015:  ldloc.1
      IL_0016:  box        [mscorlib]System.Int32
      IL_001b:  stloc.2
      IL_001c:  ldloc.2
      IL_001d:  brfalse.s  IL_002d

      IL_001f:  ldloc.2
      IL_0020:  isinst     [mscorlib]System.IFormattable
      IL_0025:  stloc.3
      IL_0026:  ldloc.3
      IL_0027:  brfalse.s  IL_002b

      IL_0029:  br.s       IL_0035

      IL_002b:  br.s       IL_004d

//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_002d:  ldstr      ""
      IL_0032:  nop
      IL_0033:  br.s       IL_0058

      IL_0035:  ldloc.3
      IL_0036:  stloc.s    V_4
      IL_0038:  ldloc.s    V_4
      IL_003a:  ldnull
      IL_003b:  call       class [mscorlib]System.Globalization.CultureInfo [mscorlib]System.Globalization.CultureInfo::get_InvariantCulture()
      IL_0040:  unbox.any  [mscorlib]System.IFormatProvider
      IL_0045:  callvirt   instance string [mscorlib]System.IFormattable::ToString(string,
                                                                                   class [mscorlib]System.IFormatProvider)
      IL_004a:  nop
      IL_004b:  br.s       IL_0058

      IL_004d:  ldloc.2
      IL_004e:  stloc.s    V_5
      IL_0050:  ldloc.s    V_5
      IL_0052:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0057:  nop
      IL_0058:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
      IL_005d:  ldarg.0
      IL_005e:  ldfld      class Harness/RayTracerForm Harness/'-ctor@174-10'::this
      IL_0063:  ldarg.0
      IL_0064:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@174-10'::numProcsTrackBar
      IL_0069:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
      IL_006e:  stfld      int32 Harness/RayTracerForm::degreeOfParallelism
      IL_0073:  ldnull
      IL_0074:  ret
    } // end of method '-ctor@174-10'::Invoke

  } // end of class '-ctor@174-10'

  .class auto ansi nested assembly beforefieldinit '-ctor@179-11'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.Button eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.Button eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-11'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@179-11'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-11'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@179-11'::Invoke

  } // end of class '-ctor@179-11'

  .class auto ansi nested assembly beforefieldinit '-ctor@179-12'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [System.Windows.Forms]System.Windows.Forms.Button eventTarget
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System.Windows.Forms]System.Windows.Forms.Button eventTarget) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventHandler,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-12'::eventTarget
      IL_000d:  ret
    } // end of method '-ctor@179-12'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventHandler eventDelegate) cil managed
    {
      // Code size       15 (0xf)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-12'::eventTarget
      IL_0007:  ldarg.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::remove_Click(class [mscorlib]System.EventHandler)
      IL_000d:  ldnull
      IL_000e:  ret
    } // end of method '-ctor@179-12'::Invoke

  } // end of class '-ctor@179-12'

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname '-ctor@179-14'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@179-14'::callback
      IL_0007:  ldarg.0
      IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
      IL_000d:  ret
    } // end of method '-ctor@179-14'::.ctor

    .method assembly instance void  Invoke(object sender,
                                           class [mscorlib]System.EventArgs e) cil managed
    {
      // Code size       16 (0x10)
      .maxstack  7
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> Harness/'-ctor@179-14'::callback
      IL_0007:  ldarg.1
      IL_0008:  ldarg.2
      IL_0009:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [mscorlib]System.EventArgs>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                         !0,
                                                                                                                                                                                         !1)
      IL_000e:  pop
      IL_000f:  ret
    } // end of method '-ctor@179-14'::Invoke

  } // end of class '-ctor@179-14'

  .class auto ansi serializable nested assembly beforefieldinit '-ctor@179-13'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>,class [mscorlib]System.EventHandler>::.ctor()
      IL_0006:  ret
    } // end of method '-ctor@179-13'::.ctor

    .method public strict virtual instance class [mscorlib]System.EventHandler 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>> callback) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  newobj     instance void Harness/'-ctor@179-14'::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>)
      IL_0007:  ldftn      instance void Harness/'-ctor@179-14'::Invoke(object,
                                                                        class [mscorlib]System.EventArgs)
      IL_000d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                              native int)
      IL_0012:  ret
    } // end of method '-ctor@179-13'::Invoke

  } // end of class '-ctor@179-13'

  .class auto ansi serializable nested assembly beforefieldinit 't@190-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'t@190-1'::builder@
      IL_000d:  ret
    } // end of method 't@190-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit _arg5) cil managed
    {
      // Code size       16 (0x10)
      .maxstack  6
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  pop
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'t@190-1'::builder@
      IL_0009:  ldnull
      IL_000a:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Return<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(!!0)
      IL_000f:  ret
    } // end of method 't@190-1'::Invoke

  } // end of class 't@190-1'

  .class auto ansi serializable nested assembly beforefieldinit t@190
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/t@190::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/t@190::builder@
      IL_0014:  ret
    } // end of method t@190::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       35 (0x23)
      .maxstack  7
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/t@190::builder@
      IL_0007:  ldarg.0
      IL_0008:  ldfld      class Harness/RayTracerForm Harness/t@190::this
      IL_000d:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> Harness/RayTracerForm::renderLoop()
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/t@190::builder@
      IL_0018:  newobj     instance void Harness/'t@190-1'::.ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder)
      IL_001d:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!1> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Bind<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>,
                                                                                                                                                                                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!1>>)
      IL_0022:  ret
    } // end of method t@190::Invoke

  } // end of class t@190

  .class auto autochar sealed nested assembly beforefieldinit specialname '-ctor@192-16'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System.Windows.Forms]System.Windows.Forms.Button startStopButton
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox
    .field public class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar
    .method public specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [System.Windows.Forms]System.Windows.Forms.Button startStopButton,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox,
                                 class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel,
                                 class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar) cil managed
    {
      // Code size       52 (0x34)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Harness/RayTracerForm Harness/'-ctor@192-16'::this
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@192-16'::startStopButton
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@192-16'::isParallelCheckBox
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    showThreadsCheckbox
      IL_0018:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@192-16'::showThreadsCheckbox
      IL_001d:  ldarg.0
      IL_001e:  ldarg.s    numProcsLabel
      IL_0020:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@192-16'::numProcsLabel
      IL_0025:  ldarg.0
      IL_0026:  ldarg.s    numProcsTrackBar
      IL_0028:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@192-16'::numProcsTrackBar
      IL_002d:  ldarg.0
      IL_002e:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0033:  ret
    } // end of method '-ctor@192-16'::.ctor

    .method assembly instance void  Invoke(class [mscorlib]System.Threading.Tasks.Task obj) cil managed
    {
      // Code size       100 (0x64)
      .maxstack  6
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@192-16'::isParallelCheckBox
      IL_0007:  ldc.i4.1
      IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@192-16'::showThreadsCheckbox
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@192-16'::isParallelCheckBox
      IL_0019:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_001e:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000195:                 numProcsLabel.Enabled <- true
      IL_0023:  ldarg.0
      IL_0024:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@192-16'::numProcsLabel
      IL_0029:  ldc.i4.1
      IL_002a:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000196:                 numProcsTrackBar.Enabled <- true
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@192-16'::numProcsTrackBar
      IL_0035:  ldc.i4.1
      IL_0036:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000197:                 startStopButton.Enabled <- true
      IL_003b:  ldarg.0
      IL_003c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@192-16'::startStopButton
      IL_0041:  ldc.i4.1
      IL_0042:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000198:                 startStopButton.Text <- "Start"
      IL_0047:  ldarg.0
      IL_0048:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@192-16'::startStopButton
      IL_004d:  ldstr      "Start"
      IL_0052:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class Harness/RayTracerForm Harness/'-ctor@192-16'::this
      IL_005d:  ldnull
      IL_005e:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Harness/RayTracerForm::cancellation
      IL_0063:  ret
    } // end of method '-ctor@192-16'::Invoke

  } // end of class '-ctor@192-16'

  .class auto ansi nested assembly beforefieldinit '-ctor@179-15'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System.Windows.Forms]System.Windows.Forms.Button startStopButton
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox
    .field public class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox
    .field public class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel
    .field public class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [System.Windows.Forms]System.Windows.Forms.Button startStopButton,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox isParallelCheckBox,
                                 class [System.Windows.Forms]System.Windows.Forms.CheckBox showThreadsCheckbox,
                                 class [System.Windows.Forms]System.Windows.Forms.Label numProcsLabel,
                                 class [System.Windows.Forms]System.Windows.Forms.TrackBar numProcsTrackBar) cil managed
    {
      // Code size       52 (0x34)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.EventArgs,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-15'::startStopButton
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::isParallelCheckBox
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    showThreadsCheckbox
      IL_001e:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::showThreadsCheckbox
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    numProcsLabel
      IL_0026:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@179-15'::numProcsLabel
      IL_002b:  ldarg.0
      IL_002c:  ldarg.s    numProcsTrackBar
      IL_002e:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@179-15'::numProcsTrackBar
      IL_0033:  ret
    } // end of method '-ctor@179-15'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.EventArgs _arg3) cil managed
    {
      // Code size       294 (0x126)
      .maxstack  11
      .locals init ([0] class [mscorlib]System.EventArgs V_0,
               [1] class [mscorlib]System.Threading.CancellationTokenSource V_1,
               [2] class [mscorlib]System.Threading.CancellationTokenSource V_2,
               [3] class Harness/RayTracerForm V_3,
               [4] class [mscorlib]System.Threading.SynchronizationContext sc,
               [5] class [mscorlib]System.Threading.Tasks.Task`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> t,
               [6] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_6,
               [7] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@,
               [8] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_8,
               [9] class [mscorlib]System.Threading.Tasks.Task V_9,
               [10] class [mscorlib]System.Threading.Tasks.Task V_10)
//000180:         if cancellation <> null 
      IL_0000:  ldarg.1
      IL_0001:  stloc.0
      IL_0002:  nop
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_0009:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Harness/RayTracerForm::cancellation
      IL_000e:  stloc.1
      IL_000f:  ldnull
      IL_0010:  stloc.2
      IL_0011:  ldloc.1
      IL_0012:  ldloc.2
      IL_0013:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Threading.CancellationTokenSource>(!!0,
                                                                                                                                                                                      !!0)
      IL_0018:  ldc.i4.0
      IL_0019:  ceq
      IL_001b:  brfalse.s  IL_001f

      IL_001d:  br.s       IL_0021

      IL_001f:  br.s       IL_0035

//000181:         then
//000182:             startStopButton.Enabled <- false 
      IL_0021:  ldarg.0
      IL_0022:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-15'::startStopButton
      IL_0027:  ldc.i4.0
      IL_0028:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000183:             Async.CancelDefaultToken()
      IL_002d:  call       void [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync::CancelDefaultToken()
      IL_0032:  nop
      IL_0033:  ldnull
      IL_0034:  ret

//000184:         else
//000185:             configureImage()  
      IL_0035:  ldarg.0
      IL_0036:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_003b:  stloc.3
      IL_003c:  ldloc.3
      IL_003d:  ldnull
      IL_003e:  pop
      IL_003f:  call       instance void Harness/RayTracerForm::configureImage()
      IL_0044:  nop
//000186:             showThreads <- showThreadsCheckbox.Checked
      IL_0045:  ldarg.0
      IL_0046:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_004b:  ldarg.0
      IL_004c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::showThreadsCheckbox
      IL_0051:  call       instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
      IL_0056:  stfld      bool Harness/RayTracerForm::showThreads
//000187:             cancellation <- new CancellationTokenSource()
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_0061:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
      IL_0066:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Harness/RayTracerForm::cancellation
//000188:             let sc = SynchronizationContext.Current
      IL_006b:  call       class [mscorlib]System.Threading.SynchronizationContext [mscorlib]System.Threading.SynchronizationContext::get_Current()
      IL_0070:  stloc.s    sc
//000189:             let t = 
      IL_0072:  call       class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::get_DefaultAsyncBuilder()
      IL_0077:  stloc.s    builder@
      IL_0079:  ldloc.s    builder@
      IL_007b:  ldarg.0
      IL_007c:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_0081:  ldloc.s    builder@
      IL_0083:  newobj     instance void Harness/t@190::.ctor(class Harness/RayTracerForm,
                                                              class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder)
      IL_0088:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_008d:  stloc.s    V_6
      IL_008f:  ldloc.s    V_6
      IL_0091:  stloc.s    V_8
      IL_0093:  ldloc.s    V_8
      IL_0095:  ldnull
      IL_0096:  ldnull
      IL_0097:  call       class [mscorlib]System.Threading.Tasks.Task`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync::StartAsTask<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>,
                                                                                                                                                                                            class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<valuetype [mscorlib]System.Threading.Tasks.TaskCreationOptions>,
                                                                                                                                                                                            class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<valuetype [mscorlib]System.Threading.CancellationToken>)
      IL_009c:  stloc.s    t
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
      IL_009e:  ldloc.s    t
      IL_00a0:  ldarg.0
      IL_00a1:  ldfld      class Harness/RayTracerForm Harness/'-ctor@179-15'::this
      IL_00a6:  ldarg.0
      IL_00a7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-15'::startStopButton
      IL_00ac:  ldarg.0
      IL_00ad:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::isParallelCheckBox
      IL_00b2:  ldarg.0
      IL_00b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::showThreadsCheckbox
      IL_00b8:  ldarg.0
      IL_00b9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@179-15'::numProcsLabel
      IL_00be:  ldarg.0
      IL_00bf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@179-15'::numProcsTrackBar
      IL_00c4:  newobj     instance void Harness/'-ctor@192-16'::.ctor(class Harness/RayTracerForm,
                                                                       class [System.Windows.Forms]System.Windows.Forms.Button,
                                                                       class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                       class [System.Windows.Forms]System.Windows.Forms.CheckBox,
                                                                       class [System.Windows.Forms]System.Windows.Forms.Label,
                                                                       class [System.Windows.Forms]System.Windows.Forms.TrackBar)
      IL_00c9:  ldftn      instance void Harness/'-ctor@192-16'::Invoke(class [mscorlib]System.Threading.Tasks.Task)
      IL_00cf:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>::.ctor(object,
                                                                                                                             native int)
      IL_00d4:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
      IL_00d9:  call       instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>,
                                                                                                                                    class [mscorlib]System.Threading.Tasks.TaskScheduler)
      IL_00de:  stloc.s    V_9
      IL_00e0:  ldloc.s    V_9
      IL_00e2:  stloc.s    V_10
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
      IL_00e4:  ldarg.0
      IL_00e5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::isParallelCheckBox
      IL_00ea:  ldc.i4.0
      IL_00eb:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000201:             showThreadsCheckbox.Enabled <- true
      IL_00f0:  ldarg.0
      IL_00f1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Harness/'-ctor@179-15'::showThreadsCheckbox
      IL_00f6:  ldc.i4.1
      IL_00f7:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000202:             numProcsLabel.Enabled <- false
      IL_00fc:  ldarg.0
      IL_00fd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Harness/'-ctor@179-15'::numProcsLabel
      IL_0102:  ldc.i4.0
      IL_0103:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000203:             numProcsTrackBar.Enabled <- false
      IL_0108:  ldarg.0
      IL_0109:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Harness/'-ctor@179-15'::numProcsTrackBar
      IL_010e:  ldc.i4.0
      IL_010f:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
//000204:             startStopButton.Text <- "Stop")
      IL_0114:  ldarg.0
      IL_0115:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Harness/'-ctor@179-15'::startStopButton
      IL_011a:  ldstr      "Stop"
      IL_011f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_0124:  ldnull
      IL_0125:  ret
    } // end of method '-ctor@179-15'::Invoke

  } // end of class '-ctor@179-15'

  .class auto ansi serializable nested assembly beforefieldinit 'clo@128-2'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,int32[]>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,int32[]>::.ctor()
      IL_0006:  ret
    } // end of method 'clo@128-2'::.ctor

    .method public strict virtual instance int32[] 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar0) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
      IL_0000:  nop
      IL_0001:  call       int32 Harness::get_width()
      IL_0006:  call       int32 Harness::get_height()
      IL_000b:  mul
      IL_000c:  ldc.i4.0
      IL_000d:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Create<int32>(int32,
                                                                                                      !!0)
      IL_0012:  ret
    } // end of method 'clo@128-2'::Invoke

  } // end of class 'clo@128-2'

  .class auto ansi serializable nested assembly beforefieldinit 'clo@138-4'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,bool>::.ctor()
      IL_0006:  ret
    } // end of method 'clo@138-4'::.ctor

    .method public strict virtual instance bool 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       3 (0x3)
      .maxstack  5
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
      IL_0000:  nop
      IL_0001:  ldc.i4.1
      IL_0002:  ret
    } // end of method 'clo@138-4'::Invoke

  } // end of class 'clo@138-4'

  .class auto ansi nested assembly beforefieldinit 'clo@145-6'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .field public class Raytracer_FSharp/RayTracer raytracer
    .field public class [System]System.Diagnostics.Stopwatch totalElapsed
    .field public int32[] rgb
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@,
                                 class Raytracer_FSharp/RayTracer raytracer,
                                 class [System]System.Diagnostics.Stopwatch totalElapsed,
                                 int32[] rgb) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@145-6'::builder@
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class Raytracer_FSharp/RayTracer Harness/'clo@145-6'::raytracer
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    totalElapsed
      IL_001e:  stfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@145-6'::totalElapsed
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    rgb
      IL_0026:  stfld      int32[] Harness/'clo@145-6'::rgb
      IL_002b:  ret
    } // end of method 'clo@145-6'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       201 (0xc9)
      .maxstack  8
      .locals init ([0] class [mscorlib]System.Threading.Tasks.ParallelOptions parallelOptions,
               [1] class [mscorlib]System.Threading.Tasks.ParallelOptions V_1,
               [2] class Raytracer_FSharp/Scene scene)
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
      IL_0000:  nop
      IL_0001:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
      IL_0006:  stloc.1
      IL_0007:  ldloc.1
      IL_0008:  ldarg.0
      IL_0009:  ldfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_000e:  ldfld      int32 Harness/RayTracerForm::degreeOfParallelism
      IL_0013:  call       instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_MaxDegreeOfParallelism(int32)
      IL_0018:  ldloc.1
      IL_0019:  ldarg.0
      IL_001a:  ldfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_001f:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Harness/RayTracerForm::cancellation
      IL_0024:  call       instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
      IL_0029:  call       instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_CancellationToken(valuetype [mscorlib]System.Threading.CancellationToken)
      IL_002e:  ldloc.1
      IL_002f:  stloc.0
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
      IL_0030:  ldarg.0
      IL_0031:  ldfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_0036:  ldarg.0
      IL_0037:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@145-6'::totalElapsed
      IL_003c:  call       instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
      IL_0041:  call       instance class Raytracer_FSharp/Scene Harness/RayTracerForm::sceneAtTime(int64)
      IL_0046:  stloc.2
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
      IL_0047:  ldarg.0
      IL_0048:  ldfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_004d:  ldfld      bool Harness/RayTracerForm::isParallel
      IL_0052:  brtrue.s   IL_0056

      IL_0054:  br.s       IL_0058

      IL_0056:  br.s       IL_0077

      IL_0058:  ldarg.0
      IL_0059:  ldfld      class Raytracer_FSharp/RayTracer Harness/'clo@145-6'::raytracer
      IL_005e:  ldloc.2
      IL_005f:  ldarg.0
      IL_0060:  ldfld      int32[] Harness/'clo@145-6'::rgb
      IL_0065:  call       instance void Raytracer_FSharp/RayTracer::RenderSequential(class Raytracer_FSharp/Scene,
                                                                                      int32[])
      IL_006a:  nop
      IL_006b:  ldarg.0
      IL_006c:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@145-6'::builder@
      IL_0071:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Zero()
      IL_0076:  ret

//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
      IL_0077:  ldarg.0
      IL_0078:  ldfld      class Harness/RayTracerForm Harness/'clo@145-6'::this
      IL_007d:  ldfld      bool Harness/RayTracerForm::showThreads
      IL_0082:  brfalse.s  IL_0086

      IL_0084:  br.s       IL_0088

      IL_0086:  br.s       IL_00a8

      IL_0088:  ldarg.0
      IL_0089:  ldfld      class Raytracer_FSharp/RayTracer Harness/'clo@145-6'::raytracer
      IL_008e:  ldloc.2
      IL_008f:  ldarg.0
      IL_0090:  ldfld      int32[] Harness/'clo@145-6'::rgb
      IL_0095:  ldloc.0
      IL_0096:  call       instance void Raytracer_FSharp/RayTracer::RenderParallelShowingThreads(class Raytracer_FSharp/Scene,
                                                                                                  int32[],
                                                                                                  class [mscorlib]System.Threading.Tasks.ParallelOptions)
      IL_009b:  nop
      IL_009c:  ldarg.0
      IL_009d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@145-6'::builder@
      IL_00a2:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Zero()
      IL_00a7:  ret

      IL_00a8:  nop
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
      IL_00a9:  ldarg.0
      IL_00aa:  ldfld      class Raytracer_FSharp/RayTracer Harness/'clo@145-6'::raytracer
      IL_00af:  ldloc.2
      IL_00b0:  ldarg.0
      IL_00b1:  ldfld      int32[] Harness/'clo@145-6'::rgb
      IL_00b6:  ldloc.0
      IL_00b7:  call       instance void Raytracer_FSharp/RayTracer::RenderParallel(class Raytracer_FSharp/Scene,
                                                                                    int32[],
                                                                                    class [mscorlib]System.Threading.Tasks.ParallelOptions)
      IL_00bc:  nop
      IL_00bd:  ldarg.0
      IL_00be:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@145-6'::builder@
      IL_00c3:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Zero()
      IL_00c8:  ret
    } // end of method 'clo@145-6'::Invoke

  } // end of class 'clo@145-6'

  .class auto ansi serializable nested assembly beforefieldinit 'clo@144-7'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Exception,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Exception,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@144-7'::builder@
      IL_000d:  ret
    } // end of method 'clo@144-7'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [mscorlib]System.Exception _arg4) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  5
      .locals init ([0] class [mscorlib]System.Exception V_0,
               [1] class [mscorlib]System.OperationCanceledException V_1)
//000144:             try 
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  isinst     [mscorlib]System.OperationCanceledException
      IL_0009:  stloc.1
      IL_000a:  ldloc.1
      IL_000b:  brfalse.s  IL_000f

      IL_000d:  br.s       IL_0011

      IL_000f:  br.s       IL_001d

//000133:     let renderLoop () = async { 
      IL_0011:  ldarg.0
      IL_0012:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@144-7'::builder@
      IL_0017:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Zero()
      IL_001c:  ret

//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
//000220: do Application.SetCompatibleTextRenderingDefault(false);
//000221: do Application.Run(new RayTracerForm())
//000222: #endif
      IL_001d:  ldloc.0
      IL_001e:  throw
    } // end of method 'clo@144-7'::Invoke

  } // end of class 'clo@144-7'

  .class auto autochar sealed nested assembly beforefieldinit specialname 'clo@158-9'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32[] rgb
    .field public float64 framesPerSecond
    .method public specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 int32[] rgb,
                                 float64 framesPerSecond) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      int32[] Harness/'clo@158-9'::rgb
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      float64 Harness/'clo@158-9'::framesPerSecond
      IL_0015:  ldarg.0
      IL_0016:  call       instance void [mscorlib]System.Object::.ctor()
      IL_001b:  ret
    } // end of method 'clo@158-9'::.ctor

    .method assembly instance void  Invoke() cil managed
    {
      // Code size       182 (0xb6)
      .maxstack  8
      .locals init ([0] class [System.Drawing]System.Drawing.Imaging.BitmapData bmpData)
//000158:             this.BeginInvoke (Action< >(fun () -> 
      IL_0000:  nop
      IL_0001:  nop
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0008:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0013:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle Harness/RayTracerForm::rect
      IL_0018:  ldc.i4.2
      IL_0019:  ldarg.0
      IL_001a:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_001f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0024:  call       instance valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat [System.Drawing]System.Drawing.Image::get_PixelFormat()
      IL_0029:  call       instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_002e:  stloc.0
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
      IL_002f:  ldarg.0
      IL_0030:  ldfld      int32[] Harness/'clo@158-9'::rgb
      IL_0035:  ldc.i4.0
      IL_0036:  ldloc.0
      IL_0037:  call       instance native int [System.Drawing]System.Drawing.Imaging.BitmapData::get_Scan0()
      IL_003c:  ldarg.0
      IL_003d:  ldfld      int32[] Harness/'clo@158-9'::rgb
      IL_0042:  ldlen
      IL_0043:  conv.i4
      IL_0044:  call       void [mscorlib]System.Runtime.InteropServices.Marshal::Copy(int32[],
                                                                                       int32,
                                                                                       native int,
                                                                                       int32)
//000161:                 bitmap.UnlockBits bmpData
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_004f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Harness/RayTracerForm::bitmap
      IL_0054:  ldloc.0
      IL_0055:  call       instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
//000162:                 buffers.PutObject(rgb) 
      IL_005a:  ldarg.0
      IL_005b:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0060:  ldfld      class Harness/ObjectPool`1<int32[]> Harness/RayTracerForm::buffers
      IL_0065:  ldarg.0
      IL_0066:  ldfld      int32[] Harness/'clo@158-9'::rgb
      IL_006b:  call       instance void class Harness/ObjectPool`1<int32[]>::PutObject(!0)
      IL_0070:  nop
//000163:                 pictureBox.Invalidate ()
      IL_0071:  ldarg.0
      IL_0072:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0077:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Harness/RayTracerForm::pictureBox
      IL_007c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::Invalidate()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
      IL_0081:  ldarg.0
      IL_0082:  ldfld      class Harness/RayTracerForm Harness/'clo@158-9'::this
      IL_0087:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_008c:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_0091:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0096:  ldstr      "RayTracer - FPS: "
      IL_009b:  ldarg.0
      IL_009c:  ldflda     float64 Harness/'clo@158-9'::framesPerSecond
      IL_00a1:  ldstr      "F1"
      IL_00a6:  call       instance string [mscorlib]System.Double::ToString(string)
      IL_00ab:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_00b0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_00b5:  ret
    } // end of method 'clo@158-9'::Invoke

  } // end of class 'clo@158-9'

  .class auto ansi nested assembly beforefieldinit 'clo@153-8'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .field public class [System]System.Diagnostics.Stopwatch renderingTime
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> frame
    .field public int32[] rgb
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@,
                                 class [System]System.Diagnostics.Stopwatch renderingTime,
                                 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> frame,
                                 int32[] rgb) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'clo@153-8'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@153-8'::builder@
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@153-8'::renderingTime
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    frame
      IL_001e:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Harness/'clo@153-8'::frame
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    rgb
      IL_0026:  stfld      int32[] Harness/'clo@153-8'::rgb
      IL_002b:  ret
    } // end of method 'clo@153-8'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       117 (0x75)
      .maxstack  8
      .locals init ([0] float64 framesPerSecond,
               [1] class [mscorlib]System.IAsyncResult V_1,
               [2] class [mscorlib]System.IAsyncResult V_2)
//000153:             renderingTime.Stop ()
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@153-8'::renderingTime
      IL_0007:  call       instance void [System]System.Diagnostics.Stopwatch::Stop()
//000154:             
//000155:             incr frame
      IL_000c:  ldarg.0
      IL_000d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Harness/'clo@153-8'::frame
      IL_0012:  call       void [FSharp.Core]Microsoft.FSharp.Core.Operators::Increment(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>)
      IL_0017:  nop
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
      IL_0018:  ldc.r8     1000.
      IL_0021:  ldarg.0
      IL_0022:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@153-8'::renderingTime
      IL_0027:  call       instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
      IL_002c:  conv.r8
      IL_002d:  div
      IL_002e:  stloc.0
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class Harness/RayTracerForm Harness/'clo@153-8'::this
      IL_0035:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm> Harness/RayTracerForm::this
      IL_003a:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<class Harness/RayTracerForm>::get_contents()
      IL_003f:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::CheckThis<class Harness/RayTracerForm>(!!0)
      IL_0044:  ldarg.0
      IL_0045:  ldfld      class Harness/RayTracerForm Harness/'clo@153-8'::this
      IL_004a:  ldarg.0
      IL_004b:  ldfld      int32[] Harness/'clo@153-8'::rgb
      IL_0050:  ldloc.0
      IL_0051:  newobj     instance void Harness/'clo@158-9'::.ctor(class Harness/RayTracerForm,
                                                                    int32[],
                                                                    float64)
      IL_0056:  ldftn      instance void Harness/'clo@158-9'::Invoke()
      IL_005c:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_0061:  call       instance class [mscorlib]System.IAsyncResult [System.Windows.Forms]System.Windows.Forms.Control::BeginInvoke(class [mscorlib]System.Delegate)
      IL_0066:  stloc.1
      IL_0067:  ldloc.1
      IL_0068:  stloc.2
      IL_0069:  ldarg.0
      IL_006a:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@153-8'::builder@
      IL_006f:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Zero()
      IL_0074:  ret
    } // end of method 'clo@153-8'::Invoke

  } // end of class 'clo@153-8'

  .class auto ansi nested assembly beforefieldinit 'clo@139-5'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .field public class Raytracer_FSharp/RayTracer raytracer
    .field public class [System]System.Diagnostics.Stopwatch totalElapsed
    .field public class [System]System.Diagnostics.Stopwatch renderingTime
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> frame
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@,
                                 class Raytracer_FSharp/RayTracer raytracer,
                                 class [System]System.Diagnostics.Stopwatch totalElapsed,
                                 class [System]System.Diagnostics.Stopwatch renderingTime,
                                 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> frame) cil managed
    {
      // Code size       52 (0x34)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'clo@139-5'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class Raytracer_FSharp/RayTracer Harness/'clo@139-5'::raytracer
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    totalElapsed
      IL_001e:  stfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::totalElapsed
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    renderingTime
      IL_0026:  stfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::renderingTime
      IL_002b:  ldarg.0
      IL_002c:  ldarg.s    frame
      IL_002e:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Harness/'clo@139-5'::frame
      IL_0033:  ret
    } // end of method 'clo@139-5'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       156 (0x9c)
      .maxstack  12
      .locals init ([0] int32[] rgb)
//000139:             let rgb = buffers.GetObject()
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Harness/RayTracerForm Harness/'clo@139-5'::this
      IL_0007:  ldfld      class Harness/ObjectPool`1<int32[]> Harness/RayTracerForm::buffers
      IL_000c:  call       instance !0 class Harness/ObjectPool`1<int32[]>::GetObject()
      IL_0011:  stloc.0
//000140:             
//000141:             renderingTime.Reset ()
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::renderingTime
      IL_0018:  call       instance void [System]System.Diagnostics.Stopwatch::Reset()
//000142:             renderingTime.Start ()
      IL_001d:  ldarg.0
      IL_001e:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::renderingTime
      IL_0023:  call       instance void [System]System.Diagnostics.Stopwatch::Start()
//000143:             
//000144:             try 
      IL_0028:  ldarg.0
      IL_0029:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_0034:  ldarg.0
      IL_0035:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_003a:  ldarg.0
      IL_003b:  ldfld      class Harness/RayTracerForm Harness/'clo@139-5'::this
      IL_0040:  ldarg.0
      IL_0041:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_0046:  ldarg.0
      IL_0047:  ldfld      class Raytracer_FSharp/RayTracer Harness/'clo@139-5'::raytracer
      IL_004c:  ldarg.0
      IL_004d:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::totalElapsed
      IL_0052:  ldloc.0
      IL_0053:  newobj     instance void Harness/'clo@145-6'::.ctor(class Harness/RayTracerForm,
                                                                    class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder,
                                                                    class Raytracer_FSharp/RayTracer,
                                                                    class [System]System.Diagnostics.Stopwatch,
                                                                    int32[])
      IL_0058:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_005d:  ldarg.0
      IL_005e:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_0063:  newobj     instance void Harness/'clo@144-7'::.ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder)
      IL_0068:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::TryWith<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>,
                                                                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Exception,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_006d:  ldarg.0
      IL_006e:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_0073:  ldarg.0
      IL_0074:  ldfld      class Harness/RayTracerForm Harness/'clo@139-5'::this
      IL_0079:  ldarg.0
      IL_007a:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@139-5'::builder@
      IL_007f:  ldarg.0
      IL_0080:  ldfld      class [System]System.Diagnostics.Stopwatch Harness/'clo@139-5'::renderingTime
      IL_0085:  ldarg.0
      IL_0086:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Harness/'clo@139-5'::frame
      IL_008b:  ldloc.0
      IL_008c:  newobj     instance void Harness/'clo@153-8'::.ctor(class Harness/RayTracerForm,
                                                                    class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder,
                                                                    class [System]System.Diagnostics.Stopwatch,
                                                                    class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>,
                                                                    int32[])
      IL_0091:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_0096:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Combine<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>)
      IL_009b:  ret
    } // end of method 'clo@139-5'::Invoke

  } // end of class 'clo@139-5'

  .class auto ansi serializable nested assembly beforefieldinit 'clo@134-3'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
  {
    .field public class Harness/RayTracerForm this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Harness/RayTracerForm this,
                                 class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Harness/RayTracerForm Harness/'clo@134-3'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@134-3'::builder@
      IL_0014:  ret
    } // end of method 'clo@134-3'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       85 (0x55)
      .maxstack  13
      .locals init ([0] class Raytracer_FSharp/RayTracer raytracer,
               [1] class [System]System.Diagnostics.Stopwatch totalElapsed,
               [2] class [System]System.Diagnostics.Stopwatch renderingTime,
               [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> frame)
//000134:         let raytracer = RayTracer(width,height)
      IL_0000:  nop
      IL_0001:  call       int32 Harness::get_width()
      IL_0006:  call       int32 Harness::get_height()
      IL_000b:  newobj     instance void Raytracer_FSharp/RayTracer::.ctor(int32,
                                                                           int32)
      IL_0010:  stloc.0
//000135:         let totalElapsed = Stopwatch.StartNew()
      IL_0011:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
      IL_0016:  stloc.1
//000136:         let renderingTime = Stopwatch()
      IL_0017:  newobj     instance void [System]System.Diagnostics.Stopwatch::.ctor()
      IL_001c:  stloc.2
//000137:         let frame = ref 0
      IL_001d:  ldc.i4.0
      IL_001e:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::Ref<int32>(!!0)
      IL_0023:  stloc.3
//000138:         while true do
      IL_0024:  ldarg.0
      IL_0025:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@134-3'::builder@
      IL_002a:  newobj     instance void Harness/'clo@138-4'::.ctor()
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@134-3'::builder@
      IL_0035:  ldarg.0
      IL_0036:  ldfld      class Harness/RayTracerForm Harness/'clo@134-3'::this
      IL_003b:  ldarg.0
      IL_003c:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Harness/'clo@134-3'::builder@
      IL_0041:  ldloc.0
      IL_0042:  ldloc.1
      IL_0043:  ldloc.2
      IL_0044:  ldloc.3
      IL_0045:  newobj     instance void Harness/'clo@139-5'::.ctor(class Harness/RayTracerForm,
                                                                    class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder,
                                                                    class Raytracer_FSharp/RayTracer,
                                                                    class [System]System.Diagnostics.Stopwatch,
                                                                    class [System]System.Diagnostics.Stopwatch,
                                                                    class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>)
      IL_004a:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>)
      IL_004f:  call       instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::While(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,bool>,
                                                                                                                                                                                                             class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit>)
      IL_0054:  ret
    } // end of method 'clo@134-3'::Invoke

  } // end of class 'clo@134-3'

  .class abstract auto ansi sealed nested public Surfaces
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
    .class auto autochar serializable sealed nested assembly beforefieldinit specialname Shiny@20
           extends [mscorlib]System.Object
           implements Raytracer_FSharp/Surface
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
      .method public specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       10 (0xa)
        .maxstack  5
        IL_0000:  nop
        IL_0001:  ldarg.0
        IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0007:  ldarg.0
        IL_0008:  pop
        IL_0009:  ret
      } // end of method Shiny@20::.ctor

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Diffuse(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       34 (0x22)
        .maxstack  7
//000021:             member s.Diffuse pos = Color(1.0,1.0,1.0) 
        IL_0000:  nop
        IL_0001:  ldc.r8     1.
        IL_000a:  ldc.r8     1.
        IL_0013:  ldc.r8     1.
        IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0021:  ret
      } // end of method Shiny@20::Diffuse

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Specular(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       34 (0x22)
        .maxstack  7
//000022:             member s.Specular pos = Color(0.5,0.5,0.5)
        IL_0000:  nop
        IL_0001:  ldc.r8     0.5
        IL_000a:  ldc.r8     0.5
        IL_0013:  ldc.r8     0.5
        IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0021:  ret
      } // end of method Shiny@20::Specular

      .method public hidebysig virtual instance float64 
              Reflect(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       11 (0xb)
        .maxstack  5
//000023:             member s.Reflect pos = 0.7
        IL_0000:  nop
        IL_0001:  ldc.r8     0.69999999999999996
        IL_000a:  ret
      } // end of method Shiny@20::Reflect

      .method public hidebysig virtual instance float64 
              get_Roughness() cil managed
      {
        // Code size       11 (0xb)
        .maxstack  5
//000024:             member s.Roughness = 250.0 }
        IL_0000:  nop
        IL_0001:  ldc.r8     250.
        IL_000a:  ret
      } // end of method Shiny@20::get_Roughness

    } // end of class Shiny@20

    .class auto autochar serializable sealed nested assembly beforefieldinit specialname MatteShiny@26
           extends [mscorlib]System.Object
           implements Raytracer_FSharp/Surface
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
      .method public specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       10 (0xa)
        .maxstack  5
        IL_0000:  nop
        IL_0001:  ldarg.0
        IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0007:  ldarg.0
        IL_0008:  pop
        IL_0009:  ret
      } // end of method MatteShiny@26::.ctor

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Diffuse(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       34 (0x22)
        .maxstack  7
//000025:     let MatteShiny = 
//000026:         { new Surface with
//000027:             member s.Diffuse pos = Color(1.0,1.0,1.0)
        IL_0000:  nop
        IL_0001:  ldc.r8     1.
        IL_000a:  ldc.r8     1.
        IL_0013:  ldc.r8     1.
        IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0021:  ret
      } // end of method MatteShiny@26::Diffuse

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Specular(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       34 (0x22)
        .maxstack  7
//000028:             member s.Specular pos = Color(0.25,0.25,0.25)
        IL_0000:  nop
        IL_0001:  ldc.r8     0.25
        IL_000a:  ldc.r8     0.25
        IL_0013:  ldc.r8     0.25
        IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0021:  ret
      } // end of method MatteShiny@26::Specular

      .method public hidebysig virtual instance float64 
              Reflect(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       11 (0xb)
        .maxstack  5
//000029:             member s.Reflect pos = 0.7
        IL_0000:  nop
        IL_0001:  ldc.r8     0.69999999999999996
        IL_000a:  ret
      } // end of method MatteShiny@26::Reflect

      .method public hidebysig virtual instance float64 
              get_Roughness() cil managed
      {
        // Code size       11 (0xb)
        .maxstack  5
//000030:             member s.Roughness = 250.0 }
        IL_0000:  nop
        IL_0001:  ldc.r8     250.
        IL_000a:  ret
      } // end of method MatteShiny@26::get_Roughness

    } // end of class MatteShiny@26

    .class auto autochar serializable sealed nested assembly beforefieldinit specialname Checkerboard@32
           extends [mscorlib]System.Object
           implements Raytracer_FSharp/Surface
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
      .method public specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       10 (0xa)
        .maxstack  5
        IL_0000:  nop
        IL_0001:  ldarg.0
        IL_0002:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0007:  ldarg.0
        IL_0008:  pop
        IL_0009:  ret
      } // end of method Checkerboard@32::.ctor

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Diffuse(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       113 (0x71)
        .maxstack  7
        .locals init ([0] int32 V_0,
                 [1] float64 V_1,
                 [2] float64 V_2,
                 [3] int32 V_3)
//000031:     let Checkerboard = 
//000032:         { new Surface with 
//000033:             member s.Diffuse pos =
//000034:                 if (int (System.Math.Floor(pos.Z) + System.Math.Floor(pos.X))) % 2 <> 0
        IL_0000:  nop
        IL_0001:  ldarg.1
        IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
        IL_0007:  call       float64 [mscorlib]System.Math::Floor(float64)
        IL_000c:  ldarg.1
        IL_000d:  call       instance float64 Raytracer_FSharp/Vector::get_X()
        IL_0012:  call       float64 [mscorlib]System.Math::Floor(float64)
        IL_0017:  add
        IL_0018:  stloc.1
        IL_0019:  ldloc.1
        IL_001a:  stloc.2
        IL_001b:  ldloc.1
        IL_001c:  conv.i4
        IL_001d:  ldc.i4.2
        IL_001e:  rem
        IL_001f:  stloc.0
        IL_0020:  ldc.i4.0
        IL_0021:  stloc.3
        IL_0022:  ldloc.0
        IL_0023:  ldloc.3
        IL_0024:  ceq
        IL_0026:  ldc.i4.0
        IL_0027:  ceq
        IL_0029:  brfalse.s  IL_002d

        IL_002b:  br.s       IL_002f

        IL_002d:  br.s       IL_0050

//000035:                 then Color(1.0,1.0,1.0)
        IL_002f:  ldc.r8     1.
        IL_0038:  ldc.r8     1.
        IL_0041:  ldc.r8     1.
        IL_004a:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_004f:  ret

//000036:                 else Color(0.0,0.0,0.0);
        IL_0050:  ldc.r8     0.0
        IL_0059:  ldc.r8     0.0
        IL_0062:  ldc.r8     0.0
        IL_006b:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0070:  ret
      } // end of method Checkerboard@32::Diffuse

      .method public hidebysig virtual instance class Raytracer_FSharp/Color 
              Specular(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       34 (0x22)
        .maxstack  7
//000037:             member s.Specular pos = Color(1.0,1.0,1.0);
        IL_0000:  nop
        IL_0001:  ldc.r8     1.
        IL_000a:  ldc.r8     1.
        IL_0013:  ldc.r8     1.
        IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                         float64,
                                                                         float64)
        IL_0021:  ret
      } // end of method Checkerboard@32::Specular

      .method public hidebysig virtual instance float64 
              Reflect(class Raytracer_FSharp/Vector A_1) cil managed
      {
        // Code size       67 (0x43)
        .maxstack  6
        .locals init ([0] int32 V_0,
                 [1] float64 V_1,
                 [2] float64 V_2,
                 [3] int32 V_3)
//000038:             member s.Reflect pos =
//000039:                 if (int (System.Math.Floor(pos.Z) + System.Math.Floor(pos.X))) % 2 <> 0
        IL_0000:  nop
        IL_0001:  ldarg.1
        IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
        IL_0007:  call       float64 [mscorlib]System.Math::Floor(float64)
        IL_000c:  ldarg.1
        IL_000d:  call       instance float64 Raytracer_FSharp/Vector::get_X()
        IL_0012:  call       float64 [mscorlib]System.Math::Floor(float64)
        IL_0017:  add
        IL_0018:  stloc.1
        IL_0019:  ldloc.1
        IL_001a:  stloc.2
        IL_001b:  ldloc.1
        IL_001c:  conv.i4
        IL_001d:  ldc.i4.2
        IL_001e:  rem
        IL_001f:  stloc.0
        IL_0020:  ldc.i4.0
        IL_0021:  stloc.3
        IL_0022:  ldloc.0
        IL_0023:  ldloc.3
        IL_0024:  ceq
        IL_0026:  ldc.i4.0
        IL_0027:  ceq
        IL_0029:  brfalse.s  IL_002d

        IL_002b:  br.s       IL_002f

        IL_002d:  br.s       IL_0039

//000040:                 then 0.1
        IL_002f:  ldc.r8     0.10000000000000001
        IL_0038:  ret

//000041:                 else 0.7;
        IL_0039:  ldc.r8     0.69999999999999996
        IL_0042:  ret
      } // end of method Checkerboard@32::Reflect

      .method public hidebysig virtual instance float64 
              get_Roughness() cil managed
      {
        // Code size       11 (0xb)
        .maxstack  5
//000042:             member s.Roughness = 150.0 }
        IL_0000:  nop
        IL_0001:  ldc.r8     150.
        IL_000a:  ret
      } // end of method Checkerboard@32::get_Roughness

    } // end of class Checkerboard@32

    .method public specialname static class Raytracer_FSharp/Surface 
            get_Shiny() cil managed
    {
      // Code size       6 (0x6)
      .maxstack  4
      IL_0000:  ldsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::Shiny@19
      IL_0005:  ret
    } // end of method Surfaces::get_Shiny

    .method public specialname static class Raytracer_FSharp/Surface 
            get_MatteShiny() cil managed
    {
      // Code size       6 (0x6)
      .maxstack  4
      IL_0000:  ldsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::MatteShiny@25
      IL_0005:  ret
    } // end of method Surfaces::get_MatteShiny

    .method public specialname static class Raytracer_FSharp/Surface 
            get_Checkerboard() cil managed
    {
      // Code size       6 (0x6)
      .maxstack  4
      IL_0000:  ldsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::Checkerboard@31
      IL_0005:  ret
    } // end of method Surfaces::get_Checkerboard

    .property class Raytracer_FSharp/Surface
            Shiny()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
      .get class Raytracer_FSharp/Surface Harness/Surfaces::get_Shiny()
    } // end of property Surfaces::Shiny
    .property class Raytracer_FSharp/Surface
            MatteShiny()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
      .get class Raytracer_FSharp/Surface Harness/Surfaces::get_MatteShiny()
    } // end of property Surfaces::MatteShiny
    .property class Raytracer_FSharp/Surface
            Checkerboard()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
      .get class Raytracer_FSharp/Surface Harness/Surfaces::get_Checkerboard()
    } // end of property Surfaces::Checkerboard
  } // end of class Surfaces

  .method public specialname static int32 
          get_width() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::width@15
    IL_0005:  ret
  } // end of method Harness::get_width

  .method public specialname static void 
          set_width(int32 'value') cil managed
  {
    // Code size       7 (0x7)
    .maxstack  4
    IL_0000:  ldarg.0
    IL_0001:  stsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::width@15
    IL_0006:  ret
  } // end of method Harness::set_width

  .method public specialname static int32 
          get_height() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::height@16
    IL_0005:  ret
  } // end of method Harness::get_height

  .method public specialname static void 
          set_height(int32 'value') cil managed
  {
    // Code size       7 (0x7)
    .maxstack  4
    IL_0000:  ldarg.0
    IL_0001:  stsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::height@16
    IL_0006:  ret
  } // end of method Harness::set_height

  .method public specialname static class Raytracer_FSharp/Scene 
          get_baseScene() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     class Raytracer_FSharp/Scene '<StartupCode$Raytracer_FSharp>'.$Harness::baseScene@44
    IL_0005:  ret
  } // end of method Harness::get_baseScene

  .property int32 width()
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .set void Harness::set_width(int32)
    .get int32 Harness::get_width()
  } // end of property Harness::width
  .property int32 height()
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .set void Harness::set_height(int32)
    .get int32 Harness::get_height()
  } // end of property Harness::height
  .property class Raytracer_FSharp/Scene baseScene()
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .get class Raytracer_FSharp/Scene Harness::get_baseScene()
  } // end of property Harness::baseScene
} // end of class Harness

.class private abstract auto ansi sealed '<StartupCode$Raytracer_FSharp>'.$Harness
       extends [mscorlib]System.Object
{
  .field static assembly int32 width@15
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly int32 height@16
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly class Raytracer_FSharp/Surface Shiny@19
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly class Raytracer_FSharp/Surface MatteShiny@25
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly class Raytracer_FSharp/Surface Checkerboard@31
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly class Raytracer_FSharp/Scene baseScene@44
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly int32 init@
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public static void  main@() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       430 (0x1ae)
    .maxstack  8
    .locals init ([0] class Raytracer_FSharp/Surface Shiny,
             [1] class Raytracer_FSharp/Surface MatteShiny,
             [2] class Raytracer_FSharp/Surface Checkerboard,
             [3] class Raytracer_FSharp/Scene baseScene)
//000015: let mutable width = 400
    IL_0000:  nop
    IL_0001:  ldc.i4     0x190
    IL_0006:  stsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::width@15
//000016: let mutable height = 400
    IL_000b:  ldc.i4     0x190
    IL_0010:  stsfld     int32 '<StartupCode$Raytracer_FSharp>'.$Harness::height@16
    IL_0015:  newobj     instance void Harness/Surfaces/Shiny@20::.ctor()
    IL_001a:  dup
    IL_001b:  stsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::Shiny@19
    IL_0020:  stloc.0
    IL_0021:  newobj     instance void Harness/Surfaces/MatteShiny@26::.ctor()
    IL_0026:  dup
    IL_0027:  stsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::MatteShiny@25
    IL_002c:  stloc.1
    IL_002d:  newobj     instance void Harness/Surfaces/Checkerboard@32::.ctor()
    IL_0032:  dup
    IL_0033:  stsfld     class Raytracer_FSharp/Surface '<StartupCode$Raytracer_FSharp>'.$Harness::Checkerboard@31
    IL_0038:  stloc.2
//000017: 
//000018: module Surfaces = 
//000019:     let Shiny = 
//000020:         { new Surface with 
//000021:             member s.Diffuse pos = Color(1.0,1.0,1.0) 
//000022:             member s.Specular pos = Color(0.5,0.5,0.5)
//000023:             member s.Reflect pos = 0.7
//000024:             member s.Roughness = 250.0 }
//000025:     let MatteShiny = 
//000026:         { new Surface with
//000027:             member s.Diffuse pos = Color(1.0,1.0,1.0)
//000028:             member s.Specular pos = Color(0.25,0.25,0.25)
//000029:             member s.Reflect pos = 0.7
//000030:             member s.Roughness = 250.0 }
//000031:     let Checkerboard = 
//000032:         { new Surface with 
//000033:             member s.Diffuse pos =
//000034:                 if (int (System.Math.Floor(pos.Z) + System.Math.Floor(pos.X))) % 2 <> 0
//000035:                 then Color(1.0,1.0,1.0)
//000036:                 else Color(0.0,0.0,0.0);
//000037:             member s.Specular pos = Color(1.0,1.0,1.0);
//000038:             member s.Reflect pos =
//000039:                 if (int (System.Math.Floor(pos.Z) + System.Math.Floor(pos.X))) % 2 <> 0
//000040:                 then 0.1
//000041:                 else 0.7;
//000042:             member s.Roughness = 150.0 }
//000043: 
//000044: let baseScene = 
    IL_0039:  ldc.r8     0.0
    IL_0042:  ldc.r8     1.
    IL_004b:  ldc.r8     0.0
    IL_0054:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_0059:  ldc.r8     0.0
    IL_0062:  call       class Raytracer_FSharp/Surface Harness/Surfaces::get_Checkerboard()
    IL_0067:  call       class Raytracer_FSharp/SceneObject Raytracer_FSharp::Plane(class Raytracer_FSharp/Vector,
                                                                                    float64,
                                                                                    class Raytracer_FSharp/Surface)
    IL_006c:  ldc.r8     0.0
    IL_0075:  ldc.r8     1.
    IL_007e:  ldc.r8     -0.25
    IL_0087:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_008c:  ldc.r8     1.
    IL_0095:  call       class Raytracer_FSharp/Surface Harness/Surfaces::get_Shiny()
    IL_009a:  call       class Raytracer_FSharp/SceneObject Raytracer_FSharp::Sphere(class Raytracer_FSharp/Vector,
                                                                                     float64,
                                                                                     class Raytracer_FSharp/Surface)
    IL_009f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::get_Empty()
    IL_00a4:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::Cons(!0,
                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00a9:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::Cons(!0,
                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00ae:  ldc.r8     -2.
    IL_00b7:  ldc.r8     2.5
    IL_00c0:  ldc.r8     0.0
    IL_00c9:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_00ce:  ldc.r8     0.5
    IL_00d7:  ldc.r8     0.45000000000000001
    IL_00e0:  ldc.r8     0.40999999999999998
    IL_00e9:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                     float64,
                                                                     float64)
    IL_00ee:  newobj     instance void Raytracer_FSharp/Light::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Color)
    IL_00f3:  ldc.r8     2.
    IL_00fc:  ldc.r8     4.5
    IL_0105:  ldc.r8     2.
    IL_010e:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_0113:  ldc.r8     0.98999999999999999
    IL_011c:  ldc.r8     0.94999999999999996
    IL_0125:  ldc.r8     0.80000000000000004
    IL_012e:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                     float64,
                                                                     float64)
    IL_0133:  newobj     instance void Raytracer_FSharp/Light::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Color)
    IL_0138:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>::get_Empty()
    IL_013d:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>::Cons(!0,
                                                                                                                                                                                           class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0142:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>::Cons(!0,
                                                                                                                                                                                           class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0147:  ldc.r8     2.75
    IL_0150:  ldc.r8     2.
    IL_0159:  ldc.r8     3.75
    IL_0162:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_0167:  ldc.r8     -0.59999999999999998
    IL_0170:  ldc.r8     0.5
    IL_0179:  ldc.r8     0.0
    IL_0182:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                      float64,
                                                                      float64)
    IL_0187:  newobj     instance void Raytracer_FSharp/Camera::.ctor(class Raytracer_FSharp/Vector,
                                                                      class Raytracer_FSharp/Vector)
    IL_018c:  newobj     instance void Raytracer_FSharp/Scene::.ctor(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>,
                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>,
                                                                     class Raytracer_FSharp/Camera)
    IL_0191:  dup
    IL_0192:  stsfld     class Raytracer_FSharp/Scene '<StartupCode$Raytracer_FSharp>'.$Harness::baseScene@44
    IL_0197:  stloc.3
//000045:     { Things = [ Plane( Vector(0.0,1.0,0.0), 0.0, Surfaces.Checkerboard);
//000046:                  Sphere( Vector(0.0,1.0,-0.25), 1.0, Surfaces.Shiny) ];
//000047:       Lights = [ { Pos = Vector(-2.0,2.5,0.0); Color = Color(0.5,0.45,0.41) };
//000048:                  { Pos = Vector(2.0,4.5,2.0); Color = Color(0.99,0.95,0.8) } ];
//000049:       Camera = Camera(Vector(2.75, 2.0, 3.75), Vector(-0.6, 0.5, 0.0)) }
//000050: 
//000051: type ObjectPool<'a>(valueSelector : unit -> 'a) = 
//000052:     let objects = new ConcurrentQueue<'a>() :> IProducerConsumerCollection<'a>
//000053:     member pool.GetObject () = 
//000054:         let b, item = objects.TryTake()
//000055:         if b then item else valueSelector ()
//000056:     member pool.PutObject o = 
//000057:         objects.TryAdd(o) |> ignore
//000058: 
//000059: type RayTracerForm() as this = 
//000060:     inherit Form(ClientSize = new Size(width + 95, height + 59),
//000061:                  Text = "RayTracer")
//000062:     let mutable bitmap = new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000063:     let mutable buffers = ObjectPool(fun () -> Array.create (width * height) 0)
//000064:     let mutable rect = Rectangle(0,0,width,height)
//000065:     let mutable renderTask : Task = null
//000066:     let mutable isParallel = false
//000067:     let mutable showThreads = false
//000068:     let mutable degreeOfParallelism = Environment.ProcessorCount 
//000069:     let mutable cancellation : CancellationTokenSource = null
//000070:     
//000071:     let pictureBox = 
//000072:         new PictureBox(Location = Point(13,15), 
//000073:                        BackColor = Color.Black,
//000074:                        BorderStyle = BorderStyle.Fixed3D,
//000075:                        Size = Size(width+69, height),
//000076:                        SizeMode = PictureBoxSizeMode.CenterImage,
//000077:                        Anchor = (AnchorStyles.Left ||| AnchorStyles.Right ||| AnchorStyles.Top ||| AnchorStyles.Bottom),
//000078:                        Image = bitmap )
//000079:     let startStopButton = 
//000080:         new Button(Text = "Start",
//000081:                    Location = Point(14,height + 21),
//000082:                    Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000083:                    Size = Size(88,23))
//000084:     let isParallelCheckBox = 
//000085:         new CheckBox(Text = "Parallel",
//000086:                      AutoSize = true,
//000087:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000088:                      Location = Point(108, height + 26),
//000089:                      UseVisualStyleBackColor = true,
//000090:                      Size = Size(60,17))
//000091:     let showThreadsCheckbox = 
//000092:         new CheckBox(Text = "Show Threads",
//000093:                      AutoSize = true,
//000094:                      Enabled = false,
//000095:                      Anchor = (AnchorStyles.Left ||| AnchorStyles.Bottom),
//000096:                      Location = Point(174, height + 26),
//000097:                      Size = Size(95,17))
//000098:     let numProcsLabel = 
//000099:         new Label(Text = string Environment.ProcessorCount,
//000100:                   Enabled = false,
//000101:                   Font = new Font("Microsoft Sans Serif", 8.25F, FontStyle.Bold, GraphicsUnit.Point, 0uy),
//000102:                   Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000103:                   Location = Point(295, height + 31),
//000104:                   Size = Size(14,13))
//000105:     let numProcsTrackBar = 
//000106:         new TrackBar(Value = Environment.ProcessorCount,
//000107:                      Maximum = Environment.ProcessorCount,
//000108:                      Minimum = 1,
//000109:                      Enabled = false,
//000110:                      Anchor = (AnchorStyles.Right ||| AnchorStyles.Bottom),
//000111:                      Location = Point(304, height + 21),
//000112:                      Size = Size(178,45))
//000113:     
//000114:     let sceneAtTime elapsedSecs = 
//000115:         let dy2 = 0.8 * abs (sin ((float elapsedSecs) * Math.PI / 3000.0))
//000116:         let sphere = Sphere( Vector(-0.5,0.5+dy2,1.5), 0.5, Surfaces.MatteShiny)
//000117:         { baseScene with Things = sphere :: baseScene.Things  }
//000118:         
//000119:     let configureImage () =
//000120:         if bitmap = null || (bitmap.Width <> pictureBox.Width) || (bitmap.Height <> pictureBox.Height)    
//000121:         then
//000122:             if bitmap <> null
//000123:             then
//000124:                 pictureBox.Image <- null
//000125:                 bitmap.Dispose()
//000126:             width <- Math.Min(pictureBox.Width, pictureBox.Height)
//000127:             height <- width
//000128:             buffers <- ObjectPool(fun () -> Array.create (width * height) 0)
//000129:             bitmap <- new Bitmap(width, height, PixelFormat.Format32bppRgb)
//000130:             rect <- Rectangle(0,0,width,height)
//000131:             pictureBox.Image <- bitmap
//000132:             
//000133:     let renderLoop () = async { 
//000134:         let raytracer = RayTracer(width,height)
//000135:         let totalElapsed = Stopwatch.StartNew()
//000136:         let renderingTime = Stopwatch()
//000137:         let frame = ref 0
//000138:         while true do
//000139:             let rgb = buffers.GetObject()
//000140:             
//000141:             renderingTime.Reset ()
//000142:             renderingTime.Start ()
//000143:             
//000144:             try 
//000145:                 let parallelOptions = new ParallelOptions( MaxDegreeOfParallelism = degreeOfParallelism, CancellationToken = cancellation.Token)
//000146:                 let scene = sceneAtTime totalElapsed.ElapsedMilliseconds
//000147:                 if not isParallel then raytracer.RenderSequential(scene, rgb)
//000148:                 else if showThreads then raytracer.RenderParallelShowingThreads(scene, rgb, parallelOptions)
//000149:                 else raytracer.RenderParallel(scene, rgb, parallelOptions)
//000150:             with
//000151:             | :? OperationCanceledException -> ()
//000152:             
//000153:             renderingTime.Stop ()
//000154:             
//000155:             incr frame
//000156:             let framesPerSecond = 1000.0 / float renderingTime.ElapsedMilliseconds;
//000157:             
//000158:             this.BeginInvoke (Action< >(fun () -> 
//000159:                 let bmpData = bitmap.LockBits(rect, Imaging.ImageLockMode.WriteOnly, bitmap.PixelFormat)
//000160:                 Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
//000161:                 bitmap.UnlockBits bmpData
//000162:                 buffers.PutObject(rgb) 
//000163:                 pictureBox.Invalidate ()
//000164:                 this.Text <- "RayTracer - FPS: " + framesPerSecond.ToString("F1") )) |> ignore
//000165:         }
//000166:     
//000167:     do isParallelCheckBox.CheckedChanged.Add(fun _ ->
//000168:         isParallel <- isParallelCheckBox.Checked
//000169:         numProcsLabel.Enabled <- isParallelCheckBox.Checked
//000170:         numProcsTrackBar.Enabled <- isParallelCheckBox.Checked
//000171:         showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000172:         )
//000173: 
//000174:     do numProcsTrackBar.ValueChanged.Add(fun _ ->
//000175:         numProcsLabel.Text <- string numProcsTrackBar.Value
//000176:         degreeOfParallelism <- numProcsTrackBar.Value 
//000177:         )
//000178: 
//000179:     do startStopButton.Click.Add(fun _ ->      
//000180:         if cancellation <> null 
//000181:         then
//000182:             startStopButton.Enabled <- false 
//000183:             Async.CancelDefaultToken()
//000184:         else
//000185:             configureImage()  
//000186:             showThreads <- showThreadsCheckbox.Checked
//000187:             cancellation <- new CancellationTokenSource()
//000188:             let sc = SynchronizationContext.Current
//000189:             let t = 
//000190:                 async { do! renderLoop () }
//000191:                 |> Async.StartAsTask
//000192:             t.ContinueWith(new Action<Task>(fun t -> 
//000193:                 isParallelCheckBox.Enabled <- true
//000194:                 showThreadsCheckbox.Enabled <- isParallelCheckBox.Checked
//000195:                 numProcsLabel.Enabled <- true
//000196:                 numProcsTrackBar.Enabled <- true
//000197:                 startStopButton.Enabled <- true
//000198:                 startStopButton.Text <- "Start"
//000199:                 cancellation <- null), TaskScheduler.FromCurrentSynchronizationContext()) |> ignore
//000200:             isParallelCheckBox.Enabled <- false
//000201:             showThreadsCheckbox.Enabled <- true
//000202:             numProcsLabel.Enabled <- false
//000203:             numProcsTrackBar.Enabled <- false
//000204:             startStopButton.Text <- "Stop")
//000205:         
//000206:     do this.SuspendLayout()
//000207:     do this.AutoScaleDimensions <- new SizeF(6.0f,13.0f)
//000208:     do this.AutoScaleMode <- AutoScaleMode.Font
//000209:     do this.Controls.Add(pictureBox)
//000210:     do this.Controls.Add(startStopButton)
//000211:     do this.Controls.Add(isParallelCheckBox)
//000212:     do this.Controls.Add(showThreadsCheckbox)
//000213:     do this.Controls.Add(numProcsLabel)
//000214:     do this.Controls.Add(numProcsTrackBar)
//000215:     do this.ResumeLayout()
//000216:     
//000217: #if COMPILED
//000218: [<STAThread>]
//000219: do Application.EnableVisualStyles();
    IL_0198:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
//000220: do Application.SetCompatibleTextRenderingDefault(false);
    IL_019d:  ldc.i4.0
    IL_019e:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
//000221: do Application.Run(new RayTracerForm())
    IL_01a3:  newobj     instance void Harness/RayTracerForm::.ctor()
    IL_01a8:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_01ad:  ret
  } // end of method $Harness::main@

} // end of class '<StartupCode$Raytracer_FSharp>'.$Harness

.class public abstract auto ansi sealed Raytracer_FSharp
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public Vector
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly float64 z
    .field assembly float64 y
    .field assembly float64 x
    .method public specialname rtspecialname 
            instance void  .ctor(float64 x,
                                 float64 y,
                                 float64 z) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  4
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_FSharp\raytracer.fs' 
//000019: type Vector(x:float, y:float, z:float) = 
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      float64 Raytracer_FSharp/Vector::x
      IL_0010:  ldarg.0
      IL_0011:  ldarg.2
      IL_0012:  stfld      float64 Raytracer_FSharp/Vector::y
      IL_0017:  ldarg.0
      IL_0018:  ldarg.3
      IL_0019:  stfld      float64 Raytracer_FSharp/Vector::z
      IL_001e:  ret
    } // end of method Vector::.ctor

    .method public specialname instance float64 
            get_X() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000020:     member this.X = x
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Vector::x
      IL_0007:  ret
    } // end of method Vector::get_X

    .method public specialname instance float64 
            get_Y() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000021:     member this.Y = y
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Vector::y
      IL_0007:  ret
    } // end of method Vector::get_Y

    .method public specialname instance float64 
            get_Z() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000022:     member this.Z = z
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Vector::z
      IL_0007:  ret
    } // end of method Vector::get_Z

    .method public specialname static class Raytracer_FSharp/Vector 
            op_Multiply(float64 k,
                        class Raytracer_FSharp/Vector v) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  6
//000023:     static member ( * ) (k, (v:Vector)) = Vector(k*v.X, k*v.Y, k*v.Z)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldarg.1
      IL_0003:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0008:  mul
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0010:  mul
      IL_0011:  ldarg.0
      IL_0012:  ldarg.1
      IL_0013:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0018:  mul
      IL_0019:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_001e:  ret
    } // end of method Vector::op_Multiply

    .method public specialname static class Raytracer_FSharp/Vector 
            op_Subtraction(class Raytracer_FSharp/Vector v1,
                           class Raytracer_FSharp/Vector v2) cil managed
    {
      // Code size       46 (0x2e)
      .maxstack  6
//000024:     static member ( - ) (v1:Vector, v2:Vector) = Vector(v1.X-v2.X, v1.Y-v2.Y, v1.Z-v2.Z)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_000d:  sub
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_001a:  sub
      IL_001b:  ldarg.0
      IL_001c:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0021:  ldarg.1
      IL_0022:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0027:  sub
      IL_0028:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_002d:  ret
    } // end of method Vector::op_Subtraction

    .method public specialname static class Raytracer_FSharp/Vector 
            op_Addition(class Raytracer_FSharp/Vector v1,
                        class Raytracer_FSharp/Vector v2) cil managed
    {
      // Code size       46 (0x2e)
      .maxstack  6
//000025:     static member ( + ) (v1:Vector, v2:Vector) = Vector(v1.X+v2.X, v1.Y+v2.Y, v1.Z+v2.Z)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_000d:  add
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_001a:  add
      IL_001b:  ldarg.0
      IL_001c:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0021:  ldarg.1
      IL_0022:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0027:  add
      IL_0028:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_002d:  ret
    } // end of method Vector::op_Addition

    .method public static float64  Dot(class Raytracer_FSharp/Vector v1,
                                       class Raytracer_FSharp/Vector v2) cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  5
//000026:     static member Dot (v1:Vector, v2:Vector) = v1.X*v2.X + v1.Y*v2.Y + v1.Z*v2.Z
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_000d:  mul
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_001a:  mul
      IL_001b:  add
      IL_001c:  ldarg.0
      IL_001d:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0022:  ldarg.1
      IL_0023:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0028:  mul
      IL_0029:  add
      IL_002a:  ret
    } // end of method Vector::Dot

    .method public static float64  Mag(class Raytracer_FSharp/Vector v) cil managed
    {
      // Code size       52 (0x34)
      .maxstack  5
      .locals init ([0] float64 V_0,
               [1] float64 V_1)
//000027:     static member Mag (v:Vector) = sqrt(v.X*v.X + v.Y*v.Y + v.Z*v.Z)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0007:  ldarg.0
      IL_0008:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_000d:  mul
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0014:  ldarg.0
      IL_0015:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_001a:  mul
      IL_001b:  add
      IL_001c:  ldarg.0
      IL_001d:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0022:  ldarg.0
      IL_0023:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0028:  mul
      IL_0029:  add
      IL_002a:  stloc.0
      IL_002b:  ldloc.0
      IL_002c:  stloc.1
      IL_002d:  ldloc.0
      IL_002e:  call       float64 [mscorlib]System.Math::Sqrt(float64)
      IL_0033:  ret
    } // end of method Vector::Mag

    .method public static class Raytracer_FSharp/Vector 
            Norm(class Raytracer_FSharp/Vector v) cil managed
    {
      // Code size       60 (0x3c)
      .maxstack  4
      .locals init ([0] float64 mag,
               [1] float64 'div',
               [2] float64 V_2,
               [3] class Raytracer_FSharp/Vector V_3)
//000028:     static member Norm (v:Vector) = 
//000029:         let mag = Vector.Mag v
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       float64 Raytracer_FSharp/Vector::Mag(class Raytracer_FSharp/Vector)
      IL_0007:  stloc.0
//000030:         let div = if mag = 0.0 then infinity else 1.0/mag 
      IL_0008:  nop
      IL_0009:  ldloc.0
      IL_000a:  ldc.r8     0.0
      IL_0013:  ceq
      IL_0015:  brfalse.s  IL_0019

      IL_0017:  br.s       IL_001b

      IL_0019:  br.s       IL_0023

      IL_001b:  call       float64 [FSharp.Core]Microsoft.FSharp.Core.Operators::get_Infinity()
//000031:         div * v
//000032:     static member Cross (v1:Vector, v2:Vector) = 
//000033:         Vector(v1.Y * v2.Z - v1.Z * v2.Y,
//000034:                v1.Z * v2.X - v1.X * v2.Z,
//000035:                v1.X * v2.Y - v1.Y * v2.X)
//000036: 
//000037: type Color(r:float, g:float, b:float) = 
//000038:     static member private floatToInt c = let c' = int (255.0 * c) in if c' > 255 then 255 else c'
//000039:     static member private legalize d = if d > 1.0 then 1.0 else d
//000040:     member this.R = r
//000041:     member this.G = g
//000042:     member this.B = b
//000043:     member this.ToDrawingColor () = System.Drawing.Color.FromArgb(this.ToInt())
//000044:     member this.ToInt () = (Color.floatToInt b) ||| (Color.floatToInt g <<< 8) ||| (Color.floatToInt r <<< 16) ||| (255 <<< 24)
//000045:     member this.ShiftHue(hue) = 
//000046:         let c = this.ToDrawingColor()
//000047:         let h,s,l = hue, 0.9, ((float(c.GetBrightness()) - 0.5) * 0.5) + 0.5
//000048:         match s,l with
//000049:         | _, 0.0 -> Color(0.0,0.0,0.0)
//000050:         | 0.0, _ -> Color(float l,float l,float l)
//000051:         | s,l -> 
//000052:             let temp2 = if l <= 0.5 then l * (1.0 + s) else l + s - (l * s)
//000053:             let temp1 = 2.0 * l - temp2
//000054:             let convert x =
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0020:  nop
      IL_0021:  br.s       IL_002f

//000030:         let div = if mag = 0.0 then infinity else 1.0/mag 
      IL_0023:  ldc.r8     1.
      IL_002c:  ldloc.0
      IL_002d:  div
//000031:         div * v
//000032:     static member Cross (v1:Vector, v2:Vector) = 
//000033:         Vector(v1.Y * v2.Z - v1.Z * v2.Y,
//000034:                v1.Z * v2.X - v1.X * v2.Z,
//000035:                v1.X * v2.Y - v1.Y * v2.X)
//000036: 
//000037: type Color(r:float, g:float, b:float) = 
//000038:     static member private floatToInt c = let c' = int (255.0 * c) in if c' > 255 then 255 else c'
//000039:     static member private legalize d = if d > 1.0 then 1.0 else d
//000040:     member this.R = r
//000041:     member this.G = g
//000042:     member this.B = b
//000043:     member this.ToDrawingColor () = System.Drawing.Color.FromArgb(this.ToInt())
//000044:     member this.ToInt () = (Color.floatToInt b) ||| (Color.floatToInt g <<< 8) ||| (Color.floatToInt r <<< 16) ||| (255 <<< 24)
//000045:     member this.ShiftHue(hue) = 
//000046:         let c = this.ToDrawingColor()
//000047:         let h,s,l = hue, 0.9, ((float(c.GetBrightness()) - 0.5) * 0.5) + 0.5
//000048:         match s,l with
//000049:         | _, 0.0 -> Color(0.0,0.0,0.0)
//000050:         | 0.0, _ -> Color(float l,float l,float l)
//000051:         | s,l -> 
//000052:             let temp2 = if l <= 0.5 then l * (1.0 + s) else l + s - (l * s)
//000053:             let temp1 = 2.0 * l - temp2
//000054:             let convert x =
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_002e:  nop
      IL_002f:  stloc.1
//000031:         div * v
      IL_0030:  ldloc.1
      IL_0031:  stloc.2
      IL_0032:  ldarg.0
      IL_0033:  stloc.3
      IL_0034:  ldloc.2
      IL_0035:  ldloc.3
      IL_0036:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_003b:  ret
    } // end of method Vector::Norm

    .method public static class Raytracer_FSharp/Vector 
            Cross(class Raytracer_FSharp/Vector v1,
                  class Raytracer_FSharp/Vector v2) cil managed
    {
      // Code size       88 (0x58)
      .maxstack  7
//000032:     static member Cross (v1:Vector, v2:Vector) = 
//000033:         Vector(v1.Y * v2.Z - v1.Z * v2.Y,
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_000d:  mul
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_001a:  mul
      IL_001b:  sub
      IL_001c:  ldarg.0
      IL_001d:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0022:  ldarg.1
      IL_0023:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0028:  mul
      IL_0029:  ldarg.0
      IL_002a:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_002f:  ldarg.1
      IL_0030:  call       instance float64 Raytracer_FSharp/Vector::get_Z()
      IL_0035:  mul
      IL_0036:  sub
      IL_0037:  ldarg.0
      IL_0038:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_003d:  ldarg.1
      IL_003e:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_0043:  mul
      IL_0044:  ldarg.0
      IL_0045:  call       instance float64 Raytracer_FSharp/Vector::get_Y()
      IL_004a:  ldarg.1
      IL_004b:  call       instance float64 Raytracer_FSharp/Vector::get_X()
      IL_0050:  mul
      IL_0051:  sub
      IL_0052:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_0057:  ret
    } // end of method Vector::Cross

    .property instance float64 X()
    {
      .get instance float64 Raytracer_FSharp/Vector::get_X()
    } // end of property Vector::X
    .property instance float64 Y()
    {
      .get instance float64 Raytracer_FSharp/Vector::get_Y()
    } // end of property Vector::Y
    .property instance float64 Z()
    {
      .get instance float64 Raytracer_FSharp/Vector::get_Z()
    } // end of property Vector::Z
  } // end of class Vector

  .class auto ansi serializable nested public Color
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly float64 r
    .field assembly float64 g
    .field assembly float64 b
    .method public specialname rtspecialname 
            instance void  .ctor(float64 r,
                                 float64 g,
                                 float64 b) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  4
//000034:                v1.Z * v2.X - v1.X * v2.Z,
//000035:                v1.X * v2.Y - v1.Y * v2.X)
//000036: 
//000037: type Color(r:float, g:float, b:float) = 
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      float64 Raytracer_FSharp/Color::r
      IL_0010:  ldarg.0
      IL_0011:  ldarg.2
      IL_0012:  stfld      float64 Raytracer_FSharp/Color::g
      IL_0017:  ldarg.0
      IL_0018:  ldarg.3
      IL_0019:  stfld      float64 Raytracer_FSharp/Color::b
      IL_001e:  ret
    } // end of method Color::.ctor

    .method assembly static int32  floatToInt(float64 c) cil managed
    {
      // Code size       38 (0x26)
      .maxstack  4
      .locals init ([0] int32 'c\'',[1] float64 V_1,[2] float64 V_2)
//000038:     static member private floatToInt c = let c' = int (255.0 * c) in if c' > 255 then 255 else c'
      IL_0000:  nop
      IL_0001:  ldc.r8     255.
      IL_000a:  ldarg.0
      IL_000b:  mul
      IL_000c:  stloc.1
      IL_000d:  ldloc.1
      IL_000e:  stloc.2
      IL_000f:  ldloc.1
      IL_0010:  conv.i4
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  ldc.i4     0xff
      IL_0018:  ble.s      IL_001c

      IL_001a:  br.s       IL_001e

      IL_001c:  br.s       IL_0024

      IL_001e:  ldc.i4     0xff
      IL_0023:  ret

      IL_0024:  ldloc.0
      IL_0025:  ret
    } // end of method Color::floatToInt

    .method assembly static float64  legalize(float64 d) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  4
//000039:     static member private legalize d = if d > 1.0 then 1.0 else d
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldc.r8     1.
      IL_000b:  cgt
      IL_000d:  brfalse.s  IL_0011

      IL_000f:  br.s       IL_0013

      IL_0011:  br.s       IL_001d

      IL_0013:  ldc.r8     1.
      IL_001c:  ret

      IL_001d:  ldarg.0
      IL_001e:  ret
    } // end of method Color::legalize

    .method public specialname instance float64 
            get_R() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000040:     member this.R = r
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Color::r
      IL_0007:  ret
    } // end of method Color::get_R

    .method public specialname instance float64 
            get_G() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000041:     member this.G = g
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Color::g
      IL_0007:  ret
    } // end of method Color::get_G

    .method public specialname instance float64 
            get_B() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000042:     member this.B = b
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Color::b
      IL_0007:  ret
    } // end of method Color::get_B

    .method public instance valuetype [System.Drawing]System.Drawing.Color 
            ToDrawingColor() cil managed
    {
      // Code size       13 (0xd)
      .maxstack  3
//000043:     member this.ToDrawingColor () = System.Drawing.Color.FromArgb(this.ToInt())
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance int32 Raytracer_FSharp/Color::ToInt()
      IL_0007:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32)
      IL_000c:  ret
    } // end of method Color::ToDrawingColor

    .method public instance int32  ToInt() cil managed
    {
      // Code size       76 (0x4c)
      .maxstack  6
      .locals init ([0] int32 V_0,
               [1] int32 V_1,
               [2] int32 V_2,
               [3] int32 V_3,
               [4] int32 V_4,
               [5] int32 V_5)
//000044:     member this.ToInt () = (Color.floatToInt b) ||| (Color.floatToInt g <<< 8) ||| (Color.floatToInt r <<< 16) ||| (255 <<< 24)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      float64 Raytracer_FSharp/Color::b
      IL_0007:  call       int32 Raytracer_FSharp/Color::floatToInt(float64)
      IL_000c:  ldarg.0
      IL_000d:  ldfld      float64 Raytracer_FSharp/Color::g
      IL_0012:  call       int32 Raytracer_FSharp/Color::floatToInt(float64)
      IL_0017:  stloc.0
      IL_0018:  ldc.i4.8
      IL_0019:  stloc.1
      IL_001a:  ldloc.0
      IL_001b:  ldloc.1
      IL_001c:  ldc.i4.s   31
      IL_001e:  and
      IL_001f:  shl
      IL_0020:  or
      IL_0021:  ldarg.0
      IL_0022:  ldfld      float64 Raytracer_FSharp/Color::r
      IL_0027:  call       int32 Raytracer_FSharp/Color::floatToInt(float64)
      IL_002c:  stloc.2
      IL_002d:  ldc.i4.s   16
      IL_002f:  stloc.3
      IL_0030:  ldloc.2
      IL_0031:  ldloc.3
      IL_0032:  ldc.i4.s   31
      IL_0034:  and
      IL_0035:  shl
      IL_0036:  or
      IL_0037:  ldc.i4     0xff
      IL_003c:  stloc.s    V_4
      IL_003e:  ldc.i4.s   24
      IL_0040:  stloc.s    V_5
      IL_0042:  ldloc.s    V_4
      IL_0044:  ldloc.s    V_5
      IL_0046:  ldc.i4.s   31
      IL_0048:  and
      IL_0049:  shl
      IL_004a:  or
      IL_004b:  ret
    } // end of method Color::ToInt

    .method public instance class Raytracer_FSharp/Color 
            ShiftHue(float64 hue) cil managed
    {
      // Code size       403 (0x193)
      .maxstack  8
      .locals init ([0] valuetype [System.Drawing]System.Drawing.Color c,
               [1] class [mscorlib]System.Tuple`3<float64,float64,float64> V_1,
               [2] float64 s,
               [3] float64 l,
               [4] float64 h,
               [5] class [mscorlib]System.Tuple`2<float64,float64> V_5,
               [6] float64 V_6,
               [7] float64 V_7,
               [8] float64 temp2,
               [9] float64 V_9,
               [10] float64 V_10,
               [11] float64 temp1,
               [12] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64> convert,
               [13] class [mscorlib]System.Tuple`3<float64,float64,float64> V_13,
               [14] float64 c3,
               [15] float64 c2,
               [16] float64 c1)
//000045:     member this.ShiftHue(hue) = 
//000046:         let c = this.ToDrawingColor()
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance valuetype [System.Drawing]System.Drawing.Color Raytracer_FSharp/Color::ToDrawingColor()
      IL_0007:  stloc.0
//000047:         let h,s,l = hue, 0.9, ((float(c.GetBrightness()) - 0.5) * 0.5) + 0.5
      IL_0008:  ldarg.1
      IL_0009:  ldc.r8     0.90000000000000002
      IL_0012:  ldloca.s   c
      IL_0014:  call       instance float32 [System.Drawing]System.Drawing.Color::GetBrightness()
      IL_0019:  conv.r8
      IL_001a:  ldc.r8     0.5
      IL_0023:  sub
      IL_0024:  ldc.r8     0.5
      IL_002d:  mul
      IL_002e:  ldc.r8     0.5
      IL_0037:  add
      IL_0038:  newobj     instance void class [mscorlib]System.Tuple`3<float64,float64,float64>::.ctor(!0,
                                                                                                        !1,
                                                                                                        !2)
      IL_003d:  stloc.1
      IL_003e:  ldloc.1
      IL_003f:  call       instance !1 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item2()
      IL_0044:  stloc.2
      IL_0045:  ldloc.1
      IL_0046:  call       instance !2 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item3()
      IL_004b:  stloc.3
      IL_004c:  ldloc.1
      IL_004d:  call       instance !0 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item1()
      IL_0052:  stloc.s    h
//000048:         match s,l with
      IL_0054:  ldloc.2
      IL_0055:  ldloc.3
      IL_0056:  newobj     instance void class [mscorlib]System.Tuple`2<float64,float64>::.ctor(!0,
                                                                                                !1)
      IL_005b:  stloc.s    V_5
      IL_005d:  ldloc.s    V_5
      IL_005f:  call       instance !1 class [mscorlib]System.Tuple`2<float64,float64>::get_Item2()
      IL_0064:  ldc.r8     0.0
      IL_006d:  ceq
      IL_006f:  brfalse.s  IL_0073

      IL_0071:  br.s       IL_008b

      IL_0073:  ldloc.s    V_5
      IL_0075:  call       instance !0 class [mscorlib]System.Tuple`2<float64,float64>::get_Item1()
      IL_007a:  ldc.r8     0.0
      IL_0083:  ceq
      IL_0085:  brfalse.s  IL_0089

      IL_0087:  br.s       IL_00ac

      IL_0089:  br.s       IL_00b5

//000049:         | _, 0.0 -> Color(0.0,0.0,0.0)
      IL_008b:  ldc.r8     0.0
      IL_0094:  ldc.r8     0.0
      IL_009d:  ldc.r8     0.0
      IL_00a6:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_00ab:  ret

//000050:         | 0.0, _ -> Color(float l,float l,float l)
      IL_00ac:  ldloc.3
      IL_00ad:  ldloc.3
      IL_00ae:  ldloc.3
      IL_00af:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_00b4:  ret

//000048:         match s,l with
      IL_00b5:  ldloc.s    V_5
      IL_00b7:  call       instance !0 class [mscorlib]System.Tuple`2<float64,float64>::get_Item1()
      IL_00bc:  stloc.s    V_6
      IL_00be:  ldloc.s    V_5
      IL_00c0:  call       instance !1 class [mscorlib]System.Tuple`2<float64,float64>::get_Item2()
      IL_00c5:  stloc.s    V_7
//000049:         | _, 0.0 -> Color(0.0,0.0,0.0)
//000050:         | 0.0, _ -> Color(float l,float l,float l)
//000051:         | s,l -> 
//000052:             let temp2 = if l <= 0.5 then l * (1.0 + s) else l + s - (l * s)
      IL_00c7:  nop
      IL_00c8:  ldloc.s    V_7
      IL_00ca:  stloc.s    V_9
      IL_00cc:  ldc.r8     0.5
      IL_00d5:  stloc.s    V_10
      IL_00d7:  ldloc.s    V_9
      IL_00d9:  ldloc.s    V_10
      IL_00db:  cgt.un
      IL_00dd:  ldc.i4.0
      IL_00de:  ceq
      IL_00e0:  brfalse.s  IL_00e4

      IL_00e2:  br.s       IL_00e6

      IL_00e4:  br.s       IL_00f8

      IL_00e6:  ldloc.s    V_7
      IL_00e8:  ldc.r8     1.
      IL_00f1:  ldloc.s    V_6
      IL_00f3:  add
      IL_00f4:  mul
//000053:             let temp1 = 2.0 * l - temp2
//000054:             let convert x =
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_00f5:  nop
      IL_00f6:  br.s       IL_0104

//000052:             let temp2 = if l <= 0.5 then l * (1.0 + s) else l + s - (l * s)
      IL_00f8:  ldloc.s    V_7
      IL_00fa:  ldloc.s    V_6
      IL_00fc:  add
      IL_00fd:  ldloc.s    V_7
      IL_00ff:  ldloc.s    V_6
      IL_0101:  mul
      IL_0102:  sub
//000053:             let temp1 = 2.0 * l - temp2
//000054:             let convert x =
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0103:  nop
      IL_0104:  stloc.s    temp2
//000053:             let temp1 = 2.0 * l - temp2
      IL_0106:  ldc.r8     2.
      IL_010f:  ldloc.s    V_7
      IL_0111:  mul
      IL_0112:  ldloc.s    temp2
      IL_0114:  sub
      IL_0115:  stloc.s    temp1
//000054:             let convert x =
      IL_0117:  ldloc.s    temp2
      IL_0119:  ldloc.s    temp1
      IL_011b:  newobj     instance void Raytracer_FSharp/convert@55::.ctor(float64,
                                                                            float64)
      IL_0120:  stloc.s    convert
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
      IL_0122:  ldloc.s    convert
      IL_0124:  ldloc.s    h
      IL_0126:  ldc.r8     1.
      IL_012f:  ldc.r8     3.
      IL_0138:  div
      IL_0139:  add
      IL_013a:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::Invoke(!0)
      IL_013f:  ldloc.s    convert
      IL_0141:  ldloc.s    h
      IL_0143:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::Invoke(!0)
      IL_0148:  ldloc.s    convert
      IL_014a:  ldloc.s    h
      IL_014c:  ldc.r8     1.
      IL_0155:  ldc.r8     3.
      IL_015e:  div
      IL_015f:  sub
      IL_0160:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::Invoke(!0)
      IL_0165:  newobj     instance void class [mscorlib]System.Tuple`3<float64,float64,float64>::.ctor(!0,
                                                                                                        !1,
                                                                                                        !2)
      IL_016a:  stloc.s    V_13
      IL_016c:  ldloc.s    V_13
      IL_016e:  call       instance !2 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item3()
      IL_0173:  stloc.s    c3
      IL_0175:  ldloc.s    V_13
      IL_0177:  call       instance !1 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item2()
      IL_017c:  stloc.s    c2
      IL_017e:  ldloc.s    V_13
      IL_0180:  call       instance !0 class [mscorlib]System.Tuple`3<float64,float64,float64>::get_Item1()
      IL_0185:  stloc.s    c1
//000061:             new Color(c1, c2, c3)        
      IL_0187:  ldloc.s    c1
      IL_0189:  ldloc.s    c2
      IL_018b:  ldloc.s    c3
      IL_018d:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_0192:  ret
    } // end of method Color::ShiftHue

    .method public static class Raytracer_FSharp/Color 
            Scale(float64 k,
                  class Raytracer_FSharp/Color v) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  6
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldarg.1
      IL_0003:  call       instance float64 Raytracer_FSharp/Color::get_R()
      IL_0008:  mul
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  call       instance float64 Raytracer_FSharp/Color::get_G()
      IL_0010:  mul
      IL_0011:  ldarg.0
      IL_0012:  ldarg.1
      IL_0013:  call       instance float64 Raytracer_FSharp/Color::get_B()
      IL_0018:  mul
      IL_0019:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_001e:  ret
    } // end of method Color::Scale

    .method public specialname static class Raytracer_FSharp/Color 
            op_Addition(class Raytracer_FSharp/Color v1,
                        class Raytracer_FSharp/Color v2) cil managed
    {
      // Code size       46 (0x2e)
      .maxstack  6
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Color::get_R()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Color::get_R()
      IL_000d:  add
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Color::get_G()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Color::get_G()
      IL_001a:  add
      IL_001b:  ldarg.0
      IL_001c:  call       instance float64 Raytracer_FSharp/Color::get_B()
      IL_0021:  ldarg.1
      IL_0022:  call       instance float64 Raytracer_FSharp/Color::get_B()
      IL_0027:  add
      IL_0028:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_002d:  ret
    } // end of method Color::op_Addition

    .method public specialname static class Raytracer_FSharp/Color 
            op_Multiply(class Raytracer_FSharp/Color v1,
                        class Raytracer_FSharp/Color v2) cil managed
    {
      // Code size       46 (0x2e)
      .maxstack  6
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance float64 Raytracer_FSharp/Color::get_R()
      IL_0007:  ldarg.1
      IL_0008:  call       instance float64 Raytracer_FSharp/Color::get_R()
      IL_000d:  mul
      IL_000e:  ldarg.0
      IL_000f:  call       instance float64 Raytracer_FSharp/Color::get_G()
      IL_0014:  ldarg.1
      IL_0015:  call       instance float64 Raytracer_FSharp/Color::get_G()
      IL_001a:  mul
      IL_001b:  ldarg.0
      IL_001c:  call       instance float64 Raytracer_FSharp/Color::get_B()
      IL_0021:  ldarg.1
      IL_0022:  call       instance float64 Raytracer_FSharp/Color::get_B()
      IL_0027:  mul
      IL_0028:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_002d:  ret
    } // end of method Color::op_Multiply

    .method public specialname static class Raytracer_FSharp/Color 
            get_Background() cil managed
    {
      // Code size       34 (0x22)
      .maxstack  5
//000065:     static member Background = Color(0.0,0.0,0.0)
      IL_0000:  nop
      IL_0001:  ldc.r8     0.0
      IL_000a:  ldc.r8     0.0
      IL_0013:  ldc.r8     0.0
      IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_0021:  ret
    } // end of method Color::get_Background

    .method public specialname static class Raytracer_FSharp/Color 
            get_DefaultColor() cil managed
    {
      // Code size       34 (0x22)
      .maxstack  5
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
      IL_0000:  nop
      IL_0001:  ldc.r8     0.0
      IL_000a:  ldc.r8     0.0
      IL_0013:  ldc.r8     0.0
      IL_001c:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
      IL_0021:  ret
    } // end of method Color::get_DefaultColor

    .property instance float64 R()
    {
      .get instance float64 Raytracer_FSharp/Color::get_R()
    } // end of property Color::R
    .property instance float64 G()
    {
      .get instance float64 Raytracer_FSharp/Color::get_G()
    } // end of property Color::G
    .property instance float64 B()
    {
      .get instance float64 Raytracer_FSharp/Color::get_B()
    } // end of property Color::B
    .property class Raytracer_FSharp/Color
            Background()
    {
      .get class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_Background()
    } // end of property Color::Background
    .property class Raytracer_FSharp/Color
            DefaultColor()
    {
      .get class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_DefaultColor()
    } // end of property Color::DefaultColor
  } // end of class Color

  .class auto ansi serializable nested assembly beforefieldinit convert@55
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>
  {
    .field public float64 temp2
    .field public float64 temp1
    .method assembly specialname rtspecialname 
            instance void  .ctor(float64 temp2,
                                 float64 temp1) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      float64 Raytracer_FSharp/convert@55::temp2
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_0014:  ret
    } // end of method convert@55::.ctor

    .method public strict virtual instance float64 
            Invoke(float64 x) cil managed
    {
      // Code size       243 (0xf3)
      .maxstack  8
      .locals init ([0] float64 x)
//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
      IL_0000:  nop
      IL_0001:  nop
      IL_0002:  ldarg.1
      IL_0003:  ldc.r8     0.0
      IL_000c:  clt
      IL_000e:  brfalse.s  IL_0012

      IL_0010:  br.s       IL_0014

      IL_0012:  br.s       IL_0022

      IL_0014:  ldarg.1
      IL_0015:  ldc.r8     1.
      IL_001e:  add
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_001f:  nop
      IL_0020:  br.s       IL_0044

//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
      IL_0022:  ldarg.1
      IL_0023:  ldc.r8     1.
      IL_002c:  cgt
      IL_002e:  brfalse.s  IL_0032

      IL_0030:  br.s       IL_0034

      IL_0032:  br.s       IL_0042

      IL_0034:  ldarg.1
      IL_0035:  ldc.r8     1.
      IL_003e:  sub
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_003f:  nop
      IL_0040:  br.s       IL_0044

//000055:                 let x = if x < 0.0 then x + 1.0 elif x > 1.0 then x - 1.0 else x
      IL_0042:  ldarg.1
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
//000057:                 elif x < 1.0/2.0 then temp2
//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
//000059:                 else temp1
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0043:  nop
      IL_0044:  stloc.0
//000056:                 if x < 1.0/6.0 then temp1 + (temp2 - temp1) * x* 6.0
      IL_0045:  ldloc.0
      IL_0046:  ldc.r8     1.
      IL_004f:  ldc.r8     6.
      IL_0058:  div
      IL_0059:  clt
      IL_005b:  brfalse.s  IL_005f

      IL_005d:  br.s       IL_0061

      IL_005f:  br.s       IL_0082

      IL_0061:  ldarg.0
      IL_0062:  ldfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_0067:  ldarg.0
      IL_0068:  ldfld      float64 Raytracer_FSharp/convert@55::temp2
      IL_006d:  ldarg.0
      IL_006e:  ldfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_0073:  sub
      IL_0074:  ldloc.0
      IL_0075:  mul
      IL_0076:  ldc.r8     6.
      IL_007f:  mul
      IL_0080:  add
      IL_0081:  ret

//000057:                 elif x < 1.0/2.0 then temp2
      IL_0082:  ldloc.0
      IL_0083:  ldc.r8     1.
      IL_008c:  ldc.r8     2.
      IL_0095:  div
      IL_0096:  clt
      IL_0098:  brfalse.s  IL_009c

      IL_009a:  br.s       IL_009e

      IL_009c:  br.s       IL_00a5

      IL_009e:  ldarg.0
      IL_009f:  ldfld      float64 Raytracer_FSharp/convert@55::temp2
      IL_00a4:  ret

//000058:                 elif x< 2.0/3.0 then (temp1 + (temp2 - temp1) * ((2.0/3.0) - x))
      IL_00a5:  ldloc.0
      IL_00a6:  ldc.r8     2.
      IL_00af:  ldc.r8     3.
      IL_00b8:  div
      IL_00b9:  clt
      IL_00bb:  brfalse.s  IL_00bf

      IL_00bd:  br.s       IL_00c1

      IL_00bf:  br.s       IL_00ec

      IL_00c1:  ldarg.0
      IL_00c2:  ldfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_00c7:  ldarg.0
      IL_00c8:  ldfld      float64 Raytracer_FSharp/convert@55::temp2
      IL_00cd:  ldarg.0
      IL_00ce:  ldfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_00d3:  sub
      IL_00d4:  ldc.r8     2.
      IL_00dd:  ldc.r8     3.
      IL_00e6:  div
      IL_00e7:  ldloc.0
      IL_00e8:  sub
      IL_00e9:  mul
      IL_00ea:  add
      IL_00eb:  ret

//000059:                 else temp1
      IL_00ec:  ldarg.0
      IL_00ed:  ldfld      float64 Raytracer_FSharp/convert@55::temp1
      IL_00f2:  ret
    } // end of method convert@55::Invoke

  } // end of class convert@55

  .class auto ansi serializable sealed nested public Ray
         extends [mscorlib]System.Object
         implements class [mscorlib]System.IEquatable`1<class Raytracer_FSharp/Ray>,
                    [mscorlib]System.Collections.IStructuralEquatable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 02 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Vector Start@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Vector Dir@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Start() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0006:  ret
    } // end of method Ray::get_Start

    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Dir() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0006:  ret
    } // end of method Ray::get_Dir

    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Vector start,
                                 class Raytracer_FSharp/Vector dir) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0014:  ret
    } // end of method Ray::.ctor

    .method public hidebysig virtual final 
            instance int32  GetHashCode(class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       71 (0x47)
      .maxstack  7
      .locals init (int32 V_0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0045

      IL_000b:  ldc.i4.0
      IL_000c:  stloc.0
      IL_000d:  ldc.i4     0x9e3779b9
      IL_0012:  ldarg.1
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0019:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                    !!0)
      IL_001e:  ldloc.0
      IL_001f:  ldc.i4.6
      IL_0020:  shl
      IL_0021:  ldloc.0
      IL_0022:  ldc.i4.2
      IL_0023:  shr
      IL_0024:  add
      IL_0025:  add
      IL_0026:  add
      IL_0027:  stloc.0
      IL_0028:  ldc.i4     0x9e3779b9
      IL_002d:  ldarg.1
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0034:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                    !!0)
      IL_0039:  ldloc.0
      IL_003a:  ldc.i4.6
      IL_003b:  shl
      IL_003c:  ldloc.0
      IL_003d:  ldc.i4.2
      IL_003e:  shr
      IL_003f:  add
      IL_0040:  add
      IL_0041:  add
      IL_0042:  stloc.0
      IL_0043:  ldloc.0
      IL_0044:  ret

      IL_0045:  ldc.i4.0
      IL_0046:  ret
    } // end of method Ray::GetHashCode

    .method public hidebysig virtual final 
            instance int32  GetHashCode() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       13 (0xd)
      .maxstack  4
//000060:             let c1,c2,c3 = (convert(h + 1.0/3.0), convert(h), convert(h - 1.0/3.0))
//000061:             new Color(c1, c2, c3)        
//000062:     static member Scale (k, v:Color) = Color(k*v.R, k*v.G, k*v.B)
//000063:     static member ( + ) (v1:Color, v2:Color) = Color(v1.R+v2.R, v1.G+v2.G, v1.B+v2.B)
//000064:     static member ( * ) (v1:Color, v2:Color) = Color(v1.R*v2.R, v1.G*v2.G, v1.B*v2.B)
//000065:     static member Background = Color(0.0,0.0,0.0)
//000066:     static member DefaultColor = Color(0.0,0.0,0.0)
//000067:     
//000068: type Ray = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       class [mscorlib]System.Collections.IEqualityComparer [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::get_GenericEqualityComparer()
      IL_0007:  call       instance int32 Raytracer_FSharp/Ray::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_000c:  ret
    } // end of method Ray::GetHashCode

    .method public hidebysig virtual final 
            instance bool  Equals(object obj,
                                  class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       82 (0x52)
      .maxstack  5
      .locals init (class Raytracer_FSharp/Ray V_0,
               class Raytracer_FSharp/Ray V_1)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_004a

      IL_000b:  ldarg.1
      IL_000c:  isinst     Raytracer_FSharp/Ray
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  brfalse.s  IL_0017

      IL_0015:  br.s       IL_0019

      IL_0017:  br.s       IL_0048

      IL_0019:  ldloc.0
      IL_001a:  stloc.1
      IL_001b:  ldarg.2
      IL_001c:  ldarg.0
      IL_001d:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0022:  ldloc.1
      IL_0023:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0028:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                       !!0,
                                                                                                                                                                       !!0)
      IL_002d:  brfalse.s  IL_0031

      IL_002f:  br.s       IL_0033

      IL_0031:  br.s       IL_0046

      IL_0033:  ldarg.2
      IL_0034:  ldarg.0
      IL_0035:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_003a:  ldloc.1
      IL_003b:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0040:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                       !!0,
                                                                                                                                                                       !!0)
      IL_0045:  ret

      IL_0046:  ldc.i4.0
      IL_0047:  ret

      IL_0048:  ldc.i4.0
      IL_0049:  ret

      IL_004a:  ldarg.1
      IL_004b:  ldnull
      IL_004c:  cgt.un
      IL_004e:  ldc.i4.0
      IL_004f:  ceq
      IL_0051:  ret
    } // end of method Ray::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(class Raytracer_FSharp/Ray obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       74 (0x4a)
      .maxstack  4
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0042

      IL_000b:  ldarg.1
      IL_000c:  ldnull
      IL_000d:  cgt.un
      IL_000f:  brfalse.s  IL_0013

      IL_0011:  br.s       IL_0015

      IL_0013:  br.s       IL_0040

      IL_0015:  ldarg.0
      IL_0016:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_001b:  ldarg.1
      IL_001c:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0021:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/Vector>(!!0,
                                                                                                                                                             !!0)
      IL_0026:  brfalse.s  IL_002a

      IL_0028:  br.s       IL_002c

      IL_002a:  br.s       IL_003e

      IL_002c:  ldarg.0
      IL_002d:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0032:  ldarg.1
      IL_0033:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_0038:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/Vector>(!!0,
                                                                                                                                                             !!0)
      IL_003d:  ret

      IL_003e:  ldc.i4.0
      IL_003f:  ret

      IL_0040:  ldc.i4.0
      IL_0041:  ret

      IL_0042:  ldarg.1
      IL_0043:  ldnull
      IL_0044:  cgt.un
      IL_0046:  ldc.i4.0
      IL_0047:  ceq
      IL_0049:  ret
    } // end of method Ray::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(object obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       25 (0x19)
      .maxstack  4
      .locals init (class Raytracer_FSharp/Ray V_0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  isinst     Raytracer_FSharp/Ray
      IL_0007:  stloc.0
      IL_0008:  ldloc.0
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

      IL_000d:  br.s       IL_0017

      IL_000f:  ldarg.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance bool Raytracer_FSharp/Ray::Equals(class Raytracer_FSharp/Ray)
      IL_0016:  ret

      IL_0017:  ldc.i4.0
      IL_0018:  ret
    } // end of method Ray::Equals

    .property instance class Raytracer_FSharp/Vector
            Start()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 00 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::get_Start()
    } // end of property Ray::Start
    .property instance class Raytracer_FSharp/Vector
            Dir()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 01 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::get_Dir()
    } // end of property Ray::Dir
  } // end of class Ray

  .class interface abstract auto ansi serializable nested public Surface
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .method public hidebysig abstract virtual 
            instance class Raytracer_FSharp/Color 
            Diffuse(class Raytracer_FSharp/Vector A_1) cil managed
    {
    } // end of method Surface::Diffuse

    .method public hidebysig abstract virtual 
            instance class Raytracer_FSharp/Color 
            Specular(class Raytracer_FSharp/Vector A_1) cil managed
    {
    } // end of method Surface::Specular

    .method public hidebysig abstract virtual 
            instance float64  Reflect(class Raytracer_FSharp/Vector A_1) cil managed
    {
    } // end of method Surface::Reflect

    .method public hidebysig specialname abstract virtual 
            instance float64  get_Roughness() cil managed
    {
    } // end of method Surface::get_Roughness

    .property instance float64 Roughness()
    {
      .get instance float64 Raytracer_FSharp/Surface::get_Roughness()
    } // end of property Surface::Roughness
  } // end of class Surface

  .class auto ansi serializable sealed nested public Intersection
         extends [mscorlib]System.Object
         implements class [mscorlib]System.IEquatable`1<class Raytracer_FSharp/Intersection>,
                    [mscorlib]System.Collections.IStructuralEquatable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 02 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/SceneObject Thing@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Ray Ray@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly float64 Dist@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .method public specialname instance class Raytracer_FSharp/SceneObject 
            get_Thing() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0006:  ret
    } // end of method Intersection::get_Thing

    .method public specialname instance class Raytracer_FSharp/Ray 
            get_Ray() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0006:  ret
    } // end of method Intersection::get_Ray

    .method public specialname instance float64 
            get_Dist() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0006:  ret
    } // end of method Intersection::get_Dist

    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/SceneObject thing,
                                 class Raytracer_FSharp/Ray ray,
                                 float64 dist) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_001b:  ret
    } // end of method Intersection::.ctor

    .method public hidebysig virtual final 
            instance int32  GetHashCode(class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       98 (0x62)
      .maxstack  7
      .locals init (int32 V_0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0060

      IL_000b:  ldc.i4.0
      IL_000c:  stloc.0
      IL_000d:  ldc.i4     0x9e3779b9
      IL_0012:  ldarg.1
      IL_0013:  ldarg.0
      IL_0014:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0019:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<float64>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                              !!0)
      IL_001e:  ldloc.0
      IL_001f:  ldc.i4.6
      IL_0020:  shl
      IL_0021:  ldloc.0
      IL_0022:  ldc.i4.2
      IL_0023:  shr
      IL_0024:  add
      IL_0025:  add
      IL_0026:  add
      IL_0027:  stloc.0
      IL_0028:  ldc.i4     0x9e3779b9
      IL_002d:  ldarg.0
      IL_002e:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0033:  ldarg.1
      IL_0034:  call       instance int32 Raytracer_FSharp/Ray::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_0039:  ldloc.0
      IL_003a:  ldc.i4.6
      IL_003b:  shl
      IL_003c:  ldloc.0
      IL_003d:  ldc.i4.2
      IL_003e:  shr
      IL_003f:  add
      IL_0040:  add
      IL_0041:  add
      IL_0042:  stloc.0
      IL_0043:  ldc.i4     0x9e3779b9
      IL_0048:  ldarg.1
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_004f:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/SceneObject>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                         !!0)
      IL_0054:  ldloc.0
      IL_0055:  ldc.i4.6
      IL_0056:  shl
      IL_0057:  ldloc.0
      IL_0058:  ldc.i4.2
      IL_0059:  shr
      IL_005a:  add
      IL_005b:  add
      IL_005c:  add
      IL_005d:  stloc.0
      IL_005e:  ldloc.0
      IL_005f:  ret

      IL_0060:  ldc.i4.0
      IL_0061:  ret
    } // end of method Intersection::GetHashCode

    .method public hidebysig virtual final 
            instance int32  GetHashCode() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       13 (0xd)
      .maxstack  4
//000069:     { Start: Vector; 
//000070:       Dir: Vector}
//000071: 
//000072: type Surface = 
//000073:     abstract Diffuse: Vector -> Color; 
//000074:     abstract Specular: Vector -> Color; 
//000075:     abstract Reflect: Vector -> double; 
//000076:     abstract Roughness : double
//000077: 
//000078: type Intersection = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       class [mscorlib]System.Collections.IEqualityComparer [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::get_GenericEqualityComparer()
      IL_0007:  call       instance int32 Raytracer_FSharp/Intersection::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_000c:  ret
    } // end of method Intersection::GetHashCode

    .method public hidebysig virtual final 
            instance bool  Equals(object obj,
                                  class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       115 (0x73)
      .maxstack  5
      .locals init (class Raytracer_FSharp/Intersection V_0,
               class Raytracer_FSharp/Intersection V_1,
               class [mscorlib]System.Collections.IEqualityComparer V_2,
               class Raytracer_FSharp/Ray V_3,
               class Raytracer_FSharp/Ray V_4,
               class [mscorlib]System.Collections.IEqualityComparer V_5)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_006b

      IL_000b:  ldarg.1
      IL_000c:  isinst     Raytracer_FSharp/Intersection
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  brfalse.s  IL_0017

      IL_0015:  br.s       IL_0019

      IL_0017:  br.s       IL_0069

      IL_0019:  ldloc.0
      IL_001a:  stloc.1
      IL_001b:  ldarg.2
      IL_001c:  ldarg.0
      IL_001d:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0022:  ldloc.1
      IL_0023:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0028:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/SceneObject>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                            !!0,
                                                                                                                                                                            !!0)
      IL_002d:  brfalse.s  IL_0031

      IL_002f:  br.s       IL_0033

      IL_0031:  br.s       IL_0067

      IL_0033:  ldarg.2
      IL_0034:  stloc.2
      IL_0035:  ldarg.0
      IL_0036:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_003b:  stloc.3
      IL_003c:  ldloc.1
      IL_003d:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0042:  stloc.s    V_4
      IL_0044:  ldloc.3
      IL_0045:  ldloc.s    V_4
      IL_0047:  ldloc.2
      IL_0048:  call       instance bool Raytracer_FSharp/Ray::Equals(object,
                                                                      class [mscorlib]System.Collections.IEqualityComparer)
      IL_004d:  brfalse.s  IL_0051

      IL_004f:  br.s       IL_0053

      IL_0051:  br.s       IL_0065

      IL_0053:  ldarg.2
      IL_0054:  stloc.s    V_5
      IL_0056:  ldarg.0
      IL_0057:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_005c:  ldloc.1
      IL_005d:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0062:  ceq
      IL_0064:  ret

      IL_0065:  ldc.i4.0
      IL_0066:  ret

      IL_0067:  ldc.i4.0
      IL_0068:  ret

      IL_0069:  ldc.i4.0
      IL_006a:  ret

      IL_006b:  ldarg.1
      IL_006c:  ldnull
      IL_006d:  cgt.un
      IL_006f:  ldc.i4.0
      IL_0070:  ceq
      IL_0072:  ret
    } // end of method Intersection::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(class Raytracer_FSharp/Intersection obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       134 (0x86)
      .maxstack  4
      .locals init (float64 V_0,
               float64 V_1)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000e

      IL_0009:  br         IL_007e

      IL_000e:  ldarg.1
      IL_000f:  ldnull
      IL_0010:  cgt.un
      IL_0012:  brfalse.s  IL_0016

      IL_0014:  br.s       IL_001b

      IL_0016:  br         IL_007c

      IL_001b:  ldarg.0
      IL_001c:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0021:  ldarg.1
      IL_0022:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0027:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/SceneObject>(!!0,
                                                                                                                                                                  !!0)
      IL_002c:  brfalse.s  IL_0030

      IL_002e:  br.s       IL_0032

      IL_0030:  br.s       IL_007a

      IL_0032:  ldarg.0
      IL_0033:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0038:  ldarg.1
      IL_0039:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_003e:  call       instance bool Raytracer_FSharp/Ray::Equals(class Raytracer_FSharp/Ray)
      IL_0043:  brfalse.s  IL_0047

      IL_0045:  br.s       IL_0049

      IL_0047:  br.s       IL_0078

      IL_0049:  ldarg.0
      IL_004a:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_004f:  stloc.0
      IL_0050:  ldarg.1
      IL_0051:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0056:  stloc.1
      IL_0057:  ldloc.0
      IL_0058:  ldloc.0
      IL_0059:  beq.s      IL_005d

      IL_005b:  br.s       IL_005f

      IL_005d:  br.s       IL_0069

      IL_005f:  ldloc.1
      IL_0060:  ldloc.1
      IL_0061:  ceq
      IL_0063:  ldc.i4.0
      IL_0064:  ceq
      IL_0066:  nop
      IL_0067:  br.s       IL_006b

      IL_0069:  ldc.i4.0
      IL_006a:  nop
      IL_006b:  brfalse.s  IL_006f

      IL_006d:  br.s       IL_0071

      IL_006f:  br.s       IL_0073

      IL_0071:  ldc.i4.1
      IL_0072:  ret

      IL_0073:  ldloc.0
      IL_0074:  ldloc.1
      IL_0075:  ceq
      IL_0077:  ret

      IL_0078:  ldc.i4.0
      IL_0079:  ret

      IL_007a:  ldc.i4.0
      IL_007b:  ret

      IL_007c:  ldc.i4.0
      IL_007d:  ret

      IL_007e:  ldarg.1
      IL_007f:  ldnull
      IL_0080:  cgt.un
      IL_0082:  ldc.i4.0
      IL_0083:  ceq
      IL_0085:  ret
    } // end of method Intersection::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(object obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       25 (0x19)
      .maxstack  4
      .locals init (class Raytracer_FSharp/Intersection V_0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  isinst     Raytracer_FSharp/Intersection
      IL_0007:  stloc.0
      IL_0008:  ldloc.0
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

      IL_000d:  br.s       IL_0017

      IL_000f:  ldarg.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance bool Raytracer_FSharp/Intersection::Equals(class Raytracer_FSharp/Intersection)
      IL_0016:  ret

      IL_0017:  ldc.i4.0
      IL_0018:  ret
    } // end of method Intersection::Equals

    .property instance class Raytracer_FSharp/SceneObject
            Thing()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 00 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::get_Thing()
    } // end of property Intersection::Thing
    .property instance class Raytracer_FSharp/Ray
            Ray()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 01 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::get_Ray()
    } // end of property Intersection::Ray
    .property instance float64 Dist()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 02 00 00 00 00 00 ) 
      .get instance float64 Raytracer_FSharp/Intersection::get_Dist()
    } // end of property Intersection::Dist
  } // end of class Intersection

  .class interface abstract auto ansi serializable nested public SceneObject
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .method public hidebysig specialname abstract virtual 
            instance class Raytracer_FSharp/Surface 
            get_Surface() cil managed
    {
    } // end of method SceneObject::get_Surface

    .method public hidebysig abstract virtual 
            instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection> 
            Intersect(class Raytracer_FSharp/Ray A_1) cil managed
    {
    } // end of method SceneObject::Intersect

    .method public hidebysig abstract virtual 
            instance class Raytracer_FSharp/Vector 
            Normal(class Raytracer_FSharp/Vector A_1) cil managed
    {
    } // end of method SceneObject::Normal

    .property instance class Raytracer_FSharp/Surface
            Surface()
    {
      .get instance class Raytracer_FSharp/Surface Raytracer_FSharp/SceneObject::get_Surface()
    } // end of property SceneObject::Surface
  } // end of class SceneObject

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname Sphere@90
         extends [mscorlib]System.Object
         implements Raytracer_FSharp/SceneObject
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Raytracer_FSharp/Surface surface
    .field public class Raytracer_FSharp/Vector center
    .field public float64 radius2
    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Surface surface,
                                 class Raytracer_FSharp/Vector center,
                                 float64 radius2) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  5
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Raytracer_FSharp/Surface Raytracer_FSharp/Sphere@90::surface
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Sphere@90::center
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      float64 Raytracer_FSharp/Sphere@90::radius2
      IL_0015:  nop
      IL_0016:  ldarg.0
      IL_0017:  call       instance void [mscorlib]System.Object::.ctor()
      IL_001c:  ldarg.0
      IL_001d:  pop
      IL_001e:  ret
    } // end of method Sphere@90::.ctor

    .method public hidebysig virtual instance class Raytracer_FSharp/Surface 
            get_Surface() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000079:     { Thing: SceneObject; 
//000080:       Ray: Ray; 
//000081:       Dist: double}
//000082: 
//000083: and SceneObject = 
//000084:     abstract Surface : Surface
//000085:     abstract Intersect : Ray -> Intersection option
//000086:     abstract Normal : Vector -> Vector
//000087: 
//000088: let Sphere(center, radius, surface) =
//000089:     let radius2 = radius * radius
//000090:     { new SceneObject with 
//000091:         member this.Surface = surface
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Surface Raytracer_FSharp/Sphere@90::surface
      IL_0007:  ret
    } // end of method Sphere@90::get_Surface

    .method public hidebysig virtual instance class Raytracer_FSharp/Vector 
            Normal(class Raytracer_FSharp/Vector A_1) cil managed
    {
      // Code size       23 (0x17)
      .maxstack  6
      .locals init ([0] class Raytracer_FSharp/Vector V_0,
               [1] class Raytracer_FSharp/Vector V_1)
//000092:         member this.Normal pos = Vector.Norm(pos - center)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Sphere@90::center
      IL_0009:  stloc.1
      IL_000a:  ldloc.0
      IL_000b:  ldloc.1
      IL_000c:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Subtraction(class Raytracer_FSharp/Vector,
                                                                                                 class Raytracer_FSharp/Vector)
      IL_0011:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_0016:  ret
    } // end of method Sphere@90::Normal

    .method public hidebysig virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection> 
            Intersect(class Raytracer_FSharp/Ray A_1) cil managed
    {
      // Code size       174 (0xae)
      .maxstack  8
      .locals init ([0] class Raytracer_FSharp/Vector eo,
               [1] class Raytracer_FSharp/Vector V_1,
               [2] class Raytracer_FSharp/Vector V_2,
               [3] float64 v,
               [4] float64 dist,
               [5] float64 disc,
               [6] float64 V_6,
               [7] float64 V_7)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Sphere@90::center
      IL_0007:  stloc.1
      IL_0008:  ldarg.1
      IL_0009:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_000e:  stloc.2
      IL_000f:  ldloc.1
      IL_0010:  ldloc.2
      IL_0011:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Subtraction(class Raytracer_FSharp/Vector,
                                                                                                 class Raytracer_FSharp/Vector)
      IL_0016:  stloc.0
//000095:             let v = Vector.Dot(eo, ray.Dir)
      IL_0017:  ldloc.0
      IL_0018:  ldarg.1
      IL_0019:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_001e:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_0023:  stloc.3
//000096:             let dist = 
      IL_0024:  nop
//000097:                 if (v<0.0) 
      IL_0025:  ldloc.3
      IL_0026:  ldc.r8     0.0
      IL_002f:  clt
      IL_0031:  brfalse.s  IL_0035

      IL_0033:  br.s       IL_0037

      IL_0035:  br.s       IL_0043

//000098:                 then 0.0
      IL_0037:  ldc.r8     0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0040:  nop
      IL_0041:  br.s       IL_0088

//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
      IL_0043:  ldarg.0
      IL_0044:  ldfld      float64 Raytracer_FSharp/Sphere@90::radius2
      IL_0049:  ldloc.0
      IL_004a:  ldloc.0
      IL_004b:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_0050:  ldloc.3
      IL_0051:  ldloc.3
      IL_0052:  mul
      IL_0053:  sub
      IL_0054:  sub
      IL_0055:  stloc.s    disc
//000100:                      if disc < 0.0
      IL_0057:  ldloc.s    disc
      IL_0059:  ldc.r8     0.0
      IL_0062:  clt
      IL_0064:  brfalse.s  IL_0068

      IL_0066:  br.s       IL_006a

      IL_0068:  br.s       IL_0076

//000101:                      then 0.0
      IL_006a:  ldc.r8     0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0073:  nop
      IL_0074:  br.s       IL_0088

//000102:                      else v - (sqrt(disc))
      IL_0076:  ldloc.3
      IL_0077:  ldloc.s    disc
      IL_0079:  stloc.s    V_6
      IL_007b:  ldloc.s    V_6
      IL_007d:  stloc.s    V_7
      IL_007f:  ldloc.s    V_6
      IL_0081:  call       float64 [mscorlib]System.Math::Sqrt(float64)
      IL_0086:  sub
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
//000111:         member this.Normal pos = norm
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
//000114:             if denom > 0.0
//000115:             then None
//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
//000126:     member c.Forward = forward
//000127:     member c.Up      = up
//000128:     member c.Right   = right
//000129: 
//000130: type Light = 
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0087:  nop
      IL_0088:  stloc.s    dist
//000103:             if dist = 0.0 
      IL_008a:  ldloc.s    dist
      IL_008c:  ldc.r8     0.0
      IL_0095:  ceq
      IL_0097:  brfalse.s  IL_009b

      IL_0099:  br.s       IL_009d

      IL_009b:  br.s       IL_009f

//000104:             then None
      IL_009d:  ldnull
      IL_009e:  ret

//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
      IL_009f:  ldarg.0
      IL_00a0:  ldarg.1
      IL_00a1:  ldloc.s    dist
      IL_00a3:  newobj     instance void Raytracer_FSharp/Intersection::.ctor(class Raytracer_FSharp/SceneObject,
                                                                              class Raytracer_FSharp/Ray,
                                                                              float64)
      IL_00a8:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection>::Some(!0)
      IL_00ad:  ret
    } // end of method Sphere@90::Intersect

  } // end of class Sphere@90

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname Plane@109
         extends [mscorlib]System.Object
         implements Raytracer_FSharp/SceneObject
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Raytracer_FSharp/Surface surface
    .field public float64 offset
    .field public class Raytracer_FSharp/Vector norm
    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Surface surface,
                                 float64 offset,
                                 class Raytracer_FSharp/Vector norm) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  5
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Raytracer_FSharp/Surface Raytracer_FSharp/Plane@109::surface
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      float64 Raytracer_FSharp/Plane@109::offset
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Plane@109::norm
      IL_0015:  nop
      IL_0016:  ldarg.0
      IL_0017:  call       instance void [mscorlib]System.Object::.ctor()
      IL_001c:  ldarg.0
      IL_001d:  pop
      IL_001e:  ret
    } // end of method Plane@109::.ctor

    .method public hidebysig virtual instance class Raytracer_FSharp/Surface 
            get_Surface() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
//000110:         member this.Surface = surface
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Surface Raytracer_FSharp/Plane@109::surface
      IL_0007:  ret
    } // end of method Plane@109::get_Surface

    .method public hidebysig virtual instance class Raytracer_FSharp/Vector 
            Normal(class Raytracer_FSharp/Vector A_1) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000111:         member this.Normal pos = norm
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Plane@109::norm
      IL_0007:  ret
    } // end of method Plane@109::Normal

    .method public hidebysig virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection> 
            Intersect(class Raytracer_FSharp/Ray A_1) cil managed
    {
      // Code size       81 (0x51)
      .maxstack  7
      .locals init ([0] float64 denom,
               [1] float64 dist)
//000112:         member this.Intersect (ray) =
//000113:             let denom = Vector.Dot(norm, ray.Dir)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Plane@109::norm
      IL_0007:  ldarg.1
      IL_0008:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_000d:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_0012:  stloc.0
//000114:             if denom > 0.0
      IL_0013:  ldloc.0
      IL_0014:  ldc.r8     0.0
      IL_001d:  cgt
      IL_001f:  brfalse.s  IL_0023

      IL_0021:  br.s       IL_0025

      IL_0023:  br.s       IL_0027

//000115:             then None
      IL_0025:  ldnull
      IL_0026:  ret

//000116:             else let dist = (Vector.Dot(norm, ray.Start) + offset) / (-denom) 
      IL_0027:  ldarg.0
      IL_0028:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Plane@109::norm
      IL_002d:  ldarg.1
      IL_002e:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_0033:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_0038:  ldarg.0
      IL_0039:  ldfld      float64 Raytracer_FSharp/Plane@109::offset
      IL_003e:  add
      IL_003f:  ldloc.0
      IL_0040:  neg
      IL_0041:  div
      IL_0042:  stloc.1
//000117:                  Some { Thing = this; Ray = ray; Dist = dist }
      IL_0043:  ldarg.0
      IL_0044:  ldarg.1
      IL_0045:  ldloc.1
      IL_0046:  newobj     instance void Raytracer_FSharp/Intersection::.ctor(class Raytracer_FSharp/SceneObject,
                                                                              class Raytracer_FSharp/Ray,
                                                                              float64)
      IL_004b:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection>::Some(!0)
      IL_0050:  ret
    } // end of method Plane@109::Intersect

  } // end of class Plane@109

  .class auto ansi serializable nested public Camera
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Vector pos
    .field assembly class Raytracer_FSharp/Vector forward
    .field assembly class Raytracer_FSharp/Vector right
    .field assembly class Raytracer_FSharp/Vector up
    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Vector pos,
                                 class Raytracer_FSharp/Vector lookAt) cil managed
    {
      // Code size       170 (0xaa)
      .maxstack  5
      .locals init ([0] class Raytracer_FSharp/Vector V_0,
               [1] class Raytracer_FSharp/Vector V_1,
               [2] class Raytracer_FSharp/Vector down,
               [3] float64 V_3,
               [4] class Raytracer_FSharp/Vector V_4,
               [5] float64 V_5,
               [6] class Raytracer_FSharp/Vector V_6)
//000118:     }
//000119: 
//000120: type Camera(pos : Vector, lookAt : Vector) = 
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::pos
//000121:     let forward = Vector.Norm(lookAt - pos)
      IL_0010:  ldarg.0
      IL_0011:  ldarg.2
      IL_0012:  stloc.0
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::pos
      IL_0019:  stloc.1
      IL_001a:  ldloc.0
      IL_001b:  ldloc.1
      IL_001c:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Subtraction(class Raytracer_FSharp/Vector,
                                                                                                 class Raytracer_FSharp/Vector)
      IL_0021:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_0026:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::forward
//000122:     let down = Vector(0.0,-1.0,0.0)
      IL_002b:  ldc.r8     0.0
      IL_0034:  ldc.r8     -1.
      IL_003d:  ldc.r8     0.0
      IL_0046:  newobj     instance void Raytracer_FSharp/Vector::.ctor(float64,
                                                                        float64,
                                                                        float64)
      IL_004b:  stloc.2
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
      IL_004c:  ldarg.0
      IL_004d:  ldc.r8     1.5
      IL_0056:  stloc.3
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::forward
      IL_005d:  ldloc.2
      IL_005e:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Cross(class Raytracer_FSharp/Vector,
                                                                                        class Raytracer_FSharp/Vector)
      IL_0063:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_0068:  stloc.s    V_4
      IL_006a:  ldloc.3
      IL_006b:  ldloc.s    V_4
      IL_006d:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0072:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::right
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
      IL_0077:  ldarg.0
      IL_0078:  ldc.r8     1.5
      IL_0081:  stloc.s    V_5
      IL_0083:  ldarg.0
      IL_0084:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::forward
      IL_0089:  ldarg.0
      IL_008a:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::right
      IL_008f:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Cross(class Raytracer_FSharp/Vector,
                                                                                        class Raytracer_FSharp/Vector)
      IL_0094:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_0099:  stloc.s    V_6
      IL_009b:  ldloc.s    V_5
      IL_009d:  ldloc.s    V_6
      IL_009f:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_00a4:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::up
//000120: type Camera(pos : Vector, lookAt : Vector) = 
      IL_00a9:  ret
    } // end of method Camera::.ctor

    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Pos() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000121:     let forward = Vector.Norm(lookAt - pos)
//000122:     let down = Vector(0.0,-1.0,0.0)
//000123:     let right = 1.5 * Vector.Norm(Vector.Cross(forward, down))
//000124:     let up = 1.5 * Vector.Norm(Vector.Cross(forward, right))
//000125:     member c.Pos     = pos
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::pos
      IL_0007:  ret
    } // end of method Camera::get_Pos

    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Forward() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000126:     member c.Forward = forward
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::forward
      IL_0007:  ret
    } // end of method Camera::get_Forward

    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Up() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000127:     member c.Up      = up
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::up
      IL_0007:  ret
    } // end of method Camera::get_Up

    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Right() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000128:     member c.Right   = right
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::right
      IL_0007:  ret
    } // end of method Camera::get_Right

    .property instance class Raytracer_FSharp/Vector
            Pos()
    {
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Pos()
    } // end of property Camera::Pos
    .property instance class Raytracer_FSharp/Vector
            Forward()
    {
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Forward()
    } // end of property Camera::Forward
    .property instance class Raytracer_FSharp/Vector
            Up()
    {
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Up()
    } // end of property Camera::Up
    .property instance class Raytracer_FSharp/Vector
            Right()
    {
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Right()
    } // end of property Camera::Right
  } // end of class Camera

  .class auto ansi serializable sealed nested public Light
         extends [mscorlib]System.Object
         implements class [mscorlib]System.IEquatable`1<class Raytracer_FSharp/Light>,
                    [mscorlib]System.Collections.IStructuralEquatable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 02 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Vector Pos@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Color Color@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .method public specialname instance class Raytracer_FSharp/Vector 
            get_Pos() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0006:  ret
    } // end of method Light::get_Pos

    .method public specialname instance class Raytracer_FSharp/Color 
            get_Color() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0006:  ret
    } // end of method Light::get_Color

    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Vector pos,
                                 class Raytracer_FSharp/Color color) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0014:  ret
    } // end of method Light::.ctor

    .method public hidebysig virtual final 
            instance int32  GetHashCode(class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       71 (0x47)
      .maxstack  7
      .locals init (int32 V_0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0045

      IL_000b:  ldc.i4.0
      IL_000c:  stloc.0
      IL_000d:  ldc.i4     0x9e3779b9
      IL_0012:  ldarg.1
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0019:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/Color>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                   !!0)
      IL_001e:  ldloc.0
      IL_001f:  ldc.i4.6
      IL_0020:  shl
      IL_0021:  ldloc.0
      IL_0022:  ldc.i4.2
      IL_0023:  shr
      IL_0024:  add
      IL_0025:  add
      IL_0026:  add
      IL_0027:  stloc.0
      IL_0028:  ldc.i4     0x9e3779b9
      IL_002d:  ldarg.1
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0034:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                    !!0)
      IL_0039:  ldloc.0
      IL_003a:  ldc.i4.6
      IL_003b:  shl
      IL_003c:  ldloc.0
      IL_003d:  ldc.i4.2
      IL_003e:  shr
      IL_003f:  add
      IL_0040:  add
      IL_0041:  add
      IL_0042:  stloc.0
      IL_0043:  ldloc.0
      IL_0044:  ret

      IL_0045:  ldc.i4.0
      IL_0046:  ret
    } // end of method Light::GetHashCode

    .method public hidebysig virtual final 
            instance int32  GetHashCode() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       13 (0xd)
      .maxstack  4
//000129: 
//000130: type Light = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       class [mscorlib]System.Collections.IEqualityComparer [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::get_GenericEqualityComparer()
      IL_0007:  call       instance int32 Raytracer_FSharp/Light::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_000c:  ret
    } // end of method Light::GetHashCode

    .method public hidebysig virtual final 
            instance bool  Equals(object obj,
                                  class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       82 (0x52)
      .maxstack  5
      .locals init (class Raytracer_FSharp/Light V_0,
               class Raytracer_FSharp/Light V_1)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_004a

      IL_000b:  ldarg.1
      IL_000c:  isinst     Raytracer_FSharp/Light
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  brfalse.s  IL_0017

      IL_0015:  br.s       IL_0019

      IL_0017:  br.s       IL_0048

      IL_0019:  ldloc.0
      IL_001a:  stloc.1
      IL_001b:  ldarg.2
      IL_001c:  ldarg.0
      IL_001d:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0022:  ldloc.1
      IL_0023:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0028:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/Vector>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                       !!0,
                                                                                                                                                                       !!0)
      IL_002d:  brfalse.s  IL_0031

      IL_002f:  br.s       IL_0033

      IL_0031:  br.s       IL_0046

      IL_0033:  ldarg.2
      IL_0034:  ldarg.0
      IL_0035:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_003a:  ldloc.1
      IL_003b:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0040:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/Color>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                      !!0,
                                                                                                                                                                      !!0)
      IL_0045:  ret

      IL_0046:  ldc.i4.0
      IL_0047:  ret

      IL_0048:  ldc.i4.0
      IL_0049:  ret

      IL_004a:  ldarg.1
      IL_004b:  ldnull
      IL_004c:  cgt.un
      IL_004e:  ldc.i4.0
      IL_004f:  ceq
      IL_0051:  ret
    } // end of method Light::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(class Raytracer_FSharp/Light obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       74 (0x4a)
      .maxstack  4
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0042

      IL_000b:  ldarg.1
      IL_000c:  ldnull
      IL_000d:  cgt.un
      IL_000f:  brfalse.s  IL_0013

      IL_0011:  br.s       IL_0015

      IL_0013:  br.s       IL_0040

      IL_0015:  ldarg.0
      IL_0016:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_001b:  ldarg.1
      IL_001c:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0021:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/Vector>(!!0,
                                                                                                                                                             !!0)
      IL_0026:  brfalse.s  IL_002a

      IL_0028:  br.s       IL_002c

      IL_002a:  br.s       IL_003e

      IL_002c:  ldarg.0
      IL_002d:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0032:  ldarg.1
      IL_0033:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0038:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/Color>(!!0,
                                                                                                                                                            !!0)
      IL_003d:  ret

      IL_003e:  ldc.i4.0
      IL_003f:  ret

      IL_0040:  ldc.i4.0
      IL_0041:  ret

      IL_0042:  ldarg.1
      IL_0043:  ldnull
      IL_0044:  cgt.un
      IL_0046:  ldc.i4.0
      IL_0047:  ceq
      IL_0049:  ret
    } // end of method Light::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(object obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       25 (0x19)
      .maxstack  4
      .locals init (class Raytracer_FSharp/Light V_0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  isinst     Raytracer_FSharp/Light
      IL_0007:  stloc.0
      IL_0008:  ldloc.0
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

      IL_000d:  br.s       IL_0017

      IL_000f:  ldarg.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance bool Raytracer_FSharp/Light::Equals(class Raytracer_FSharp/Light)
      IL_0016:  ret

      IL_0017:  ldc.i4.0
      IL_0018:  ret
    } // end of method Light::Equals

    .property instance class Raytracer_FSharp/Vector
            Pos()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 00 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Vector Raytracer_FSharp/Light::get_Pos()
    } // end of property Light::Pos
    .property instance class Raytracer_FSharp/Color
            Color()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 01 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Color Raytracer_FSharp/Light::get_Color()
    } // end of property Light::Color
  } // end of class Light

  .class auto ansi serializable sealed nested public Scene
         extends [mscorlib]System.Object
         implements class [mscorlib]System.IEquatable`1<class Raytracer_FSharp/Scene>,
                    [mscorlib]System.Collections.IStructuralEquatable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 02 00 00 00 00 00 ) 
    .field assembly class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Things@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Lights@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .field assembly class Raytracer_FSharp/Camera Camera@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .method public specialname instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> 
            get_Things() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_0006:  ret
    } // end of method Scene::get_Things

    .method public specialname instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> 
            get_Lights() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0006:  ret
    } // end of method Scene::get_Lights

    .method public specialname instance class Raytracer_FSharp/Camera 
            get_Camera() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0006:  ret
    } // end of method Scene::get_Camera

    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> things,
                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> lights,
                                 class Raytracer_FSharp/Camera camera) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_001b:  ret
    } // end of method Scene::.ctor

    .method public hidebysig virtual final 
            instance int32  GetHashCode(class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       98 (0x62)
      .maxstack  7
      .locals init (int32 V_0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0060

      IL_000b:  ldc.i4.0
      IL_000c:  stloc.0
      IL_000d:  ldc.i4     0x9e3779b9
      IL_0012:  ldarg.1
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0019:  call       int32 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericHashWithComparerIntrinsic<class Raytracer_FSharp/Camera>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                    !!0)
      IL_001e:  ldloc.0
      IL_001f:  ldc.i4.6
      IL_0020:  shl
      IL_0021:  ldloc.0
      IL_0022:  ldc.i4.2
      IL_0023:  shr
      IL_0024:  add
      IL_0025:  add
      IL_0026:  add
      IL_0027:  stloc.0
      IL_0028:  ldc.i4     0x9e3779b9
      IL_002d:  ldarg.0
      IL_002e:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0033:  ldarg.1
      IL_0034:  call       instance int32 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_0039:  ldloc.0
      IL_003a:  ldc.i4.6
      IL_003b:  shl
      IL_003c:  ldloc.0
      IL_003d:  ldc.i4.2
      IL_003e:  shr
      IL_003f:  add
      IL_0040:  add
      IL_0041:  add
      IL_0042:  stloc.0
      IL_0043:  ldc.i4     0x9e3779b9
      IL_0048:  ldarg.0
      IL_0049:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_004e:  ldarg.1
      IL_004f:  call       instance int32 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_0054:  ldloc.0
      IL_0055:  ldc.i4.6
      IL_0056:  shl
      IL_0057:  ldloc.0
      IL_0058:  ldc.i4.2
      IL_0059:  shr
      IL_005a:  add
      IL_005b:  add
      IL_005c:  add
      IL_005d:  stloc.0
      IL_005e:  ldloc.0
      IL_005f:  ret

      IL_0060:  ldc.i4.0
      IL_0061:  ret
    } // end of method Scene::GetHashCode

    .method public hidebysig virtual final 
            instance int32  GetHashCode() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       13 (0xd)
      .maxstack  4
//000131:     { Pos : Vector;
//000132:       Color : Color }
//000133:            
//000134: type Scene = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       class [mscorlib]System.Collections.IEqualityComparer [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::get_GenericEqualityComparer()
      IL_0007:  call       instance int32 Raytracer_FSharp/Scene::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_000c:  ret
    } // end of method Scene::GetHashCode

    .method public hidebysig virtual final 
            instance bool  Equals(object obj,
                                  class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       131 (0x83)
      .maxstack  5
      .locals init (class Raytracer_FSharp/Scene V_0,
               class Raytracer_FSharp/Scene V_1,
               class [mscorlib]System.Collections.IEqualityComparer V_2,
               class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> V_3,
               class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> V_4,
               class [mscorlib]System.Collections.IEqualityComparer V_5,
               class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> V_6,
               class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> V_7)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000e

      IL_0009:  br         IL_007b

      IL_000e:  ldarg.1
      IL_000f:  isinst     Raytracer_FSharp/Scene
      IL_0014:  stloc.0
      IL_0015:  ldloc.0
      IL_0016:  brfalse.s  IL_001a

      IL_0018:  br.s       IL_001c

      IL_001a:  br.s       IL_0079

      IL_001c:  ldloc.0
      IL_001d:  stloc.1
      IL_001e:  ldarg.2
      IL_001f:  stloc.2
      IL_0020:  ldarg.0
      IL_0021:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_0026:  stloc.3
      IL_0027:  ldloc.1
      IL_0028:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_002d:  stloc.s    V_4
      IL_002f:  ldloc.3
      IL_0030:  ldloc.s    V_4
      IL_0032:  ldloc.2
      IL_0033:  call       instance bool class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>::Equals(object,
                                                                                                                                                  class [mscorlib]System.Collections.IEqualityComparer)
      IL_0038:  brfalse.s  IL_003c

      IL_003a:  br.s       IL_003e

      IL_003c:  br.s       IL_0077

      IL_003e:  ldarg.2
      IL_003f:  stloc.s    V_5
      IL_0041:  ldarg.0
      IL_0042:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0047:  stloc.s    V_6
      IL_0049:  ldloc.1
      IL_004a:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_004f:  stloc.s    V_7
      IL_0051:  ldloc.s    V_6
      IL_0053:  ldloc.s    V_7
      IL_0055:  ldloc.s    V_5
      IL_0057:  call       instance bool class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>::Equals(object,
                                                                                                                                            class [mscorlib]System.Collections.IEqualityComparer)
      IL_005c:  brfalse.s  IL_0060

      IL_005e:  br.s       IL_0062

      IL_0060:  br.s       IL_0075

      IL_0062:  ldarg.2
      IL_0063:  ldarg.0
      IL_0064:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0069:  ldloc.1
      IL_006a:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_006f:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityWithComparerIntrinsic<class Raytracer_FSharp/Camera>(class [mscorlib]System.Collections.IEqualityComparer,
                                                                                                                                                                       !!0,
                                                                                                                                                                       !!0)
      IL_0074:  ret

      IL_0075:  ldc.i4.0
      IL_0076:  ret

      IL_0077:  ldc.i4.0
      IL_0078:  ret

      IL_0079:  ldc.i4.0
      IL_007a:  ret

      IL_007b:  ldarg.1
      IL_007c:  ldnull
      IL_007d:  cgt.un
      IL_007f:  ldc.i4.0
      IL_0080:  ceq
      IL_0082:  ret
    } // end of method Scene::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(class Raytracer_FSharp/Scene obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       99 (0x63)
      .maxstack  4
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_005b

      IL_000b:  ldarg.1
      IL_000c:  ldnull
      IL_000d:  cgt.un
      IL_000f:  brfalse.s  IL_0013

      IL_0011:  br.s       IL_0015

      IL_0013:  br.s       IL_0059

      IL_0015:  ldarg.0
      IL_0016:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_001b:  ldarg.1
      IL_001c:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_0021:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>>(!!0,
                                                                                                                                                                                                                                !!0)
      IL_0026:  brfalse.s  IL_002a

      IL_0028:  br.s       IL_002c

      IL_002a:  br.s       IL_0057

      IL_002c:  ldarg.0
      IL_002d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0032:  ldarg.1
      IL_0033:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_0038:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>>(!!0,
                                                                                                                                                                                                                          !!0)
      IL_003d:  brfalse.s  IL_0041

      IL_003f:  br.s       IL_0043

      IL_0041:  br.s       IL_0055

      IL_0043:  ldarg.0
      IL_0044:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0049:  ldarg.1
      IL_004a:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_004f:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityERIntrinsic<class Raytracer_FSharp/Camera>(!!0,
                                                                                                                                                             !!0)
      IL_0054:  ret

      IL_0055:  ldc.i4.0
      IL_0056:  ret

      IL_0057:  ldc.i4.0
      IL_0058:  ret

      IL_0059:  ldc.i4.0
      IL_005a:  ret

      IL_005b:  ldarg.1
      IL_005c:  ldnull
      IL_005d:  cgt.un
      IL_005f:  ldc.i4.0
      IL_0060:  ceq
      IL_0062:  ret
    } // end of method Scene::Equals

    .method public hidebysig virtual final 
            instance bool  Equals(object obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       25 (0x19)
      .maxstack  4
      .locals init (class Raytracer_FSharp/Scene V_0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  isinst     Raytracer_FSharp/Scene
      IL_0007:  stloc.0
      IL_0008:  ldloc.0
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

      IL_000d:  br.s       IL_0017

      IL_000f:  ldarg.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance bool Raytracer_FSharp/Scene::Equals(class Raytracer_FSharp/Scene)
      IL_0016:  ret

      IL_0017:  ldc.i4.0
      IL_0018:  ret
    } // end of method Scene::Equals

    .property instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject>
            Things()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 00 00 00 00 00 00 ) 
      .get instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::get_Things()
    } // end of property Scene::Things
    .property instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light>
            Lights()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 01 00 00 00 00 00 ) 
      .get instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::get_Lights()
    } // end of property Scene::Lights
    .property instance class Raytracer_FSharp/Camera
            Camera()
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags,
                                                                                                  int32) = ( 01 00 04 00 00 00 02 00 00 00 00 00 ) 
      .get instance class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::get_Camera()
    } // end of property Scene::Camera
  } // end of class Scene

  .class auto ansi serializable nested public RayTracer
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly int32 screenWidth
    .field assembly int32 screenHeight
    .field assembly int32 maxDepth
    .field assembly class [mscorlib]System.Random rand
    .field assembly class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> numToHueShiftLookup
    .method public specialname rtspecialname 
            instance void  .ctor(int32 screenWidth,
                                 int32 screenHeight) cil managed
    {
      // Code size       53 (0x35)
      .maxstack  4
//000135:     { Things : SceneObject list;
//000136:       Lights : Light list;
//000137:       Camera : Camera }
//000138:     
//000139: type RayTracer(screenWidth, screenHeight) = 
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_0010:  ldarg.0
      IL_0011:  ldarg.2
      IL_0012:  stfld      int32 Raytracer_FSharp/RayTracer::screenHeight
//000140: 
//000141:     let maxDepth = 5
      IL_0017:  ldarg.0
      IL_0018:  ldc.i4.5
      IL_0019:  stfld      int32 Raytracer_FSharp/RayTracer::maxDepth
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
      IL_001e:  ldarg.0
      IL_001f:  newobj     instance void [mscorlib]System.Random::.ctor()
      IL_0024:  stfld      class [mscorlib]System.Random Raytracer_FSharp/RayTracer::rand
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
      IL_0029:  ldarg.0
      IL_002a:  newobj     instance void class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::.ctor()
      IL_002f:  stfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Raytracer_FSharp/RayTracer::numToHueShiftLookup
//000139: type RayTracer(screenWidth, screenHeight) = 
      IL_0034:  ret
    } // end of method RayTracer::.ctor

    .method public instance void  RenderSequential(class Raytracer_FSharp/Scene scene,
                                                   int32[] rgb) cil managed
    {
      // Code size       200 (0xc8)
      .maxstack  7
      .locals init ([0] int32 V_0,
               [1] int32 y,
               [2] int32 stride,
               [3] int32 V_3,
               [4] int32 x,
               [5] class Raytracer_FSharp/Color color,
               [6] class Raytracer_FSharp/RayTracer V_6,
               [7] class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32> V_7,
               [8] class Raytracer_FSharp/RayTracer V_8,
               [9] int32 V_9,
               [10] int32 V_10,
               [11] class Raytracer_FSharp/Camera V_11,
               [12] class Raytracer_FSharp/Ray V_12,
               [13] class Raytracer_FSharp/Scene V_13,
               [14] int32 V_14,
               [15] int32 intColor)
//000140: 
//000141:     let maxDepth = 5
//000142: 
//000143:     let Intersections ray scene =
//000144:         scene.Things
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  stloc.1
      IL_0003:  ldarg.0
      IL_0004:  ldfld      int32 Raytracer_FSharp/RayTracer::screenHeight
      IL_0009:  ldc.i4.1
      IL_000a:  sub
      IL_000b:  stloc.0
      IL_000c:  ldloc.0
      IL_000d:  ldloc.1
      IL_000e:  blt        IL_00c7

//000207:             let stride = y * screenWidth
      IL_0013:  ldloc.1
      IL_0014:  ldarg.0
      IL_0015:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_001a:  mul
      IL_001b:  stloc.2
//000208:             for x = 0 to screenWidth - 1 do 
      IL_001c:  ldc.i4.0
      IL_001d:  stloc.s    x
      IL_001f:  ldarg.0
      IL_0020:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_0025:  ldc.i4.1
      IL_0026:  sub
      IL_0027:  stloc.3
      IL_0028:  ldloc.3
      IL_0029:  ldloc.s    x
      IL_002b:  blt        IL_00ba

//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
      IL_0030:  ldarg.0
      IL_0031:  stloc.s    V_6
      IL_0033:  ldarg.1
      IL_0034:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0039:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Pos()
      IL_003e:  ldarg.0
      IL_003f:  stloc.s    V_8
      IL_0041:  ldloc.s    x
      IL_0043:  stloc.s    V_9
      IL_0045:  ldloc.1
      IL_0046:  stloc.s    V_10
      IL_0048:  ldarg.1
      IL_0049:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_004e:  stloc.s    V_11
      IL_0050:  ldloc.s    V_8
      IL_0052:  ldloc.s    V_9
      IL_0054:  ldloc.s    V_10
      IL_0056:  ldloc.s    V_11
      IL_0058:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/RayTracer::GetPoint(int32,
                                                                                                       int32,
                                                                                                       class Raytracer_FSharp/Camera)
      IL_005d:  newobj     instance void Raytracer_FSharp/Ray::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Vector)
      IL_0062:  ldarg.1
      IL_0063:  ldc.i4.0
      IL_0064:  newobj     instance void class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::.ctor(!0,
                                                                                                                                              !1,
                                                                                                                                              !2)
      IL_0069:  stloc.s    V_7
      IL_006b:  ldloc.s    V_7
      IL_006d:  call       instance !0 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item1()
      IL_0072:  stloc.s    V_12
      IL_0074:  ldloc.s    V_7
      IL_0076:  call       instance !1 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item2()
      IL_007b:  stloc.s    V_13
      IL_007d:  ldloc.s    V_7
      IL_007f:  call       instance !2 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item3()
      IL_0084:  stloc.s    V_14
      IL_0086:  ldloc.s    V_6
      IL_0088:  ldloc.s    V_12
      IL_008a:  ldloc.s    V_13
      IL_008c:  ldloc.s    V_14
      IL_008e:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::TraceRay(class Raytracer_FSharp/Ray,
                                                                                                      class Raytracer_FSharp/Scene,
                                                                                                      int32)
      IL_0093:  stloc.s    color
//000210:                 let intColor = color.ToInt ()
      IL_0095:  ldloc.s    color
      IL_0097:  call       instance int32 Raytracer_FSharp/Color::ToInt()
      IL_009c:  stloc.s    intColor
//000211:                 rgb.[x + stride] <- intColor
      IL_009e:  ldarg.2
      IL_009f:  ldloc.s    x
      IL_00a1:  ldloc.2
      IL_00a2:  add
      IL_00a3:  ldloc.s    intColor
      IL_00a5:  stelem     [mscorlib]System.Int32
      IL_00aa:  ldloc.s    x
      IL_00ac:  ldc.i4.1
      IL_00ad:  add
      IL_00ae:  stloc.s    x
//000208:             for x = 0 to screenWidth - 1 do 
      IL_00b0:  ldloc.s    x
      IL_00b2:  ldloc.3
      IL_00b3:  ldc.i4.1
      IL_00b4:  add
      IL_00b5:  bne.un     IL_0030

      IL_00ba:  ldloc.1
      IL_00bb:  ldc.i4.1
      IL_00bc:  add
      IL_00bd:  stloc.1
//000206:         for y = 0 to  screenHeight - 1 do
      IL_00be:  ldloc.1
      IL_00bf:  ldloc.0
      IL_00c0:  ldc.i4.1
      IL_00c1:  add
      IL_00c2:  bne.un     IL_0013

      IL_00c7:  ret
    } // end of method RayTracer::RenderSequential

    .method public instance void  RenderParallel(class Raytracer_FSharp/Scene scene,
                                                 int32[] rgb,
                                                 class [mscorlib]System.Threading.Tasks.ParallelOptions options) cil managed
    {
      // Code size       37 (0x25)
      .maxstack  8
      .locals init ([0] valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult V_0,
               [1] valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult V_1)
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldarg.0
      IL_0003:  ldfld      int32 Raytracer_FSharp/RayTracer::screenHeight
      IL_0008:  ldarg.3
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  ldarg.2
      IL_000c:  newobj     instance void Raytracer_FSharp/RenderParallel@214::.ctor(class Raytracer_FSharp/RayTracer,
                                                                                    class Raytracer_FSharp/Scene,
                                                                                    int32[])
      IL_0011:  ldftn      instance void Raytracer_FSharp/RenderParallel@214::Invoke(int32)
      IL_0017:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                       native int)
      IL_001c:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                        int32,
                                                                                                                                        class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                        class [mscorlib]System.Action`1<int32>)
      IL_0021:  stloc.0
      IL_0022:  ldloc.0
      IL_0023:  stloc.1
      IL_0024:  ret
    } // end of method RayTracer::RenderParallel

    .method public instance void  RenderParallelShowingThreads(class Raytracer_FSharp/Scene scene,
                                                               int32[] rgb,
                                                               class [mscorlib]System.Threading.Tasks.ParallelOptions options) cil managed
    {
      // Code size       86 (0x56)
      .maxstack  9
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> hueShift,
               [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> id,
               [2] valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult V_2,
               [3] valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult V_3)
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  newobj     instance void Raytracer_FSharp/hueShift@224::.ctor(class Raytracer_FSharp/RayTracer)
      IL_0007:  stloc.0
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
      IL_0008:  ldc.i4.0
      IL_0009:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::Ref<int32>(!!0)
      IL_000e:  stloc.1
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
      IL_000f:  ldc.i4.0
      IL_0010:  ldarg.0
      IL_0011:  ldfld      int32 Raytracer_FSharp/RayTracer::screenHeight
      IL_0016:  ldarg.3
      IL_0017:  ldloc.0
      IL_0018:  ldloc.1
      IL_0019:  newobj     instance void Raytracer_FSharp/RenderParallelShowingThreads@233::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>,
                                                                                                  class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>)
      IL_001e:  ldftn      instance float64 Raytracer_FSharp/RenderParallelShowingThreads@233::Invoke()
      IL_0024:  newobj     instance void class [mscorlib]System.Func`1<float64>::.ctor(object,
                                                                                       native int)
      IL_0029:  ldarg.0
      IL_002a:  ldarg.1
      IL_002b:  ldarg.2
      IL_002c:  newobj     instance void Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::.ctor(class Raytracer_FSharp/RayTracer,
                                                                                                      class Raytracer_FSharp/Scene,
                                                                                                      int32[])
      IL_0031:  ldftn      instance float64 Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::Invoke(int32,
                                                                                                          class [mscorlib]System.Threading.Tasks.ParallelLoopState,
                                                                                                          float64)
      IL_0037:  newobj     instance void class [mscorlib]System.Func`4<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState,float64,float64>::.ctor(object,
                                                                                                                                                              native int)
      IL_003c:  ldloc.1
      IL_003d:  newobj     instance void Raytracer_FSharp/'RenderParallelShowingThreads@240-2'::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>)
      IL_0042:  ldftn      instance void Raytracer_FSharp/'RenderParallelShowingThreads@240-2'::Invoke(float64)
      IL_0048:  newobj     instance void class [mscorlib]System.Action`1<float64>::.ctor(object,
                                                                                         native int)
      IL_004d:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For<float64>(int32,
                                                                                                                                                 int32,
                                                                                                                                                 class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                                 class [mscorlib]System.Func`1<!!0>,
                                                                                                                                                 class [mscorlib]System.Func`4<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState,!!0,!!0>,
                                                                                                                                                 class [mscorlib]System.Action`1<!!0>)
      IL_0052:  stloc.2
      IL_0053:  ldloc.2
      IL_0054:  stloc.3
      IL_0055:  ret
    } // end of method RayTracer::RenderParallelShowingThreads

    .method assembly instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> 
            Intersections(class Raytracer_FSharp/Ray ray,
                          class Raytracer_FSharp/Scene scene) cil managed
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationArgumentCountsAttribute::.ctor(int32[]) = ( 01 00 02 00 00 00 01 00 00 00 01 00 00 00 00 00 ) 
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       29 (0x1d)
      .maxstack  5
//000144:         scene.Things
      IL_0000:  nop
      IL_0001:  newobj     instance void Raytracer_FSharp/clo@146::.ctor()
      IL_0006:  ldarg.1
      IL_0007:  newobj     instance void Raytracer_FSharp/'clo@145-1'::.ctor(class Raytracer_FSharp/Ray)
      IL_000c:  ldarg.2
      IL_000d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/SceneObject> Raytracer_FSharp/Scene::Things@
      IL_0012:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!1> [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Choose<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Intersection>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!!1>>,
                                                                                                                                                                                                                                  class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
      IL_0017:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.ListModule::SortBy<class Raytracer_FSharp/Intersection,float64>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,!!1>,
                                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
      IL_001c:  ret
    } // end of method RayTracer::Intersections

    .method assembly instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64> 
            TestRay(class Raytracer_FSharp/Ray ray,
                    class Raytracer_FSharp/Scene scene) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       53 (0x35)
      .maxstack  5
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> V_0,
               [1] class Raytracer_FSharp/RayTracer V_1,
               [2] class Raytracer_FSharp/Ray V_2,
               [3] class Raytracer_FSharp/Scene V_3,
               [4] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> V_4,
               [5] class Raytracer_FSharp/Intersection isect)
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  stloc.1
      IL_0003:  ldarg.1
      IL_0004:  stloc.2
      IL_0005:  ldarg.2
      IL_0006:  stloc.3
      IL_0007:  ldloc.1
      IL_0008:  ldloc.2
      IL_0009:  ldloc.3
      IL_000a:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> Raytracer_FSharp/RayTracer::Intersections(class Raytracer_FSharp/Ray,
                                                                                                                                                                                class Raytracer_FSharp/Scene)
      IL_000f:  stloc.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection>::get_TailOrNull()
      IL_0016:  brfalse.s  IL_001a

      IL_0018:  br.s       IL_001c

//000150:         | [] -> None
      IL_001a:  ldnull
      IL_001b:  ret

//000149:         match Intersections ray scene with
      IL_001c:  ldloc.0
      IL_001d:  stloc.s    V_4
      IL_001f:  ldloc.s    V_4
      IL_0021:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection>::get_HeadOrDefault()
      IL_0026:  stloc.s    isect
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
      IL_0028:  ldloc.s    isect
      IL_002a:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_002f:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64>::Some(!0)
      IL_0034:  ret
    } // end of method RayTracer::TestRay

    .method assembly instance class Raytracer_FSharp/Color 
            TraceRay(class Raytracer_FSharp/Ray ray,
                     class Raytracer_FSharp/Scene scene,
                     int32 depth) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       71 (0x47)
      .maxstack  6
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> V_0,
               [1] class Raytracer_FSharp/RayTracer V_1,
               [2] class Raytracer_FSharp/Ray V_2,
               [3] class Raytracer_FSharp/Scene V_3,
               [4] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> V_4,
               [5] class Raytracer_FSharp/Intersection isect,
               [6] class Raytracer_FSharp/RayTracer V_6,
               [7] class Raytracer_FSharp/Intersection V_7,
               [8] class Raytracer_FSharp/Scene V_8,
               [9] int32 V_9)
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  stloc.1
      IL_0003:  ldarg.1
      IL_0004:  stloc.2
      IL_0005:  ldarg.2
      IL_0006:  stloc.3
      IL_0007:  ldloc.1
      IL_0008:  ldloc.2
      IL_0009:  ldloc.3
      IL_000a:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection> Raytracer_FSharp/RayTracer::Intersections(class Raytracer_FSharp/Ray,
                                                                                                                                                                                class Raytracer_FSharp/Scene)
      IL_000f:  stloc.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection>::get_TailOrNull()
      IL_0016:  brfalse.s  IL_001a

      IL_0018:  br.s       IL_0020

//000155:         | [] -> Color.Background
      IL_001a:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_Background()
      IL_001f:  ret

//000154:         match Intersections ray scene with
      IL_0020:  ldloc.0
      IL_0021:  stloc.s    V_4
      IL_0023:  ldloc.s    V_4
      IL_0025:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Intersection>::get_HeadOrDefault()
      IL_002a:  stloc.s    isect
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
      IL_002c:  ldarg.0
      IL_002d:  stloc.s    V_6
      IL_002f:  ldloc.s    isect
      IL_0031:  stloc.s    V_7
      IL_0033:  ldarg.2
      IL_0034:  stloc.s    V_8
      IL_0036:  ldarg.3
      IL_0037:  stloc.s    V_9
      IL_0039:  ldloc.s    V_6
      IL_003b:  ldloc.s    V_7
      IL_003d:  ldloc.s    V_8
      IL_003f:  ldloc.s    V_9
      IL_0041:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::Shade(class Raytracer_FSharp/Intersection,
                                                                                                   class Raytracer_FSharp/Scene,
                                                                                                   int32)
      IL_0046:  ret
    } // end of method RayTracer::TraceRay

    .method assembly instance class Raytracer_FSharp/Color 
            Shade(class Raytracer_FSharp/Intersection isect,
                  class Raytracer_FSharp/Scene scene,
                  int32 depth) cil managed
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationArgumentCountsAttribute::.ctor(int32[]) = ( 01 00 03 00 00 00 01 00 00 00 01 00 00 00 01 00 
                                                                                                                      00 00 00 00 ) 
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       440 (0x1b8)
      .maxstack  9
      .locals init ([0] class Raytracer_FSharp/Vector d,
               [1] class Raytracer_FSharp/Vector pos,
               [2] class Raytracer_FSharp/Vector V_2,
               [3] float64 V_3,
               [4] class Raytracer_FSharp/Vector V_4,
               [5] class Raytracer_FSharp/Vector V_5,
               [6] class Raytracer_FSharp/Vector normal,
               [7] class Raytracer_FSharp/Vector reflectDir,
               [8] class Raytracer_FSharp/Vector V_8,
               [9] class Raytracer_FSharp/Vector V_9,
               [10] float64 V_10,
               [11] class Raytracer_FSharp/Vector V_11,
               [12] class Raytracer_FSharp/Color naturalcolor,
               [13] class Raytracer_FSharp/Color V_13,
               [14] class Raytracer_FSharp/Color V_14,
               [15] class Raytracer_FSharp/RayTracer V_15,
               [16] class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene> V_16,
               [17] class Raytracer_FSharp/SceneObject V_17,
               [18] class Raytracer_FSharp/Vector V_18,
               [19] class Raytracer_FSharp/Vector V_19,
               [20] class Raytracer_FSharp/Vector V_20,
               [21] class Raytracer_FSharp/Scene V_21,
               [22] class Raytracer_FSharp/Color reflectedColor,
               [23] int32 V_23,
               [24] int32 V_24,
               [25] class Raytracer_FSharp/RayTracer V_25,
               [26] class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32> V_26,
               [27] class Raytracer_FSharp/Vector V_27,
               [28] class Raytracer_FSharp/Vector V_28,
               [29] float64 V_29,
               [30] class Raytracer_FSharp/Vector V_30,
               [31] class Raytracer_FSharp/SceneObject V_31,
               [32] class Raytracer_FSharp/Vector V_32,
               [33] class Raytracer_FSharp/Vector V_33,
               [34] class Raytracer_FSharp/Vector V_34,
               [35] class Raytracer_FSharp/Scene V_35,
               [36] int32 V_36,
               [37] class Raytracer_FSharp/Color V_37,
               [38] class Raytracer_FSharp/Color V_38)
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0007:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Dir@
      IL_000c:  stloc.0
//000160:         let pos = isect.Dist * d + isect.Ray.Start
      IL_000d:  ldarg.1
      IL_000e:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0013:  stloc.3
      IL_0014:  ldloc.0
      IL_0015:  stloc.s    V_4
      IL_0017:  ldloc.3
      IL_0018:  ldloc.s    V_4
      IL_001a:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_001f:  stloc.2
      IL_0020:  ldarg.1
      IL_0021:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/Intersection::Ray@
      IL_0026:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Ray::Start@
      IL_002b:  stloc.s    V_5
      IL_002d:  ldloc.2
      IL_002e:  ldloc.s    V_5
      IL_0030:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Addition(class Raytracer_FSharp/Vector,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0035:  stloc.1
//000161:         let normal = isect.Thing.Normal(pos)
      IL_0036:  ldarg.1
      IL_0037:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_003c:  ldloc.1
      IL_003d:  callvirt   instance class Raytracer_FSharp/Vector Raytracer_FSharp/SceneObject::Normal(class Raytracer_FSharp/Vector)
      IL_0042:  stloc.s    normal
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
      IL_0044:  ldloc.0
      IL_0045:  stloc.s    V_8
      IL_0047:  ldc.r8     2.
      IL_0050:  ldloc.s    normal
      IL_0052:  ldloc.0
      IL_0053:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_0058:  mul
      IL_0059:  stloc.s    V_10
      IL_005b:  ldloc.s    normal
      IL_005d:  stloc.s    V_11
      IL_005f:  ldloc.s    V_10
      IL_0061:  ldloc.s    V_11
      IL_0063:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0068:  stloc.s    V_9
      IL_006a:  ldloc.s    V_8
      IL_006c:  ldloc.s    V_9
      IL_006e:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Subtraction(class Raytracer_FSharp/Vector,
                                                                                                 class Raytracer_FSharp/Vector)
      IL_0073:  stloc.s    reflectDir
//000163:         let naturalcolor = Color.DefaultColor +
      IL_0075:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_DefaultColor()
      IL_007a:  stloc.s    V_13
      IL_007c:  ldarg.0
      IL_007d:  stloc.s    V_15
      IL_007f:  ldarg.1
      IL_0080:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0085:  ldloc.1
      IL_0086:  ldloc.s    normal
      IL_0088:  ldloc.s    reflectDir
      IL_008a:  ldarg.2
      IL_008b:  newobj     instance void class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::.ctor(!0,
                                                                                                                                                                                                                                          !1,
                                                                                                                                                                                                                                          !2,
                                                                                                                                                                                                                                          !3,
                                                                                                                                                                                                                                          !4)
      IL_0090:  stloc.s    V_16
      IL_0092:  ldloc.s    V_16
      IL_0094:  call       instance !0 class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::get_Item1()
      IL_0099:  stloc.s    V_17
      IL_009b:  ldloc.s    V_16
      IL_009d:  call       instance !1 class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::get_Item2()
      IL_00a2:  stloc.s    V_18
      IL_00a4:  ldloc.s    V_16
      IL_00a6:  call       instance !2 class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::get_Item3()
      IL_00ab:  stloc.s    V_19
      IL_00ad:  ldloc.s    V_16
      IL_00af:  call       instance !3 class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::get_Item4()
      IL_00b4:  stloc.s    V_20
      IL_00b6:  ldloc.s    V_16
      IL_00b8:  call       instance !4 class [mscorlib]System.Tuple`5<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene>::get_Item5()
      IL_00bd:  stloc.s    V_21
      IL_00bf:  ldloc.s    V_15
      IL_00c1:  ldloc.s    V_17
      IL_00c3:  ldloc.s    V_18
      IL_00c5:  ldloc.s    V_19
      IL_00c7:  ldloc.s    V_20
      IL_00c9:  ldloc.s    V_21
      IL_00cb:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::GetNaturalColor(class Raytracer_FSharp/SceneObject,
                                                                                                             class Raytracer_FSharp/Vector,
                                                                                                             class Raytracer_FSharp/Vector,
                                                                                                             class Raytracer_FSharp/Vector,
                                                                                                             class Raytracer_FSharp/Scene)
      IL_00d0:  stloc.s    V_14
      IL_00d2:  ldloc.s    V_13
      IL_00d4:  ldloc.s    V_14
      IL_00d6:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Addition(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_00db:  stloc.s    naturalcolor
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
      IL_00dd:  nop
      IL_00de:  ldarg.3
      IL_00df:  stloc.s    V_23
      IL_00e1:  ldarg.0
      IL_00e2:  ldfld      int32 Raytracer_FSharp/RayTracer::maxDepth
      IL_00e7:  stloc.s    V_24
      IL_00e9:  ldloc.s    V_23
      IL_00eb:  ldloc.s    V_24
      IL_00ed:  clt
      IL_00ef:  ldc.i4.0
      IL_00f0:  ceq
      IL_00f2:  brfalse.s  IL_00f6

      IL_00f4:  br.s       IL_00f8

      IL_00f6:  br.s       IL_011e

//000166:                              then Color(0.5,0.5,0.5)
      IL_00f8:  ldc.r8     0.5
      IL_0101:  ldc.r8     0.5
      IL_010a:  ldc.r8     0.5
      IL_0113:  newobj     instance void Raytracer_FSharp/Color::.ctor(float64,
                                                                       float64,
                                                                       float64)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0118:  nop
      IL_0119:  br         IL_01a4

//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
      IL_011e:  ldarg.0
      IL_011f:  stloc.s    V_25
      IL_0121:  ldarg.1
      IL_0122:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/Intersection::Thing@
      IL_0127:  ldloc.1
      IL_0128:  stloc.s    V_27
      IL_012a:  ldc.r8     1.e-003
      IL_0133:  stloc.s    V_29
      IL_0135:  ldloc.s    reflectDir
      IL_0137:  stloc.s    V_30
      IL_0139:  ldloc.s    V_29
      IL_013b:  ldloc.s    V_30
      IL_013d:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0142:  stloc.s    V_28
      IL_0144:  ldloc.s    V_27
      IL_0146:  ldloc.s    V_28
      IL_0148:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Addition(class Raytracer_FSharp/Vector,
                                                                                              class Raytracer_FSharp/Vector)
      IL_014d:  ldloc.s    normal
      IL_014f:  ldloc.s    reflectDir
      IL_0151:  ldarg.2
      IL_0152:  ldarg.3
      IL_0153:  newobj     instance void class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::.ctor(!0,
                                                                                                                                                                                                                                                !1,
                                                                                                                                                                                                                                                !2,
                                                                                                                                                                                                                                                !3,
                                                                                                                                                                                                                                                !4,
                                                                                                                                                                                                                                                !5)
      IL_0158:  stloc.s    V_26
      IL_015a:  ldloc.s    V_26
      IL_015c:  call       instance !0 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item1()
      IL_0161:  stloc.s    V_31
      IL_0163:  ldloc.s    V_26
      IL_0165:  call       instance !1 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item2()
      IL_016a:  stloc.s    V_32
      IL_016c:  ldloc.s    V_26
      IL_016e:  call       instance !2 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item3()
      IL_0173:  stloc.s    V_33
      IL_0175:  ldloc.s    V_26
      IL_0177:  call       instance !3 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item4()
      IL_017c:  stloc.s    V_34
      IL_017e:  ldloc.s    V_26
      IL_0180:  call       instance !4 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item5()
      IL_0185:  stloc.s    V_35
      IL_0187:  ldloc.s    V_26
      IL_0189:  call       instance !5 class [mscorlib]System.Tuple`6<class Raytracer_FSharp/SceneObject,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Vector,class Raytracer_FSharp/Scene,int32>::get_Item6()
      IL_018e:  stloc.s    V_36
      IL_0190:  ldloc.s    V_25
      IL_0192:  ldloc.s    V_31
      IL_0194:  ldloc.s    V_32
      IL_0196:  ldloc.s    V_33
      IL_0198:  ldloc.s    V_34
      IL_019a:  ldloc.s    V_35
      IL_019c:  ldloc.s    V_36
      IL_019e:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::GetReflectionColor(class Raytracer_FSharp/SceneObject,
                                                                                                                class Raytracer_FSharp/Vector,
                                                                                                                class Raytracer_FSharp/Vector,
                                                                                                                class Raytracer_FSharp/Vector,
                                                                                                                class Raytracer_FSharp/Scene,
                                                                                                                int32)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_01a3:  nop
      IL_01a4:  stloc.s    reflectedColor
//000168:         naturalcolor + reflectedColor
      IL_01a6:  ldloc.s    naturalcolor
      IL_01a8:  stloc.s    V_37
      IL_01aa:  ldloc.s    reflectedColor
      IL_01ac:  stloc.s    V_38
      IL_01ae:  ldloc.s    V_37
      IL_01b0:  ldloc.s    V_38
      IL_01b2:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Addition(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_01b7:  ret
    } // end of method RayTracer::Shade

    .method assembly instance class Raytracer_FSharp/Color 
            GetReflectionColor(class Raytracer_FSharp/SceneObject thing,
                               class Raytracer_FSharp/Vector pos,
                               class Raytracer_FSharp/Vector normal,
                               class Raytracer_FSharp/Vector rd,
                               class Raytracer_FSharp/Scene scene,
                               int32 depth) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       73 (0x49)
      .maxstack  7
      .locals init ([0] class Raytracer_FSharp/RayTracer V_0,
               [1] class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32> V_1,
               [2] class Raytracer_FSharp/Ray V_2,
               [3] class Raytracer_FSharp/Scene V_3,
               [4] int32 V_4)
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance class Raytracer_FSharp/Surface Raytracer_FSharp/SceneObject::get_Surface()
      IL_0007:  ldarg.2
      IL_0008:  callvirt   instance float64 Raytracer_FSharp/Surface::Reflect(class Raytracer_FSharp/Vector)
      IL_000d:  ldarg.0
      IL_000e:  stloc.0
      IL_000f:  ldarg.2
      IL_0010:  ldarg.s    rd
      IL_0012:  newobj     instance void Raytracer_FSharp/Ray::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Vector)
      IL_0017:  ldarg.s    scene
      IL_0019:  ldarg.s    depth
      IL_001b:  ldc.i4.1
      IL_001c:  add
      IL_001d:  newobj     instance void class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::.ctor(!0,
                                                                                                                                              !1,
                                                                                                                                              !2)
      IL_0022:  stloc.1
      IL_0023:  ldloc.1
      IL_0024:  call       instance !0 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item1()
      IL_0029:  stloc.2
      IL_002a:  ldloc.1
      IL_002b:  call       instance !1 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item2()
      IL_0030:  stloc.3
      IL_0031:  ldloc.1
      IL_0032:  call       instance !2 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item3()
      IL_0037:  stloc.s    V_4
      IL_0039:  ldloc.0
      IL_003a:  ldloc.2
      IL_003b:  ldloc.3
      IL_003c:  ldloc.s    V_4
      IL_003e:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::TraceRay(class Raytracer_FSharp/Ray,
                                                                                                      class Raytracer_FSharp/Scene,
                                                                                                      int32)
      IL_0043:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::Scale(float64,
                                                                                      class Raytracer_FSharp/Color)
      IL_0048:  ret
    } // end of method RayTracer::GetReflectionColor

    .method assembly instance class Raytracer_FSharp/Color 
            GetNaturalColor(class Raytracer_FSharp/SceneObject thing,
                            class Raytracer_FSharp/Vector pos,
                            class Raytracer_FSharp/Vector norm,
                            class Raytracer_FSharp/Vector rd,
                            class Raytracer_FSharp/Scene scene) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       34 (0x22)
      .maxstack  8
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/Color,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/Light,class Raytracer_FSharp/Color>> addLight)
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldarg.1
      IL_0003:  ldarg.s    scene
      IL_0005:  ldarg.s    rd
      IL_0007:  ldarg.2
      IL_0008:  ldarg.3
      IL_0009:  newobj     instance void Raytracer_FSharp/addLight@175::.ctor(class Raytracer_FSharp/RayTracer,
                                                                              class Raytracer_FSharp/SceneObject,
                                                                              class Raytracer_FSharp/Scene,
                                                                              class Raytracer_FSharp/Vector,
                                                                              class Raytracer_FSharp/Vector,
                                                                              class Raytracer_FSharp/Vector)
      IL_000e:  stloc.0
//000175:             let ldis = light.Pos - pos
//000176:             let livec = Vector.Norm(ldis)
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
//000178:             let isInShadow = match neatIsect with 
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
      IL_000f:  ldloc.0
      IL_0010:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_DefaultColor()
      IL_0015:  ldarg.s    scene
      IL_0017:  ldfld      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class Raytracer_FSharp/Light> Raytracer_FSharp/Scene::Lights@
      IL_001c:  call       !!1 [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Fold<class Raytracer_FSharp/Light,class Raytracer_FSharp/Color>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!1,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,!!1>>,
                                                                                                                                                     !!1,
                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
      IL_0021:  ret
    } // end of method RayTracer::GetNaturalColor

    .method assembly instance class Raytracer_FSharp/Vector 
            GetPoint(int32 x,
                     int32 y,
                     class Raytracer_FSharp/Camera camera) cil managed
    {
      .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationArgumentCountsAttribute::.ctor(int32[]) = ( 01 00 03 00 00 00 01 00 00 00 01 00 00 00 01 00 
                                                                                                                      00 00 00 00 ) 
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       101 (0x65)
      .maxstack  4
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> RecenterX,
               [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> RecenterY,
               [2] class Raytracer_FSharp/Vector V_2,
               [3] class Raytracer_FSharp/Vector V_3,
               [4] class Raytracer_FSharp/Vector V_4,
               [5] float64 V_5,
               [6] class Raytracer_FSharp/Vector V_6,
               [7] class Raytracer_FSharp/Vector V_7,
               [8] float64 V_8,
               [9] class Raytracer_FSharp/Vector V_9)
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
      IL_0000:  ldarg.0
      IL_0001:  newobj     instance void Raytracer_FSharp/RecenterX@198::.ctor(class Raytracer_FSharp/RayTracer)
      IL_0006:  stloc.0
      IL_0007:  ldarg.0
      IL_0008:  newobj     instance void Raytracer_FSharp/RecenterY@199::.ctor(class Raytracer_FSharp/RayTracer)
      IL_000d:  stloc.1
      IL_000e:  nop
      IL_000f:  ldarg.3
      IL_0010:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Forward()
      IL_0015:  stloc.3
      IL_0016:  ldloc.0
      IL_0017:  ldarg.1
      IL_0018:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::Invoke(!0)
      IL_001d:  stloc.s    V_5
      IL_001f:  ldarg.3
      IL_0020:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Right()
      IL_0025:  stloc.s    V_6
      IL_0027:  ldloc.s    V_5
      IL_0029:  ldloc.s    V_6
      IL_002b:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0030:  stloc.s    V_4
      IL_0032:  ldloc.3
      IL_0033:  ldloc.s    V_4
      IL_0035:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Addition(class Raytracer_FSharp/Vector,
                                                                                              class Raytracer_FSharp/Vector)
      IL_003a:  stloc.2
      IL_003b:  ldloc.1
      IL_003c:  ldarg.2
      IL_003d:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::Invoke(!0)
      IL_0042:  stloc.s    V_8
      IL_0044:  ldarg.3
      IL_0045:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Up()
      IL_004a:  stloc.s    V_9
      IL_004c:  ldloc.s    V_8
      IL_004e:  ldloc.s    V_9
      IL_0050:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Multiply(float64,
                                                                                              class Raytracer_FSharp/Vector)
      IL_0055:  stloc.s    V_7
      IL_0057:  ldloc.2
      IL_0058:  ldloc.s    V_7
      IL_005a:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Addition(class Raytracer_FSharp/Vector,
                                                                                              class Raytracer_FSharp/Vector)
      IL_005f:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_0064:  ret
    } // end of method RayTracer::GetPoint

  } // end of class RayTracer

  .class auto autochar sealed nested assembly beforefieldinit specialname RenderParallel@214
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Raytracer_FSharp/RayTracer this
    .field public class Raytracer_FSharp/Scene scene
    .field public int32[] rgb
    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this,
                                 class Raytracer_FSharp/Scene scene,
                                 int32[] rgb) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RenderParallel@214::this
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class Raytracer_FSharp/Scene Raytracer_FSharp/RenderParallel@214::scene
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32[] Raytracer_FSharp/RenderParallel@214::rgb
      IL_0015:  ldarg.0
      IL_0016:  call       instance void [mscorlib]System.Object::.ctor()
      IL_001b:  ret
    } // end of method RenderParallel@214::.ctor

    .method assembly instance void  Invoke(int32 obj) cil managed
    {
      // Code size       184 (0xb8)
      .maxstack  9
      .locals init ([0] int32 stride,
               [1] int32 V_1,
               [2] int32 x,
               [3] class Raytracer_FSharp/Color color,
               [4] class Raytracer_FSharp/RayTracer V_4,
               [5] class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32> V_5,
               [6] class Raytracer_FSharp/Ray V_6,
               [7] class Raytracer_FSharp/Scene V_7,
               [8] int32 V_8,
               [9] int32 intColor)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RenderParallel@214::this
      IL_0008:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_000d:  mul
      IL_000e:  stloc.0
//000216:             for x = 0 to screenWidth - 1 do 
      IL_000f:  ldc.i4.0
      IL_0010:  stloc.2
      IL_0011:  ldarg.0
      IL_0012:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RenderParallel@214::this
      IL_0017:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_001c:  ldc.i4.1
      IL_001d:  sub
      IL_001e:  stloc.1
      IL_001f:  ldloc.1
      IL_0020:  ldloc.2
      IL_0021:  blt        IL_00b7

//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
      IL_0026:  ldarg.0
      IL_0027:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RenderParallel@214::this
      IL_002c:  stloc.s    V_4
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/RenderParallel@214::scene
      IL_0034:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0039:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Pos()
      IL_003e:  ldarg.0
      IL_003f:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RenderParallel@214::this
      IL_0044:  ldloc.2
      IL_0045:  ldarg.1
      IL_0046:  ldarg.0
      IL_0047:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/RenderParallel@214::scene
      IL_004c:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0051:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/RayTracer::GetPoint(int32,
                                                                                                       int32,
                                                                                                       class Raytracer_FSharp/Camera)
      IL_0056:  newobj     instance void Raytracer_FSharp/Ray::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Vector)
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/RenderParallel@214::scene
      IL_0061:  ldc.i4.0
      IL_0062:  newobj     instance void class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::.ctor(!0,
                                                                                                                                              !1,
                                                                                                                                              !2)
      IL_0067:  stloc.s    V_5
      IL_0069:  ldloc.s    V_5
      IL_006b:  call       instance !0 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item1()
      IL_0070:  stloc.s    V_6
      IL_0072:  ldloc.s    V_5
      IL_0074:  call       instance !1 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item2()
      IL_0079:  stloc.s    V_7
      IL_007b:  ldloc.s    V_5
      IL_007d:  call       instance !2 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item3()
      IL_0082:  stloc.s    V_8
      IL_0084:  ldloc.s    V_4
      IL_0086:  ldloc.s    V_6
      IL_0088:  ldloc.s    V_7
      IL_008a:  ldloc.s    V_8
      IL_008c:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::TraceRay(class Raytracer_FSharp/Ray,
                                                                                                      class Raytracer_FSharp/Scene,
                                                                                                      int32)
      IL_0091:  stloc.3
//000218:                 let intColor = color.ToInt ()
      IL_0092:  ldloc.3
      IL_0093:  call       instance int32 Raytracer_FSharp/Color::ToInt()
      IL_0098:  stloc.s    intColor
//000219:                 rgb.[x + stride] <- intColor)
      IL_009a:  ldarg.0
      IL_009b:  ldfld      int32[] Raytracer_FSharp/RenderParallel@214::rgb
      IL_00a0:  ldloc.2
      IL_00a1:  ldloc.0
      IL_00a2:  add
      IL_00a3:  ldloc.s    intColor
      IL_00a5:  stelem     [mscorlib]System.Int32
      IL_00aa:  ldloc.2
      IL_00ab:  ldc.i4.1
      IL_00ac:  add
      IL_00ad:  stloc.2
//000216:             for x = 0 to screenWidth - 1 do 
      IL_00ae:  ldloc.2
      IL_00af:  ldloc.1
      IL_00b0:  ldc.i4.1
      IL_00b1:  add
      IL_00b2:  bne.un     IL_0026

      IL_00b7:  ret
    } // end of method RenderParallel@214::Invoke

  } // end of class RenderParallel@214

  .class auto ansi serializable nested assembly beforefieldinit 'hueShift@225-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class Raytracer_FSharp/RayTracer this
    .field public int32 id
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> shift
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this,
                                 int32 id,
                                 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> shift) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'hueShift@225-1'::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      int32 Raytracer_FSharp/'hueShift@225-1'::id
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> Raytracer_FSharp/'hueShift@225-1'::shift
      IL_001b:  ret
    } // end of method 'hueShift@225-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar0) cil managed
    {
      // Code size       107 (0x6b)
      .maxstack  7
      .locals init ([0] bool exists)
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'hueShift@225-1'::this
      IL_0007:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Raytracer_FSharp/RayTracer::numToHueShiftLookup
      IL_000c:  ldarg.0
      IL_000d:  ldfld      int32 Raytracer_FSharp/'hueShift@225-1'::id
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> Raytracer_FSharp/'hueShift@225-1'::shift
      IL_0018:  ldflda     !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64>::contents@
      IL_001d:  callvirt   instance bool class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::TryGetValue(!0,
                                                                                                                             !1&)
      IL_0022:  stloc.0
//000227:                 if not exists 
      IL_0023:  ldloc.0
      IL_0024:  brtrue.s   IL_0028

      IL_0026:  br.s       IL_002a

      IL_0028:  br.s       IL_0069

//000228:                 then shift := rand.NextDouble()
      IL_002a:  ldarg.0
      IL_002b:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> Raytracer_FSharp/'hueShift@225-1'::shift
      IL_0030:  ldarg.0
      IL_0031:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'hueShift@225-1'::this
      IL_0036:  ldfld      class [mscorlib]System.Random Raytracer_FSharp/RayTracer::rand
      IL_003b:  callvirt   instance float64 [mscorlib]System.Random::NextDouble()
      IL_0040:  call       void [FSharp.Core]Microsoft.FSharp.Core.Operators::op_ColonEquals<float64>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0>,
                                                                                                      !!0)
      IL_0045:  nop
//000229:                      numToHueShiftLookup.Add(id,!shift)
      IL_0046:  ldarg.0
      IL_0047:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'hueShift@225-1'::this
      IL_004c:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Raytracer_FSharp/RayTracer::numToHueShiftLookup
      IL_0051:  ldarg.0
      IL_0052:  ldfld      int32 Raytracer_FSharp/'hueShift@225-1'::id
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> Raytracer_FSharp/'hueShift@225-1'::shift
      IL_005d:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::op_Dereference<float64>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0>)
      IL_0062:  callvirt   instance void class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::Add(!0,
                                                                                                                     !1)
      IL_0067:  ldnull
      IL_0068:  ret

//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0069:  ldnull
      IL_006a:  ret
    } // end of method 'hueShift@225-1'::Invoke

  } // end of class 'hueShift@225-1'

  .class auto ansi serializable nested assembly beforefieldinit hueShift@224
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>
  {
    .field public class Raytracer_FSharp/RayTracer this
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/hueShift@224::this
      IL_000d:  ret
    } // end of method hueShift@224::.ctor

    .method public strict virtual instance float64 
            Invoke(int32 id) cil managed
    {
      // Code size       92 (0x5c)
      .maxstack  7
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64> shift,
               [1] class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> V_1,
               [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_2,
               [3] bool V_3,
               [4] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_4)
//000224:             let shift = ref 0.0
      IL_0000:  nop
      IL_0001:  ldc.r8     0.0
      IL_000a:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::Ref<float64>(!!0)
      IL_000f:  stloc.0
//000225:             lock numToHueShiftLookup (fun () -> 
      IL_0010:  ldarg.0
      IL_0011:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/hueShift@224::this
      IL_0016:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Raytracer_FSharp/RayTracer::numToHueShiftLookup
      IL_001b:  stloc.1
      IL_001c:  ldarg.0
      IL_001d:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/hueShift@224::this
      IL_0022:  ldarg.1
      IL_0023:  ldloc.0
      IL_0024:  newobj     instance void Raytracer_FSharp/'hueShift@225-1'::.ctor(class Raytracer_FSharp/RayTracer,
                                                                                  int32,
                                                                                  class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<float64>)
      IL_0029:  stloc.2
      IL_002a:  ldc.i4.0
      IL_002b:  stloc.3
      .try
      {
        IL_002c:  ldloc.1
        IL_002d:  ldloca.s   V_3
        IL_002f:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                            bool&)
        IL_0034:  ldloc.2
        IL_0035:  ldnull
        IL_0036:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
        IL_003b:  stloc.s    V_4
        IL_003d:  leave.s    IL_0052

      }  // end .try
      finally
      {
        IL_003f:  ldloc.3
        IL_0040:  brfalse.s  IL_0044

        IL_0042:  br.s       IL_0046

        IL_0044:  br.s       IL_004f

//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
        IL_0046:  ldloc.1
        IL_0047:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
        IL_004c:  ldnull
        IL_004d:  pop
        IL_004e:  endfinally
        IL_004f:  ldnull
        IL_0050:  pop
        IL_0051:  endfinally
      }  // end handler
      IL_0052:  ldloc.s    V_4
      IL_0054:  pop
//000231:             !shift
      IL_0055:  ldloc.0
      IL_0056:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::op_Dereference<float64>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<!!0>)
      IL_005b:  ret
    } // end of method hueShift@224::Invoke

  } // end of class hueShift@224

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname RenderParallelShowingThreads@233
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> hueShift
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> id
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> hueShift,
                                 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> id) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> Raytracer_FSharp/RenderParallelShowingThreads@233::hueShift
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Raytracer_FSharp/RenderParallelShowingThreads@233::id
      IL_000e:  ldarg.0
      IL_000f:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0014:  ret
    } // end of method RenderParallelShowingThreads@233::.ctor

    .method assembly instance float64  Invoke() cil managed
    {
      // Code size       29 (0x1d)
      .maxstack  6
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64> Raytracer_FSharp/RenderParallelShowingThreads@233::hueShift
      IL_0007:  ldarg.0
      IL_0008:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Raytracer_FSharp/RenderParallelShowingThreads@233::id
      IL_000d:  ldflda     !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>::contents@
      IL_0012:  call       int32 [mscorlib]System.Threading.Interlocked::Increment(int32&)
      IL_0017:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::Invoke(!0)
      IL_001c:  ret
    } // end of method RenderParallelShowingThreads@233::Invoke

  } // end of class RenderParallelShowingThreads@233

  .class auto autochar sealed nested assembly beforefieldinit specialname 'RenderParallelShowingThreads@233-1'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class Raytracer_FSharp/RayTracer this
    .field public class Raytracer_FSharp/Scene scene
    .field public int32[] rgb
    .method public specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this,
                                 class Raytracer_FSharp/Scene scene,
                                 int32[] rgb) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::this
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class Raytracer_FSharp/Scene Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::scene
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32[] Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::rgb
      IL_0015:  ldarg.0
      IL_0016:  call       instance void [mscorlib]System.Object::.ctor()
      IL_001b:  ret
    } // end of method 'RenderParallelShowingThreads@233-1'::.ctor

    .method assembly instance float64  Invoke(int32 arg1,
                                              class [mscorlib]System.Threading.Tasks.ParallelLoopState arg2,
                                              float64 arg3) cil managed
    {
      // Code size       191 (0xbf)
      .maxstack  9
      .locals init ([0] int32 stride,
               [1] int32 V_1,
               [2] int32 x,
               [3] class Raytracer_FSharp/Color color,
               [4] class Raytracer_FSharp/RayTracer V_4,
               [5] class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32> V_5,
               [6] class Raytracer_FSharp/Ray V_6,
               [7] class Raytracer_FSharp/Scene V_7,
               [8] int32 V_8,
               [9] int32 intColor)
//000234:             let stride = y * screenWidth
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::this
      IL_0008:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_000d:  mul
      IL_000e:  stloc.0
//000235:             for x = 0 to screenWidth - 1 do 
      IL_000f:  ldc.i4.0
      IL_0010:  stloc.2
      IL_0011:  ldarg.0
      IL_0012:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::this
      IL_0017:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_001c:  ldc.i4.1
      IL_001d:  sub
      IL_001e:  stloc.1
      IL_001f:  ldloc.1
      IL_0020:  ldloc.2
      IL_0021:  blt        IL_00bd

//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
      IL_0026:  ldarg.0
      IL_0027:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::this
      IL_002c:  stloc.s    V_4
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::scene
      IL_0034:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0039:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/Camera::get_Pos()
      IL_003e:  ldarg.0
      IL_003f:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::this
      IL_0044:  ldloc.2
      IL_0045:  ldarg.1
      IL_0046:  ldarg.0
      IL_0047:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::scene
      IL_004c:  ldfld      class Raytracer_FSharp/Camera Raytracer_FSharp/Scene::Camera@
      IL_0051:  call       instance class Raytracer_FSharp/Vector Raytracer_FSharp/RayTracer::GetPoint(int32,
                                                                                                       int32,
                                                                                                       class Raytracer_FSharp/Camera)
      IL_0056:  newobj     instance void Raytracer_FSharp/Ray::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Vector)
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::scene
      IL_0061:  ldc.i4.0
      IL_0062:  newobj     instance void class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::.ctor(!0,
                                                                                                                                              !1,
                                                                                                                                              !2)
      IL_0067:  stloc.s    V_5
      IL_0069:  ldloc.s    V_5
      IL_006b:  call       instance !0 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item1()
      IL_0070:  stloc.s    V_6
      IL_0072:  ldloc.s    V_5
      IL_0074:  call       instance !1 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item2()
      IL_0079:  stloc.s    V_7
      IL_007b:  ldloc.s    V_5
      IL_007d:  call       instance !2 class [mscorlib]System.Tuple`3<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene,int32>::get_Item3()
      IL_0082:  stloc.s    V_8
      IL_0084:  ldloc.s    V_4
      IL_0086:  ldloc.s    V_6
      IL_0088:  ldloc.s    V_7
      IL_008a:  ldloc.s    V_8
      IL_008c:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/RayTracer::TraceRay(class Raytracer_FSharp/Ray,
                                                                                                      class Raytracer_FSharp/Scene,
                                                                                                      int32)
      IL_0091:  stloc.3
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
      IL_0092:  ldloc.3
      IL_0093:  ldarg.3
      IL_0094:  call       instance class Raytracer_FSharp/Color Raytracer_FSharp/Color::ShiftHue(float64)
      IL_0099:  call       instance int32 Raytracer_FSharp/Color::ToInt()
      IL_009e:  stloc.s    intColor
//000238:                 rgb.[x + stride] <- intColor
      IL_00a0:  ldarg.0
      IL_00a1:  ldfld      int32[] Raytracer_FSharp/'RenderParallelShowingThreads@233-1'::rgb
      IL_00a6:  ldloc.2
      IL_00a7:  ldloc.0
      IL_00a8:  add
      IL_00a9:  ldloc.s    intColor
      IL_00ab:  stelem     [mscorlib]System.Int32
      IL_00b0:  ldloc.2
      IL_00b1:  ldc.i4.1
      IL_00b2:  add
      IL_00b3:  stloc.2
//000235:             for x = 0 to screenWidth - 1 do 
      IL_00b4:  ldloc.2
      IL_00b5:  ldloc.1
      IL_00b6:  ldc.i4.1
      IL_00b7:  add
      IL_00b8:  bne.un     IL_0026

//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
      IL_00bd:  ldarg.3
      IL_00be:  ret
    } // end of method 'RenderParallelShowingThreads@233-1'::Invoke

  } // end of class 'RenderParallelShowingThreads@233-1'

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname 'RenderParallelShowingThreads@240-2'
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> id
    .method public specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> id) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Raytracer_FSharp/'RenderParallelShowingThreads@240-2'::id
      IL_0007:  ldarg.0
      IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
      IL_000d:  ret
    } // end of method 'RenderParallelShowingThreads@240-2'::.ctor

    .method assembly instance void  Invoke(float64 obj) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  5
      .locals init ([0] int32 V_0,
               [1] int32 V_1)
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32> Raytracer_FSharp/'RenderParallelShowingThreads@240-2'::id
      IL_0007:  ldflda     !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpRef`1<int32>::contents@
      IL_000c:  call       int32 [mscorlib]System.Threading.Interlocked::Decrement(int32&)
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  stloc.1
      IL_0014:  ret
    } // end of method 'RenderParallelShowingThreads@240-2'::Invoke

  } // end of class 'RenderParallelShowingThreads@240-2'

  .class auto ansi serializable nested assembly beforefieldinit clo@146
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/Intersection,float64>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/Intersection,float64>::.ctor()
      IL_0006:  ret
    } // end of method clo@146::.ctor

    .method public strict virtual instance float64 
            Invoke(class Raytracer_FSharp/Intersection inter) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000146:         |> List.sortBy (fun inter-> inter.Dist)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldfld      float64 Raytracer_FSharp/Intersection::Dist@
      IL_0007:  ret
    } // end of method clo@146::Invoke

  } // end of class clo@146

  .class auto ansi serializable nested assembly beforefieldinit 'clo@145-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/SceneObject,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection>>
  {
    .field public class Raytracer_FSharp/Ray ray
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/Ray ray) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class Raytracer_FSharp/SceneObject,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/Ray Raytracer_FSharp/'clo@145-1'::ray
      IL_000d:  ret
    } // end of method 'clo@145-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection> 
            Invoke(class Raytracer_FSharp/SceneObject obj) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  6
//000145:         |> List.choose (fun obj -> obj.Intersect(ray))
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Raytracer_FSharp/Ray Raytracer_FSharp/'clo@145-1'::ray
      IL_0008:  callvirt   instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class Raytracer_FSharp/Intersection> Raytracer_FSharp/SceneObject::Intersect(class Raytracer_FSharp/Ray)
      IL_000d:  ret
    } // end of method 'clo@145-1'::Invoke

  } // end of class 'clo@145-1'

  .class auto ansi serializable nested assembly beforefieldinit addLight@175
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<class Raytracer_FSharp/Color,class Raytracer_FSharp/Light,class Raytracer_FSharp/Color>
  {
    .field public class Raytracer_FSharp/RayTracer this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Raytracer_FSharp/SceneObject thing
    .field public class Raytracer_FSharp/Scene scene
    .field public class Raytracer_FSharp/Vector rd
    .field public class Raytracer_FSharp/Vector pos
    .field public class Raytracer_FSharp/Vector norm
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this,
                                 class Raytracer_FSharp/SceneObject thing,
                                 class Raytracer_FSharp/Scene scene,
                                 class Raytracer_FSharp/Vector rd,
                                 class Raytracer_FSharp/Vector pos,
                                 class Raytracer_FSharp/Vector norm) cil managed
    {
      // Code size       52 (0x34)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<class Raytracer_FSharp/Color,class Raytracer_FSharp/Light,class Raytracer_FSharp/Color>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/addLight@175::this
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/addLight@175::thing
      IL_0014:  ldarg.0
      IL_0015:  ldarg.3
      IL_0016:  stfld      class Raytracer_FSharp/Scene Raytracer_FSharp/addLight@175::scene
      IL_001b:  ldarg.0
      IL_001c:  ldarg.s    rd
      IL_001e:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::rd
      IL_0023:  ldarg.0
      IL_0024:  ldarg.s    pos
      IL_0026:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::pos
      IL_002b:  ldarg.0
      IL_002c:  ldarg.s    norm
      IL_002e:  stfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::norm
      IL_0033:  ret
    } // end of method addLight@175::.ctor

    .method public strict virtual instance class Raytracer_FSharp/Color 
            Invoke(class Raytracer_FSharp/Color col,
                   class Raytracer_FSharp/Light light) cil managed
    {
      // Code size       392 (0x188)
      .maxstack  7
      .locals init ([0] class Raytracer_FSharp/Vector ldis,
               [1] class Raytracer_FSharp/Vector V_1,
               [2] class Raytracer_FSharp/Vector V_2,
               [3] class Raytracer_FSharp/Vector livec,
               [4] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64> neatIsect,
               [5] class Raytracer_FSharp/RayTracer V_5,
               [6] class [mscorlib]System.Tuple`2<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene> V_6,
               [7] class Raytracer_FSharp/Ray V_7,
               [8] class Raytracer_FSharp/Scene V_8,
               [9] bool isInShadow,
               [10] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64> V_10,
               [11] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64> V_11,
               [12] float64 d,
               [13] float64 illum,
               [14] class Raytracer_FSharp/Color lcolor,
               [15] float64 specular,
               [16] class Raytracer_FSharp/Color scolor,
               [17] class Raytracer_FSharp/Color V_17,
               [18] class Raytracer_FSharp/Color V_18,
               [19] class Raytracer_FSharp/Color V_19,
               [20] class Raytracer_FSharp/Color V_20,
               [21] class Raytracer_FSharp/Color V_21,
               [22] class Raytracer_FSharp/Color V_22,
               [23] class Raytracer_FSharp/Color V_23,
               [24] class Raytracer_FSharp/Color V_24)
//000146:         |> List.sortBy (fun inter-> inter.Dist)
//000147:         
//000148:     let TestRay (ray, scene)=
//000149:         match Intersections ray scene with
//000150:         | [] -> None
//000151:         | isect::_ -> Some isect.Dist
//000152:         
//000153:     let rec TraceRay (ray,scene,depth : int) = 
//000154:         match Intersections ray scene with
//000155:         | [] -> Color.Background
//000156:         | isect::_ -> Shade isect  scene  depth
//000157:     
//000158:     and Shade isect scene depth = 
//000159:         let d = isect.Ray.Dir
//000160:         let pos = isect.Dist * d + isect.Ray.Start
//000161:         let normal = isect.Thing.Normal(pos)
//000162:         let reflectDir = d - 2.0 * Vector.Dot(normal, d) * normal
//000163:         let naturalcolor = Color.DefaultColor +
//000164:                            GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene)
//000165:         let reflectedColor = if depth >= maxDepth
//000166:                              then Color(0.5,0.5,0.5)
//000167:                              else GetReflectionColor(isect.Thing, pos + (0.001*reflectDir), normal, reflectDir, scene, depth)
//000168:         naturalcolor + reflectedColor
//000169: 
//000170:     and GetReflectionColor (thing : SceneObject ,pos,normal : Vector,rd : Vector,scene : Scene, depth : int) = 
//000171:         Color.Scale(thing.Surface.Reflect(pos), TraceRay ( { Start = pos; Dir = rd }, scene, depth + 1))
//000172:     
//000173:     and GetNaturalColor (thing, pos, norm, rd, scene) =
//000174:         let addLight col (light : Light) = 
//000175:             let ldis = light.Pos - pos
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/Light::Pos@
      IL_0007:  stloc.1
      IL_0008:  ldarg.0
      IL_0009:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::pos
      IL_000e:  stloc.2
      IL_000f:  ldloc.1
      IL_0010:  ldloc.2
      IL_0011:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::op_Subtraction(class Raytracer_FSharp/Vector,
                                                                                                 class Raytracer_FSharp/Vector)
      IL_0016:  stloc.0
//000176:             let livec = Vector.Norm(ldis)
      IL_0017:  ldloc.0
      IL_0018:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_001d:  stloc.3
//000177:             let neatIsect = TestRay({Start = pos; Dir = livec}, scene)
      IL_001e:  ldarg.0
      IL_001f:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/addLight@175::this
      IL_0024:  stloc.s    V_5
      IL_0026:  ldarg.0
      IL_0027:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::pos
      IL_002c:  ldloc.3
      IL_002d:  newobj     instance void Raytracer_FSharp/Ray::.ctor(class Raytracer_FSharp/Vector,
                                                                     class Raytracer_FSharp/Vector)
      IL_0032:  ldarg.0
      IL_0033:  ldfld      class Raytracer_FSharp/Scene Raytracer_FSharp/addLight@175::scene
      IL_0038:  newobj     instance void class [mscorlib]System.Tuple`2<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene>::.ctor(!0,
                                                                                                                                        !1)
      IL_003d:  stloc.s    V_6
      IL_003f:  ldloc.s    V_6
      IL_0041:  call       instance !0 class [mscorlib]System.Tuple`2<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene>::get_Item1()
      IL_0046:  stloc.s    V_7
      IL_0048:  ldloc.s    V_6
      IL_004a:  call       instance !1 class [mscorlib]System.Tuple`2<class Raytracer_FSharp/Ray,class Raytracer_FSharp/Scene>::get_Item2()
      IL_004f:  stloc.s    V_8
      IL_0051:  ldloc.s    V_5
      IL_0053:  ldloc.s    V_7
      IL_0055:  ldloc.s    V_8
      IL_0057:  call       instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64> Raytracer_FSharp/RayTracer::TestRay(class Raytracer_FSharp/Ray,
                                                                                                                                         class Raytracer_FSharp/Scene)
      IL_005c:  stloc.s    neatIsect
//000178:             let isInShadow = match neatIsect with 
      IL_005e:  nop
      IL_005f:  ldloc.s    neatIsect
      IL_0061:  stloc.s    V_10
      IL_0063:  ldloc.s    V_10
      IL_0065:  brfalse.s  IL_0069

      IL_0067:  br.s       IL_006d

//000179:                              | None -> false 
      IL_0069:  ldc.i4.0
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_006a:  nop
      IL_006b:  br.s       IL_0088

//000178:             let isInShadow = match neatIsect with 
      IL_006d:  ldloc.s    V_10
      IL_006f:  stloc.s    V_11
      IL_0071:  ldloc.s    V_11
      IL_0073:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<float64>::get_Value()
      IL_0078:  stloc.s    d
//000179:                              | None -> false 
//000180:                              | Some d -> not (d > Vector.Mag(ldis))
      IL_007a:  ldloc.s    d
      IL_007c:  ldloc.0
      IL_007d:  call       float64 Raytracer_FSharp/Vector::Mag(class Raytracer_FSharp/Vector)
      IL_0082:  cgt
      IL_0084:  ldc.i4.0
      IL_0085:  ceq
//000181:             if isInShadow
//000182:             then col
//000183:             else let illum = Vector.Dot(livec, norm)
//000184:                  let lcolor = if illum > 0.0
//000185:                               then Color.Scale(illum, light.Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0087:  nop
      IL_0088:  stloc.s    isInShadow
//000181:             if isInShadow
      IL_008a:  ldloc.s    isInShadow
      IL_008c:  brfalse.s  IL_0090

      IL_008e:  br.s       IL_0092

      IL_0090:  br.s       IL_0094

//000182:             then col
      IL_0092:  ldarg.1
      IL_0093:  ret

//000183:             else let illum = Vector.Dot(livec, norm)
      IL_0094:  ldloc.3
      IL_0095:  ldarg.0
      IL_0096:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::norm
      IL_009b:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_00a0:  stloc.s    illum
//000184:                  let lcolor = if illum > 0.0
      IL_00a2:  nop
      IL_00a3:  ldloc.s    illum
      IL_00a5:  ldc.r8     0.0
      IL_00ae:  cgt
      IL_00b0:  brfalse.s  IL_00b4

      IL_00b2:  br.s       IL_00b6

      IL_00b4:  br.s       IL_00c6

//000185:                               then Color.Scale(illum, light.Color)
      IL_00b6:  ldloc.s    illum
      IL_00b8:  ldarg.2
      IL_00b9:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_00be:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::Scale(float64,
                                                                                      class Raytracer_FSharp/Color)
//000186:                               else Color.DefaultColor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_00c3:  nop
      IL_00c4:  br.s       IL_00cc

//000186:                               else Color.DefaultColor
      IL_00c6:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_DefaultColor()
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
//000188:                  let scolor = if specular > 0.0 
//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_00cb:  nop
      IL_00cc:  stloc.s    lcolor
//000187:                  let specular = Vector.Dot(livec, Vector.Norm(rd))
      IL_00ce:  ldloc.3
      IL_00cf:  ldarg.0
      IL_00d0:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::rd
      IL_00d5:  call       class Raytracer_FSharp/Vector Raytracer_FSharp/Vector::Norm(class Raytracer_FSharp/Vector)
      IL_00da:  call       float64 Raytracer_FSharp/Vector::Dot(class Raytracer_FSharp/Vector,
                                                                class Raytracer_FSharp/Vector)
      IL_00df:  stloc.s    specular
//000188:                  let scolor = if specular > 0.0 
      IL_00e1:  nop
      IL_00e2:  ldloc.s    specular
      IL_00e4:  ldc.r8     0.0
      IL_00ed:  cgt
      IL_00ef:  brfalse.s  IL_00f3

      IL_00f1:  br.s       IL_00f5

      IL_00f3:  br.s       IL_011a

//000189:                               then Color.Scale(System.Math.Pow(specular, thing.Surface.Roughness), light.Color)
      IL_00f5:  ldloc.s    specular
      IL_00f7:  ldarg.0
      IL_00f8:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/addLight@175::thing
      IL_00fd:  callvirt   instance class Raytracer_FSharp/Surface Raytracer_FSharp/SceneObject::get_Surface()
      IL_0102:  callvirt   instance float64 Raytracer_FSharp/Surface::get_Roughness()
      IL_0107:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                              float64)
      IL_010c:  ldarg.2
      IL_010d:  ldfld      class Raytracer_FSharp/Color Raytracer_FSharp/Light::Color@
      IL_0112:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::Scale(float64,
                                                                                      class Raytracer_FSharp/Color)
//000190:                               else Color.DefaultColor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_0117:  nop
      IL_0118:  br.s       IL_0120

//000190:                               else Color.DefaultColor
      IL_011a:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::get_DefaultColor()
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
//000200:         Vector.Norm(camera.Forward + RecenterX(x) * camera.Right + RecenterY(y) * camera.Up)
//000201: 
//000202:     let rand = new Random()
//000203:     let numToHueShiftLookup = new System.Collections.Generic.Dictionary<int,double>()
//000204:                                                  
//000205:     member this.RenderSequential(scene, rgb : int[]) = 
//000206:         for y = 0 to  screenHeight - 1 do
//000207:             let stride = y * screenWidth
//000208:             for x = 0 to screenWidth - 1 do 
//000209:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000210:                 let intColor = color.ToInt ()
//000211:                 rgb.[x + stride] <- intColor
//000212:                 
//000213:     member this.RenderParallel(scene, rgb : int[], options) = 
//000214:         Parallel.For(0, screenHeight, options, fun y -> 
//000215:             let stride = y * screenWidth
//000216:             for x = 0 to screenWidth - 1 do 
//000217:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000218:                 let intColor = color.ToInt ()
//000219:                 rgb.[x + stride] <- intColor)
//000220:         |> ignore
//000221: 
//000222:     member this.RenderParallelShowingThreads(scene, rgb : int[], options) = 
//000223:         let hueShift id = 
//000224:             let shift = ref 0.0
//000225:             lock numToHueShiftLookup (fun () -> 
//000226:                 let exists = numToHueShiftLookup.TryGetValue(id, shift)
//000227:                 if not exists 
//000228:                 then shift := rand.NextDouble()
//000229:                      numToHueShiftLookup.Add(id,!shift)
//000230:             )
//000231:             !shift
//000232:         let id = ref 0
//000233:         Parallel.For(0, screenHeight, options, Func<float>(fun () -> hueShift(Interlocked.Increment(id))), (fun y state hue -> 
//000234:             let stride = y * screenWidth
//000235:             for x = 0 to screenWidth - 1 do 
//000236:                 let color = TraceRay ({Start = scene.Camera.Pos; Dir = GetPoint x y scene.Camera }, scene, 0)
//000237:                 let intColor = color.ShiftHue(hue).ToInt()
//000238:                 rgb.[x + stride] <- intColor
//000239:             hue),
//000240:             Action<float>(fun hue -> 
//000241:                 Interlocked.Decrement(id) 
//000242:                 |> ignore))
//000243:         |> ignore
      IL_011f:  nop
      IL_0120:  stloc.s    scolor
//000191:                  col + thing.Surface.Diffuse(pos) * lcolor +
      IL_0122:  ldarg.1
      IL_0123:  stloc.s    V_18
      IL_0125:  ldarg.0
      IL_0126:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/addLight@175::thing
      IL_012b:  callvirt   instance class Raytracer_FSharp/Surface Raytracer_FSharp/SceneObject::get_Surface()
      IL_0130:  ldarg.0
      IL_0131:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::pos
      IL_0136:  callvirt   instance class Raytracer_FSharp/Color Raytracer_FSharp/Surface::Diffuse(class Raytracer_FSharp/Vector)
      IL_013b:  stloc.s    V_20
      IL_013d:  ldloc.s    lcolor
      IL_013f:  stloc.s    V_21
      IL_0141:  ldloc.s    V_20
      IL_0143:  ldloc.s    V_21
      IL_0145:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Multiply(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_014a:  stloc.s    V_19
      IL_014c:  ldloc.s    V_18
      IL_014e:  ldloc.s    V_19
      IL_0150:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Addition(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_0155:  stloc.s    V_17
      IL_0157:  ldarg.0
      IL_0158:  ldfld      class Raytracer_FSharp/SceneObject Raytracer_FSharp/addLight@175::thing
      IL_015d:  callvirt   instance class Raytracer_FSharp/Surface Raytracer_FSharp/SceneObject::get_Surface()
      IL_0162:  ldarg.0
      IL_0163:  ldfld      class Raytracer_FSharp/Vector Raytracer_FSharp/addLight@175::pos
      IL_0168:  callvirt   instance class Raytracer_FSharp/Color Raytracer_FSharp/Surface::Specular(class Raytracer_FSharp/Vector)
      IL_016d:  stloc.s    V_23
      IL_016f:  ldloc.s    scolor
      IL_0171:  stloc.s    V_24
      IL_0173:  ldloc.s    V_23
      IL_0175:  ldloc.s    V_24
      IL_0177:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Multiply(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_017c:  stloc.s    V_22
      IL_017e:  ldloc.s    V_17
      IL_0180:  ldloc.s    V_22
      IL_0182:  call       class Raytracer_FSharp/Color Raytracer_FSharp/Color::op_Addition(class Raytracer_FSharp/Color,
                                                                                            class Raytracer_FSharp/Color)
      IL_0187:  ret
    } // end of method addLight@175::Invoke

  } // end of class addLight@175

  .class auto ansi serializable nested assembly beforefieldinit RecenterX@198
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>
  {
    .field public class Raytracer_FSharp/RayTracer this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterX@198::this
      IL_000d:  ret
    } // end of method RecenterX@198::.ctor

    .method public strict virtual instance float64 
            Invoke(int32 x) cil managed
    {
      // Code size       50 (0x32)
      .maxstack  7
//000192:                        thing.Surface.Specular(pos) * scolor
//000193:         List.fold addLight
//000194:                        Color.DefaultColor
//000195:                        scene.Lights
//000196:     
//000197:     let GetPoint x y (camera:Camera) =
//000198:         let RecenterX x =  (float x - (float screenWidth / 2.0))  / (2.0 * float screenWidth)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  conv.r8
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterX@198::this
      IL_0009:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_000e:  conv.r8
      IL_000f:  ldc.r8     2.
      IL_0018:  div
      IL_0019:  sub
      IL_001a:  ldc.r8     2.
      IL_0023:  ldarg.0
      IL_0024:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterX@198::this
      IL_0029:  ldfld      int32 Raytracer_FSharp/RayTracer::screenWidth
      IL_002e:  conv.r8
      IL_002f:  mul
      IL_0030:  div
      IL_0031:  ret
    } // end of method RecenterX@198::Invoke

  } // end of class RecenterX@198

  .class auto ansi serializable nested assembly beforefieldinit RecenterY@199
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>
  {
    .field public class Raytracer_FSharp/RayTracer this
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class Raytracer_FSharp/RayTracer this) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,float64>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterY@199::this
      IL_000d:  ret
    } // end of method RecenterY@199::.ctor

    .method public strict virtual instance float64 
            Invoke(int32 y) cil managed
    {
      // Code size       51 (0x33)
      .maxstack  7
//000199:         let RecenterY y = -(float y - (float screenHeight / 2.0)) / (2.0 * float screenHeight)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  conv.r8
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterY@199::this
      IL_0009:  ldfld      int32 Raytracer_FSharp/RayTracer::screenHeight
      IL_000e:  conv.r8
      IL_000f:  ldc.r8     2.
      IL_0018:  div
      IL_0019:  sub
      IL_001a:  neg
      IL_001b:  ldc.r8     2.
      IL_0024:  ldarg.0
      IL_0025:  ldfld      class Raytracer_FSharp/RayTracer Raytracer_FSharp/RecenterY@199::this
      IL_002a:  ldfld      int32 Raytracer_FSharp/RayTracer::screenHeight
      IL_002f:  conv.r8
      IL_0030:  mul
      IL_0031:  div
      IL_0032:  ret
    } // end of method RecenterY@199::Invoke

  } // end of class RecenterY@199

  .method public static class Raytracer_FSharp/SceneObject 
          Sphere(class Raytracer_FSharp/Vector center,
                 float64 radius,
                 class Raytracer_FSharp/Surface surface) cil managed
  {
    // Code size       14 (0xe)
    .maxstack  5
    .locals init ([0] float64 radius2)
//000089:     let radius2 = radius * radius
    IL_0000:  nop
    IL_0001:  ldarg.1
    IL_0002:  ldarg.1
    IL_0003:  mul
    IL_0004:  stloc.0
//000090:     { new SceneObject with 
    IL_0005:  ldarg.2
    IL_0006:  ldarg.0
    IL_0007:  ldloc.0
    IL_0008:  newobj     instance void Raytracer_FSharp/Sphere@90::.ctor(class Raytracer_FSharp/Surface,
                                                                         class Raytracer_FSharp/Vector,
                                                                         float64)
    IL_000d:  ret
  } // end of method Raytracer_FSharp::Sphere

  .method public static class Raytracer_FSharp/SceneObject 
          Plane(class Raytracer_FSharp/Vector norm,
                float64 offset,
                class Raytracer_FSharp/Surface surface) cil managed
  {
    // Code size       10 (0xa)
    .maxstack  5
//000091:         member this.Surface = surface
//000092:         member this.Normal pos = Vector.Norm(pos - center)
//000093:         member this.Intersect (ray : Ray)  =
//000094:             let eo = center - ray.Start
//000095:             let v = Vector.Dot(eo, ray.Dir)
//000096:             let dist = 
//000097:                 if (v<0.0) 
//000098:                 then 0.0
//000099:                 else let disc = radius2 - (Vector.Dot(eo,eo) - (v*v))
//000100:                      if disc < 0.0
//000101:                      then 0.0
//000102:                      else v - (sqrt(disc))
//000103:             if dist = 0.0 
//000104:             then None
//000105:             else Some {Thing = this; Ray = ray; Dist = dist} 
//000106:     }
//000107: 
//000108: let Plane(norm, offset, surface) =           
//000109:     { new SceneObject with
    IL_0000:  nop
    IL_0001:  ldarg.2
    IL_0002:  ldarg.1
    IL_0003:  ldarg.0
    IL_0004:  newobj     instance void Raytracer_FSharp/Plane@109::.ctor(class Raytracer_FSharp/Surface,
                                                                         float64,
                                                                         class Raytracer_FSharp/Vector)
    IL_0009:  ret
  } // end of method Raytracer_FSharp::Plane

} // end of class Raytracer_FSharp

.class private abstract auto ansi sealed '<StartupCode$Raytracer_FSharp>'.$Raytracer_FSharp
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Raytracer_FSharp>'.$Raytracer_FSharp

.class private abstract auto ansi sealed '<StartupCode$Raytracer_FSharp>.$.NETFramework,Version=v4.0'.AssemblyAttributes
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Raytracer_FSharp>.$.NETFramework,Version=v4.0'.AssemblyAttributes


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
