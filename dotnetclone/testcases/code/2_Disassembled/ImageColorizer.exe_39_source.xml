<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="30" endline="192"><![CDATA[
         Public Function Colorize(ByVal original As Bitmap, ByVal selectedPixels As List(Of Point), ByVal epsilon As Integer,
             ByVal paths As List(Of GraphicsPath), ByVal parallel As Boolean) As Bitmap
             ' Create a new bitmap with the same size as the original.
             Dim width = original.Width
             Dim height = original.Height
             Dim colorizedImage As New Bitmap(width, height)
 
             ' Optimization
             ' ruling out pixels that are definitely not containing within the selected region.
             Dim pathsBounds() As Rectangle = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 pathsBounds = New Rectangle(paths.Count - 1) {}
                 For i = 0 To pathsBounds.Length - 1
                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
                 Next i
             End If
 
             ' Optimization
             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             ' with rectangles which can be hit tested against instead of the paths.  Not quite
             ' as accurate, but much faster.
             Dim compositions As List(Of RectangleF()) = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 compositions = New List(Of RectangleF())(paths.Count)
                 Using m As New Matrix()
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             Dim width = original.Width
             Dim height = original.Height
             Dim colorizedImage As New Bitmap(width, height)
 
             ' Optimization
             ' ruling out pixels that are definitely not containing within the selected region.
             Dim pathsBounds() As Rectangle = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 pathsBounds = New Rectangle(paths.Count - 1) {}
                 For i = 0 To pathsBounds.Length - 1
                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
                 Next i
             End If
 
             ' Optimization
             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             ' with rectangles which can be hit tested against instead of the paths.  Not quite
             ' as accurate, but much faster.
             Dim compositions As List(Of RectangleF()) = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 compositions = New List(Of RectangleF())(paths.Count)
                 Using m As New Matrix()
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 pathsBounds = New Rectangle(paths.Count - 1) {}
                 For i = 0 To pathsBounds.Length - 1
                     pathsBounds(i) = Rectangle.Ceiling(paths(i).GetBounds())
                 Next i
             End If
 
             ' Optimization
             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             ' with rectangles which can be hit tested against instead of the paths.  Not quite
             ' as accurate, but much faster.
             Dim compositions As List(Of RectangleF()) = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 compositions = New List(Of RectangleF())(paths.Count)
                 Using m As New Matrix()
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             End If
 
             ' Optimization
             ' against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             ' with rectangles which can be hit tested against instead of the paths.  Not quite
             ' as accurate, but much faster.
             Dim compositions As List(Of RectangleF()) = Nothing
             If paths IsNot Nothing AndAlso paths.Count > 0 Then
                 compositions = New List(Of RectangleF())(paths.Count)
                 Using m As New Matrix()
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 compositions = New List(Of RectangleF())(paths.Count)
                 Using m As New Matrix()
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     For i = 0 To paths.Count - 1
                         Using r As New Region(paths(i))
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                             compositions.Add(r.GetRegionScans(m))
                         End Using
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     Next i
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 End Using
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             End If
 
             ' Use FastBitmap instances to provide unsafe/faster access to the pixels
             ' in the original and in the new images.
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             Using fastColorizedImage As New FastBitmap(colorizedImage)
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Using fastOriginalImage As New FastBitmap(original)
                     ' Extract the selected hues from the selected pixels.
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     Dim selectedHues As New List(Of Single)(selectedPixels.Count)
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     For Each p In selectedPixels
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                         selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue())
                     Next p
 
                     ' For progress update purposes, figure out how many pixels there
                     ' are in total, and how many constitute 1% so that we can raise
                     ' events after every additional 1% has been completed.
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     Dim totalPixels = height * width
                     Dim pixelsPerProgressUpdate = totalPixels \ 100
                     If pixelsPerProgressUpdate = 0 Then
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                         pixelsPerProgressUpdate = 1
                     End If
                     Dim pixelsProcessed = 0
 
                     ' Pixels close to the selected hue but not close enough may be
                     ' left partially desaturated.  The saturation window determines
                     ' what pixels fall into that range.
                     Const maxSaturationWindow = 10
                     Dim saturationWindow = Math.Min(maxSaturationWindow, epsilon)
 
                     ' Separated out the body of the loop just to make it easier
                     ' to switch between sequential and parallel for demo purposes.
                     Dim processRow As Action(Of Integer) = Sub(y)
                                                                For x = 0 To width - 1
                                                                    ' Get the color/hue of th epixel.
                                                                    Dim c = fastOriginalImage.GetColor(x, y)
                                                                    Dim pixelHue = c.GetHue()
 
                                                                    ' Use hit-testing to determine if the pixel is in the selected region.
                                                                    Dim pixelInSelectedRegion = False
 
                                                                    ' First, if there are no paths, by definition it is in the selected
                                                                    ' region, since the whole image is then selected.
                                                                    If paths Is Nothing OrElse paths.Count = 0 Then
                                                                        pixelInSelectedRegion = True
                                                                    Else
                                                                        ' For each path, first see if the pixel is within the bounding
                                                                        ' rectangle; if it's not, it's not in the selected region.
                                                                        Dim p As New Point(x, y)
                                                                        Dim i = 0
                                                                        Do While i < pathsBounds.Length AndAlso Not pixelInSelectedRegion
                                                                            If pathsBounds(i).Contains(p) Then
                                                                                ' The pixel is within a bounding rectangle, so now
                                                                                ' see if it's within the composition rectangles
                                                                                ' approximating the region.
                                                                                For Each bound In compositions(i)
                                                                                    If bound.Contains(x, y) Then
                                                                                        ' If it is, it's in the region.
                                                                                        pixelInSelectedRegion = True
                                                                                        Exit For
                                                                                    End If
                                                                                Next bound
                                                                            End If
                                                                            i += 1
                                                                        Loop
                                                                    End If
 
                                                                    ' Now that we know whether a pixel is in the region,
                                                                    ' we can figure out what to do with it.  If the pixel
                                                                    ' is not in the selected region, it needs to be converted
                                                                    ' to grayscale.
                                                                    Dim useGrayscale = True
                                                                    If pixelInSelectedRegion Then
                                                                        ' If it is in the selected region, get the color hue's distance 
                                                                        ' from each target hue.  If that distance is less than the user-selected
                                                                        ' hue variation limit, leave it in color.  If it's greater than the
                                                                        ' variation limit, but within the saturation window of the limit,
                                                                        ' desaturate it proportionally to the distance from the limit.
                                                                        For Each selectedHue In selectedHues
                                                                            ' A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                                                            ' will be two distances between them, depending on which way you go around
                                                                            ' the wheel from one to the other (unless they're exactly opposite from
                                                                            ' each other on the wheel, the two distances will be different).  We always
                                                                            ' want to do our work based on the smaller of the two distances (e.g. a hue
                                                                            ' with the value 359 is very, very close to a hue with the value 1).  So,
                                                                            ' we take the absolute value of the difference between the two hues.  If that
                                                                            ' distance is 180 degrees, then both distances are the same, so it doesn't
                                                                            ' matter which we go with. If that difference is less than 180 degrees, 
                                                                            ' we know this must be the smaller of the two distances, since the sum of the 
                                                                            ' two distances must add up to 360.  If, however, it's larger than 180, it's the
                                                                            ' longer distance, so to get the shorter one, we have to subtract it from 360.
                                                                            Dim distance = Math.Abs(pixelHue - selectedHue)
                                                                            If distance > 180 Then
                                                                                distance = 360 - distance
                                                                            End If
 
                                                                            If distance <= epsilon Then
                                                                                useGrayscale = False
                                                                                Exit For
                                                                            ElseIf (distance - epsilon) / saturationWindow < 1.0F Then
                                                                                useGrayscale = False
                                                                                c = ColorFromHsb(pixelHue, c.GetSaturation() * (1.0F - ((distance - epsilon) / maxSaturationWindow)),
                                                                                         c.GetBrightness())
                                                                                Exit For
                                                                            End If
                                                                        Next selectedHue
                                                                    End If
 
                                                                    ' Set the pixel color into the new image.
                                                                    If useGrayscale Then
                                                                        c = ToGrayscale(c)
                                                                    End If
                                                                    fastColorizedImage.SetColor(x, y, c)
                                                                Next x
 
                                                                ' Notify any listeners of our progress, if enough progress has been made.
                                                                Interlocked.Add(pixelsProcessed, width)
                                                                OnProgressChanged(CInt(Fix(100 * pixelsProcessed / CDbl(totalPixels))))
                                                            End Sub
 
                     ' Copy over every single pixel, and possibly transform it in the process.
                     If parallel Then
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                         System.Threading.Tasks.Parallel.For(0, height, processRow)
                     Else
                         For y = 0 To height - 1
                             processRow(y)
                         Next y
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                     End If
                 End Using
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             End Using
 
             ' We're done creating the image.  Return it.
             Return colorizedImage
         End Function
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             Return colorizedImage
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="193" endline="198"><![CDATA[
 
         ''' <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         ''' <param name="progressPercentage">The progress percentage.</param>
         Private Sub OnProgressChanged(ByVal progressPercentage As Integer)
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
             RaiseEvent ProgressChanged(Me, New ProgressChangedEventArgs(progressPercentage, Nothing))
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="199" endline="206"><![CDATA[
 
         ''' <summary>Converts a color to grayscale.</summary>
         ''' <param name="c">The color to convert.</param>
         ''' <returns>The grayscale color.</returns>
         Private Shared Function ToGrayscale(ByVal c As Color) As Color
             Dim luminance = CInt(Fix(0.299 * c.R + 0.587 * c.G + 0.114 * c.B))
             Return Color.FromArgb(luminance, luminance, luminance)
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="207" endline="273"><![CDATA[
 
         ''' <summary>HSB to RGB color conversion.</summary>
         ''' <param name="h">The color's hue.</param>
         ''' <param name="s">The color's saturation.</param>
         ''' <param name="b">The color's brightness.</param>
         ''' <returns>The RGB color for the supplied HSB values.</returns>
         ''' <remarks>
         ''' Based on Chris Jackson's conversion routine from
         ''' http
         ''' </remarks>
         Private Shared Function ColorFromHsb(ByVal h As Single, ByVal s As Single, ByVal b As Single) As Color
             If 0.0F > h OrElse 360.0F < h Then
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Throw New ArgumentOutOfRangeException("h")
             End If
             If 0.0F > s OrElse 1.0F < s Then
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Throw New ArgumentOutOfRangeException("s")
             End If
             If 0.0F > b OrElse 1.0F < b Then
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Throw New ArgumentOutOfRangeException("b")
             End If
 
             If 0 = s Then
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Return Color.FromArgb(CInt(Fix(b * 255)), CInt(Fix(b * 255)), CInt(Fix(b * 255)))
             End If
 
             Dim fMax, fMid, fMin As Single
             Dim iSextant, iMax, iMid, iMin As Integer
 
             If 0.5 < b Then
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 fMax = b - (b * s) + s
                 fMin = b + (b * s) - s
             Else
                 fMax = b + (b * s)
                 fMin = b - (b * s)
             End If
 
             iSextant = CInt(Fix(h / 60.0F))
             If 300.0F <= h Then
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 h -= 360.0F
             End If
             h /= 60.0F
             h -= 2.0F * CSng(Math.Floor(((iSextant + 1.0F) Mod 6.0F) / 2.0F))
             If 0 = iSextant Mod 2 Then
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 fMid = h * (fMax - fMin) + fMin
             Else
                 fMid = fMin - h * (fMax - fMin)
             End If
 
             iMax = CInt(Fix(fMax * 255))
             iMid = CInt(Fix(fMid * 255))
             iMin = CInt(Fix(fMin * 255))
 
             Select Case iSextant
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
     End Class
 End Namespace
                 Case 1
                     Return Color.FromArgb(iMid, iMax, iMin)
                 Case 2
                     Return Color.FromArgb(iMin, iMax, iMid)
                 Case 3
                     Return Color.FromArgb(iMin, iMid, iMax)
                 Case 4
                     Return Color.FromArgb(iMid, iMin, iMax)
                 Case 5
                     Return Color.FromArgb(iMax, iMin, iMid)
                 Case Else
                     Return Color.FromArgb(iMax, iMid, iMin)
             End Select
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ImageManipulation.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="12" endline="17"><![CDATA[
         Protected Overrides Sub Dispose(ByVal disposing As Boolean)
             If disposing AndAlso (components IsNot Nothing) Then
                 components.Dispose()
             End If
             MyBase.Dispose(disposing)
         End Sub
 
 #Region "Windows Form Designer generated code"
 
         ''' <summary>
         ''' Required method for Designer support - do not modify
         ''' the contents of this method with the code editor.
         ''' </summary>
         Private Sub InitializeComponent()
             Me.components = New System.ComponentModel.Container()
             Dim resources As New System.ComponentModel.ComponentResourceManager(GetType(MainForm))
             Me.bwColorize = New System.ComponentModel.BackgroundWorker()
             Me.tmRefresh = New Timer(Me.components)
             Me.toolStripContainer = New ToolStripContainer()
             Me.pbImage = New PictureBox()
             Me.toolStripMain = New ToolStrip()
             Me.btnLoadImage = New ToolStripButton()
             Me.btnSaveImage = New ToolStripButton()
             Me.separator1 = New ToolStripSeparator()
             Me.tbEpsilon = New Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar()
             Me.separator2 = New ToolStripSeparator()
             Me.btnParallel = New ToolStripButton()
             Me.btnInk = New ToolStripButton()
             Me.btnEraser = New ToolStripButton()
             Me.pbColorizing = New ToolStripProgressBar()
             Me.lblHuesSelected = New ToolStripLabel()
             Me.toolStripContainer.ContentPanel.SuspendLayout()
             Me.toolStripContainer.TopToolStripPanel.SuspendLayout()
             Me.toolStripContainer.SuspendLayout()
             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.toolStripMain.SuspendLayout()
             Me.SuspendLayout()
             ' 
             ' bwColorize
             ' 
             Me.bwColorize.WorkerReportsProgress = True
             ' Me.bwColorize.DoWork += New System.ComponentModel.DoWorkEventHandler(Me.bwColorize_DoWork)
             ' Me.bwColorize.RunWorkerCompleted += New System.ComponentModel.RunWorkerCompletedEventHandler(Me.bwColorize_RunWorkerCompleted)
             ' Me.bwColorize.ProgressChanged += New System.ComponentModel.ProgressChangedEventHandler(Me.bwColorize_ProgressChanged)
             ' 
             ' tmRefresh
             ' 
             Me.tmRefresh.Interval = 1000
             '			Me.tmRefresh.Tick += New System.EventHandler(Me.tmRefresh_Tick)
             ' 
             ' toolStripContainer
             ' 
             ' 
             ' toolStripContainer.ContentPanel
             ' 
             Me.toolStripContainer.ContentPanel.Controls.Add(Me.pbImage)
             Me.toolStripContainer.ContentPanel.Size = New Size(619, 397)
             Me.toolStripContainer.Dock = DockStyle.Fill
             Me.toolStripContainer.Location = New Point(0, 0)
             Me.toolStripContainer.Name = "toolStripContainer"
             Me.toolStripContainer.Size = New Size(619, 422)
             Me.toolStripContainer.TabIndex = 10
             Me.toolStripContainer.Text = "toolStripContainer1"
             ' 
             ' toolStripContainer.TopToolStripPanel
             ' 
             Me.toolStripContainer.TopToolStripPanel.Controls.Add(Me.toolStripMain)
             ' 
             ' pbImage
             ' 
             Me.pbImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
             Me.pbImage.BorderStyle = BorderStyle.Fixed3D
             Me.pbImage.Cursor = Cursors.Default
             Me.pbImage.Location = New Point(3, 3)
             Me.pbImage.Name = "pbImage"
             Me.pbImage.Size = New Size(613, 391)
             Me.pbImage.SizeMode = PictureBoxSizeMode.StretchImage
             Me.pbImage.TabIndex = 10
             Me.pbImage.TabStop = False
             ' Me.pbImage.DragDrop += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragDrop)
             ' Me.pbImage.Resize += New System.EventHandler(Me.pbImage_Resize)
             ' Me.pbImage.MouseClick += New System.Windows.Forms.MouseEventHandler(Me.pbImage_MouseClick)
             ' Me.pbImage.DragEnter += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragEnter)
             ' 
             ' toolStripMain
             ' 
             Me.toolStripMain.AllowItemReorder = True
             Me.toolStripMain.Dock = DockStyle.None
             Me.toolStripMain.Items.AddRange(New ToolStripItem() {Me.btnLoadImage, Me.btnSaveImage, Me.separator1, Me.tbEpsilon, Me.separator2, Me.btnParallel, _
                                                                  Me.btnInk, Me.btnEraser, Me.pbColorizing, Me.lblHuesSelected})
             Me.toolStripMain.LayoutStyle = ToolStripLayoutStyle.HorizontalStackWithOverflow
             Me.toolStripMain.Location = New Point(3, 0)
             Me.toolStripMain.Name = "toolStripMain"
             Me.toolStripMain.Size = New Size(616, 25)
             Me.toolStripMain.TabIndex = 9
             Me.toolStripMain.Text = "toolStrip1"
             ' 
             ' btnLoadImage
             ' 
             Me.btnLoadImage.Image = My.Resources.InsertPictureHS
             Me.btnLoadImage.ImageTransparentColor = Color.Magenta
             Me.btnLoadImage.Name = "btnLoadImage"
             Me.btnLoadImage.Size = New Size(89, 22)
             Me.btnLoadImage.Text = "&Load Image"
             ' Me.btnLoadImage.Click += New System.EventHandler(Me.btnLoadImage_Click)
             '
             ' btnSaveImage
             ' 
             Me.btnSaveImage.Image = My.Resources.saveHS
             Me.btnSaveImage.ImageTransparentColor = Color.Magenta
             Me.btnSaveImage.Name = "btnSaveImage"
             Me.btnSaveImage.Size = New Size(87, 22)
             Me.btnSaveImage.Text = "&Save Image"
             ' Me.btnSaveImage.Click += New System.EventHandler(Me.btnSaveImage_Click)
             ' 
             ' separator1
             ' 
             Me.separator1.Name = "separator1"
             Me.separator1.Size = New Size(6, 25)
             ' 
             ' tbEpsilon
             ' 
             Me.tbEpsilon.BackColor = SystemColors.Control
             Me.tbEpsilon.Maximum = 180
             Me.tbEpsilon.Name = "tbEpsilon"
             Me.tbEpsilon.Size = New Size(150, 22)
             Me.tbEpsilon.Text = "toolStripTrackBar1"
             Me.tbEpsilon.Value = 15
             ' Me.tbEpsilon.ValueChanged += New System.EventHandler(Me.tbEpsilon_ValueChanged)
             ' 
             ' separator2
             ' 
             Me.separator2.Name = "separator2"
             Me.separator2.Size = New Size(6, 25)
             ' 
             ' btnParallel
             ' 
             Me.btnParallel.CheckOnClick = True
             Me.btnParallel.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnParallel.Image = (CType(resources.GetObject("btnParallel.Image"), Image))
             Me.btnParallel.ImageTransparentColor = Color.Magenta
             Me.btnParallel.Name = "btnParallel"
             Me.btnParallel.Size = New Size(23, 22)
             Me.btnParallel.Text = "btnParallel"
             ' Me.btnParallel.CheckedChanged += New System.EventHandler(Me.btnParallel_CheckedChanged)
             ' 
             ' btnInk
             ' 
             Me.btnInk.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnInk.Enabled = False
             Me.btnInk.Image = My.Resources.pen
             Me.btnInk.ImageTransparentColor = Color.Magenta
             Me.btnInk.Name = "btnInk"
             Me.btnInk.Size = New Size(23, 22)
             Me.btnInk.Text = "btnInk"
             ' Me.btnInk.Click += New System.EventHandler(Me.btnInk_Click)
             ' 
             ' btnEraser
             ' 
             Me.btnEraser.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnEraser.Enabled = False
             Me.btnEraser.Image = My.Resources.eraser
             Me.btnEraser.ImageTransparentColor = Color.Magenta
             Me.btnEraser.Name = "btnEraser"
             Me.btnEraser.Size = New Size(23, 22)
             Me.btnEraser.Text = "btnEraser"
             ' Me.btnEraser.Click += New System.EventHandler(Me.btnEraser_Click)
             ' 
             ' pbColorizing
             ' 
             Me.pbColorizing.Alignment = ToolStripItemAlignment.Right
             Me.pbColorizing.Name = "pbColorizing"
             Me.pbColorizing.Overflow = ToolStripItemOverflow.Never
             Me.pbColorizing.Size = New Size(140, 22)
             Me.pbColorizing.Visible = False
             ' 
             ' lblHuesSelected
             ' 
             Me.lblHuesSelected.Name = "lblHuesSelected"
             Me.lblHuesSelected.Size = New Size(81, 15)
             Me.lblHuesSelected.Text = "Hues Selected"
             ' Me.lblHuesSelected.Click += New System.EventHandler(Me.lblHuesSelected_Click)
             ' 
             ' MainForm
             ' 
             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
             Me.AutoScaleMode = AutoScaleMode.Font
             Me.ClientSize = New Size(619, 422)
             Me.Controls.Add(Me.toolStripContainer)
             Me.Icon = (CType(resources.GetObject("$this.Icon"), Icon))
             Me.KeyPreview = True
             Me.Name = "MainForm"
             Me.Text = "Image Colorizer"
             ' Me.Load += New System.EventHandler(Me.MainForm_Load)
             Me.toolStripContainer.ContentPanel.ResumeLayout(False)
             Me.toolStripContainer.TopToolStripPanel.ResumeLayout(False)
             Me.toolStripContainer.TopToolStripPanel.PerformLayout()
             Me.toolStripContainer.ResumeLayout(False)
             Me.toolStripContainer.PerformLayout()
             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).EndInit()
             Me.toolStripMain.ResumeLayout(False)
             Me.toolStripMain.PerformLayout()
             Me.ResumeLayout(False)
 
         End Sub
 
 #End Region
 
         Private WithEvents bwColorize As System.ComponentModel.BackgroundWorker
         Private WithEvents tmRefresh As Timer
         Private toolStripContainer As ToolStripContainer
         Private WithEvents pbImage As PictureBox
         Private toolStripMain As ToolStrip
         Private WithEvents btnLoadImage As ToolStripButton
         Private WithEvents btnSaveImage As ToolStripButton
         Private separator1 As ToolStripSeparator
         Private WithEvents tbEpsilon As ToolStripTrackBar
         Private separator2 As ToolStripSeparator
         Private WithEvents btnInk As ToolStripButton
         Private WithEvents btnEraser As ToolStripButton
         Private pbColorizing As ToolStripProgressBar
         Private WithEvents lblHuesSelected As ToolStripLabel
         Private WithEvents btnParallel As ToolStripButton
     End Class
 End Namespace
 
                 components.Dispose()
             End If
             MyBase.Dispose(disposing)
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="18" endline="216"><![CDATA[
 
 #Region "Windows Form Designer generated code"
 
         ''' <summary>
         ''' Required method for Designer support - do not modify
         ''' the contents of this method with the code editor.
         ''' </summary>
         Private Sub InitializeComponent()
             Me.components = New System.ComponentModel.Container()
             Dim resources As New System.ComponentModel.ComponentResourceManager(GetType(MainForm))
             Me.bwColorize = New System.ComponentModel.BackgroundWorker()
             Me.tmRefresh = New Timer(Me.components)
             Me.toolStripContainer = New ToolStripContainer()
             Me.pbImage = New PictureBox()
             Me.toolStripMain = New ToolStrip()
             Me.btnLoadImage = New ToolStripButton()
             Me.btnSaveImage = New ToolStripButton()
             Me.separator1 = New ToolStripSeparator()
             Me.tbEpsilon = New Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar()
             Me.separator2 = New ToolStripSeparator()
             Me.btnParallel = New ToolStripButton()
             Me.btnInk = New ToolStripButton()
             Me.btnEraser = New ToolStripButton()
             Me.pbColorizing = New ToolStripProgressBar()
             Me.lblHuesSelected = New ToolStripLabel()
             Me.toolStripContainer.ContentPanel.SuspendLayout()
             Me.toolStripContainer.TopToolStripPanel.SuspendLayout()
             Me.toolStripContainer.SuspendLayout()
             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).BeginInit()
             Me.toolStripMain.SuspendLayout()
             Me.SuspendLayout()
             ' 
             ' bwColorize
             ' 
             Me.bwColorize.WorkerReportsProgress = True
             ' Me.bwColorize.DoWork += New System.ComponentModel.DoWorkEventHandler(Me.bwColorize_DoWork)
             ' Me.bwColorize.RunWorkerCompleted += New System.ComponentModel.RunWorkerCompletedEventHandler(Me.bwColorize_RunWorkerCompleted)
             ' Me.bwColorize.ProgressChanged += New System.ComponentModel.ProgressChangedEventHandler(Me.bwColorize_ProgressChanged)
             ' 
             ' tmRefresh
             ' 
             Me.tmRefresh.Interval = 1000
             '			Me.tmRefresh.Tick += New System.EventHandler(Me.tmRefresh_Tick)
             ' 
             ' toolStripContainer
             ' 
             ' 
             ' toolStripContainer.ContentPanel
             ' 
             Me.toolStripContainer.ContentPanel.Controls.Add(Me.pbImage)
             Me.toolStripContainer.ContentPanel.Size = New Size(619, 397)
             Me.toolStripContainer.Dock = DockStyle.Fill
             Me.toolStripContainer.Location = New Point(0, 0)
             Me.toolStripContainer.Name = "toolStripContainer"
             Me.toolStripContainer.Size = New Size(619, 422)
             Me.toolStripContainer.TabIndex = 10
             Me.toolStripContainer.Text = "toolStripContainer1"
             ' 
             ' toolStripContainer.TopToolStripPanel
             ' 
             Me.toolStripContainer.TopToolStripPanel.Controls.Add(Me.toolStripMain)
             ' 
             ' pbImage
             ' 
             Me.pbImage.Anchor = (CType((((AnchorStyles.Top Or AnchorStyles.Bottom) Or AnchorStyles.Left) Or AnchorStyles.Right), AnchorStyles))
             Me.pbImage.BorderStyle = BorderStyle.Fixed3D
             Me.pbImage.Cursor = Cursors.Default
             Me.pbImage.Location = New Point(3, 3)
             Me.pbImage.Name = "pbImage"
             Me.pbImage.Size = New Size(613, 391)
             Me.pbImage.SizeMode = PictureBoxSizeMode.StretchImage
             Me.pbImage.TabIndex = 10
             Me.pbImage.TabStop = False
             ' Me.pbImage.DragDrop += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragDrop)
             ' Me.pbImage.Resize += New System.EventHandler(Me.pbImage_Resize)
             ' Me.pbImage.MouseClick += New System.Windows.Forms.MouseEventHandler(Me.pbImage_MouseClick)
             ' Me.pbImage.DragEnter += New System.Windows.Forms.DragEventHandler(Me.pbImage_DragEnter)
             ' 
             ' toolStripMain
             ' 
             Me.toolStripMain.AllowItemReorder = True
             Me.toolStripMain.Dock = DockStyle.None
             Me.toolStripMain.Items.AddRange(New ToolStripItem() {Me.btnLoadImage, Me.btnSaveImage, Me.separator1, Me.tbEpsilon, Me.separator2, Me.btnParallel, _
                                                                  Me.btnInk, Me.btnEraser, Me.pbColorizing, Me.lblHuesSelected})
             Me.toolStripMain.LayoutStyle = ToolStripLayoutStyle.HorizontalStackWithOverflow
             Me.toolStripMain.Location = New Point(3, 0)
             Me.toolStripMain.Name = "toolStripMain"
             Me.toolStripMain.Size = New Size(616, 25)
             Me.toolStripMain.TabIndex = 9
             Me.toolStripMain.Text = "toolStrip1"
             ' 
             ' btnLoadImage
             ' 
             Me.btnLoadImage.Image = My.Resources.InsertPictureHS
             Me.btnLoadImage.ImageTransparentColor = Color.Magenta
             Me.btnLoadImage.Name = "btnLoadImage"
             Me.btnLoadImage.Size = New Size(89, 22)
             Me.btnLoadImage.Text = "&Load Image"
             ' Me.btnLoadImage.Click += New System.EventHandler(Me.btnLoadImage_Click)
             '
             ' btnSaveImage
             ' 
             Me.btnSaveImage.Image = My.Resources.saveHS
             Me.btnSaveImage.ImageTransparentColor = Color.Magenta
             Me.btnSaveImage.Name = "btnSaveImage"
             Me.btnSaveImage.Size = New Size(87, 22)
             Me.btnSaveImage.Text = "&Save Image"
             ' Me.btnSaveImage.Click += New System.EventHandler(Me.btnSaveImage_Click)
             ' 
             ' separator1
             ' 
             Me.separator1.Name = "separator1"
             Me.separator1.Size = New Size(6, 25)
             ' 
             ' tbEpsilon
             ' 
             Me.tbEpsilon.BackColor = SystemColors.Control
             Me.tbEpsilon.Maximum = 180
             Me.tbEpsilon.Name = "tbEpsilon"
             Me.tbEpsilon.Size = New Size(150, 22)
             Me.tbEpsilon.Text = "toolStripTrackBar1"
             Me.tbEpsilon.Value = 15
             ' Me.tbEpsilon.ValueChanged += New System.EventHandler(Me.tbEpsilon_ValueChanged)
             ' 
             ' separator2
             ' 
             Me.separator2.Name = "separator2"
             Me.separator2.Size = New Size(6, 25)
             ' 
             ' btnParallel
             ' 
             Me.btnParallel.CheckOnClick = True
             Me.btnParallel.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnParallel.Image = (CType(resources.GetObject("btnParallel.Image"), Image))
             Me.btnParallel.ImageTransparentColor = Color.Magenta
             Me.btnParallel.Name = "btnParallel"
             Me.btnParallel.Size = New Size(23, 22)
             Me.btnParallel.Text = "btnParallel"
             ' Me.btnParallel.CheckedChanged += New System.EventHandler(Me.btnParallel_CheckedChanged)
             ' 
             ' btnInk
             ' 
             Me.btnInk.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnInk.Enabled = False
             Me.btnInk.Image = My.Resources.pen
             Me.btnInk.ImageTransparentColor = Color.Magenta
             Me.btnInk.Name = "btnInk"
             Me.btnInk.Size = New Size(23, 22)
             Me.btnInk.Text = "btnInk"
             ' Me.btnInk.Click += New System.EventHandler(Me.btnInk_Click)
             ' 
             ' btnEraser
             ' 
             Me.btnEraser.DisplayStyle = ToolStripItemDisplayStyle.Image
             Me.btnEraser.Enabled = False
             Me.btnEraser.Image = My.Resources.eraser
             Me.btnEraser.ImageTransparentColor = Color.Magenta
             Me.btnEraser.Name = "btnEraser"
             Me.btnEraser.Size = New Size(23, 22)
             Me.btnEraser.Text = "btnEraser"
             ' Me.btnEraser.Click += New System.EventHandler(Me.btnEraser_Click)
             ' 
             ' pbColorizing
             ' 
             Me.pbColorizing.Alignment = ToolStripItemAlignment.Right
             Me.pbColorizing.Name = "pbColorizing"
             Me.pbColorizing.Overflow = ToolStripItemOverflow.Never
             Me.pbColorizing.Size = New Size(140, 22)
             Me.pbColorizing.Visible = False
             ' 
             ' lblHuesSelected
             ' 
             Me.lblHuesSelected.Name = "lblHuesSelected"
             Me.lblHuesSelected.Size = New Size(81, 15)
             Me.lblHuesSelected.Text = "Hues Selected"
             ' Me.lblHuesSelected.Click += New System.EventHandler(Me.lblHuesSelected_Click)
             ' 
             ' MainForm
             ' 
             Me.AutoScaleDimensions = New SizeF(6.0F, 13.0F)
             Me.AutoScaleMode = AutoScaleMode.Font
             Me.ClientSize = New Size(619, 422)
             Me.Controls.Add(Me.toolStripContainer)
             Me.Icon = (CType(resources.GetObject("$this.Icon"), Icon))
             Me.KeyPreview = True
             Me.Name = "MainForm"
             Me.Text = "Image Colorizer"
             ' Me.Load += New System.EventHandler(Me.MainForm_Load)
             Me.toolStripContainer.ContentPanel.ResumeLayout(False)
             Me.toolStripContainer.TopToolStripPanel.ResumeLayout(False)
             Me.toolStripContainer.TopToolStripPanel.PerformLayout()
             Me.toolStripContainer.ResumeLayout(False)
             Me.toolStripContainer.PerformLayout()
             CType(Me.pbImage, System.ComponentModel.ISupportInitialize).EndInit()
             Me.toolStripMain.ResumeLayout(False)
             Me.toolStripMain.PerformLayout()
             Me.ResumeLayout(False)
 
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="22" endline="24"><![CDATA[
 		Public Sub New()
 			InitializeComponent()
 		End Sub
 
 		''' <summary>A list of all selected points from which colors will be extracted from the image.</summary>
 		Private _selectedPixels As New List(Of Point)()
 		''' <summary>The last hue epsilon selected by the user.</summary>
 		Private _lastEpsilon As Integer = -1
 		''' <summary>The last size of the image picture box before a resize.</summary>
 		Private _lastPictureBoxSize As New Size(-1, -1)
 		''' <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
 		Private _paths As List(Of GraphicsPath)
 		''' <summary>The image as originally loaded.</summary>
 		Private _originalImage As Bitmap
 		''' <summary>The current image after all color transformations.</summary>
 		Private _colorizedImage As Bitmap
 		''' <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
 		Private _overlay As InkOverlay
 
 		''' <summary>Loads the form.</summary>
 		Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
 			' Store the current size of the picture box.  When the picture box is
 			' resized (due to the form being resized), we need to scale any ink
 			' that may exist on the form so that it sizes in accordance with the picture box.
 			_lastPictureBoxSize = pbImage.Size
 			pbImage.AllowDrop = True
 
             ' If the current platform supports ink, initialize the InkOverlay.
 			If PlatformDetection.SupportsInk Then
 				InitializeInk()
 			End If
 
             ' Setup the help text for the toolstrip.
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 		End Sub
 
 		Private _ofd As OpenFileDialog
 
 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
             ' Show a dialog to select JPG files.
 			If _ofd Is Nothing Then
 				_ofd = New OpenFileDialog()
 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
 			End If
 			If _ofd.ShowDialog() = DialogResult.OK Then
 				LoadImage(_ofd.FileName)
 			End If
 		End Sub
 
 		Private Sub LoadImage(ByVal path As String)
 			Try
 				_originalImage = New Bitmap(path)
 				pbImage.Image = _originalImage
 
 				' Disable saving of the image.  We only allow saving once changes have been made.
 				btnSaveImage.Enabled = False
 
 				' Change the cursor on the picture box to let the user know they
 				' can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
 
 
 				' If ink is available on the current machine, enable the button that
 				' turns on the overlay, and clear any existing ink from previous images
                 ' that may have existed in the app.
 				If PlatformDetection.SupportsInk Then
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
         Private components As System.ComponentModel.IContainer = Nothing
 		Private _selectedPixels As New List(Of Point)()
 		''' <summary>The last hue epsilon selected by the user.</summary>
 		Private _lastEpsilon As Integer = -1
 		''' <summary>The last size of the image picture box before a resize.</summary>
 		Private _lastPictureBoxSize As New Size(-1, -1)
 			InitializeComponent()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="25" endline="57"><![CDATA[
 
 		''' <summary>A list of all selected points from which colors will be extracted from the image.</summary>
 		Private _selectedPixels As New List(Of Point)()
 		''' <summary>The last hue epsilon selected by the user.</summary>
 		Private _lastEpsilon As Integer = -1
 		''' <summary>The last size of the image picture box before a resize.</summary>
 		Private _lastPictureBoxSize As New Size(-1, -1)
 		''' <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
 		Private _paths As List(Of GraphicsPath)
 		''' <summary>The image as originally loaded.</summary>
 		Private _originalImage As Bitmap
 		''' <summary>The current image after all color transformations.</summary>
 		Private _colorizedImage As Bitmap
 		''' <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
 		Private _overlay As InkOverlay
 
 		''' <summary>Loads the form.</summary>
 		Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
 			' Store the current size of the picture box.  When the picture box is
 			' resized (due to the form being resized), we need to scale any ink
 			' that may exist on the form so that it sizes in accordance with the picture box.
 			_lastPictureBoxSize = pbImage.Size
 			pbImage.AllowDrop = True
 
             ' If the current platform supports ink, initialize the InkOverlay.
 			If PlatformDetection.SupportsInk Then
 				InitializeInk()
 			End If
 
             ' Setup the help text for the toolstrip.
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 		End Sub
 
 		Private _ofd As OpenFileDialog
 
 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
             ' Show a dialog to select JPG files.
 			If _ofd Is Nothing Then
 				_ofd = New OpenFileDialog()
 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
 			End If
 			If _ofd.ShowDialog() = DialogResult.OK Then
 				LoadImage(_ofd.FileName)
 			End If
 		End Sub
 
 		Private Sub LoadImage(ByVal path As String)
 			Try
 				_originalImage = New Bitmap(path)
 				pbImage.Image = _originalImage
 
 				' Disable saving of the image.  We only allow saving once changes have been made.
 				btnSaveImage.Enabled = False
 
 				' Change the cursor on the picture box to let the user know they
 				' can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
 
 
 				' If ink is available on the current machine, enable the button that
 				' turns on the overlay, and clear any existing ink from previous images
                 ' that may have existed in the app.
 				If PlatformDetection.SupportsInk Then
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				InitializeInk()
 			End If
 
             ' Setup the help text for the toolstrip.
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="58" endline="72"><![CDATA[
 
 		Private _ofd As OpenFileDialog
 
 		''' <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
 		Private Sub btnLoadImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnLoadImage.Click
             ' Show a dialog to select JPG files.
 			If _ofd Is Nothing Then
 				_ofd = New OpenFileDialog()
 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
 			End If
 			If _ofd.ShowDialog() = DialogResult.OK Then
 				LoadImage(_ofd.FileName)
 			End If
 		End Sub
 
 		Private Sub LoadImage(ByVal path As String)
 			Try
 				_originalImage = New Bitmap(path)
 				pbImage.Image = _originalImage
 
 				' Disable saving of the image.  We only allow saving once changes have been made.
 				btnSaveImage.Enabled = False
 
 				' Change the cursor on the picture box to let the user know they
 				' can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
 
 
 				' If ink is available on the current machine, enable the button that
 				' turns on the overlay, and clear any existing ink from previous images
                 ' that may have existed in the app.
 				If PlatformDetection.SupportsInk Then
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				_ofd = New OpenFileDialog()
 				_ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif"
 				_ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures)
 			End If
 			If _ofd.ShowDialog() = DialogResult.OK Then
 				LoadImage(_ofd.FileName)
 			End If
 		End Sub
 
 		Private Sub LoadImage(ByVal path As String)
 			Try
 				_originalImage = New Bitmap(path)
 				pbImage.Image = _originalImage
 
 				' Disable saving of the image.  We only allow saving once changes have been made.
 				btnSaveImage.Enabled = False
 
 				' Change the cursor on the picture box to let the user know they
 				' can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
 
 
 				' If ink is available on the current machine, enable the button that
 				' turns on the overlay, and clear any existing ink from previous images
                 ' that may have existed in the app.
 				If PlatformDetection.SupportsInk Then
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				LoadImage(_ofd.FileName)
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="73" endline="96"><![CDATA[
 
 		Private Sub LoadImage(ByVal path As String)
 			Try
 				_originalImage = New Bitmap(path)
 				pbImage.Image = _originalImage
 
 				' Disable saving of the image.  We only allow saving once changes have been made.
 				btnSaveImage.Enabled = False
 
 				' Change the cursor on the picture box to let the user know they
 				' can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand
 
 
 				' If ink is available on the current machine, enable the button that
 				' turns on the overlay, and clear any existing ink from previous images
                 ' that may have existed in the app.
 				If PlatformDetection.SupportsInk Then
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					btnInk.Enabled = True
 					ClearInk()
 				End If
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 			Catch e1 As ArgumentException
 			End Try
 		End Sub
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 			End Try
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="97" endline="121"><![CDATA[
 
 		''' <summary>Recomputes the image based on the newly selected pixel.</summary>
 		Private Sub pbImage_MouseClick(ByVal sender As Object, ByVal e As MouseEventArgs) Handles pbImage.MouseClick
             ' Only run if an image has been loaded and if ink isn't being drawn.
 			If _originalImage IsNot Nothing AndAlso Not(btnInk.Enabled AndAlso btnInk.Checked) Then
 				' Get the point in the original image.  To get this we need
 				' to scale the selected point based on how much the image
 				' is being resized for display.
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Dim p As New Point(CInt(Fix(e.X * _originalImage.Width / CDbl(pbImage.Width))), CInt(Fix(e.Y * _originalImage.Height / CDbl(pbImage.Height))))
 
 				' Add the selected point to the list or make it the only
                 ' point in the list, based on whether the shift key is being held down.
 				If Control.ModifierKeys <> Keys.Shift Then
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					_selectedPixels.Clear()
 				End If
 				_selectedPixels.Add(p)
 
 				' With our updated list of selected pixels in hand, update
                 ' the toolstrip help text.
 				lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 
                 ' Start recomputing the image based on the new parameters.
 				StartColorizeImage()
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="122" endline="151"><![CDATA[
 
 		Private Sub StartColorizeImage()
 			' Stop the timer if it's running, since the timer's purpose
             ' is to cause this method to be called when the timer expires.
 			tmRefresh.Stop()
 			_lastEpsilon = tbEpsilon.Value
 
 			' If we have an image and if a pixel has been selected
 			' and if we're not currently recomputing the image...
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso (Not bwColorize.IsBusy) Then
                 ' If there are any strokes, turn them into GraphicsPaths.
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				If PlatformDetection.SupportsInk Then
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					If _paths IsNot Nothing Then
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 						For Each path As GraphicsPath In _paths
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 							path.Dispose()
 						Next path
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					End If
 					_paths = InkToGraphicsPaths(True)
 				End If
 
                 ' Modify the UI for progress.
 				toolStripMain.Enabled = False
 				pbImage.Enabled = False
 				pbColorizing.Value = 0
 				pbColorizing.Visible = True
 
                 ' Recompute the image!.
 				bwColorize.RunWorkerAsync()
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="152" endline="166"><![CDATA[
 
 		''' <summary>Colorizes the image on a background thread.</summary>
 		Private Sub bwColorize_DoWork(ByVal sender As Object, ByVal e As DoWorkEventArgs) Handles bwColorize.DoWork
 			' Create the colorizer instance.  Any progress updates
 			' will in turn update the progress through the BackgroundWorker.
 			Dim colorizer As New ImageManipulation()
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="167" endline="194"><![CDATA[
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="195" endline="201"><![CDATA[
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="202" endline="213"><![CDATA[
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="214" endline="253"><![CDATA[
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
             End Select
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="254" endline="258"><![CDATA[
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="259" endline="264"><![CDATA[
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="265" endline="273"><![CDATA[
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="274" endline="281"><![CDATA[
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="282" endline="304"><![CDATA[
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="305" endline="310"><![CDATA[
 
 		''' <summary>Clears all ink from the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ClearInk()
 			_overlay.Ink.DeleteStrokes()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="311" endline="318"><![CDATA[
 
 		''' <summary>Scales the ink in the overlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub ScaleInk()
 			If pbImage.Size.Width > 0 AndAlso pbImage.Size.Height > 0 AndAlso _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso _overlay IsNot Nothing Then
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 _overlay.Ink.Strokes.Scale(pbImage.Size.Width / CSng(_lastPictureBoxSize.Width), pbImage.Size.Height / CSng(_lastPictureBoxSize.Height))
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="319" endline="353"><![CDATA[
 
 		''' <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
 		''' <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
 		''' <returns>The list of converted GraphicsPath instances.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Function InkToGraphicsPaths(ByVal scalePath As Boolean) As List(Of GraphicsPath)
             Dim renderer = _overlay.Renderer
             Dim strokes = _overlay.Ink.Strokes
 
             Dim scaleX = _originalImage.Width / CSng(pbImage.Width)
             Dim scaleY = _originalImage.Height / CSng(pbImage.Height)
 
 			If strokes.Count > 0 Then
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Using g = CreateGraphics()
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                     Dim paths As New List(Of GraphicsPath)(strokes.Count)
                     For Each stroke As Stroke In strokes
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                         Dim points() = stroke.GetPoints()
                         If points.Length >= 3 Then
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                             For i = 0 To points.Length - 1
                                 renderer.InkSpaceToPixel(g, points(i))
                                 If scalePath Then
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                                     points(i) = New Point(CInt(Fix(scaleX * points(i).X)), CInt(Fix(scaleY * points(i).Y)))
                                 End If
                             Next i
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                             Dim path As New GraphicsPath()
                             path.AddPolygon(points)
                             path.CloseFigure()
                             paths.Add(path)
                         End If
                     Next stroke
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                     Return paths
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 End Using
 			End If
 			Return Nothing
 		End Function
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 			End If
 			Return Nothing
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="354" endline="360"><![CDATA[
 
 		''' <summary>Enables or disables the InkOverlay.</summary>
 		Private Sub btnInk_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnInk.Click
 			_overlay.Enabled = Not _overlay.Enabled
 			btnInk.Checked = _overlay.Enabled
 			btnEraser.Enabled = btnInk.Checked
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="361" endline="366"><![CDATA[
 
 		''' <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
 		Private Sub btnEraser_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnEraser.Click
 			_overlay.EditingMode = If((_overlay.EditingMode = InkOverlayEditingMode.Delete), InkOverlayEditingMode.Ink, InkOverlayEditingMode.Delete)
 			btnEraser.Checked = _overlay.EditingMode = InkOverlayEditingMode.Delete
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="367" endline="379"><![CDATA[
 
 		''' <summary>Resets back to the original image.</summary>
 		Private Sub lblHuesSelected_Click(ByVal sender As Object, ByVal e As EventArgs) Handles lblHuesSelected.Click
 			_selectedPixels.Clear()
 			pbImage.Image = _originalImage
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				_colorizedImage.Dispose()
 				_colorizedImage = Nothing
 			End If
 
 			lblHuesSelected.Text = String.Format(My.Resources.HuesSelectedDisplay, _selectedPixels.Count)
 			lblHuesSelected.ToolTipText = Nothing
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="380" endline="386"><![CDATA[
 
 		''' <summary>Sets up a drag & drop affect.</summary>
 		Private Sub pbImage_DragEnter(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragEnter
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso (CType(e.Data.GetData(DataFormats.FileDrop), String())).Length = 1 Then
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 				e.Effect = DragDropEffects.Copy
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="387" endline="396"><![CDATA[
 
 		''' <summary>Completes a drag & drop operation, loading the dropped image.</summary>
 		Private Sub pbImage_DragDrop(ByVal sender As Object, ByVal e As DragEventArgs) Handles pbImage.DragDrop
 			If e.Data.GetDataPresent(DataFormats.FileDrop) AndAlso e.Effect = DragDropEffects.Copy Then
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
                 Dim paths() = CType(e.Data.GetData(DataFormats.FileDrop), String())
 				If paths.Length = 1 Then
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
 	End Class
 End Namespace
 					LoadImage(paths(0))
 				End If
 			End If
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="397" endline="400"><![CDATA[
 
 		Private Sub btnParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles btnParallel.CheckedChanged
 			StartColorizeImage()
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="158" endline="158"><![CDATA[
 			AddHandler colorizer.ProgressChanged, Sub(s As Object, pcea As ProgressChangedEventArgs) bwColorize.ReportProgress(pcea.ProgressPercentage)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="159" endline="244"><![CDATA[
 
 			' Create a clone of the original image, so that we can lock its bits
             ' while still allowing the UI to refresh and resize appropriately.
             Using workImage = _originalImage.Clone(New Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb)
                 ' Colorize the image and store the resulting Bitmap.
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked)
             End Using
 		End Sub
 
 		''' <summary>Configures the MainForm after colorization is complete.</summary>
 		Private Sub bwColorize_RunWorkerCompleted(ByVal sender As Object, ByVal e As RunWorkerCompletedEventArgs) Handles bwColorize.RunWorkerCompleted
             ' Reenable the UI.
 			pbColorizing.Visible = False
 			toolStripMain.Enabled = True
 			pbImage.Enabled = True
 			btnLoadImage.Enabled = True
 			btnSaveImage.Enabled = True
 			tbEpsilon.Focus()
 
             ' Rethrow any exceptions.
 			If e.Error IsNot Nothing Then
 				Throw New TargetInvocationException(e.Error)
 			End If
 
             ' Get the newly computed image.
 			If _colorizedImage IsNot Nothing Then
 				_colorizedImage.Dispose()
 			End If
 			_colorizedImage = CType(e.Result, Bitmap)
 
             ' Set the newly computed image into the PictureBox.
 			If pbImage.Image IsNot Nothing AndAlso pbImage.Image IsNot _originalImage Then
 				pbImage.Image.Dispose()
 			End If
 			pbImage.Image = _colorizedImage
 		End Sub
 
 		''' <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
 		Private Sub bwColorize_ProgressChanged(ByVal sender As Object, ByVal e As ProgressChangedEventArgs) Handles bwColorize.ProgressChanged
 			If e.ProgressPercentage > pbColorizing.Value Then
 				pbColorizing.Value = e.ProgressPercentage
 			End If
 		End Sub
 
 		''' <summary>Saves the colorized image to a file.</summary>
 		Private Sub btnSaveImage_Click(ByVal sender As Object, ByVal e As EventArgs) Handles btnSaveImage.Click
 			If _colorizedImage IsNot Nothing Then
 				Dim sfd As New SaveFileDialog()
 				sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*"
 				sfd.DefaultExt = ".jpg"
 				If sfd.ShowDialog(Me) = DialogResult.OK Then
 					SaveImage(_colorizedImage, sfd.FileName, 100)
 				End If
 			End If
 		End Sub
 
 		''' <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
 		''' <param name="bmp">The image to be saved.</param>
 		''' <param name="path">The path where to save the image.</param>
 		''' <param name="quality">The quality of the image to save.</param>
 		Private Shared Sub SaveImage(ByVal bmp As Bitmap, ByVal path As String, ByVal quality As Long)
             ' Validate parameters.
 			If bmp Is Nothing Then
 				Throw New ArgumentNullException("bmp")
 			End If
 			If path Is Nothing Then
 				Throw New ArgumentNullException("path")
 			End If
 			If quality < 1 OrElse quality > 100 Then
 				Throw New ArgumentOutOfRangeException("quality", quality, "Quality out of range.")
 			End If
 
             ' Save it to a file format based on the path's extension.
 
             Select Case System.IO.Path.GetExtension(path).ToLowerInvariant()
                 Case ".bmp"
                     bmp.Save(path, ImageFormat.Bmp)
                 Case ".png"
                     bmp.Save(path, ImageFormat.Png)
                 Case ".gif"
                     bmp.Save(path, ImageFormat.Gif)
                 Case ".tif", ".tiff"
                     bmp.Save(path, ImageFormat.Tiff)
                 Case ".jpg"
 
                     Dim jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(), Function(ici As ImageCodecInfo) ici.MimeType = "image/jpeg")
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="245" endline="295"><![CDATA[
                     Using codecParams As New EncoderParameters(1)
                         Using ratio As New EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality)
                             ' Set the JPEG quality value and save the image.
                             codecParams.Param(0) = ratio
                             bmp.Save(path, jpegCodec, codecParams)
                         End Using
                     End Using
             End Select
 		End Sub
 
 		''' <summary>Starts the colorization process when the refresh timer expires.</summary>
 		Private Sub tmRefresh_Tick(ByVal sender As Object, ByVal e As EventArgs) Handles tmRefresh.Tick
 			StartColorizeImage()
 		End Sub
 
 		''' <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
 		Private Sub tbEpsilon_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbEpsilon.ValueChanged
 			tbEpsilon.ToolTipText = String.Format(My.Resources.EpsilonDisplay, tbEpsilon.Value)
 			StartRefreshTimer()
 		End Sub
 
 		''' <summary>Starts/restarts the refresh timer.</summary>
 		Private Sub StartRefreshTimer()
 			If _originalImage IsNot Nothing AndAlso _selectedPixels.Count > 0 AndAlso _lastEpsilon >= 0 AndAlso (Not bwColorize.IsBusy) Then
 				btnLoadImage.Enabled = False
 				tmRefresh.Stop()
 				tmRefresh.Start()
 			End If
 		End Sub
 
 		''' <summary>Resizes any ink in the picture box when it resizes.</summary>
 		Private Sub pbImage_Resize(ByVal sender As Object, ByVal e As EventArgs) Handles pbImage.Resize
 			If _lastPictureBoxSize.Width > 0 AndAlso _lastPictureBoxSize.Height > 0 AndAlso PlatformDetection.SupportsInk Then
 				ScaleInk()
 			End If
 			_lastPictureBoxSize = pbImage.Size
 		End Sub
 
 		''' <summary>Initializes the InkOverlay.</summary>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Sub InitializeInk()
 			_overlay = New InkOverlay(pbImage, True)
 			_overlay.DefaultDrawingAttributes.Width = 1
 			_overlay.DefaultDrawingAttributes.Color = Color.Red
 			_overlay.DefaultDrawingAttributes.IgnorePressure = True
 
 			' When a stroke is received, we start a timer that, when expiring,
 			' will cause the image to be redrawn.  This timer allows the user
 			' to draw multiple strokes without the image having to be redrawn
 			' after each.
 			AddHandler _overlay.Stroke, Sub() StartRefreshTimer()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="296" endline="303"><![CDATA[
 
 			' We also don't want the image to be redrawn midstroke (which
 			' could happen if the user drew a stroke, causing the timer
 			' to start, and then took longer than a second to draw the
 			' second stroke), so when new packets are received, the timer
 			' is stopped; it'll be restarted by the above when the Stroke
 			' is completed.
 			AddHandler _overlay.NewPackets, Sub() tmRefresh.Stop()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\MainForm.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="40" endline="46"><![CDATA[
 			Get
 				If Object.ReferenceEquals(resourceMan, Nothing) Then
 					Dim temp As New Global.System.Resources.ResourceManager("Resourc" & "es", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
 		End Property
 
 		''' <summary>
 		'''   Looks up a localized string similar to Hue variation
 		''' </summary>
 		Friend ReadOnly Property EpsilonDisplay() As String
 			Get
 				Return ResourceManager.GetString("EpsilonDisplay", resourceCulture)
 			End Get
 		End Property
 
 		Friend ReadOnly Property eraser() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("eraser", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
 		End Property
 
 		''' <summary>
 		'''   Looks up a localized string similar to Hues selected
 		''' </summary>
 		Friend ReadOnly Property HuesSelectedDisplay() As String
 			Get
 				Return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture)
 			End Get
 		End Property
 
 		Friend ReadOnly Property InsertPictureHS() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
 		End Property
 
 		Friend ReadOnly Property pen() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("pen", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
 		End Property
 
 		Friend ReadOnly Property saveHS() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("saveHS", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
 		End Property
 	End Module
 End Namespace
 					Dim temp As New Global.System.Resources.ResourceManager("Resourc" & "es", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="47" endline="57"><![CDATA[
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="58" endline="60"><![CDATA[
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="61" endline="69"><![CDATA[
 		End Property
 
 		''' <summary>
 		'''   Looks up a localized string similar to Hue variation
 		''' </summary>
 		Friend ReadOnly Property EpsilonDisplay() As String
 			Get
 				Return ResourceManager.GetString("EpsilonDisplay", resourceCulture)
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="70" endline="76"><![CDATA[
 		End Property
 
 		Friend ReadOnly Property eraser() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("eraser", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="77" endline="85"><![CDATA[
 		End Property
 
 		''' <summary>
 		'''   Looks up a localized string similar to Hues selected
 		''' </summary>
 		Friend ReadOnly Property HuesSelectedDisplay() As String
 			Get
 				Return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture)
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="86" endline="92"><![CDATA[
 		End Property
 
 		Friend ReadOnly Property InsertPictureHS() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="93" endline="99"><![CDATA[
 		End Property
 
 		Friend ReadOnly Property pen() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("pen", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Resources.Designer.vb" startline="100" endline="106"><![CDATA[
 		End Property
 
 		Friend ReadOnly Property saveHS() As Bitmap
 			Get
                 Dim obj = ResourceManager.GetObject("saveHS", resourceCulture)
 				Return (CType(obj, Bitmap))
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Settings.Designer.vb" startline="19" endline="19"><![CDATA[
         Private Shared defaultInstance As Settings = (CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New Settings()), Settings))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\My Project\Settings.Designer.vb" startline="20" endline="24"><![CDATA[
 
         Public Shared ReadOnly Property [Default]() As Settings
             Get
                 Return defaultInstance
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="27" endline="27"><![CDATA[
 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="23" endline="24"><![CDATA[
 		Private Sub New()
 		End Sub
 
 		''' <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
 		Private Shared Function LoadInkAssembly() As System.Reflection.Assembly
 			Try
 				Return LoadInkAssemblyInternal()
 			Catch e1 As TypeLoadException
 			Catch e2 As IOException
 			Catch e3 As SecurityException
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 		End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="25" endline="40"><![CDATA[
 
 		''' <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Private Shared _inkAssemblyAvailable As Boolean = (LoadInkAssembly() IsNot Nothing)
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
 		Private Shared Function LoadInkAssembly() As System.Reflection.Assembly
 			Try
 				Return LoadInkAssemblyInternal()
 			Catch e1 As TypeLoadException
 			Catch e2 As IOException
 			Catch e3 As SecurityException
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			Catch e1 As TypeLoadException
 			Catch e2 As IOException
 			Catch e3 As SecurityException
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			Catch e2 As IOException
 			Catch e3 As SecurityException
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			Catch e3 As SecurityException
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			Catch e4 As BadImageFormatException
 			End Try
 			Return Nothing
 		End Function
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			End Try
 			Return Nothing
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="41" endline="47"><![CDATA[
 
 		''' <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		''' <returns>The Assembly instance for Microsoft.Ink.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Private Shared Function LoadInkAssemblyInternal() As System.Reflection.Assembly
 			Return GetType(InkOverlay).Assembly
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="48" endline="53"><![CDATA[
 
 		''' <summary>Gets whether this platform supports using ink.</summary>
 		Public Shared ReadOnly Property SupportsInk() As Boolean
 			Get
 				Return InkAssemblyAvailable AndAlso RecognizerInstalled
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="54" endline="60"><![CDATA[
 		End Property
 
 		''' <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		Public Shared ReadOnly Property InkAssemblyAvailable() As Boolean
 			Get
 				Return _inkAssemblyAvailable
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="61" endline="70"><![CDATA[
 		End Property
 
 		''' <summary>Gets whether a valid recognizer is installed.</summary>
 		Public Shared ReadOnly Property RecognizerInstalled() As Boolean
 			Get
 				If Not _inkAssemblyAvailable Then
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 					Return False
 				End If
 				Return GetDefaultRecognizer() IsNot Nothing
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="71" endline="98"><![CDATA[
 		End Property
 
 		''' <summary>Gets the best recognizer for the current locale.</summary>
 		''' <returns>The best recognizer for the current locale.</returns>
 		<MethodImpl(MethodImplOptions.NoInlining)>
 		Public Shared Function GetDefaultRecognizer() As Recognizer
 			Dim recognizer As Recognizer = Nothing
 			Try
 				Dim recognizers As New Recognizers()
 				If recognizers.Count > 1 Then
                     ' First try the current locale's recognizer.
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 					Try
 						recognizer = recognizers.GetDefaultRecognizer()
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 					Catch
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 					End Try
 
                     ' Fallback to the en-US (1033) recognizer.
 					If recognizer Is Nothing Then
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 						Try
 							recognizer = recognizers.GetDefaultRecognizer(1033)
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 						Catch
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 						End Try
 					End If
 				End If
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			Catch
 			End Try
 			Return recognizer
 		End Function
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 			End Try
 			Return recognizer
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="99" endline="104"><![CDATA[
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		Public Shared ReadOnly Property GestureRecognizerInstalled() As Boolean
 			Get
 				Return _inkAssemblyAvailable AndAlso GestureRecognizerInstalledInternal
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="105" endline="122"><![CDATA[
 		End Property
 
 		''' <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		''' <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		Private Shared ReadOnly Property GestureRecognizerInstalledInternal() As Boolean
 			<MethodImpl(MethodImplOptions.NoInlining)>
 			Get
 				Try
 					Dim recognizers As New Recognizers()
 					If recognizers.Count > 0 Then
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
                         Using TempGestureRecognizer = New GestureRecognizer()
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
                             Return True
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
                         End Using
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 					End If
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 				Catch
 				End Try
 				Return False
 			End Get
 		End Property
 	End Class
 End Namespace
 				End Try
 				Return False
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\PlatformDetection.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="19" endline="21"><![CDATA[
         Public Sub New()
             MyBase.New(CreateControlInstance())
         End Sub
 
         ''' <summary>Gets the actual TrackBar instance.</summary>
         Public ReadOnly Property TrackBar() As TrackBar
             Get
                 Return TryCast(Control, TrackBar)
             End Get
         End Property
 
         ''' <summary>Create the actual TrackBar control.</summary>
         Private Shared Function CreateControlInstance() As Control
             Dim t As New TrackBar()
             t.AutoSize = False
             t.Height = 16
             t.TickStyle = TickStyle.None
             t.Minimum = 0
             t.Maximum = 100
             t.Value = 0
             Return t
         End Function
 
         ''' <summary>Gets the current TrackBar value.</summary>
         <DefaultValue(0)>
         Public Property Value() As Integer
             Get
                 Return TrackBar.Value
             End Get
             Set(ByVal value As Integer)
                 TrackBar.Value = value
             End Set
         End Property
 
         ''' <summary>Gets the minimum TrackBar value.</summary>
         <DefaultValue(0)>
         Public Property Minimum() As Integer
             Get
                 Return TrackBar.Minimum
             End Get
             Set(ByVal value As Integer)
                 TrackBar.Minimum = value
             End Set
         End Property
 
         ''' <summary>Gets the maximum TrackBar value.</summary>
         <DefaultValue(100)>
         Public Property Maximum() As Integer
             Get
                 Return TrackBar.Maximum
             End Get
             Set(ByVal value As Integer)
                 TrackBar.Maximum = value
             End Set
         End Property
 
         ''' <summary>Attach to events that need to be wrapped.</summary>
         Protected Overrides Sub OnSubscribeControlEvents(ByVal control As Control)
             MyBase.OnSubscribeControlEvents(control)
             AddHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
         End Sub
 
         ''' <summary>Detach from events that were wrapped.</summary>
         Protected Overrides Sub OnUnsubscribeControlEvents(ByVal control As Control)
             MyBase.OnUnsubscribeControlEvents(control)
             RemoveHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
         End Sub
 
         ''' <summary>Raise the ValueChanged event.</summary>
         Private Sub trackBar_ValueChanged(ByVal sender As Object, ByVal e As EventArgs)
             RaiseEvent ValueChanged(sender, e)
         End Sub
 
         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
         Public Event ValueChanged As EventHandler
 
         ''' <summary>Gets the default size for the control.</summary>
         Protected Overrides ReadOnly Property DefaultSize() As Size
             Get
                 Return New Size(200, 16)
             End Get
         End Property
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="22" endline="27"><![CDATA[
 
         ''' <summary>Gets the actual TrackBar instance.</summary>
         Public ReadOnly Property TrackBar() As TrackBar
             Get
                 Return TryCast(Control, TrackBar)
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="28" endline="40"><![CDATA[
         End Property
 
         ''' <summary>Create the actual TrackBar control.</summary>
         Private Shared Function CreateControlInstance() As Control
             Dim t As New TrackBar()
             t.AutoSize = False
             t.Height = 16
             t.TickStyle = TickStyle.None
             t.Minimum = 0
             t.Maximum = 100
             t.Value = 0
             Return t
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="41" endline="47"><![CDATA[
 
         ''' <summary>Gets the current TrackBar value.</summary>
         <DefaultValue(0)>
         Public Property Value() As Integer
             Get
                 Return TrackBar.Value
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="48" endline="50"><![CDATA[
             Set(ByVal value As Integer)
                 TrackBar.Value = value
             End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="51" endline="58"><![CDATA[
         End Property
 
         ''' <summary>Gets the minimum TrackBar value.</summary>
         <DefaultValue(0)>
         Public Property Minimum() As Integer
             Get
                 Return TrackBar.Minimum
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="59" endline="61"><![CDATA[
             Set(ByVal value As Integer)
                 TrackBar.Minimum = value
             End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="62" endline="69"><![CDATA[
         End Property
 
         ''' <summary>Gets the maximum TrackBar value.</summary>
         <DefaultValue(100)>
         Public Property Maximum() As Integer
             Get
                 Return TrackBar.Maximum
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="70" endline="72"><![CDATA[
             Set(ByVal value As Integer)
                 TrackBar.Maximum = value
             End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="73" endline="79"><![CDATA[
         End Property
 
         ''' <summary>Attach to events that need to be wrapped.</summary>
         Protected Overrides Sub OnSubscribeControlEvents(ByVal control As Control)
             MyBase.OnSubscribeControlEvents(control)
             AddHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="80" endline="85"><![CDATA[
 
         ''' <summary>Detach from events that were wrapped.</summary>
         Protected Overrides Sub OnUnsubscribeControlEvents(ByVal control As Control)
             MyBase.OnUnsubscribeControlEvents(control)
             RemoveHandler (CType(control, TrackBar)).ValueChanged, AddressOf trackBar_ValueChanged
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="86" endline="90"><![CDATA[
 
         ''' <summary>Raise the ValueChanged event.</summary>
         Private Sub trackBar_ValueChanged(ByVal sender As Object, ByVal e As EventArgs)
             RaiseEvent ValueChanged(sender, e)
         End Sub
 
         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
         Public Event ValueChanged As EventHandler
 
         ''' <summary>Gets the default size for the control.</summary>
         Protected Overrides ReadOnly Property DefaultSize() As Size
             Get
                 Return New Size(200, 16)
             End Get
         End Property
     End Class
 End Namespace
             RaiseEvent ValueChanged(sender, e)
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="91" endline="99"><![CDATA[
 
         ''' <summary>Event used to notify when the TrackBar's value changes.</summary>
         Public Event ValueChanged As EventHandler
 
         ''' <summary>Gets the default size for the control.</summary>
         Protected Overrides ReadOnly Property DefaultSize() As Size
             Get
                 Return New Size(200, 16)
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_VisualBasic\ToolStripTrackBar.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
