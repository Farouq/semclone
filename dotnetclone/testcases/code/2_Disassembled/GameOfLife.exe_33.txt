
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly GameOfLife
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0A 47 61 6D 65 4F 66 4C 69 66 65 00 00 )    // ...GameOfLife..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0A 47 61 6D 65 4F 66 4C 69 66 65 00 00 )    // ...GameOfLife..
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 61 38 36 32 65 32 37 31 2D 33 33 31 62   // ..$a862e271-331b
                                                                                                  2D 34 61 33 63 2D 39 39 38 63 2D 39 65 34 32 38   // -4a3c-998c-9e428
                                                                                                  39 65 61 33 65 35 38 00 00 )                      // 9ea3e58..
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public GameOfLife.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public GameOfLife.MainForm.resources
{
  // Offset: 0x000000B8 Length: 0x000000B4
}
.module GameOfLife.exe
// MVID: {4997ADD0-1ED7-4610-831B-9A3323C8B17E}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x006C0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private abstract auto ansi sealed beforefieldinit GameOfLife.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\Program.cs' 
//000019:         {
    IL_0000:  nop
//000020:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000021:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000022:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void GameOfLife.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000023:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class GameOfLife.Program

.class private auto ansi beforefieldinit GameOfLife.GameBoard
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] current
    .field public valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] next
    .field public class GameOfLife.GameBoard '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1'::.ctor

  } // end of class '<>c__DisplayClass1'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass4'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class GameOfLife.GameBoard/'<>c__DisplayClass1' 'CS$<>8__locals2'
    .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap fastBmp
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass4'::.ctor

    .method public hidebysig instance void 
            '<MoveNext>b__0'(int32 i) cil managed
    {
      // Code size       619 (0x26b)
      .maxstack  6
      .locals init ([0] int32 j,
               [1] int32 count,
               [2] int32 r,
               [3] int32 g,
               [4] int32 b,
               [5] int32 x,
               [6] int32 y,
               [7] valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color> c,
               [8] bool CS$4$0000,
               [9] valuetype [System.Drawing]System.Drawing.Color CS$0$0001,
               [10] valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color> CS$0$0002)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\GameOfLifeLogic.cs' 
//000076:                 {
      IL_0000:  nop
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
      IL_0001:  ldc.i4.0
      IL_0002:  stloc.0
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0003:  br         IL_024e

//000079:                     {
      IL_0008:  nop
//000080:                         int count = 0;
      IL_0009:  ldc.i4.0
      IL_000a:  stloc.1
//000081:                         int r = 0, g = 0, b = 0;
      IL_000b:  ldc.i4.0
      IL_000c:  stloc.2
      IL_000d:  ldc.i4.0
      IL_000e:  stloc.3
      IL_000f:  ldc.i4.0
      IL_0010:  stloc.s    b
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
      IL_0012:  ldarg.1
      IL_0013:  ldc.i4.1
      IL_0014:  sub
      IL_0015:  stloc.s    x
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0017:  br         IL_00fc

//000085:                         {
      IL_001c:  nop
//000086:                             for (int y = j - 1; y <= j + 1; y++)
      IL_001d:  ldloc.0
      IL_001e:  ldc.i4.1
      IL_001f:  sub
      IL_0020:  stloc.s    y
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0022:  br         IL_00e2

//000087:                             {
      IL_0027:  nop
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
      IL_0028:  ldloc.s    x
      IL_002a:  ldarg.1
      IL_002b:  bne.un.s   IL_0032

      IL_002d:  ldloc.0
      IL_002e:  ldloc.s    y
      IL_0030:  beq.s      IL_0066

      IL_0032:  ldloc.s    x
      IL_0034:  ldc.i4.0
      IL_0035:  blt.s      IL_0066

      IL_0037:  ldloc.s    x
      IL_0039:  ldarg.0
      IL_003a:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_003f:  ldfld      class GameOfLife.GameBoard GameOfLife.GameBoard/'<>c__DisplayClass1'::'<>4__this'
      IL_0044:  call       instance int32 GameOfLife.GameBoard::get_Width()
      IL_0049:  bge.s      IL_0066

      IL_004b:  ldloc.s    y
      IL_004d:  ldc.i4.0
      IL_004e:  blt.s      IL_0066

      IL_0050:  ldloc.s    y
      IL_0052:  ldarg.0
      IL_0053:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0058:  ldfld      class GameOfLife.GameBoard GameOfLife.GameBoard/'<>c__DisplayClass1'::'<>4__this'
      IL_005d:  call       instance int32 GameOfLife.GameBoard::get_Height()
      IL_0062:  clt
      IL_0064:  br.s       IL_0067

      IL_0066:  ldc.i4.0
      IL_0067:  stloc.s    CS$4$0000
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0069:  ldloc.s    CS$4$0000
      IL_006b:  brtrue.s   IL_006f

//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
      IL_006d:  br.s       IL_00dc

//000089:                                 Color? c = current[x, y];
      IL_006f:  ldarg.0
      IL_0070:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0075:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
      IL_007a:  ldloc.s    x
      IL_007c:  ldloc.s    y
      IL_007e:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_0083:  ldobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
      IL_0088:  stloc.s    c
//000090:                                 if (c.HasValue)
      IL_008a:  ldloca.s   c
      IL_008c:  call       instance bool valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_HasValue()
      IL_0091:  ldc.i4.0
      IL_0092:  ceq
      IL_0094:  stloc.s    CS$4$0000
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0096:  ldloc.s    CS$4$0000
      IL_0098:  brtrue.s   IL_00db

//000091:                                 {
      IL_009a:  nop
//000092:                                     count++;
      IL_009b:  ldloc.1
      IL_009c:  ldc.i4.1
      IL_009d:  add
      IL_009e:  stloc.1
//000093:                                     r += c.Value.R;
      IL_009f:  ldloc.2
      IL_00a0:  ldloca.s   c
      IL_00a2:  call       instance !0 valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_Value()
      IL_00a7:  stloc.s    CS$0$0001
      IL_00a9:  ldloca.s   CS$0$0001
      IL_00ab:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_R()
      IL_00b0:  add
      IL_00b1:  stloc.2
//000094:                                     g += c.Value.G;
      IL_00b2:  ldloc.3
      IL_00b3:  ldloca.s   c
      IL_00b5:  call       instance !0 valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_Value()
      IL_00ba:  stloc.s    CS$0$0001
      IL_00bc:  ldloca.s   CS$0$0001
      IL_00be:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_G()
      IL_00c3:  add
      IL_00c4:  stloc.3
//000095:                                     b += c.Value.B;
      IL_00c5:  ldloc.s    b
      IL_00c7:  ldloca.s   c
      IL_00c9:  call       instance !0 valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_Value()
      IL_00ce:  stloc.s    CS$0$0001
      IL_00d0:  ldloca.s   CS$0$0001
      IL_00d2:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_B()
      IL_00d7:  add
      IL_00d8:  stloc.s    b
//000096:                                 }
      IL_00da:  nop
//000097:                             }
      IL_00db:  nop
//000086:                             for (int y = j - 1; y <= j + 1; y++)
      IL_00dc:  ldloc.s    y
      IL_00de:  ldc.i4.1
      IL_00df:  add
      IL_00e0:  stloc.s    y
      IL_00e2:  ldloc.s    y
      IL_00e4:  ldloc.0
      IL_00e5:  ldc.i4.1
      IL_00e6:  add
      IL_00e7:  cgt
      IL_00e9:  ldc.i4.0
      IL_00ea:  ceq
      IL_00ec:  stloc.s    CS$4$0000
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_00ee:  ldloc.s    CS$4$0000
      IL_00f0:  brtrue     IL_0027

//000098:                         }
      IL_00f5:  nop
//000084:                         for (int x = i - 1; x <= i + 1; x++)
      IL_00f6:  ldloc.s    x
      IL_00f8:  ldc.i4.1
      IL_00f9:  add
      IL_00fa:  stloc.s    x
      IL_00fc:  ldloc.s    x
      IL_00fe:  ldarg.1
      IL_00ff:  ldc.i4.1
      IL_0100:  add
      IL_0101:  cgt
      IL_0103:  ldc.i4.0
      IL_0104:  ceq
      IL_0106:  stloc.s    CS$4$0000
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0108:  ldloc.s    CS$4$0000
      IL_010a:  brtrue     IL_001c

//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
      IL_010f:  ldloc.1
      IL_0110:  ldc.i4.1
      IL_0111:  blt.s      IL_0119

      IL_0113:  ldloc.1
      IL_0114:  ldc.i4.4
      IL_0115:  clt
      IL_0117:  br.s       IL_011a

      IL_0119:  ldc.i4.0
      IL_011a:  stloc.s    CS$4$0000
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_011c:  ldloc.s    CS$4$0000
      IL_011e:  brtrue.s   IL_013d

//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
      IL_0120:  ldarg.0
      IL_0121:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0126:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::next
      IL_012b:  ldarg.1
      IL_012c:  ldloc.0
      IL_012d:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_0132:  initobj    valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0138:  br         IL_020b

//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
      IL_013d:  ldarg.0
      IL_013e:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0143:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
      IL_0148:  ldarg.1
      IL_0149:  ldloc.0
      IL_014a:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_014f:  call       instance bool valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_HasValue()
      IL_0154:  brfalse.s  IL_0166

      IL_0156:  ldloc.1
      IL_0157:  ldc.i4.2
      IL_0158:  beq.s      IL_0163

      IL_015a:  ldloc.1
      IL_015b:  ldc.i4.3
      IL_015c:  ceq
      IL_015e:  ldc.i4.0
      IL_015f:  ceq
      IL_0161:  br.s       IL_0164

      IL_0163:  ldc.i4.0
      IL_0164:  br.s       IL_0167

      IL_0166:  ldc.i4.1
      IL_0167:  stloc.s    CS$4$0000
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0169:  ldloc.s    CS$4$0000
      IL_016b:  brtrue.s   IL_019d

//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
      IL_016d:  ldarg.0
      IL_016e:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0173:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::next
      IL_0178:  ldarg.1
      IL_0179:  ldloc.0
      IL_017a:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_017f:  ldarg.0
      IL_0180:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0185:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
      IL_018a:  ldarg.1
      IL_018b:  ldloc.0
      IL_018c:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_0191:  ldobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
      IL_0196:  stobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_019b:  br.s       IL_020b

//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
      IL_019d:  ldarg.0
      IL_019e:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_01a3:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
      IL_01a8:  ldarg.1
      IL_01a9:  ldloc.0
      IL_01aa:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_01af:  call       instance bool valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_HasValue()
      IL_01b4:  brtrue.s   IL_01bf

      IL_01b6:  ldloc.1
      IL_01b7:  ldc.i4.3
      IL_01b8:  ceq
      IL_01ba:  ldc.i4.0
      IL_01bb:  ceq
      IL_01bd:  br.s       IL_01c0

      IL_01bf:  ldc.i4.1
      IL_01c0:  stloc.s    CS$4$0000
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_01c2:  ldloc.s    CS$4$0000
      IL_01c4:  brtrue.s   IL_01f3

//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
      IL_01c6:  ldarg.0
      IL_01c7:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_01cc:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::next
      IL_01d1:  ldarg.1
      IL_01d2:  ldloc.0
      IL_01d3:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_01d8:  ldloc.2
      IL_01d9:  ldloc.1
      IL_01da:  div
      IL_01db:  ldloc.3
      IL_01dc:  ldloc.1
      IL_01dd:  div
      IL_01de:  ldloc.s    b
      IL_01e0:  ldloc.1
      IL_01e1:  div
      IL_01e2:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                         int32,
                                                                                                                         int32)
      IL_01e7:  newobj     instance void valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::.ctor(!0)
      IL_01ec:  stobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_01f1:  br.s       IL_020b

//000104:                         else next[i, j] = null;
      IL_01f3:  ldarg.0
      IL_01f4:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_01f9:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::next
      IL_01fe:  ldarg.1
      IL_01ff:  ldloc.0
      IL_0200:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_0205:  initobj    valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
      IL_020b:  ldarg.0
      IL_020c:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap GameOfLife.GameBoard/'<>c__DisplayClass4'::fastBmp
      IL_0211:  ldarg.1
      IL_0212:  ldloc.0
      IL_0213:  ldarg.0
      IL_0214:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0219:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
      IL_021e:  ldarg.1
      IL_021f:  ldloc.0
      IL_0220:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                     int32)
      IL_0225:  ldobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
      IL_022a:  stloc.s    CS$0$0002
      IL_022c:  ldloca.s   CS$0$0002
      IL_022e:  call       instance bool valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::get_HasValue()
      IL_0233:  brtrue.s   IL_023c

      IL_0235:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_White()
      IL_023a:  br.s       IL_0243

      IL_023c:  ldloca.s   CS$0$0002
      IL_023e:  call       instance !0 valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::GetValueOrDefault()
      IL_0243:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                          int32,
                                                                                                          valuetype [System.Drawing]System.Drawing.Color)
      IL_0248:  nop
//000108:                     }
      IL_0249:  nop
//000078:                     for (int j = 0; j < Height; j++)
      IL_024a:  ldloc.0
      IL_024b:  ldc.i4.1
      IL_024c:  add
      IL_024d:  stloc.0
      IL_024e:  ldloc.0
      IL_024f:  ldarg.0
      IL_0250:  ldfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
      IL_0255:  ldfld      class GameOfLife.GameBoard GameOfLife.GameBoard/'<>c__DisplayClass1'::'<>4__this'
      IL_025a:  call       instance int32 GameOfLife.GameBoard::get_Height()
      IL_025f:  clt
      IL_0261:  stloc.s    CS$4$0000
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0263:  ldloc.s    CS$4$0000
      IL_0265:  brtrue     IL_0008

      IL_026a:  ret
    } // end of method '<>c__DisplayClass4'::'<MoveNext>b__0'

  } // end of class '<>c__DisplayClass4'

  .field private valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] _scratch
  .field private int32 _currentIndex
  .field private class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> _pool
  .field private int32 '<Width>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private int32 '<Height>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private bool '<RunParallel>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(int32 width,
                               int32 height,
                               float64 initialDensity,
                               class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> pool) cil managed
  {
    // Code size       288 (0x120)
    .maxstack  5
    .locals init ([0] class [mscorlib]System.Random rand,
             [1] int32 i,
             [2] int32 j,
             [3] bool CS$4$0000,
             [4] valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] CS$0$0001,
             [5] valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color> CS$0$0002)
//000032:         public GameBoard(int width, int height, double initialDensity, ObjectPool<Bitmap> pool)
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000033:         {
    IL_0007:  nop
//000034:             // Validate parameters
//000035:             if (width < 1) throw new ArgumentOutOfRangeException("width");
    IL_0008:  ldarg.1
    IL_0009:  ldc.i4.1
    IL_000a:  clt
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.3
//000036:             if (height < 1) throw new ArgumentOutOfRangeException("height");
//000037:             if (pool == null) throw new ArgumentNullException("pool");
//000038:             if (initialDensity < 0 || initialDensity > 1) throw new ArgumentOutOfRangeException("initialDensity");
//000039: 
//000040:             // Store parameters
//000041:             _pool = pool;
//000042:             Width = width;
//000043:             Height = height;
//000044: 
//000045:             // Create the storage arrays
//000046:             _scratch = new Color?[2][,] { new Color?[width, height], new Color?[width, height] };
//000047: 
//000048:             // Populate the board randomly based on the provided initial density
//000049:             Random rand = new Random();
//000050:             for (int i = 0; i < width; i ++)
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_0010:  ldloc.3
    IL_0011:  brtrue.s   IL_001e

//000035:             if (width < 1) throw new ArgumentOutOfRangeException("width");
    IL_0013:  ldstr      "width"
    IL_0018:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_001d:  throw

//000036:             if (height < 1) throw new ArgumentOutOfRangeException("height");
    IL_001e:  ldarg.2
    IL_001f:  ldc.i4.1
    IL_0020:  clt
    IL_0022:  ldc.i4.0
    IL_0023:  ceq
    IL_0025:  stloc.3
//000037:             if (pool == null) throw new ArgumentNullException("pool");
//000038:             if (initialDensity < 0 || initialDensity > 1) throw new ArgumentOutOfRangeException("initialDensity");
//000039: 
//000040:             // Store parameters
//000041:             _pool = pool;
//000042:             Width = width;
//000043:             Height = height;
//000044: 
//000045:             // Create the storage arrays
//000046:             _scratch = new Color?[2][,] { new Color?[width, height], new Color?[width, height] };
//000047: 
//000048:             // Populate the board randomly based on the provided initial density
//000049:             Random rand = new Random();
//000050:             for (int i = 0; i < width; i ++)
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_0026:  ldloc.3
    IL_0027:  brtrue.s   IL_0034

//000036:             if (height < 1) throw new ArgumentOutOfRangeException("height");
    IL_0029:  ldstr      "height"
    IL_002e:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0033:  throw

//000037:             if (pool == null) throw new ArgumentNullException("pool");
    IL_0034:  ldarg.s    pool
    IL_0036:  ldnull
    IL_0037:  ceq
    IL_0039:  ldc.i4.0
    IL_003a:  ceq
    IL_003c:  stloc.3
//000038:             if (initialDensity < 0 || initialDensity > 1) throw new ArgumentOutOfRangeException("initialDensity");
//000039: 
//000040:             // Store parameters
//000041:             _pool = pool;
//000042:             Width = width;
//000043:             Height = height;
//000044: 
//000045:             // Create the storage arrays
//000046:             _scratch = new Color?[2][,] { new Color?[width, height], new Color?[width, height] };
//000047: 
//000048:             // Populate the board randomly based on the provided initial density
//000049:             Random rand = new Random();
//000050:             for (int i = 0; i < width; i ++)
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_003d:  ldloc.3
    IL_003e:  brtrue.s   IL_004b

//000037:             if (pool == null) throw new ArgumentNullException("pool");
    IL_0040:  ldstr      "pool"
    IL_0045:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_004a:  throw

//000038:             if (initialDensity < 0 || initialDensity > 1) throw new ArgumentOutOfRangeException("initialDensity");
    IL_004b:  ldarg.3
    IL_004c:  ldc.r8     0.0
    IL_0055:  blt.s      IL_0068

    IL_0057:  ldarg.3
    IL_0058:  ldc.r8     1.
    IL_0061:  cgt
    IL_0063:  ldc.i4.0
    IL_0064:  ceq
    IL_0066:  br.s       IL_0069

    IL_0068:  ldc.i4.0
    IL_0069:  stloc.3
//000039: 
//000040:             // Store parameters
//000041:             _pool = pool;
//000042:             Width = width;
//000043:             Height = height;
//000044: 
//000045:             // Create the storage arrays
//000046:             _scratch = new Color?[2][,] { new Color?[width, height], new Color?[width, height] };
//000047: 
//000048:             // Populate the board randomly based on the provided initial density
//000049:             Random rand = new Random();
//000050:             for (int i = 0; i < width; i ++)
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_006a:  ldloc.3
    IL_006b:  brtrue.s   IL_0078

//000038:             if (initialDensity < 0 || initialDensity > 1) throw new ArgumentOutOfRangeException("initialDensity");
    IL_006d:  ldstr      "initialDensity"
    IL_0072:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0077:  throw

//000039: 
//000040:             // Store parameters
//000041:             _pool = pool;
    IL_0078:  ldarg.0
    IL_0079:  ldarg.s    pool
    IL_007b:  stfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> GameOfLife.GameBoard::_pool
//000042:             Width = width;
    IL_0080:  ldarg.0
    IL_0081:  ldarg.1
    IL_0082:  call       instance void GameOfLife.GameBoard::set_Width(int32)
    IL_0087:  nop
//000043:             Height = height;
    IL_0088:  ldarg.0
    IL_0089:  ldarg.2
    IL_008a:  call       instance void GameOfLife.GameBoard::set_Height(int32)
    IL_008f:  nop
//000044: 
//000045:             // Create the storage arrays
//000046:             _scratch = new Color?[2][,] { new Color?[width, height], new Color?[width, height] };
    IL_0090:  ldarg.0
    IL_0091:  ldc.i4.2
    IL_0092:  newarr     valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]
    IL_0097:  stloc.s    CS$0$0001
    IL_0099:  ldloc.s    CS$0$0001
    IL_009b:  ldc.i4.0
    IL_009c:  ldarg.1
    IL_009d:  ldarg.2
    IL_009e:  newobj     instance void valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::.ctor(int32,
                                                                                                                                               int32)
    IL_00a3:  stelem.ref
    IL_00a4:  ldloc.s    CS$0$0001
    IL_00a6:  ldc.i4.1
    IL_00a7:  ldarg.1
    IL_00a8:  ldarg.2
    IL_00a9:  newobj     instance void valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::.ctor(int32,
                                                                                                                                               int32)
    IL_00ae:  stelem.ref
    IL_00af:  ldloc.s    CS$0$0001
    IL_00b1:  stfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] GameOfLife.GameBoard::_scratch
//000047: 
//000048:             // Populate the board randomly based on the provided initial density
//000049:             Random rand = new Random();
    IL_00b6:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_00bb:  stloc.0
//000050:             for (int i = 0; i < width; i ++)
    IL_00bc:  ldc.i4.0
    IL_00bd:  stloc.1
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_00be:  br.s       IL_0116

//000051:             {
    IL_00c0:  nop
//000052:                 for (int j = 0; j < height; j++)
    IL_00c1:  ldc.i4.0
    IL_00c2:  stloc.2
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_00c3:  br.s       IL_0109

//000053:                 {
    IL_00c5:  nop
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
    IL_00c6:  ldarg.0
    IL_00c7:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] GameOfLife.GameBoard::_scratch
    IL_00cc:  ldarg.0
    IL_00cd:  ldfld      int32 GameOfLife.GameBoard::_currentIndex
    IL_00d2:  ldelem.ref
    IL_00d3:  ldloc.1
    IL_00d4:  ldloc.2
    IL_00d5:  call       instance valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>& valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...]::Address(int32,
                                                                                                                                                                                                                                   int32)
    IL_00da:  ldloc.0
    IL_00db:  callvirt   instance float64 [mscorlib]System.Random::NextDouble()
    IL_00e0:  ldarg.3
    IL_00e1:  blt.s      IL_00ef

    IL_00e3:  ldloca.s   CS$0$0002
    IL_00e5:  initobj    valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
    IL_00eb:  ldloc.s    CS$0$0002
    IL_00ed:  br.s       IL_00ff

    IL_00ef:  ldloc.0
    IL_00f0:  callvirt   instance int32 [mscorlib]System.Random::Next()
    IL_00f5:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32)
    IL_00fa:  newobj     instance void valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>::.ctor(!0)
    IL_00ff:  stobj      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>
//000055:                 }
    IL_0104:  nop
//000052:                 for (int j = 0; j < height; j++)
    IL_0105:  ldloc.2
    IL_0106:  ldc.i4.1
    IL_0107:  add
    IL_0108:  stloc.2
    IL_0109:  ldloc.2
    IL_010a:  ldarg.2
    IL_010b:  clt
    IL_010d:  stloc.3
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_010e:  ldloc.3
    IL_010f:  brtrue.s   IL_00c5

//000056:             }
    IL_0111:  nop
//000050:             for (int i = 0; i < width; i ++)
    IL_0112:  ldloc.1
    IL_0113:  ldc.i4.1
    IL_0114:  add
    IL_0115:  stloc.1
    IL_0116:  ldloc.1
    IL_0117:  ldarg.1
    IL_0118:  clt
    IL_011a:  stloc.3
//000051:             {
//000052:                 for (int j = 0; j < height; j++)
//000053:                 {
//000054:                     _scratch[_currentIndex][i, j] = (rand.NextDouble() < initialDensity) ? Color.FromArgb(rand.Next()) : (Color?)null;
//000055:                 }
//000056:             }
//000057:         }
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_011b:  ldloc.3
    IL_011c:  brtrue.s   IL_00c0

//000057:         }
    IL_011e:  nop
    IL_011f:  ret
  } // end of method GameBoard::.ctor

  .method public hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          MoveNext() cil managed
  {
    // Code size       257 (0x101)
    .maxstack  3
    .locals init ([0] int32 nextIndex,
             [1] class [mscorlib]System.Random rand,
             [2] class [System.Drawing]System.Drawing.Bitmap bmp,
             [3] class [mscorlib]System.Action`1<int32> body,
             [4] int32 i,
             [5] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegate3',
             [6] class GameOfLife.GameBoard/'<>c__DisplayClass4' 'CS$<>8__locals5',
             [7] class GameOfLife.GameBoard/'<>c__DisplayClass1' 'CS$<>8__locals2',
             [8] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [9] bool CS$4$0001)
//000058: 
//000059:         /// <summary>Moves to the next stage of the game, returning a Bitmap that represents the state of the board.</summary>
//000060:         /// <returns>A bitmap that represents the state of the board.</returns>
//000061:         /// <remarks>The returned Bitmap should be added back to the pool supplied to the constructor when usage of it is complete.</remarks>
//000062:         public Bitmap MoveNext()
//000063:         {
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
//000066:             Color?[,] current = _scratch[_currentIndex];
//000067:             Color?[,] next = _scratch[nextIndex];
//000068:             Random rand = new Random();
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_0000:  newobj     instance void GameOfLife.GameBoard/'<>c__DisplayClass1'::.ctor()
    IL_0005:  stloc.s    'CS$<>8__locals2'
    IL_0007:  ldloc.s    'CS$<>8__locals2'
    IL_0009:  ldarg.0
    IL_000a:  stfld      class GameOfLife.GameBoard GameOfLife.GameBoard/'<>c__DisplayClass1'::'<>4__this'
//000063:         {
    IL_000f:  nop
//000064:             // Get the current and next stage board arrays
//000065:             int nextIndex = (_currentIndex + 1) % 2;
    IL_0010:  ldarg.0
    IL_0011:  ldfld      int32 GameOfLife.GameBoard::_currentIndex
    IL_0016:  ldc.i4.1
    IL_0017:  add
    IL_0018:  ldc.i4.2
    IL_0019:  rem
    IL_001a:  stloc.0
//000066:             Color?[,] current = _scratch[_currentIndex];
    IL_001b:  ldloc.s    'CS$<>8__locals2'
    IL_001d:  ldarg.0
    IL_001e:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] GameOfLife.GameBoard::_scratch
    IL_0023:  ldarg.0
    IL_0024:  ldfld      int32 GameOfLife.GameBoard::_currentIndex
    IL_0029:  ldelem.ref
    IL_002a:  stfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::current
//000067:             Color?[,] next = _scratch[nextIndex];
    IL_002f:  ldloc.s    'CS$<>8__locals2'
    IL_0031:  ldarg.0
    IL_0032:  ldfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...][] GameOfLife.GameBoard::_scratch
    IL_0037:  ldloc.0
    IL_0038:  ldelem.ref
    IL_0039:  stfld      valuetype [mscorlib]System.Nullable`1<valuetype [System.Drawing]System.Drawing.Color>[0...,0...] GameOfLife.GameBoard/'<>c__DisplayClass1'::next
//000068:             Random rand = new Random();
    IL_003e:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_0043:  stloc.1
//000069: 
//000070:             // Get a Bitmap from the pool to use
//000071:             var bmp = _pool.GetObject();
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> GameOfLife.GameBoard::_pool
    IL_004a:  callvirt   instance !0 class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap>::GetObject()
    IL_004f:  stloc.2
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
//000073:             {
//000074:                 // For every row
//000075:                 Action<int> body = i =>
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
    IL_0050:  ldnull
    IL_0051:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate3'
    IL_0053:  newobj     instance void GameOfLife.GameBoard/'<>c__DisplayClass4'::.ctor()
    IL_0058:  stloc.s    'CS$<>8__locals5'
    IL_005a:  ldloc.s    'CS$<>8__locals5'
    IL_005c:  ldloc.s    'CS$<>8__locals2'
    IL_005e:  stfld      class GameOfLife.GameBoard/'<>c__DisplayClass1' GameOfLife.GameBoard/'<>c__DisplayClass4'::'CS$<>8__locals2'
//000072:             using (FastBitmap fastBmp = new FastBitmap(bmp))
    IL_0063:  ldloc.s    'CS$<>8__locals5'
    IL_0065:  ldloc.2
    IL_0066:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_006b:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap GameOfLife.GameBoard/'<>c__DisplayClass4'::fastBmp
//000073:             {
    .try
    {
      IL_0070:  nop
//000074:                 // For every row
//000075:                 Action<int> body = i =>
      IL_0071:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate3'
      IL_0073:  brtrue.s   IL_0086

      IL_0075:  ldloc.s    'CS$<>8__locals5'
      IL_0077:  ldftn      instance void GameOfLife.GameBoard/'<>c__DisplayClass4'::'<MoveNext>b__0'(int32)
      IL_007d:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                       native int)
      IL_0082:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate3'
      IL_0084:  br.s       IL_0086

      IL_0086:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate3'
      IL_0088:  stloc.3
//000076:                 {
//000077:                     // For every column
//000078:                     for (int j = 0; j < Height; j++)
//000079:                     {
//000080:                         int count = 0;
//000081:                         int r = 0, g = 0, b = 0;
//000082: 
//000083:                         // Count neighbors
//000084:                         for (int x = i - 1; x <= i + 1; x++)
//000085:                         {
//000086:                             for (int y = j - 1; y <= j + 1; y++)
//000087:                             {
//000088:                                 if ((x == i && j == y) || x < 0 || x >= Width || y < 0 || y >= Height) continue;
//000089:                                 Color? c = current[x, y];
//000090:                                 if (c.HasValue)
//000091:                                 {
//000092:                                     count++;
//000093:                                     r += c.Value.R;
//000094:                                     g += c.Value.G;
//000095:                                     b += c.Value.B;
//000096:                                 }
//000097:                             }
//000098:                         }
//000099: 
//000100:                         // Heuristic for alive or dead based on neighbor count and current state
//000101:                         if (count < 1 || count >= 4) next[i, j] = null;
//000102:                         else if (current[i, j].HasValue && (count == 2 || count == 3)) next[i, j] = current[i, j];
//000103:                         else if (!current[i, j].HasValue && count == 3) next[i, j] = Color.FromArgb(r / count, g / count, b / count);
//000104:                         else next[i, j] = null;
//000105: 
//000106:                         // Render the cell
//000107:                         fastBmp.SetColor(i, j, current[i, j] ?? Color.White);
//000108:                     }
//000109:                 };
//000110: 
//000111:                 // Process the rows serially or in parallel based on the RunParallel property setting
//000112:                 if (RunParallel)
      IL_0089:  ldarg.0
      IL_008a:  call       instance bool GameOfLife.GameBoard::get_RunParallel()
      IL_008f:  ldc.i4.0
      IL_0090:  ceq
      IL_0092:  stloc.s    CS$4$0001
//000113:                 {
//000114:                     Parallel.For(0, Width, 
//000115:                         body);
//000116:                 }
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_0094:  ldloc.s    CS$4$0001
      IL_0096:  brtrue.s   IL_00aa

//000113:                 {
      IL_0098:  nop
//000114:                     Parallel.For(0, Width, 
      IL_0099:  ldc.i4.0
      IL_009a:  ldarg.0
      IL_009b:  call       instance int32 GameOfLife.GameBoard::get_Width()
      IL_00a0:  ldloc.3
      IL_00a1:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                        int32,
                                                                                                                                        class [mscorlib]System.Action`1<int32>)
      IL_00a6:  pop
//000115:                         body);
//000116:                 }
      IL_00a7:  nop
//000117:                 else
//000118:                 {
//000119:                     for (int i = 0; i < Width; i++) 
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_00a8:  br.s       IL_00d0

//000118:                 {
      IL_00aa:  nop
//000119:                     for (int i = 0; i < Width; i++) 
      IL_00ab:  ldc.i4.0
      IL_00ac:  stloc.s    i
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_00ae:  br.s       IL_00bf

//000120:                         body(i);
      IL_00b0:  ldloc.3
      IL_00b1:  ldloc.s    i
      IL_00b3:  callvirt   instance void class [mscorlib]System.Action`1<int32>::Invoke(!0)
      IL_00b8:  nop
//000119:                     for (int i = 0; i < Width; i++) 
      IL_00b9:  ldloc.s    i
      IL_00bb:  ldc.i4.1
      IL_00bc:  add
      IL_00bd:  stloc.s    i
      IL_00bf:  ldloc.s    i
      IL_00c1:  ldarg.0
      IL_00c2:  call       instance int32 GameOfLife.GameBoard::get_Width()
      IL_00c7:  clt
      IL_00c9:  stloc.s    CS$4$0001
//000120:                         body(i);
//000121:                 }
//000122:             }
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_00cb:  ldloc.s    CS$4$0001
      IL_00cd:  brtrue.s   IL_00b0

//000121:                 }
      IL_00cf:  nop
//000122:             }
      IL_00d0:  nop
//000123: 
//000124:             // Update and return
//000125:             _currentIndex = nextIndex;
//000126:             return bmp;
//000127:         }
//000128: 
//000129:         /// <summary>Gets the width of the board.</summary>
//000130:         public int Width { get; private set; }
//000131:         /// <summary>Gets the height of the board.</summary>
//000132:         public int Height { get; private set; }
//000133:         /// <summary>Gets or sets whether to run in parallel.</summary>
//000134:         public bool RunParallel { get; set; }
//000135:     }
//000136: }
      IL_00d1:  leave.s    IL_00f1

    }  // end .try
    finally
    {
      IL_00d3:  ldloc.s    'CS$<>8__locals5'
      IL_00d5:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap GameOfLife.GameBoard/'<>c__DisplayClass4'::fastBmp
      IL_00da:  ldnull
      IL_00db:  ceq
      IL_00dd:  stloc.s    CS$4$0001
      IL_00df:  ldloc.s    CS$4$0001
      IL_00e1:  brtrue.s   IL_00f0

      IL_00e3:  ldloc.s    'CS$<>8__locals5'
      IL_00e5:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap GameOfLife.GameBoard/'<>c__DisplayClass4'::fastBmp
      IL_00ea:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00ef:  nop
      IL_00f0:  endfinally
    }  // end handler
    IL_00f1:  nop
//000125:             _currentIndex = nextIndex;
    IL_00f2:  ldarg.0
    IL_00f3:  ldloc.0
    IL_00f4:  stfld      int32 GameOfLife.GameBoard::_currentIndex
//000126:             return bmp;
    IL_00f9:  ldloc.2
    IL_00fa:  stloc.s    CS$1$0000
    IL_00fc:  br.s       IL_00fe

//000127:         }
    IL_00fe:  ldloc.s    CS$1$0000
    IL_0100:  ret
  } // end of method GameBoard::MoveNext

  .method public hidebysig specialname instance int32 
          get_Width() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (int32 V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      int32 GameOfLife.GameBoard::'<Width>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method GameBoard::get_Width

  .method private hidebysig specialname instance void 
          set_Width(int32 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      int32 GameOfLife.GameBoard::'<Width>k__BackingField'
    IL_0007:  ret
  } // end of method GameBoard::set_Width

  .method public hidebysig specialname instance int32 
          get_Height() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (int32 V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      int32 GameOfLife.GameBoard::'<Height>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method GameBoard::get_Height

  .method private hidebysig specialname instance void 
          set_Height(int32 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      int32 GameOfLife.GameBoard::'<Height>k__BackingField'
    IL_0007:  ret
  } // end of method GameBoard::set_Height

  .method public hidebysig specialname instance bool 
          get_RunParallel() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (bool V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      bool GameOfLife.GameBoard::'<RunParallel>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method GameBoard::get_RunParallel

  .method public hidebysig specialname instance void 
          set_RunParallel(bool 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      bool GameOfLife.GameBoard::'<RunParallel>k__BackingField'
    IL_0007:  ret
  } // end of method GameBoard::set_RunParallel

  .property instance int32 Width()
  {
    .get instance int32 GameOfLife.GameBoard::get_Width()
    .set instance void GameOfLife.GameBoard::set_Width(int32)
  } // end of property GameBoard::Width
  .property instance int32 Height()
  {
    .get instance int32 GameOfLife.GameBoard::get_Height()
    .set instance void GameOfLife.GameBoard::set_Height(int32)
  } // end of property GameBoard::Height
  .property instance bool RunParallel()
  {
    .get instance bool GameOfLife.GameBoard::get_RunParallel()
    .set instance void GameOfLife.GameBoard::set_RunParallel(bool)
  } // end of property GameBoard::RunParallel
} // end of class GameOfLife.GameBoard

.class private auto ansi sealed beforefieldinit GameOfLife.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .field private static class GameOfLife.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class GameOfLife.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class GameOfLife.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class GameOfLife.Properties.Settings GameOfLife.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void GameOfLife.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  GameOfLife.Properties.Settings
    IL_000f:  stsfld     class GameOfLife.Properties.Settings GameOfLife.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class GameOfLife.Properties.Settings
          Default()
  {
    .get class GameOfLife.Properties.Settings GameOfLife.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class GameOfLife.Properties.Settings

.class private auto ansi beforefieldinit GameOfLife.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager GameOfLife.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("GameOfLife.Properties.Resources", typeof(Resources).Assembly);
//000043:                     resourceMan = temp;
//000044:                 }
//000045:                 return resourceMan;
//000046:             }
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
//000056:                 return resourceCulture;
//000057:             }
//000058:             set {
//000059:                 resourceCulture = value;
//000060:             }
//000061:         }
//000062:     }
//000063: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("GameOfLife.Properties.Resources", typeof(Resources).Assembly);
    IL_0014:  ldstr      "GameOfLife.Properties.Resources"
    IL_0019:  ldtoken    GameOfLife.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager GameOfLife.Properties.Resources::resourceMan
//000044:                 }
    IL_0034:  nop
//000045:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager GameOfLife.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000046:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
    IL_0000:  nop
//000056:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo GameOfLife.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000057:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000058:             set {
    IL_0000:  nop
//000059:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo GameOfLife.Properties.Resources::resourceCulture
//000060:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager GameOfLife.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Globalization.CultureInfo GameOfLife.Properties.Resources::get_Culture()
    .set void GameOfLife.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
  } // end of property Resources::Culture
} // end of class GameOfLife.Properties.Resources

.class public auto ansi beforefieldinit GameOfLife.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass8'
           extends [mscorlib]System.Object
    {
      .field public class GameOfLife.MainForm/'<>c__DisplayClass6' 'CS$<>8__locals7'
      .field public class [System.Drawing]System.Drawing.Bitmap bmp
      .field public float64 framesPerSecond
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass8'::.ctor

      .method public hidebysig instance void 
              '<btnRun_Click>b__4'() cil managed
      {
        // Code size       126 (0x7e)
        .maxstack  3
        .locals init ([0] class [System.Drawing]System.Drawing.Bitmap old,
                 [1] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\MainForm.cs' 
//000071:                         {
        IL_0000:  nop
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class GameOfLife.MainForm/'<>c__DisplayClass6' GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'CS$<>8__locals7'
        IL_0007:  ldfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
        IL_000c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
        IL_0011:  ldstr      "Frames / Sec: {0:F2}"
        IL_0016:  ldarg.0
        IL_0017:  ldfld      float64 GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::framesPerSecond
        IL_001c:  box        [mscorlib]System.Double
        IL_0021:  call       string [mscorlib]System.String::Format(string,
                                                                    object)
        IL_0026:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
        IL_002b:  nop
//000073:                             var old = (Bitmap)pictureBox1.Image;
        IL_002c:  ldarg.0
        IL_002d:  ldfld      class GameOfLife.MainForm/'<>c__DisplayClass6' GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'CS$<>8__locals7'
        IL_0032:  ldfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
        IL_0037:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
        IL_003c:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
        IL_0041:  castclass  [System.Drawing]System.Drawing.Bitmap
        IL_0046:  stloc.0
//000074:                             pictureBox1.Image = bmp;
        IL_0047:  ldarg.0
        IL_0048:  ldfld      class GameOfLife.MainForm/'<>c__DisplayClass6' GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'CS$<>8__locals7'
        IL_004d:  ldfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
        IL_0052:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
        IL_0057:  ldarg.0
        IL_0058:  ldfld      class [System.Drawing]System.Drawing.Bitmap GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::bmp
        IL_005d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
        IL_0062:  nop
//000075:                             if (old != null) pool.PutObject(old);
        IL_0063:  ldloc.0
        IL_0064:  ldnull
        IL_0065:  ceq
        IL_0067:  stloc.1
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
        IL_0068:  ldloc.1
        IL_0069:  brtrue.s   IL_007d

//000075:                             if (old != null) pool.PutObject(old);
        IL_006b:  ldarg.0
        IL_006c:  ldfld      class GameOfLife.MainForm/'<>c__DisplayClass6' GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'CS$<>8__locals7'
        IL_0071:  ldfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> GameOfLife.MainForm/'<>c__DisplayClass6'::pool
        IL_0076:  ldloc.0
        IL_0077:  callvirt   instance void class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap>::PutObject(!0)
        IL_007c:  nop
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
        IL_007d:  ret
      } // end of method '<>c__DisplayClass8'::'<btnRun_Click>b__4'

    } // end of class '<>c__DisplayClass8'

    .field public int32 width
    .field public int32 height
    .field public valuetype [mscorlib]System.Threading.CancellationToken token
    .field public class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> pool
    .field public class GameOfLife.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass6'::.ctor

    .method public hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
            '<btnRun_Click>b__1'() cil managed
    {
      // Code size       22 (0x16)
      .maxstack  3
      .locals init ([0] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000054:                 var pool = new ObjectPool<Bitmap>(() => new Bitmap(width, height));
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::width
      IL_0006:  ldarg.0
      IL_0007:  ldfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::height
      IL_000c:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                      int32)
      IL_0011:  stloc.0
      IL_0012:  br.s       IL_0014

//000055:                 _game = new GameBoard(width, height, initialDensity, pool) { RunParallel = chkParallel.Checked };
//000056: 
//000057:                 // Run the game on a background thread
//000058:                 Task.Factory.StartNew(() =>
//000059:                 {
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
      IL_0014:  ldloc.0
      IL_0015:  ret
    } // end of method '<>c__DisplayClass6'::'<btnRun_Click>b__1'

    .method public hidebysig instance void 
            '<btnRun_Click>b__3'() cil managed
    {
      // Code size       126 (0x7e)
      .maxstack  4
      .locals init ([0] class [System]System.Diagnostics.Stopwatch sw,
               [1] class GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8' 'CS$<>8__locals9',
               [2] valuetype [mscorlib]System.TimeSpan CS$0$0000,
               [3] bool CS$4$0001)
//000059:                 {
      IL_0000:  nop
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
      IL_0001:  newobj     instance void [System]System.Diagnostics.Stopwatch::.ctor()
      IL_0006:  stloc.0
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
      IL_0007:  br.s       IL_006b

      IL_0009:  newobj     instance void GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::.ctor()
      IL_000e:  stloc.1
      IL_000f:  ldloc.1
      IL_0010:  ldarg.0
      IL_0011:  stfld      class GameOfLife.MainForm/'<>c__DisplayClass6' GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'CS$<>8__locals7'
//000063:                     {
      IL_0016:  nop
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
      IL_0017:  ldloc.0
      IL_0018:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Restart()
      IL_001d:  nop
//000066:                         Bitmap bmp = _game.MoveNext();
      IL_001e:  ldloc.1
      IL_001f:  ldarg.0
      IL_0020:  ldfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0025:  ldfld      class GameOfLife.GameBoard GameOfLife.MainForm::_game
      IL_002a:  callvirt   instance class [System.Drawing]System.Drawing.Bitmap GameOfLife.GameBoard::MoveNext()
      IL_002f:  stfld      class [System.Drawing]System.Drawing.Bitmap GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::bmp
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
      IL_0034:  ldloc.1
      IL_0035:  ldc.r8     1.
      IL_003e:  ldloc.0
      IL_003f:  callvirt   instance valuetype [mscorlib]System.TimeSpan [System]System.Diagnostics.Stopwatch::get_Elapsed()
      IL_0044:  stloc.2
      IL_0045:  ldloca.s   CS$0$0000
      IL_0047:  call       instance float64 [mscorlib]System.TimeSpan::get_TotalSeconds()
      IL_004c:  div
      IL_004d:  stfld      float64 GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::framesPerSecond
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
      IL_0052:  ldarg.0
      IL_0053:  ldfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0058:  ldloc.1
      IL_0059:  ldftn      instance void GameOfLife.MainForm/'<>c__DisplayClass6'/'<>c__DisplayClass8'::'<btnRun_Click>b__4'()
      IL_005f:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_0064:  call       instance class [mscorlib]System.IAsyncResult [System.Windows.Forms]System.Windows.Forms.Control::BeginInvoke(class [mscorlib]System.Delegate)
      IL_0069:  pop
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
      IL_006a:  nop
//000062:                     while (!token.IsCancellationRequested)
      IL_006b:  ldarg.0
      IL_006c:  ldflda     valuetype [mscorlib]System.Threading.CancellationToken GameOfLife.MainForm/'<>c__DisplayClass6'::token
      IL_0071:  call       instance bool [mscorlib]System.Threading.CancellationToken::get_IsCancellationRequested()
      IL_0076:  ldc.i4.0
      IL_0077:  ceq
      IL_0079:  stloc.3
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
      IL_007a:  ldloc.3
      IL_007b:  brtrue.s   IL_0009

      IL_007d:  ret
    } // end of method '<>c__DisplayClass6'::'<btnRun_Click>b__3'

  } // end of class '<>c__DisplayClass6'

  .field private class [mscorlib]System.Threading.CancellationTokenSource _cancellation
  .field private class GameOfLife.GameBoard _game
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pictureBox1
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnRun
  .field private class [System.Windows.Forms]System.Windows.Forms.CheckBox chkParallel
  .field private class [System.Windows.Forms]System.Windows.Forms.TrackBar tbDensity
  .field private class [System.Windows.Forms]System.Windows.Forms.Label lblDensity
  .field private class [System.Windows.Forms]System.Windows.Forms.Label lblFramesPerSecond
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       24 (0x18)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\MainForm.Designer.cs' 
//000008:         private System.ComponentModel.IContainer components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.IContainer GameOfLife.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\MainForm.cs' 
//000021:         public MainForm()
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_000d:  nop
//000022:         {
    IL_000e:  nop
//000023:             InitializeComponent();
    IL_000f:  ldarg.0
    IL_0010:  call       instance void GameOfLife.MainForm::InitializeComponent()
    IL_0015:  nop
//000024:         }
    IL_0016:  nop
    IL_0017:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          chkParallel_CheckedChanged(object sender,
                                     class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       38 (0x26)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000025: 
//000026:         /// <summary>Used to cancel the current game.</summary>
//000027:         private CancellationTokenSource _cancellation;
//000028:         /// <summary>The current game.</summary>
//000029:         private GameBoard _game;
//000030: 
//000031:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000032:         {
    IL_0000:  nop
//000033:             if (_game != null) _game.RunParallel = chkParallel.Checked;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class GameOfLife.GameBoard GameOfLife.MainForm::_game
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.0
//000034:         }
//000035: 
//000036:         /// <summary>Run a game.</summary>
//000037:         private void btnRun_Click(object sender, EventArgs e)
//000038:         {
//000039:             // If no game is currently running, run one
//000040:             if (_cancellation == null)
//000041:             {
//000042:                 // Clear the current image, get the size of the board to use, initialize cancellation,
//000043:                 // and prepare the form for game running.
//000044:                 pictureBox1.Image = null;
//000045:                 int width = pictureBox1.Width, height = pictureBox1.Height;
//000046:                 _cancellation = new CancellationTokenSource();
//000047:                 var token = _cancellation.Token;
//000048:                 lblDensity.Visible = false;
//000049:                 tbDensity.Visible = false;
//000050:                 btnRun.Text = "Stop";
//000051:                 double initialDensity = tbDensity.Value / 1000.0;
//000052: 
//000053:                 // Initialize the object pool and the game board
//000054:                 var pool = new ObjectPool<Bitmap>(() => new Bitmap(width, height));
//000055:                 _game = new GameBoard(width, height, initialDensity, pool) { RunParallel = chkParallel.Checked };
//000056: 
//000057:                 // Run the game on a background thread
//000058:                 Task.Factory.StartNew(() =>
//000059:                 {
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
    IL_000b:  ldloc.0
    IL_000c:  brtrue.s   IL_0025

//000033:             if (_game != null) _game.RunParallel = chkParallel.Checked;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class GameOfLife.GameBoard GameOfLife.MainForm::_game
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_001a:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
    IL_001f:  callvirt   instance void GameOfLife.GameBoard::set_RunParallel(bool)
    IL_0024:  nop
//000034:         }
    IL_0025:  ret
  } // end of method MainForm::chkParallel_CheckedChanged

  .method private hidebysig instance void 
          btnRun_Click(object sender,
                       class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       327 (0x147)
    .maxstack  6
    .locals init ([0] float64 initialDensity,
             [1] class GameOfLife.GameBoard '<>g__initLocal0',
             [2] class GameOfLife.MainForm/'<>c__DisplayClass6' 'CS$<>8__locals7',
             [3] class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task> 'CS$<>9__CachedAnonymousMethodDelegate5',
             [4] bool CS$4$0000)
//000035: 
//000036:         /// <summary>Run a game.</summary>
//000037:         private void btnRun_Click(object sender, EventArgs e)
//000038:         {
//000039:             // If no game is currently running, run one
//000040:             if (_cancellation == null)
//000041:             {
//000042:                 // Clear the current image, get the size of the board to use, initialize cancellation,
//000043:                 // and prepare the form for game running.
//000044:                 pictureBox1.Image = null;
//000045:                 int width = pictureBox1.Width, height = pictureBox1.Height;
//000046:                 _cancellation = new CancellationTokenSource();
//000047:                 var token = _cancellation.Token;
//000048:                 lblDensity.Visible = false;
//000049:                 tbDensity.Visible = false;
//000050:                 btnRun.Text = "Stop";
//000051:                 double initialDensity = tbDensity.Value / 1000.0;
//000052: 
//000053:                 // Initialize the object pool and the game board
//000054:                 var pool = new ObjectPool<Bitmap>(() => new Bitmap(width, height));
//000055:                 _game = new GameBoard(width, height, initialDensity, pool) { RunParallel = chkParallel.Checked };
//000056: 
//000057:                 // Run the game on a background thread
//000058:                 Task.Factory.StartNew(() =>
//000059:                 {
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
    IL_0000:  ldnull
    IL_0001:  stloc.3
//000038:         {
    IL_0002:  nop
//000039:             // If no game is currently running, run one
//000040:             if (_cancellation == null)
    IL_0003:  ldarg.0
    IL_0004:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource GameOfLife.MainForm::_cancellation
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.s    CS$4$0000
//000041:             {
//000042:                 // Clear the current image, get the size of the board to use, initialize cancellation,
//000043:                 // and prepare the form for game running.
//000044:                 pictureBox1.Image = null;
//000045:                 int width = pictureBox1.Width, height = pictureBox1.Height;
//000046:                 _cancellation = new CancellationTokenSource();
//000047:                 var token = _cancellation.Token;
//000048:                 lblDensity.Visible = false;
//000049:                 tbDensity.Visible = false;
//000050:                 btnRun.Text = "Stop";
//000051:                 double initialDensity = tbDensity.Value / 1000.0;
//000052: 
//000053:                 // Initialize the object pool and the game board
//000054:                 var pool = new ObjectPool<Bitmap>(() => new Bitmap(width, height));
//000055:                 _game = new GameBoard(width, height, initialDensity, pool) { RunParallel = chkParallel.Checked };
//000056: 
//000057:                 // Run the game on a background thread
//000058:                 Task.Factory.StartNew(() =>
//000059:                 {
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
    IL_0011:  ldloc.s    CS$4$0000
    IL_0013:  brtrue     IL_0139

    IL_0018:  newobj     instance void GameOfLife.MainForm/'<>c__DisplayClass6'::.ctor()
    IL_001d:  stloc.2
    IL_001e:  ldloc.2
    IL_001f:  ldarg.0
    IL_0020:  stfld      class GameOfLife.MainForm GameOfLife.MainForm/'<>c__DisplayClass6'::'<>4__this'
//000041:             {
    IL_0025:  nop
//000042:                 // Clear the current image, get the size of the board to use, initialize cancellation,
//000043:                 // and prepare the form for game running.
//000044:                 pictureBox1.Image = null;
    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_002c:  ldnull
    IL_002d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0032:  nop
//000045:                 int width = pictureBox1.Width, height = pictureBox1.Height;
    IL_0033:  ldloc.2
    IL_0034:  ldarg.0
    IL_0035:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_003a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_003f:  stfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::width
    IL_0044:  ldloc.2
    IL_0045:  ldarg.0
    IL_0046:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_004b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0050:  stfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::height
//000046:                 _cancellation = new CancellationTokenSource();
    IL_0055:  ldarg.0
    IL_0056:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
    IL_005b:  stfld      class [mscorlib]System.Threading.CancellationTokenSource GameOfLife.MainForm::_cancellation
//000047:                 var token = _cancellation.Token;
    IL_0060:  ldloc.2
    IL_0061:  ldarg.0
    IL_0062:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource GameOfLife.MainForm::_cancellation
    IL_0067:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_006c:  stfld      valuetype [mscorlib]System.Threading.CancellationToken GameOfLife.MainForm/'<>c__DisplayClass6'::token
//000048:                 lblDensity.Visible = false;
    IL_0071:  ldarg.0
    IL_0072:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_0077:  ldc.i4.0
    IL_0078:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_007d:  nop
//000049:                 tbDensity.Visible = false;
    IL_007e:  ldarg.0
    IL_007f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0084:  ldc.i4.0
    IL_0085:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_008a:  nop
//000050:                 btnRun.Text = "Stop";
    IL_008b:  ldarg.0
    IL_008c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0091:  ldstr      "Stop"
    IL_0096:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_009b:  nop
//000051:                 double initialDensity = tbDensity.Value / 1000.0;
    IL_009c:  ldarg.0
    IL_009d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_00a2:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_00a7:  conv.r8
    IL_00a8:  ldc.r8     1000.
    IL_00b1:  div
    IL_00b2:  stloc.0
//000052: 
//000053:                 // Initialize the object pool and the game board
//000054:                 var pool = new ObjectPool<Bitmap>(() => new Bitmap(width, height));
    IL_00b3:  ldloc.2
    IL_00b4:  ldloc.2
    IL_00b5:  ldftn      instance class [System.Drawing]System.Drawing.Bitmap GameOfLife.MainForm/'<>c__DisplayClass6'::'<btnRun_Click>b__1'()
    IL_00bb:  newobj     instance void class [mscorlib]System.Func`1<class [System.Drawing]System.Drawing.Bitmap>::.ctor(object,
                                                                                                                         native int)
    IL_00c0:  newobj     instance void class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap>::.ctor(class [mscorlib]System.Func`1<!0>)
    IL_00c5:  stfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> GameOfLife.MainForm/'<>c__DisplayClass6'::pool
//000055:                 _game = new GameBoard(width, height, initialDensity, pool) { RunParallel = chkParallel.Checked };
    IL_00ca:  ldarg.0
    IL_00cb:  ldloc.2
    IL_00cc:  ldfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::width
    IL_00d1:  ldloc.2
    IL_00d2:  ldfld      int32 GameOfLife.MainForm/'<>c__DisplayClass6'::height
    IL_00d7:  ldloc.0
    IL_00d8:  ldloc.2
    IL_00d9:  ldfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap> GameOfLife.MainForm/'<>c__DisplayClass6'::pool
    IL_00de:  newobj     instance void GameOfLife.GameBoard::.ctor(int32,
                                                                   int32,
                                                                   float64,
                                                                   class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<class [System.Drawing]System.Drawing.Bitmap>)
    IL_00e3:  stloc.1
    IL_00e4:  ldloc.1
    IL_00e5:  ldarg.0
    IL_00e6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_00eb:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
    IL_00f0:  callvirt   instance void GameOfLife.GameBoard::set_RunParallel(bool)
    IL_00f5:  nop
    IL_00f6:  ldloc.1
    IL_00f7:  stfld      class GameOfLife.GameBoard GameOfLife.MainForm::_game
//000056: 
//000057:                 // Run the game on a background thread
//000058:                 Task.Factory.StartNew(() =>
    IL_00fc:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0101:  ldloc.2
    IL_0102:  ldftn      instance void GameOfLife.MainForm/'<>c__DisplayClass6'::'<btnRun_Click>b__3'()
    IL_0108:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_010d:  ldloc.2
    IL_010e:  ldfld      valuetype [mscorlib]System.Threading.CancellationToken GameOfLife.MainForm/'<>c__DisplayClass6'::token
    IL_0113:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0118:  ldloc.3
    IL_0119:  brtrue.s   IL_012a

    IL_011b:  ldarg.0
    IL_011c:  ldftn      instance void GameOfLife.MainForm::'<btnRun_Click>b__2'(class [mscorlib]System.Threading.Tasks.Task)
    IL_0122:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>::.ctor(object,
                                                                                                                           native int)
    IL_0127:  stloc.3
    IL_0128:  br.s       IL_012a

    IL_012a:  ldloc.3
    IL_012b:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_0130:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>,
                                                                                                                                  class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_0135:  pop
//000059:                 {
//000060:                     // Run until cancellation is requested
//000061:                     var sw = new Stopwatch();
//000062:                     while (!token.IsCancellationRequested)
//000063:                     {
//000064:                         // Move to the next board, timing how long it takes
//000065:                         sw.Restart();
//000066:                         Bitmap bmp = _game.MoveNext();
//000067:                         var framesPerSecond = 1 / sw.Elapsed.TotalSeconds;
//000068: 
//000069:                         // Update the UI with the new board image
//000070:                         BeginInvoke((Action)(() =>
//000071:                         {
//000072:                             lblFramesPerSecond.Text = String.Format("Frames / Sec: {0:F2}", framesPerSecond);
//000073:                             var old = (Bitmap)pictureBox1.Image;
//000074:                             pictureBox1.Image = bmp;
//000075:                             if (old != null) pool.PutObject(old);
//000076:                         }));
//000077:                     }
//000078:                     
//000079:                     // When the game is done, reset the board.
//000080:                 }, token).ContinueWith(_ =>
//000081:                 {
//000082:                     _cancellation = null;
//000083:                     btnRun.Text = "Start";
//000084:                     lblDensity.Visible = true;
//000085:                     tbDensity.Visible = true;
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
    IL_0136:  nop
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
    IL_0137:  br.s       IL_0145

//000090:             else _cancellation.Cancel();
    IL_0139:  ldarg.0
    IL_013a:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource GameOfLife.MainForm::_cancellation
    IL_013f:  callvirt   instance void [mscorlib]System.Threading.CancellationTokenSource::Cancel()
    IL_0144:  nop
//000091:         }
    IL_0145:  nop
    IL_0146:  ret
  } // end of method MainForm::btnRun_Click

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer GameOfLife.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.pictureBox1 = new System.Windows.Forms.PictureBox();
//000032:             this.btnRun = new System.Windows.Forms.Button();
//000033:             this.chkParallel = new System.Windows.Forms.CheckBox();
//000034:             this.tbDensity = new System.Windows.Forms.TrackBar();
//000035:             this.lblDensity = new System.Windows.Forms.Label();
//000036:             this.lblFramesPerSecond = new System.Windows.Forms.Label();
//000037:             ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
//000038:             ((System.ComponentModel.ISupportInitialize)(this.tbDensity)).BeginInit();
//000039:             this.SuspendLayout();
//000040:             // 
//000041:             // pictureBox1
//000042:             // 
//000043:             this.pictureBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000044:                         | System.Windows.Forms.AnchorStyles.Left)
//000045:                         | System.Windows.Forms.AnchorStyles.Right)));
//000046:             this.pictureBox1.BackColor = System.Drawing.Color.White;
//000047:             this.pictureBox1.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
//000048:             this.pictureBox1.Location = new System.Drawing.Point(12, 41);
//000049:             this.pictureBox1.Name = "pictureBox1";
//000050:             this.pictureBox1.Size = new System.Drawing.Size(464, 413);
//000051:             this.pictureBox1.TabIndex = 0;
//000052:             this.pictureBox1.TabStop = false;
//000053:             // 
//000054:             // btnRun
//000055:             // 
//000056:             this.btnRun.Location = new System.Drawing.Point(12, 12);
//000057:             this.btnRun.Name = "btnRun";
//000058:             this.btnRun.Size = new System.Drawing.Size(75, 23);
//000059:             this.btnRun.TabIndex = 1;
//000060:             this.btnRun.Text = "Start";
//000061:             this.btnRun.UseVisualStyleBackColor = true;
//000062:             this.btnRun.Click += new System.EventHandler(this.btnRun_Click);
//000063:             // 
//000064:             // chkParallel
//000065:             // 
//000066:             this.chkParallel.AutoSize = true;
//000067:             this.chkParallel.Location = new System.Drawing.Point(93, 16);
//000068:             this.chkParallel.Name = "chkParallel";
//000069:             this.chkParallel.Size = new System.Drawing.Size(66, 17);
//000070:             this.chkParallel.TabIndex = 2;
//000071:             this.chkParallel.Text = "Parallel?";
//000072:             this.chkParallel.UseVisualStyleBackColor = true;
//000073:             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
//000074:             // 
//000075:             // tbDensity
//000076:             // 
//000077:             this.tbDensity.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
//000078:                         | System.Windows.Forms.AnchorStyles.Right)));
//000079:             this.tbDensity.Location = new System.Drawing.Point(325, 12);
//000080:             this.tbDensity.Maximum = 1000;
//000081:             this.tbDensity.Minimum = 1;
//000082:             this.tbDensity.Name = "tbDensity";
//000083:             this.tbDensity.Size = new System.Drawing.Size(151, 45);
//000084:             this.tbDensity.TabIndex = 3;
//000085:             this.tbDensity.TickStyle = System.Windows.Forms.TickStyle.None;
//000086:             this.tbDensity.Value = 100;
//000087:             // 
//000088:             // lblDensity
//000089:             // 
//000090:             this.lblDensity.AutoSize = true;
//000091:             this.lblDensity.Location = new System.Drawing.Point(250, 16);
//000092:             this.lblDensity.Name = "lblDensity";
//000093:             this.lblDensity.Size = new System.Drawing.Size(69, 13);
//000094:             this.lblDensity.TabIndex = 4;
//000095:             this.lblDensity.Text = "Initial Density";
//000096:             // 
//000097:             // lblFramesPerSecond
//000098:             // 
//000099:             this.lblFramesPerSecond.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000100:             this.lblFramesPerSecond.AutoSize = true;
//000101:             this.lblFramesPerSecond.Location = new System.Drawing.Point(13, 457);
//000102:             this.lblFramesPerSecond.Name = "lblFramesPerSecond";
//000103:             this.lblFramesPerSecond.Size = new System.Drawing.Size(77, 13);
//000104:             this.lblFramesPerSecond.TabIndex = 5;
//000105:             this.lblFramesPerSecond.Text = "Frames / Sec: ";
//000106:             // 
//000107:             // MainForm
//000108:             // 
//000109:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000110:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000111:             this.ClientSize = new System.Drawing.Size(488, 482);
//000112:             this.Controls.Add(this.lblFramesPerSecond);
//000113:             this.Controls.Add(this.lblDensity);
//000114:             this.Controls.Add(this.chkParallel);
//000115:             this.Controls.Add(this.btnRun);
//000116:             this.Controls.Add(this.pictureBox1);
//000117:             this.Controls.Add(this.tbDensity);
//000118:             this.Name = "MainForm";
//000119:             this.Text = "Conway\'s Game Of Life";
//000120:             ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
//000121:             ((System.ComponentModel.ISupportInitialize)(this.tbDensity)).EndInit();
//000122:             this.ResumeLayout(false);
//000123:             this.PerformLayout();
//000124: 
//000125:         }
//000126: 
//000127:         #endregion
//000128: 
//000129:         private System.Windows.Forms.PictureBox pictureBox1;
//000130:         private System.Windows.Forms.Button btnRun;
//000131:         private System.Windows.Forms.CheckBox chkParallel;
//000132:         private System.Windows.Forms.TrackBar tbDensity;
//000133:         private System.Windows.Forms.Label lblDensity;
//000134:         private System.Windows.Forms.Label lblFramesPerSecond;
//000135:     }
//000136: }
//000137: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer GameOfLife.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       1094 (0x446)
    .maxstack  4
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.pictureBox1 = new System.Windows.Forms.PictureBox();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0007:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
//000032:             this.btnRun = new System.Windows.Forms.Button();
    IL_000c:  ldarg.0
    IL_000d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_0012:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
//000033:             this.chkParallel = new System.Windows.Forms.CheckBox();
    IL_0017:  ldarg.0
    IL_0018:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::.ctor()
    IL_001d:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
//000034:             this.tbDensity = new System.Windows.Forms.TrackBar();
    IL_0022:  ldarg.0
    IL_0023:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_0028:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
//000035:             this.lblDensity = new System.Windows.Forms.Label();
    IL_002d:  ldarg.0
    IL_002e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_0033:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
//000036:             this.lblFramesPerSecond = new System.Windows.Forms.Label();
    IL_0038:  ldarg.0
    IL_0039:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_003e:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
//000037:             ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0049:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_004e:  nop
//000038:             ((System.ComponentModel.ISupportInitialize)(this.tbDensity)).BeginInit();
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0055:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_005a:  nop
//000039:             this.SuspendLayout();
    IL_005b:  ldarg.0
    IL_005c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0061:  nop
//000040:             // 
//000041:             // pictureBox1
//000042:             // 
//000043:             this.pictureBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_0062:  ldarg.0
    IL_0063:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0068:  ldc.i4.s   15
    IL_006a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_006f:  nop
//000044:                         | System.Windows.Forms.AnchorStyles.Left)
//000045:                         | System.Windows.Forms.AnchorStyles.Right)));
//000046:             this.pictureBox1.BackColor = System.Drawing.Color.White;
    IL_0070:  ldarg.0
    IL_0071:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0076:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_White()
    IL_007b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0080:  nop
//000047:             this.pictureBox1.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
    IL_0081:  ldarg.0
    IL_0082:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0087:  ldc.i4.2
    IL_0088:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_008d:  nop
//000048:             this.pictureBox1.Location = new System.Drawing.Point(12, 41);
    IL_008e:  ldarg.0
    IL_008f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0094:  ldc.i4.s   12
    IL_0096:  ldc.i4.s   41
    IL_0098:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_009d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_00a2:  nop
//000049:             this.pictureBox1.Name = "pictureBox1";
    IL_00a3:  ldarg.0
    IL_00a4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_00a9:  ldstr      "pictureBox1"
    IL_00ae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_00b3:  nop
//000050:             this.pictureBox1.Size = new System.Drawing.Size(464, 413);
    IL_00b4:  ldarg.0
    IL_00b5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_00ba:  ldc.i4     0x1d0
    IL_00bf:  ldc.i4     0x19d
    IL_00c4:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_00c9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_00ce:  nop
//000051:             this.pictureBox1.TabIndex = 0;
    IL_00cf:  ldarg.0
    IL_00d0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_00d5:  ldc.i4.0
    IL_00d6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_00db:  nop
//000052:             this.pictureBox1.TabStop = false;
    IL_00dc:  ldarg.0
    IL_00dd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_00e2:  ldc.i4.0
    IL_00e3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_00e8:  nop
//000053:             // 
//000054:             // btnRun
//000055:             // 
//000056:             this.btnRun.Location = new System.Drawing.Point(12, 12);
    IL_00e9:  ldarg.0
    IL_00ea:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_00ef:  ldc.i4.s   12
    IL_00f1:  ldc.i4.s   12
    IL_00f3:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_00f8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_00fd:  nop
//000057:             this.btnRun.Name = "btnRun";
    IL_00fe:  ldarg.0
    IL_00ff:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0104:  ldstr      "btnRun"
    IL_0109:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_010e:  nop
//000058:             this.btnRun.Size = new System.Drawing.Size(75, 23);
    IL_010f:  ldarg.0
    IL_0110:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0115:  ldc.i4.s   75
    IL_0117:  ldc.i4.s   23
    IL_0119:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_011e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0123:  nop
//000059:             this.btnRun.TabIndex = 1;
    IL_0124:  ldarg.0
    IL_0125:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_012a:  ldc.i4.1
    IL_012b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0130:  nop
//000060:             this.btnRun.Text = "Start";
    IL_0131:  ldarg.0
    IL_0132:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0137:  ldstr      "Start"
    IL_013c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0141:  nop
//000061:             this.btnRun.UseVisualStyleBackColor = true;
    IL_0142:  ldarg.0
    IL_0143:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0148:  ldc.i4.1
    IL_0149:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_014e:  nop
//000062:             this.btnRun.Click += new System.EventHandler(this.btnRun_Click);
    IL_014f:  ldarg.0
    IL_0150:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_0155:  ldarg.0
    IL_0156:  ldftn      instance void GameOfLife.MainForm::btnRun_Click(object,
                                                                         class [mscorlib]System.EventArgs)
    IL_015c:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0161:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_0166:  nop
//000063:             // 
//000064:             // chkParallel
//000065:             // 
//000066:             this.chkParallel.AutoSize = true;
    IL_0167:  ldarg.0
    IL_0168:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_016d:  ldc.i4.1
    IL_016e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0173:  nop
//000067:             this.chkParallel.Location = new System.Drawing.Point(93, 16);
    IL_0174:  ldarg.0
    IL_0175:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_017a:  ldc.i4.s   93
    IL_017c:  ldc.i4.s   16
    IL_017e:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0183:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0188:  nop
//000068:             this.chkParallel.Name = "chkParallel";
    IL_0189:  ldarg.0
    IL_018a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_018f:  ldstr      "chkParallel"
    IL_0194:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0199:  nop
//000069:             this.chkParallel.Size = new System.Drawing.Size(66, 17);
    IL_019a:  ldarg.0
    IL_019b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_01a0:  ldc.i4.s   66
    IL_01a2:  ldc.i4.s   17
    IL_01a4:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01a9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01ae:  nop
//000070:             this.chkParallel.TabIndex = 2;
    IL_01af:  ldarg.0
    IL_01b0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_01b5:  ldc.i4.2
    IL_01b6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_01bb:  nop
//000071:             this.chkParallel.Text = "Parallel?";
    IL_01bc:  ldarg.0
    IL_01bd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_01c2:  ldstr      "Parallel\?"
    IL_01c7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_01cc:  nop
//000072:             this.chkParallel.UseVisualStyleBackColor = true;
    IL_01cd:  ldarg.0
    IL_01ce:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_01d3:  ldc.i4.1
    IL_01d4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_01d9:  nop
//000073:             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
    IL_01da:  ldarg.0
    IL_01db:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_01e0:  ldarg.0
    IL_01e1:  ldftn      instance void GameOfLife.MainForm::chkParallel_CheckedChanged(object,
                                                                                       class [mscorlib]System.EventArgs)
    IL_01e7:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_01ec:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_01f1:  nop
//000074:             // 
//000075:             // tbDensity
//000076:             // 
//000077:             this.tbDensity.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
    IL_01f2:  ldarg.0
    IL_01f3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_01f8:  ldc.i4.s   13
    IL_01fa:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_01ff:  nop
//000078:                         | System.Windows.Forms.AnchorStyles.Right)));
//000079:             this.tbDensity.Location = new System.Drawing.Point(325, 12);
    IL_0200:  ldarg.0
    IL_0201:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0206:  ldc.i4     0x145
    IL_020b:  ldc.i4.s   12
    IL_020d:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0212:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0217:  nop
//000080:             this.tbDensity.Maximum = 1000;
    IL_0218:  ldarg.0
    IL_0219:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_021e:  ldc.i4     0x3e8
    IL_0223:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_0228:  nop
//000081:             this.tbDensity.Minimum = 1;
    IL_0229:  ldarg.0
    IL_022a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_022f:  ldc.i4.1
    IL_0230:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0235:  nop
//000082:             this.tbDensity.Name = "tbDensity";
    IL_0236:  ldarg.0
    IL_0237:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_023c:  ldstr      "tbDensity"
    IL_0241:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0246:  nop
//000083:             this.tbDensity.Size = new System.Drawing.Size(151, 45);
    IL_0247:  ldarg.0
    IL_0248:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_024d:  ldc.i4     0x97
    IL_0252:  ldc.i4.s   45
    IL_0254:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0259:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_025e:  nop
//000084:             this.tbDensity.TabIndex = 3;
    IL_025f:  ldarg.0
    IL_0260:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0265:  ldc.i4.3
    IL_0266:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_026b:  nop
//000085:             this.tbDensity.TickStyle = System.Windows.Forms.TickStyle.None;
    IL_026c:  ldarg.0
    IL_026d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0272:  ldc.i4.0
    IL_0273:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickStyle(valuetype [System.Windows.Forms]System.Windows.Forms.TickStyle)
    IL_0278:  nop
//000086:             this.tbDensity.Value = 100;
    IL_0279:  ldarg.0
    IL_027a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_027f:  ldc.i4.s   100
    IL_0281:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0286:  nop
//000087:             // 
//000088:             // lblDensity
//000089:             // 
//000090:             this.lblDensity.AutoSize = true;
    IL_0287:  ldarg.0
    IL_0288:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_028d:  ldc.i4.1
    IL_028e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0293:  nop
//000091:             this.lblDensity.Location = new System.Drawing.Point(250, 16);
    IL_0294:  ldarg.0
    IL_0295:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_029a:  ldc.i4     0xfa
    IL_029f:  ldc.i4.s   16
    IL_02a1:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_02a6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_02ab:  nop
//000092:             this.lblDensity.Name = "lblDensity";
    IL_02ac:  ldarg.0
    IL_02ad:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_02b2:  ldstr      "lblDensity"
    IL_02b7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_02bc:  nop
//000093:             this.lblDensity.Size = new System.Drawing.Size(69, 13);
    IL_02bd:  ldarg.0
    IL_02be:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_02c3:  ldc.i4.s   69
    IL_02c5:  ldc.i4.s   13
    IL_02c7:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_02cc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_02d1:  nop
//000094:             this.lblDensity.TabIndex = 4;
    IL_02d2:  ldarg.0
    IL_02d3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_02d8:  ldc.i4.4
    IL_02d9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_02de:  nop
//000095:             this.lblDensity.Text = "Initial Density";
    IL_02df:  ldarg.0
    IL_02e0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_02e5:  ldstr      "Initial Density"
    IL_02ea:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_02ef:  nop
//000096:             // 
//000097:             // lblFramesPerSecond
//000098:             // 
//000099:             this.lblFramesPerSecond.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_02f0:  ldarg.0
    IL_02f1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_02f6:  ldc.i4.6
    IL_02f7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_02fc:  nop
//000100:             this.lblFramesPerSecond.AutoSize = true;
    IL_02fd:  ldarg.0
    IL_02fe:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_0303:  ldc.i4.1
    IL_0304:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0309:  nop
//000101:             this.lblFramesPerSecond.Location = new System.Drawing.Point(13, 457);
    IL_030a:  ldarg.0
    IL_030b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_0310:  ldc.i4.s   13
    IL_0312:  ldc.i4     0x1c9
    IL_0317:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_031c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0321:  nop
//000102:             this.lblFramesPerSecond.Name = "lblFramesPerSecond";
    IL_0322:  ldarg.0
    IL_0323:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_0328:  ldstr      "lblFramesPerSecond"
    IL_032d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0332:  nop
//000103:             this.lblFramesPerSecond.Size = new System.Drawing.Size(77, 13);
    IL_0333:  ldarg.0
    IL_0334:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_0339:  ldc.i4.s   77
    IL_033b:  ldc.i4.s   13
    IL_033d:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0342:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0347:  nop
//000104:             this.lblFramesPerSecond.TabIndex = 5;
    IL_0348:  ldarg.0
    IL_0349:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_034e:  ldc.i4.5
    IL_034f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0354:  nop
//000105:             this.lblFramesPerSecond.Text = "Frames / Sec: ";
    IL_0355:  ldarg.0
    IL_0356:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_035b:  ldstr      "Frames / Sec: "
    IL_0360:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0365:  nop
//000106:             // 
//000107:             // MainForm
//000108:             // 
//000109:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0366:  ldarg.0
    IL_0367:  ldc.r4     6.
    IL_036c:  ldc.r4     13.
    IL_0371:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0376:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_037b:  nop
//000110:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_037c:  ldarg.0
    IL_037d:  ldc.i4.1
    IL_037e:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0383:  nop
//000111:             this.ClientSize = new System.Drawing.Size(488, 482);
    IL_0384:  ldarg.0
    IL_0385:  ldc.i4     0x1e8
    IL_038a:  ldc.i4     0x1e2
    IL_038f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0394:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_0399:  nop
//000112:             this.Controls.Add(this.lblFramesPerSecond);
    IL_039a:  ldarg.0
    IL_039b:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03a0:  ldarg.0
    IL_03a1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblFramesPerSecond
    IL_03a6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_03ab:  nop
//000113:             this.Controls.Add(this.lblDensity);
    IL_03ac:  ldarg.0
    IL_03ad:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03b2:  ldarg.0
    IL_03b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_03b8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_03bd:  nop
//000114:             this.Controls.Add(this.chkParallel);
    IL_03be:  ldarg.0
    IL_03bf:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03c4:  ldarg.0
    IL_03c5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox GameOfLife.MainForm::chkParallel
    IL_03ca:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_03cf:  nop
//000115:             this.Controls.Add(this.btnRun);
    IL_03d0:  ldarg.0
    IL_03d1:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03d6:  ldarg.0
    IL_03d7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_03dc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_03e1:  nop
//000116:             this.Controls.Add(this.pictureBox1);
    IL_03e2:  ldarg.0
    IL_03e3:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03e8:  ldarg.0
    IL_03e9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_03ee:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_03f3:  nop
//000117:             this.Controls.Add(this.tbDensity);
    IL_03f4:  ldarg.0
    IL_03f5:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_03fa:  ldarg.0
    IL_03fb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0400:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0405:  nop
//000118:             this.Name = "MainForm";
    IL_0406:  ldarg.0
    IL_0407:  ldstr      "MainForm"
    IL_040c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0411:  nop
//000119:             this.Text = "Conway\'s Game Of Life";
    IL_0412:  ldarg.0
    IL_0413:  ldstr      "Conway's Game Of Life"
    IL_0418:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_041d:  nop
//000120:             ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
    IL_041e:  ldarg.0
    IL_041f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox GameOfLife.MainForm::pictureBox1
    IL_0424:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0429:  nop
//000121:             ((System.ComponentModel.ISupportInitialize)(this.tbDensity)).EndInit();
    IL_042a:  ldarg.0
    IL_042b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_0430:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0435:  nop
//000122:             this.ResumeLayout(false);
    IL_0436:  ldarg.0
    IL_0437:  ldc.i4.0
    IL_0438:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_043d:  nop
//000123:             this.PerformLayout();
    IL_043e:  ldarg.0
    IL_043f:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_0444:  nop
//000124: 
//000125:         }
    IL_0445:  ret
  } // end of method MainForm::InitializeComponent

  .method private hidebysig instance void 
          '<btnRun_Click>b__2'(class [mscorlib]System.Threading.Tasks.Task _) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       52 (0x34)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\GameOfLife\GameOfLife_CSharp\MainForm.cs' 
//000081:                 {
    IL_0000:  nop
//000082:                     _cancellation = null;
    IL_0001:  ldarg.0
    IL_0002:  ldnull
    IL_0003:  stfld      class [mscorlib]System.Threading.CancellationTokenSource GameOfLife.MainForm::_cancellation
//000083:                     btnRun.Text = "Start";
    IL_0008:  ldarg.0
    IL_0009:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button GameOfLife.MainForm::btnRun
    IL_000e:  ldstr      "Start"
    IL_0013:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0018:  nop
//000084:                     lblDensity.Visible = true;
    IL_0019:  ldarg.0
    IL_001a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label GameOfLife.MainForm::lblDensity
    IL_001f:  ldc.i4.1
    IL_0020:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_0025:  nop
//000085:                     tbDensity.Visible = true;
    IL_0026:  ldarg.0
    IL_0027:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar GameOfLife.MainForm::tbDensity
    IL_002c:  ldc.i4.1
    IL_002d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_0032:  nop
//000086:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000087:             }
//000088: 
//000089:                 // If a game is currently running, cancel it
//000090:             else _cancellation.Cancel();
//000091:         }
//000092:     }
//000093: }
    IL_0033:  ret
  } // end of method MainForm::'<btnRun_Click>b__2'

} // end of class GameOfLife.MainForm


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
