<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="26" endline="26"><![CDATA[
 		private PlatformDetection(){}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="27" endline="44"><![CDATA[
 
 		/// <summary>Whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		private static bool _inkAssemblyAvailable = (LoadInkAssembly() != null);
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
 		private static Assembly LoadInkAssembly()
 		{
 			try 
 			{ 
 				return LoadInkAssemblyInternal(); 
 			}
 			catch(TypeLoadException) {}
 			catch(IOException){}
 			catch(SecurityException){}
 			catch(BadImageFormatException){}
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			catch(IOException){}
 			catch(SecurityException){}
 			catch(BadImageFormatException){}
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			catch(SecurityException){}
 			catch(BadImageFormatException){}
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			catch(BadImageFormatException){}
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="45" endline="52"><![CDATA[
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="53" endline="55"><![CDATA[
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="56" endline="58"><![CDATA[
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="59" endline="67"><![CDATA[
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="68" endline="95"><![CDATA[
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 			return recognizer;
 		}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="96" endline="100"><![CDATA[
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="101" endline="120"><![CDATA[
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 				catch{}
 				return false;
 			}
 		}
 	}
 }
 				return false;
 			}
 		}
 	}
 }
 			}
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\PlatformDetection.cs" startline="29" endline="123"><![CDATA[
 		private static bool _inkAssemblyAvailable = (LoadInkAssembly() != null);
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink if it's available; null, otherwise.</returns>
 		private static Assembly LoadInkAssembly()
 		{
 			try 
 			{ 
 				return LoadInkAssemblyInternal(); 
 			}
 			catch(TypeLoadException) {}
 			catch(IOException){}
 			catch(SecurityException){}
 			catch(BadImageFormatException){}
 			return null;
 		}
 
 		/// <summary>Loads the Microsoft.Ink.dll assembly.</summary>
 		/// <returns>The Assembly instance for Microsoft.Ink.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		private static Assembly LoadInkAssemblyInternal()
 		{
 			return typeof(InkOverlay).Assembly;
 		}
 
         /// <summary>Gets whether this platform supports using ink.</summary>
         public static bool SupportsInk { get { return InkAssemblyAvailable && RecognizerInstalled; } }
 
 		/// <summary>Gets whether the correct version of the Microsoft.Ink.dll assembly is installed and available.</summary>
 		public static bool InkAssemblyAvailable { get { return _inkAssemblyAvailable; } }
 
 		/// <summary>Gets whether a valid recognizer is installed.</summary>
 		public static bool RecognizerInstalled
 		{
 			get
 			{
 				if (!_inkAssemblyAvailable) return false;
 				return GetDefaultRecognizer() != null;
 			}
 		}
 
 		/// <summary>Gets the best recognizer for the current locale.</summary>
 		/// <returns>The best recognizer for the current locale.</returns>
 		[MethodImpl(MethodImplOptions.NoInlining)]
 		public static Recognizer GetDefaultRecognizer() 
 		{
 			Recognizer recognizer = null;
 			try 
 			{ 
 				Recognizers recognizers = new Recognizers();
 				if (recognizers.Count > 1)
 				{
 					// First try the current locale's recognizer
 					try { recognizer = recognizers.GetDefaultRecognizer(); } 
 					catch {}
 					
 					// Fallback to the en-US (1033) recognizer
 					if (recognizer == null)
 					{
 						try { recognizer = recognizers.GetDefaultRecognizer(1033); }
 						catch {}
 					}
 				}
 			}
 			catch {} 
 			return recognizer;
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		public static bool GestureRecognizerInstalled
 		{
 			get { return _inkAssemblyAvailable && GestureRecognizerInstalledInternal; }
 		}
 
 		/// <summary>Gets whether a gesture recognizer is installed and available for use.</summary>
 		/// <remarks>Should only be called if the Microsoft.Ink assembly is already known to be available.</remarks>
 		private static bool GestureRecognizerInstalledInternal 
 		{
 			[MethodImpl(MethodImplOptions.NoInlining)]
 			get
 			{
 				try
 				{
 					Recognizers recognizers = new Recognizers();
 					if (recognizers.Count > 0)
 					{
 						using(new GestureRecognizer()) return true;
 					}
 				}
 				catch{}
 				return false;
 			}
 		}
 	}
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Settings.Designer.cs" startline="21" endline="23"><![CDATA[
             get {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Settings.Designer.cs" startline="18" endline="26"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
         
         public static Settings Default {
             get {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.bwColorize = new System.ComponentModel.BackgroundWorker();
             this.tmRefresh = new System.Windows.Forms.Timer(this.components);
             this.toolStripContainer = new System.Windows.Forms.ToolStripContainer();
             this.pbImage = new System.Windows.Forms.PictureBox();
             this.toolStripMain = new System.Windows.Forms.ToolStrip();
             this.btnLoadImage = new System.Windows.Forms.ToolStripButton();
             this.btnSaveImage = new System.Windows.Forms.ToolStripButton();
             this.separator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tbEpsilon = new Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar();
             this.separator2 = new System.Windows.Forms.ToolStripSeparator();
             this.btnParallel = new System.Windows.Forms.ToolStripButton();
             this.btnInk = new System.Windows.Forms.ToolStripButton();
             this.btnEraser = new System.Windows.Forms.ToolStripButton();
             this.pbColorizing = new System.Windows.Forms.ToolStripProgressBar();
             this.lblHuesSelected = new System.Windows.Forms.ToolStripLabel();
             this.toolStripContainer.ContentPanel.SuspendLayout();
             this.toolStripContainer.TopToolStripPanel.SuspendLayout();
             this.toolStripContainer.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
             this.toolStripMain.SuspendLayout();
             this.SuspendLayout();
             // 
             // bwColorize
             // 
             this.bwColorize.WorkerReportsProgress = true;
             this.bwColorize.DoWork += new System.ComponentModel.DoWorkEventHandler(this.bwColorize_DoWork);
             this.bwColorize.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.bwColorize_RunWorkerCompleted);
             this.bwColorize.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.bwColorize_ProgressChanged);
             // 
             // tmRefresh
             // 
             this.tmRefresh.Interval = 1000;
             this.tmRefresh.Tick += new System.EventHandler(this.tmRefresh_Tick);
             // 
             // toolStripContainer
             // 
             // 
             // toolStripContainer.ContentPanel
             // 
             this.toolStripContainer.ContentPanel.Controls.Add(this.pbImage);
             this.toolStripContainer.ContentPanel.Size = new System.Drawing.Size(619, 397);
             this.toolStripContainer.Dock = System.Windows.Forms.DockStyle.Fill;
             this.toolStripContainer.Location = new System.Drawing.Point(0, 0);
             this.toolStripContainer.Name = "toolStripContainer";
             this.toolStripContainer.Size = new System.Drawing.Size(619, 422);
             this.toolStripContainer.TabIndex = 10;
             this.toolStripContainer.Text = "toolStripContainer1";
             // 
             // toolStripContainer.TopToolStripPanel
             // 
             this.toolStripContainer.TopToolStripPanel.Controls.Add(this.toolStripMain);
             // 
             // pbImage
             // 
             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbImage.Cursor = System.Windows.Forms.Cursors.Default;
             this.pbImage.Location = new System.Drawing.Point(3, 3);
             this.pbImage.Name = "pbImage";
             this.pbImage.Size = new System.Drawing.Size(613, 391);
             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
             this.pbImage.TabIndex = 10;
             this.pbImage.TabStop = false;
             this.pbImage.DragDrop += new System.Windows.Forms.DragEventHandler(this.pbImage_DragDrop);
             this.pbImage.Resize += new System.EventHandler(this.pbImage_Resize);
             this.pbImage.MouseClick += new System.Windows.Forms.MouseEventHandler(this.pbImage_MouseClick);
             this.pbImage.DragEnter += new System.Windows.Forms.DragEventHandler(this.pbImage_DragEnter);
             // 
             // toolStripMain
             // 
             this.toolStripMain.AllowItemReorder = true;
             this.toolStripMain.Dock = System.Windows.Forms.DockStyle.None;
             this.toolStripMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.btnLoadImage,
             this.btnSaveImage,
             this.separator1,
             this.tbEpsilon,
             this.separator2,
             this.btnParallel,
             this.btnInk,
             this.btnEraser,
             this.pbColorizing,
             this.lblHuesSelected});
             this.toolStripMain.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
             this.toolStripMain.Location = new System.Drawing.Point(3, 0);
             this.toolStripMain.Name = "toolStripMain";
             this.toolStripMain.Size = new System.Drawing.Size(616, 25);
             this.toolStripMain.TabIndex = 9;
             this.toolStripMain.Text = "toolStrip1";
             // 
             // btnLoadImage
             // 
             this.btnLoadImage.Image = global
             this.btnLoadImage.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnLoadImage.Name = "btnLoadImage";
             this.btnLoadImage.Size = new System.Drawing.Size(89, 22);
             this.btnLoadImage.Text = "&Load Image";
             this.btnLoadImage.Click += new System.EventHandler(this.btnLoadImage_Click);
             // 
             // btnSaveImage
             // 
             this.btnSaveImage.Image = global
             this.btnSaveImage.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnSaveImage.Name = "btnSaveImage";
             this.btnSaveImage.Size = new System.Drawing.Size(87, 22);
             this.btnSaveImage.Text = "&Save Image";
             this.btnSaveImage.Click += new System.EventHandler(this.btnSaveImage_Click);
             // 
             // separator1
             // 
             this.separator1.Name = "separator1";
             this.separator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tbEpsilon
             // 
             this.tbEpsilon.BackColor = System.Drawing.SystemColors.Control;
             this.tbEpsilon.Maximum = 180;
             this.tbEpsilon.Name = "tbEpsilon";
             this.tbEpsilon.Size = new System.Drawing.Size(150, 22);
             this.tbEpsilon.Text = "toolStripTrackBar1";
             this.tbEpsilon.Value = 15;
             this.tbEpsilon.ValueChanged += new System.EventHandler(this.tbEpsilon_ValueChanged);
             // 
             // separator2
             // 
             this.separator2.Name = "separator2";
             this.separator2.Size = new System.Drawing.Size(6, 25);
             // 
             // btnParallel
             // 
             this.btnParallel.CheckOnClick = true;
             this.btnParallel.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnParallel.Image = ((System.Drawing.Image)(resources.GetObject("btnParallel.Image")));
             this.btnParallel.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnParallel.Name = "btnParallel";
             this.btnParallel.Size = new System.Drawing.Size(23, 22);
             this.btnParallel.Text = "btnParallel";
             this.btnParallel.CheckedChanged += new System.EventHandler(this.btnParallel_CheckedChanged);
             // 
             // btnInk
             // 
             this.btnInk.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnInk.Enabled = false;
             this.btnInk.Image = global
             this.btnInk.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnInk.Name = "btnInk";
             this.btnInk.Size = new System.Drawing.Size(23, 22);
             this.btnInk.Text = "btnInk";
             this.btnInk.Click += new System.EventHandler(this.btnInk_Click);
             // 
             // btnEraser
             // 
             this.btnEraser.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnEraser.Enabled = false;
             this.btnEraser.Image = global
             this.btnEraser.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnEraser.Name = "btnEraser";
             this.btnEraser.Size = new System.Drawing.Size(23, 22);
             this.btnEraser.Text = "btnEraser";
             this.btnEraser.Click += new System.EventHandler(this.btnEraser_Click);
             // 
             // pbColorizing
             // 
             this.pbColorizing.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.pbColorizing.Name = "pbColorizing";
             this.pbColorizing.Overflow = System.Windows.Forms.ToolStripItemOverflow.Never;
             this.pbColorizing.Size = new System.Drawing.Size(140, 22);
             this.pbColorizing.Visible = false;
             // 
             // lblHuesSelected
             // 
             this.lblHuesSelected.Name = "lblHuesSelected";
             this.lblHuesSelected.Size = new System.Drawing.Size(81, 15);
             this.lblHuesSelected.Text = "Hues Selected";
             this.lblHuesSelected.Click += new System.EventHandler(this.lblHuesSelected_Click);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(619, 422);
             this.Controls.Add(this.toolStripContainer);
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.KeyPreview = true;
             this.Name = "MainForm";
             this.Text = "Image Colorizer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             this.toolStripContainer.ContentPanel.ResumeLayout(false);
             this.toolStripContainer.TopToolStripPanel.ResumeLayout(false);
             this.toolStripContainer.TopToolStripPanel.PerformLayout();
             this.toolStripContainer.ResumeLayout(false);
             this.toolStripContainer.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
             this.toolStripMain.ResumeLayout(false);
             this.toolStripMain.PerformLayout();
             this.ResumeLayout(false);
 
         }
 
         #endregion
 
         private System.ComponentModel.BackgroundWorker bwColorize;
         private System.Windows.Forms.Timer tmRefresh;
         private System.Windows.Forms.ToolStripContainer toolStripContainer;
         private System.Windows.Forms.PictureBox pbImage;
         private System.Windows.Forms.ToolStrip toolStripMain;
         private System.Windows.Forms.ToolStripButton btnLoadImage;
         private System.Windows.Forms.ToolStripButton btnSaveImage;
         private System.Windows.Forms.ToolStripSeparator separator1;
         private ToolStripTrackBar tbEpsilon;
         private System.Windows.Forms.ToolStripSeparator separator2;
         private System.Windows.Forms.ToolStripButton btnInk;
         private System.Windows.Forms.ToolStripButton btnEraser;
         private System.Windows.Forms.ToolStripProgressBar pbColorizing;
         private System.Windows.Forms.ToolStripLabel lblHuesSelected;
         private System.Windows.Forms.ToolStripButton btnParallel;
     }
 }
 
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.Designer.cs" startline="22" endline="232"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
             this.bwColorize = new System.ComponentModel.BackgroundWorker();
             this.tmRefresh = new System.Windows.Forms.Timer(this.components);
             this.toolStripContainer = new System.Windows.Forms.ToolStripContainer();
             this.pbImage = new System.Windows.Forms.PictureBox();
             this.toolStripMain = new System.Windows.Forms.ToolStrip();
             this.btnLoadImage = new System.Windows.Forms.ToolStripButton();
             this.btnSaveImage = new System.Windows.Forms.ToolStripButton();
             this.separator1 = new System.Windows.Forms.ToolStripSeparator();
             this.tbEpsilon = new Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ToolStripTrackBar();
             this.separator2 = new System.Windows.Forms.ToolStripSeparator();
             this.btnParallel = new System.Windows.Forms.ToolStripButton();
             this.btnInk = new System.Windows.Forms.ToolStripButton();
             this.btnEraser = new System.Windows.Forms.ToolStripButton();
             this.pbColorizing = new System.Windows.Forms.ToolStripProgressBar();
             this.lblHuesSelected = new System.Windows.Forms.ToolStripLabel();
             this.toolStripContainer.ContentPanel.SuspendLayout();
             this.toolStripContainer.TopToolStripPanel.SuspendLayout();
             this.toolStripContainer.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
             this.toolStripMain.SuspendLayout();
             this.SuspendLayout();
             // 
             // bwColorize
             // 
             this.bwColorize.WorkerReportsProgress = true;
             this.bwColorize.DoWork += new System.ComponentModel.DoWorkEventHandler(this.bwColorize_DoWork);
             this.bwColorize.RunWorkerCompleted += new System.ComponentModel.RunWorkerCompletedEventHandler(this.bwColorize_RunWorkerCompleted);
             this.bwColorize.ProgressChanged += new System.ComponentModel.ProgressChangedEventHandler(this.bwColorize_ProgressChanged);
             // 
             // tmRefresh
             // 
             this.tmRefresh.Interval = 1000;
             this.tmRefresh.Tick += new System.EventHandler(this.tmRefresh_Tick);
             // 
             // toolStripContainer
             // 
             // 
             // toolStripContainer.ContentPanel
             // 
             this.toolStripContainer.ContentPanel.Controls.Add(this.pbImage);
             this.toolStripContainer.ContentPanel.Size = new System.Drawing.Size(619, 397);
             this.toolStripContainer.Dock = System.Windows.Forms.DockStyle.Fill;
             this.toolStripContainer.Location = new System.Drawing.Point(0, 0);
             this.toolStripContainer.Name = "toolStripContainer";
             this.toolStripContainer.Size = new System.Drawing.Size(619, 422);
             this.toolStripContainer.TabIndex = 10;
             this.toolStripContainer.Text = "toolStripContainer1";
             // 
             // toolStripContainer.TopToolStripPanel
             // 
             this.toolStripContainer.TopToolStripPanel.Controls.Add(this.toolStripMain);
             // 
             // pbImage
             // 
             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbImage.Cursor = System.Windows.Forms.Cursors.Default;
             this.pbImage.Location = new System.Drawing.Point(3, 3);
             this.pbImage.Name = "pbImage";
             this.pbImage.Size = new System.Drawing.Size(613, 391);
             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
             this.pbImage.TabIndex = 10;
             this.pbImage.TabStop = false;
             this.pbImage.DragDrop += new System.Windows.Forms.DragEventHandler(this.pbImage_DragDrop);
             this.pbImage.Resize += new System.EventHandler(this.pbImage_Resize);
             this.pbImage.MouseClick += new System.Windows.Forms.MouseEventHandler(this.pbImage_MouseClick);
             this.pbImage.DragEnter += new System.Windows.Forms.DragEventHandler(this.pbImage_DragEnter);
             // 
             // toolStripMain
             // 
             this.toolStripMain.AllowItemReorder = true;
             this.toolStripMain.Dock = System.Windows.Forms.DockStyle.None;
             this.toolStripMain.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             this.btnLoadImage,
             this.btnSaveImage,
             this.separator1,
             this.tbEpsilon,
             this.separator2,
             this.btnParallel,
             this.btnInk,
             this.btnEraser,
             this.pbColorizing,
             this.lblHuesSelected});
             this.toolStripMain.LayoutStyle = System.Windows.Forms.ToolStripLayoutStyle.HorizontalStackWithOverflow;
             this.toolStripMain.Location = new System.Drawing.Point(3, 0);
             this.toolStripMain.Name = "toolStripMain";
             this.toolStripMain.Size = new System.Drawing.Size(616, 25);
             this.toolStripMain.TabIndex = 9;
             this.toolStripMain.Text = "toolStrip1";
             // 
             // btnLoadImage
             // 
             this.btnLoadImage.Image = global
             this.btnLoadImage.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnLoadImage.Name = "btnLoadImage";
             this.btnLoadImage.Size = new System.Drawing.Size(89, 22);
             this.btnLoadImage.Text = "&Load Image";
             this.btnLoadImage.Click += new System.EventHandler(this.btnLoadImage_Click);
             // 
             // btnSaveImage
             // 
             this.btnSaveImage.Image = global
             this.btnSaveImage.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnSaveImage.Name = "btnSaveImage";
             this.btnSaveImage.Size = new System.Drawing.Size(87, 22);
             this.btnSaveImage.Text = "&Save Image";
             this.btnSaveImage.Click += new System.EventHandler(this.btnSaveImage_Click);
             // 
             // separator1
             // 
             this.separator1.Name = "separator1";
             this.separator1.Size = new System.Drawing.Size(6, 25);
             // 
             // tbEpsilon
             // 
             this.tbEpsilon.BackColor = System.Drawing.SystemColors.Control;
             this.tbEpsilon.Maximum = 180;
             this.tbEpsilon.Name = "tbEpsilon";
             this.tbEpsilon.Size = new System.Drawing.Size(150, 22);
             this.tbEpsilon.Text = "toolStripTrackBar1";
             this.tbEpsilon.Value = 15;
             this.tbEpsilon.ValueChanged += new System.EventHandler(this.tbEpsilon_ValueChanged);
             // 
             // separator2
             // 
             this.separator2.Name = "separator2";
             this.separator2.Size = new System.Drawing.Size(6, 25);
             // 
             // btnParallel
             // 
             this.btnParallel.CheckOnClick = true;
             this.btnParallel.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnParallel.Image = ((System.Drawing.Image)(resources.GetObject("btnParallel.Image")));
             this.btnParallel.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnParallel.Name = "btnParallel";
             this.btnParallel.Size = new System.Drawing.Size(23, 22);
             this.btnParallel.Text = "btnParallel";
             this.btnParallel.CheckedChanged += new System.EventHandler(this.btnParallel_CheckedChanged);
             // 
             // btnInk
             // 
             this.btnInk.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnInk.Enabled = false;
             this.btnInk.Image = global
             this.btnInk.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnInk.Name = "btnInk";
             this.btnInk.Size = new System.Drawing.Size(23, 22);
             this.btnInk.Text = "btnInk";
             this.btnInk.Click += new System.EventHandler(this.btnInk_Click);
             // 
             // btnEraser
             // 
             this.btnEraser.DisplayStyle = System.Windows.Forms.ToolStripItemDisplayStyle.Image;
             this.btnEraser.Enabled = false;
             this.btnEraser.Image = global
             this.btnEraser.ImageTransparentColor = System.Drawing.Color.Magenta;
             this.btnEraser.Name = "btnEraser";
             this.btnEraser.Size = new System.Drawing.Size(23, 22);
             this.btnEraser.Text = "btnEraser";
             this.btnEraser.Click += new System.EventHandler(this.btnEraser_Click);
             // 
             // pbColorizing
             // 
             this.pbColorizing.Alignment = System.Windows.Forms.ToolStripItemAlignment.Right;
             this.pbColorizing.Name = "pbColorizing";
             this.pbColorizing.Overflow = System.Windows.Forms.ToolStripItemOverflow.Never;
             this.pbColorizing.Size = new System.Drawing.Size(140, 22);
             this.pbColorizing.Visible = false;
             // 
             // lblHuesSelected
             // 
             this.lblHuesSelected.Name = "lblHuesSelected";
             this.lblHuesSelected.Size = new System.Drawing.Size(81, 15);
             this.lblHuesSelected.Text = "Hues Selected";
             this.lblHuesSelected.Click += new System.EventHandler(this.lblHuesSelected_Click);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(619, 422);
             this.Controls.Add(this.toolStripContainer);
             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
             this.KeyPreview = true;
             this.Name = "MainForm";
             this.Text = "Image Colorizer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             this.toolStripContainer.ContentPanel.ResumeLayout(false);
             this.toolStripContainer.TopToolStripPanel.ResumeLayout(false);
             this.toolStripContainer.TopToolStripPanel.PerformLayout();
             this.toolStripContainer.ResumeLayout(false);
             this.toolStripContainer.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
             this.toolStripMain.ResumeLayout(false);
             this.toolStripMain.PerformLayout();
             this.ResumeLayout(false);
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="8" endline="30"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         private List<Point> _selectedPixels = new List<Point>();
         /// <summary>The last hue epsilon selected by the user.</summary>
         private int _lastEpsilon = -1;
         /// <summary>The last size of the image picture box before a resize.</summary>
         private Size _lastPictureBoxSize = new Size(-1, -1);
         public MainForm()
         {
             InitializeComponent();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="31" endline="62"><![CDATA[
 
         /// <summary>A list of all selected points from which colors will be extracted from the image.</summary>
         private List<Point> _selectedPixels = new List<Point>();
         /// <summary>The last hue epsilon selected by the user.</summary>
         private int _lastEpsilon = -1;
         /// <summary>The last size of the image picture box before a resize.</summary>
         private Size _lastPictureBoxSize = new Size(-1, -1);
         /// <summary>A list of GraphicsPaths currently translated from Strokes.</summary>
         private List<GraphicsPath> _paths;
         /// <summary>The image as originally loaded.</summary>
         private Bitmap _originalImage;
         /// <summary>The current image after all color transformations.</summary>
         private Bitmap _colorizedImage;
         /// <summary>The InkOverlay used for accepting strokes to be translated into GraphicsPaths.</summary>
         private InkOverlay _overlay;
 
         /// <summary>Loads the form.</summary>
         private void MainForm_Load(object sender, EventArgs e)
         {
             // Store the current size of the picture box.  When the picture box is
             // resized (due to the form being resized), we need to scale any ink
             // that may exist on the form so that it sizes in accordance with the picture box.
             _lastPictureBoxSize = pbImage.Size;
             pbImage.AllowDrop = true;
 
             // If the current platform supports ink, initialize the InkOverlay
             if (PlatformDetection.SupportsInk) InitializeInk();
 
             // Setup the help text for the toolstrip
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay,  tbEpsilon.Value);
         }
 
         OpenFileDialog _ofd;
 
         /// <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
         private void btnLoadImage_Click(object sender, EventArgs e)
         {
             // Show a dialog to select JPG files
             if (_ofd == null)
             {
                 _ofd = new OpenFileDialog();
                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
             }
             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
         }
 
         private void LoadImage(string path)
         {
             try
             {
                 _originalImage = new Bitmap(path);
                 pbImage.Image = _originalImage;
 
                 // Disable saving of the image.  We only allow saving once changes have been made.
                 btnSaveImage.Enabled = false;
 
                 // Change the cursor on the picture box to let the user know they
                 // can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
 
                 // If ink is available on the current machine, enable the button that
                 // turns on the overlay, and clear any existing ink from previous images
                 // that may have existed in the app
                 if (PlatformDetection.SupportsInk)
                 {
                     btnInk.Enabled = true;
                     ClearInk();
                 }
             }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (PlatformDetection.SupportsInk) InitializeInk();
 
             // Setup the help text for the toolstrip
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay,  tbEpsilon.Value);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="63" endline="77"><![CDATA[
 
         OpenFileDialog _ofd;
 
         /// <summary>Shows an OpenFileDialog and loads the selected image into the app.</summary>
         private void btnLoadImage_Click(object sender, EventArgs e)
         {
             // Show a dialog to select JPG files
             if (_ofd == null)
             {
                 _ofd = new OpenFileDialog();
                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
             }
             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
         }
 
         private void LoadImage(string path)
         {
             try
             {
                 _originalImage = new Bitmap(path);
                 pbImage.Image = _originalImage;
 
                 // Disable saving of the image.  We only allow saving once changes have been made.
                 btnSaveImage.Enabled = false;
 
                 // Change the cursor on the picture box to let the user know they
                 // can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
 
                 // If ink is available on the current machine, enable the button that
                 // turns on the overlay, and clear any existing ink from previous images
                 // that may have existed in the app
                 if (PlatformDetection.SupportsInk)
                 {
                     btnInk.Enabled = true;
                     ClearInk();
                 }
             }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 _ofd = new OpenFileDialog();
                 _ofd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif";
                 _ofd.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyPictures);
             }
             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
         }
 
         private void LoadImage(string path)
         {
             try
             {
                 _originalImage = new Bitmap(path);
                 pbImage.Image = _originalImage;
 
                 // Disable saving of the image.  We only allow saving once changes have been made.
                 btnSaveImage.Enabled = false;
 
                 // Change the cursor on the picture box to let the user know they
                 // can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
 
                 // If ink is available on the current machine, enable the button that
                 // turns on the overlay, and clear any existing ink from previous images
                 // that may have existed in the app
                 if (PlatformDetection.SupportsInk)
                 {
                     btnInk.Enabled = true;
                     ClearInk();
                 }
             }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (_ofd.ShowDialog() == DialogResult.OK) LoadImage(_ofd.FileName);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="78" endline="103"><![CDATA[
 
         private void LoadImage(string path)
         {
             try
             {
                 _originalImage = new Bitmap(path);
                 pbImage.Image = _originalImage;
 
                 // Disable saving of the image.  We only allow saving once changes have been made.
                 btnSaveImage.Enabled = false;
 
                 // Change the cursor on the picture box to let the user know they
                 // can click on the image to select a hue.
                 pbImage.Cursor = System.Windows.Forms.Cursors.Hand;
 
                 // If ink is available on the current machine, enable the button that
                 // turns on the overlay, and clear any existing ink from previous images
                 // that may have existed in the app
                 if (PlatformDetection.SupportsInk)
                 {
                     btnInk.Enabled = true;
                     ClearInk();
                 }
             }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 {
                     btnInk.Enabled = true;
                     ClearInk();
                 }
             }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             catch (ArgumentException) { }
         }
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="104" endline="130"><![CDATA[
 
         /// <summary>Recomputes the image based on the newly selected pixel.</summary>
         private void pbImage_MouseClick(object sender, MouseEventArgs e)
         {
             // Only run if an image has been loaded and if ink isn't being drawn
             if (_originalImage != null && !(btnInk.Enabled && btnInk.Checked))
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 // Get the point in the original image.  To get this we need
                 // to scale the selected point based on how much the image
                 // is being resized for display.
                 Point p = new Point(
                     (int)(e.X * _originalImage.Width / (double)pbImage.Width),
                     (int)(e.Y * _originalImage.Height / (double)pbImage.Height));
 
                 // Add the selected point to the list or make it the only
                 // point in the list, based on whether the shift key is being held down
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 if (Control.ModifierKeys != Keys.Shift) _selectedPixels.Clear();
                 _selectedPixels.Add(p);
 
                 // With our updated list of selected pixels in hand, update
                 // the toolstrip help text
                 lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
 
                 // Start recomputing the image based on the new parameters
                 StartColorizeImage();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="131" endline="162"><![CDATA[
 
         private void StartColorizeImage()
         {
             // Stop the timer if it's running, since the timer's purpose
             // is to cause this method to be called when the timer expires
             tmRefresh.Stop();
             _lastEpsilon = tbEpsilon.Value;
 
             // If we have an image and if a pixel has been selected
             // and if we're not currently recomputing the image...
             if (_originalImage != null && _selectedPixels.Count > 0 && !bwColorize.IsBusy)
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 // If there are any strokes, turn them into GraphicsPaths
                 if (PlatformDetection.SupportsInk)
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 {
                     if (_paths != null)
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                     {
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                         foreach (GraphicsPath path in _paths) path.Dispose();
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                     }
                     _paths = InkToGraphicsPaths(true);
                 }
 
                 // Modify the UI for progress
                 toolStripMain.Enabled = false;
                 pbImage.Enabled = false;
                 pbColorizing.Value = 0;
                 pbColorizing.Visible = true;
 
                 // Recompute the image!
                 bwColorize.RunWorkerAsync();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="163" endline="183"><![CDATA[
 
         /// <summary>Colorizes the image on a background thread.</summary>
         private void bwColorize_DoWork(object sender, DoWorkEventArgs e)
         {
             // Create the colorizer instance.  Any progress updates
             // will in turn update the progress through the BackgroundWorker.
             ImageManipulation colorizer = new ImageManipulation();
             colorizer.ProgressChanged += delegate(object s, ProgressChangedEventArgs pcea)
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="184" endline="209"><![CDATA[
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="210" endline="215"><![CDATA[
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="216" endline="230"><![CDATA[
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="231" endline="264"><![CDATA[
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                     break;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="265" endline="270"><![CDATA[
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="271" endline="277"><![CDATA[
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="278" endline="290"><![CDATA[
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="291" endline="301"><![CDATA[
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="302" endline="325"><![CDATA[
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="326" endline="329"><![CDATA[
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="330" endline="343"><![CDATA[
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="344" endline="387"><![CDATA[
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="388" endline="395"><![CDATA[
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="396" endline="403"><![CDATA[
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="404" endline="418"><![CDATA[
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="419" endline="428"><![CDATA[
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="429" endline="442"><![CDATA[
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="443" endline="447"><![CDATA[
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="171" endline="449"><![CDATA[
             {
                 bwColorize.ReportProgress(pcea.ProgressPercentage);
             };
 
             // Create a clone of the original image, so that we can lock its bits
             // while still allowing the UI to refresh and resize appropriately
             using(Bitmap workImage = _originalImage.Clone(
                 new Rectangle(0, 0, _originalImage.Width, _originalImage.Height), PixelFormat.Format24bppRgb))
             {
                 // Colorize the image and store the resulting Bitmap
                 e.Result = colorizer.Colorize(workImage, _selectedPixels, _lastEpsilon, _paths, btnParallel.Checked);
             }
         }
 
         /// <summary>Configures the MainForm after colorization is complete.</summary>
         private void bwColorize_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
         {
             // Reenable the UI
             pbColorizing.Visible = false;
             toolStripMain.Enabled = true;
             pbImage.Enabled = true;
             btnLoadImage.Enabled = true;
             btnSaveImage.Enabled = true;
             tbEpsilon.Focus();
 
             // Rethrow any exceptions
             if (e.Error != null) throw new TargetInvocationException(e.Error);
 
             // Get the newly computed image
             if (_colorizedImage != null) _colorizedImage.Dispose();
             _colorizedImage = (Bitmap)e.Result;
 
             // Set the newly computed image into the PictureBox
             if (pbImage.Image != null && pbImage.Image != _originalImage)
             {
                 pbImage.Image.Dispose();
             }
             pbImage.Image = _colorizedImage;
         }
 
         /// <summary>Update the progress bar when the BackgroundWorker progress changes.</summary>
         private void bwColorize_ProgressChanged(object sender, ProgressChangedEventArgs e)
         {
             if (e.ProgressPercentage > pbColorizing.Value) pbColorizing.Value = e.ProgressPercentage;
         }
 
         /// <summary>Saves the colorized image to a file.</summary>
         private void btnSaveImage_Click(object sender, EventArgs e)
         {
             if (_colorizedImage != null)
             {
                 SaveFileDialog sfd = new SaveFileDialog();
                 sfd.Filter = "Image files (*.jpg, *.bmp, *.png, *.gif)|*.jpg;*.bmp;*.png;*.gif|All files (*.*)|*.*";
                 sfd.DefaultExt = ".jpg";
                 if (sfd.ShowDialog(this) == DialogResult.OK)
                 {
                     SaveImage(_colorizedImage, sfd.FileName, 100);
                 }
             }
         }
 
         /// <summary>Saves an image to a specified path and with a specified quality, if appropriate to the format.</summary>
         /// <param name="bmp">The image to be saved.</param>
         /// <param name="path">The path where to save the image.</param>
         /// <param name="quality">The quality of the image to save.</param>
         private static void SaveImage(Bitmap bmp, string path, long quality)
         {
             // Validate parameters
             if (bmp == null) throw new ArgumentNullException("bmp");
             if (path == null) throw new ArgumentNullException("path");
             if (quality < 1 || quality > 100) throw new ArgumentOutOfRangeException("quality", quality, "Quality out of range.");
 
             // Save it to a file format based on the path's extension
             switch (Path.GetExtension(path).ToLowerInvariant())
             {
                 default
                 case ".bmp"
                 case ".png"
                 case ".gif"
                 case ".tif"
                 case ".tiff"
                 case ".jpg"
                     ImageCodecInfo jpegCodec = Array.Find(ImageCodecInfo.GetImageEncoders(),
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="254" endline="449"><![CDATA[
                         delegate(ImageCodecInfo ici) { return ici.MimeType == "image/jpeg"; });
                     using (EncoderParameters codecParams = new EncoderParameters(1))
                     using (EncoderParameter ratio = new EncoderParameter(System.Drawing.Imaging.Encoder.Quality, quality))
                     {
                         // Set the JPEG quality value and save the image
                         codecParams.Param[0] = ratio;
                         bmp.Save(path, jpegCodec, codecParams);
                     }
                     break;
             }
         }
 
         /// <summary>Starts the colorization process when the refresh timer expires.</summary>
         private void tmRefresh_Tick(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
 
         /// <summary>Starts the refresh timer when the epsilon track bar changes value.</summary>
         private void tbEpsilon_ValueChanged(object sender, EventArgs e)
         {
             tbEpsilon.ToolTipText = string.Format(Properties.Resources.EpsilonDisplay, tbEpsilon.Value);
             StartRefreshTimer();
         }
 
         /// <summary>Starts/restarts the refresh timer.</summary>
         private void StartRefreshTimer()
         {
             if (_originalImage != null &&
                 _selectedPixels.Count > 0 && _lastEpsilon >= 0 &&
                 !bwColorize.IsBusy)
             {
                 btnLoadImage.Enabled = false;
                 tmRefresh.Stop();
                 tmRefresh.Start();
             }
         }
 
         /// <summary>Resizes any ink in the picture box when it resizes.</summary>
         private void pbImage_Resize(object sender, EventArgs e)
         {
             if (_lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 PlatformDetection.SupportsInk)
             {
                 ScaleInk();
             }
             _lastPictureBoxSize = pbImage.Size;
         }
 
         /// <summary>Initializes the InkOverlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void InitializeInk()
         {
             _overlay = new InkOverlay(pbImage, true);
             _overlay.DefaultDrawingAttributes.Width = 1;
             _overlay.DefaultDrawingAttributes.Color = Color.Red;
             _overlay.DefaultDrawingAttributes.IgnorePressure = true;
 
             // When a stroke is received, we start a timer that, when expiring,
             // will cause the image to be redrawn.  This timer allows the user
             // to draw multiple strokes without the image having to be redrawn
             // after each.
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="316" endline="449"><![CDATA[
             _overlay.Stroke += delegate { StartRefreshTimer(); };
 
             // We also don't want the image to be redrawn midstroke (which
             // could happen if the user drew a stroke, causing the timer
             // to start, and then took longer than a second to draw the
             // second stroke), so when new packets are received, the timer
             // is stopped; it'll be restarted by the above when the Stroke
             // is completed.
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\MainForm.cs" startline="324" endline="449"><![CDATA[
             _overlay.NewPackets += delegate { tmRefresh.Stop(); };
         }
 
         /// <summary>Clears all ink from the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ClearInk() { _overlay.Ink.DeleteStrokes(); }
 
         /// <summary>Scales the ink in the overlay.</summary>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private void ScaleInk()
         {
             if (pbImage.Size.Width > 0 && pbImage.Size.Height > 0 &&
                 _lastPictureBoxSize.Width > 0 && _lastPictureBoxSize.Height > 0 &&
                 _overlay != null)
             {
                 _overlay.Ink.Strokes.Scale(
                     pbImage.Size.Width / (float)_lastPictureBoxSize.Width,
                     pbImage.Size.Height / (float)_lastPictureBoxSize.Height);
             }
         }
 
         /// <summary>Converts all Strokes in the overlay to GraphicsPaths.</summary>
         /// <param name="scalePath">Whether to scale the GraphicsPaths based on the current image rescaling.</param>
         /// <returns>The list of converted GraphicsPath instances.</returns>
         [MethodImpl(MethodImplOptions.NoInlining)]
         private List<GraphicsPath> InkToGraphicsPaths(bool scalePath)
         {
             Renderer renderer = _overlay.Renderer;
             Strokes strokes = _overlay.Ink.Strokes;
 
             float scaleX = _originalImage.Width / (float)pbImage.Width;
             float scaleY = _originalImage.Height / (float)pbImage.Height;
 
             if (strokes.Count > 0)
             {
                 using (Graphics g = CreateGraphics())
                 {
                     List<GraphicsPath> paths = new List<GraphicsPath>(strokes.Count);
                     foreach (Stroke stroke in strokes)
                     {
                         Point[] points = stroke.GetPoints();
                         if (points.Length >= 3)
                         {
                             for (int i = 0; i < points.Length; i++)
                             {
                                 renderer.InkSpaceToPixel(g, ref points[i]);
                                 if (scalePath)
                                 {
                                     points[i] = new Point(
                                         (int)(scaleX * points[i].X),
                                         (int)(scaleY * points[i].Y));
                                 }
                             }
                             GraphicsPath path = new GraphicsPath();
                             path.AddPolygon(points);
                             path.CloseFigure();
                             paths.Add(path);
                         }
                     }
                     return paths;
                 }
             }
             return null;
         }
 
         /// <summary>Enables or disables the InkOverlay.</summary>
         private void btnInk_Click(object sender, EventArgs e)
         {
             _overlay.Enabled = !_overlay.Enabled;
             btnInk.Checked = _overlay.Enabled;
             btnEraser.Enabled = btnInk.Checked;
         }
 
         /// <summary>Switches back and forth between Ink and Delete editing modes on the overlay.</summary>
         private void btnEraser_Click(object sender, EventArgs e)
         {
             _overlay.EditingMode = (_overlay.EditingMode == InkOverlayEditingMode.Delete) ?
                 InkOverlayEditingMode.Ink 
             btnEraser.Checked = _overlay.EditingMode == InkOverlayEditingMode.Delete;
         }
 
         /// <summary>Resets back to the original image.</summary>
         private void lblHuesSelected_Click(object sender, EventArgs e)
         {
             _selectedPixels.Clear();
             pbImage.Image = _originalImage;
             if (_colorizedImage != null)
             {
                 _colorizedImage.Dispose();
                 _colorizedImage = null;
             }
 
             lblHuesSelected.Text = string.Format(Properties.Resources.HuesSelectedDisplay, _selectedPixels.Count);
             lblHuesSelected.ToolTipText = null;
         }
 
         /// <summary>Sets up a drag & drop affect.</summary>
         private void pbImage_DragEnter(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 ((string[])e.Data.GetData(DataFormats.FileDrop)).Length == 1)
             {
                 e.Effect = DragDropEffects.Copy;
             }
         }
 
         /// <summary>Completes a drag & drop operation, loading the dropped image.</summary>
         private void pbImage_DragDrop(object sender, DragEventArgs e)
         {
             if (e.Data.GetDataPresent(DataFormats.FileDrop) &&
                 e.Effect == DragDropEffects.Copy)
             {
                 string[] paths = (string[])e.Data.GetData(DataFormats.FileDrop);
                 if (paths.Length == 1)
                 {
                     LoadImage(paths[0]);
                 }
             }
         }
 
         private void btnParallel_CheckedChanged(object sender, EventArgs e)
         {
             StartColorizeImage();
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Program.cs" startline="24" endline="28"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="34" endline="47"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
             set {
                 resourceCulture = value;
             }
         }
         
         /// <summary>
         ///   Looks up a localized string similar to Hue variation
         /// </summary>
         internal static string EpsilonDisplay {
             get {
                 return ResourceManager.GetString("EpsilonDisplay", resourceCulture);
             }
         }
         
         internal static System.Drawing.Bitmap eraser {
             get {
                 object obj = ResourceManager.GetObject("eraser", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
         }
         
         /// <summary>
         ///   Looks up a localized string similar to Hues selected
         /// </summary>
         internal static string HuesSelectedDisplay {
             get {
                 return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture);
             }
         }
         
         internal static System.Drawing.Bitmap InsertPictureHS {
             get {
                 object obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
         }
         
         internal static System.Drawing.Bitmap pen {
             get {
                 object obj = ResourceManager.GetObject("pen", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
         }
         
         internal static System.Drawing.Bitmap saveHS {
             get {
                 object obj = ResourceManager.GetObject("saveHS", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
         }
     }
 }
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="48" endline="58"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="59" endline="61"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="62" endline="70"><![CDATA[
         }
         
         /// <summary>
         ///   Looks up a localized string similar to Hue variation
         /// </summary>
         internal static string EpsilonDisplay {
             get {
                 return ResourceManager.GetString("EpsilonDisplay", resourceCulture);
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="71" endline="77"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap eraser {
             get {
                 object obj = ResourceManager.GetObject("eraser", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="78" endline="86"><![CDATA[
         }
         
         /// <summary>
         ///   Looks up a localized string similar to Hues selected
         /// </summary>
         internal static string HuesSelectedDisplay {
             get {
                 return ResourceManager.GetString("HuesSelectedDisplay", resourceCulture);
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="87" endline="93"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap InsertPictureHS {
             get {
                 object obj = ResourceManager.GetObject("InsertPictureHS", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="94" endline="100"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap pen {
             get {
                 object obj = ResourceManager.GetObject("pen", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\Properties\Resources.Designer.cs" startline="101" endline="107"><![CDATA[
         }
         
         internal static System.Drawing.Bitmap saveHS {
             get {
                 object obj = ResourceManager.GetObject("saveHS", resourceCulture);
                 return ((System.Drawing.Bitmap)(obj));
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="24" endline="24"><![CDATA[
         public ToolStripTrackBar() 
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="25" endline="27"><![CDATA[
 
         /// <summary>Gets the actual TrackBar instance.</summary>
         public TrackBar TrackBar { get { return Control as TrackBar; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="28" endline="40"><![CDATA[
 
         /// <summary>Create the actual TrackBar control.</summary>
         private static Control CreateControlInstance()
         {
             TrackBar t = new TrackBar();
             t.AutoSize = false;
             t.Height = 16;
             t.TickStyle = TickStyle.None;
             t.Minimum = 0;
             t.Maximum = 100;
             t.Value = 0;
             return t;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="41" endline="44"><![CDATA[
 
         /// <summary>Gets the current TrackBar value.</summary>
         [DefaultValue(0)]
         public int Value { get { return TrackBar.Value; } set { TrackBar.Value = value; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="45" endline="48"><![CDATA[
 
         /// <summary>Gets the minimum TrackBar value.</summary>
         [DefaultValue(0)]
         public int Minimum { get { return TrackBar.Minimum; } set { TrackBar.Minimum = value; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="49" endline="52"><![CDATA[
 
         /// <summary>Gets the maximum TrackBar value.</summary>
         [DefaultValue(100)]
         public int Maximum { get { return TrackBar.Maximum; } set { TrackBar.Maximum = value; } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="53" endline="59"><![CDATA[
 
         /// <summary>Attach to events that need to be wrapped.</summary>
         protected override void OnSubscribeControlEvents(Control control)
         {
             base.OnSubscribeControlEvents(control);
             ((TrackBar)control).ValueChanged += trackBar_ValueChanged;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="60" endline="66"><![CDATA[
 
         /// <summary>Detach from events that were wrapped.</summary>
         protected override void OnUnsubscribeControlEvents(Control control)
         {
             base.OnUnsubscribeControlEvents(control);
             ((TrackBar)control).ValueChanged -= trackBar_ValueChanged;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="67" endline="72"><![CDATA[
 
         /// <summary>Raise the ValueChanged event.</summary>
         void trackBar_ValueChanged(object sender, EventArgs e)
         {
             if (ValueChanged != null) ValueChanged(sender, e);
         }
 
         /// <summary>Event used to notify when the TrackBar's value changes.</summary>
         public event EventHandler ValueChanged;
 
         /// <summary>Gets the default size for the control.</summary>
         protected override Size DefaultSize { get { return new Size(200, 16); } }
     }
 }
             if (ValueChanged != null) ValueChanged(sender, e);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ToolStripTrackBar.cs" startline="73" endline="78"><![CDATA[
 
         /// <summary>Event used to notify when the TrackBar's value changes.</summary>
         public event EventHandler ValueChanged;
 
         /// <summary>Gets the default size for the control.</summary>
         protected override Size DefaultSize { get { return new Size(200, 16); } }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="36" endline="206"><![CDATA[
         {
             // Create a new bitmap with the same size as the original
             int width = original.Width, height = original.Height;
             Bitmap colorizedImage = new Bitmap(width, height);
 
             // Optimization
             // ruling out pixels that are definitely not containing within the selected region.
             Rectangle [] pathsBounds = null;
             if (paths != null && paths.Count > 0) 
             {
                 pathsBounds = new Rectangle[paths.Count];
                 for(int i=0; i<pathsBounds.Length; i++)
                 {
                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
                 }
             }
 
             // Optimization
             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             // with rectangles which can be hit tested against instead of the paths.  Not quite
             // as accurate, but much faster.
             List<RectangleF[]> compositions = null;
             if (paths != null && paths.Count > 0)
             {
                 compositions = new List<RectangleF[]>(paths.Count);
                 using (Matrix m = new Matrix())
                 {
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 pathsBounds = new Rectangle[paths.Count];
                 for(int i=0; i<pathsBounds.Length; i++)
                 {
                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
                 }
             }
 
             // Optimization
             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             // with rectangles which can be hit tested against instead of the paths.  Not quite
             // as accurate, but much faster.
             List<RectangleF[]> compositions = null;
             if (paths != null && paths.Count > 0)
             {
                 compositions = new List<RectangleF[]>(paths.Count);
                 using (Matrix m = new Matrix())
                 {
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 {
                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
                 }
                 for(int i=0; i<pathsBounds.Length; i++)
                 {
                     pathsBounds[i] = Rectangle.Ceiling(paths[i].GetBounds());
                 }
             }
 
             // Optimization
             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             // with rectangles which can be hit tested against instead of the paths.  Not quite
             // as accurate, but much faster.
             List<RectangleF[]> compositions = null;
             if (paths != null && paths.Count > 0)
             {
                 compositions = new List<RectangleF[]>(paths.Count);
                 using (Matrix m = new Matrix())
                 {
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             }
 
             // Optimization
             // against rectangles is very fast.  As such, appromixate the area of the GraphicsPath
             // with rectangles which can be hit tested against instead of the paths.  Not quite
             // as accurate, but much faster.
             List<RectangleF[]> compositions = null;
             if (paths != null && paths.Count > 0)
             {
                 compositions = new List<RectangleF[]>(paths.Count);
                 using (Matrix m = new Matrix())
                 {
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 compositions = new List<RectangleF[]>(paths.Count);
                 using (Matrix m = new Matrix())
                 {
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                     }
                     for(int i=0; i<paths.Count; i++)
                     {
                         using (Region r = new Region(paths[i])) compositions.Add(r.GetRegionScans(m));
                     }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             }
 
             // Use FastBitmap instances to provide unsafe/faster access to the pixels
             // in the original and in the new images
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             using (FastBitmap fastColorizedImage = new FastBitmap(colorizedImage))
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             using (FastBitmap fastOriginalImage = new FastBitmap(original))
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 // Extract the selected hues from the selected pixels
                 List<float> selectedHues = new List<float>(selectedPixels.Count);
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
                 foreach (Point p in selectedPixels)
                 {
                     selectedHues.Add(fastOriginalImage.GetColor(p.X, p.Y).GetHue());
                 }
 
                 // For progress update purposes, figure out how many pixels there
                 // are in total, and how many constitute 1% so that we can raise
                 // events after every additional 1% has been completed.
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 long totalPixels = height * width;
                 long pixelsPerProgressUpdate = totalPixels / 100;
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 if (pixelsPerProgressUpdate == 0) pixelsPerProgressUpdate = 1;
                 long pixelsProcessed = 0;
 
                 // Pixels close to the selected hue but not close enough may be
                 // left partially desaturated.  The saturation window determines
                 // what pixels fall into that range.
                 const int maxSaturationWindow = 10;
                 int saturationWindow = Math.Min(maxSaturationWindow, epsilon);
 
                 // Separated out the body of the loop just to make it easier
                 // to switch between sequential and parallel for demo purposes
                 Action<int> processRow = y =>
                 {
                     for (int x = 0; x < width; x++)
                     {
                         // Get the color/hue of th epixel
                         Color c = fastOriginalImage.GetColor(x, y);
                         float pixelHue = c.GetHue();
 
                         // Use hit-testing to determine if the pixel is in the selected region.
                         bool pixelInSelectedRegion = false;
 
                         // First, if there are no paths, by definition it is in the selected
                         // region, since the whole image is then selected
                         if (paths == null || paths.Count == 0) pixelInSelectedRegion = true;
                         else
                         {
                             // For each path, first see if the pixel is within the bounding
                             // rectangle; if it's not, it's not in the selected region.
                             Point p = new Point(x, y);
                             for (int i = 0; i < pathsBounds.Length && !pixelInSelectedRegion; i++)
                             {
                                 if (pathsBounds[i].Contains(p))
                                 {
                                     // The pixel is within a bounding rectangle, so now
                                     // see if it's within the composition rectangles
                                     // approximating the region.
                                     foreach (RectangleF bound in compositions[i])
                                     {
                                         if (bound.Contains(x, y))
                                         {
                                             // If it is, it's in the region.
                                             pixelInSelectedRegion = true;
                                             break;
                                         }
                                     }
                                 }
                             }
                         }
 
                         // Now that we know whether a pixel is in the region,
                         // we can figure out what to do with it.  If the pixel
                         // is not in the selected region, it needs to be converted
                         // to grayscale.
                         bool useGrayscale = true;
                         if (pixelInSelectedRegion)
                         {
                             // If it is in the selected region, get the color hue's distance 
                             // from each target hue.  If that distance is less than the user-selected
                             // hue variation limit, leave it in color.  If it's greater than the
                             // variation limit, but within the saturation window of the limit,
                             // desaturate it proportionally to the distance from the limit.
                             foreach (float selectedHue in selectedHues)
                             {
                                 // A hue wheel is 360 degrees. If you pick two points on a wheel, there
                                 // will be two distances between them, depending on which way you go around
                                 // the wheel from one to the other (unless they're exactly opposite from
                                 // each other on the wheel, the two distances will be different).  We always
                                 // want to do our work based on the smaller of the two distances (e.g. a hue
                                 // with the value 359 is very, very close to a hue with the value 1).  So,
                                 // we take the absolute value of the difference between the two hues.  If that
                                 // distance is 180 degrees, then both distances are the same, so it doesn't
                                 // matter which we go with. If that difference is less than 180 degrees, 
                                 // we know this must be the smaller of the two distances, since the sum of the 
                                 // two distances must add up to 360.  If, however, it's larger than 180, it's the
                                 // longer distance, so to get the shorter one, we have to subtract it from 360.
                                 float distance = Math.Abs(pixelHue - selectedHue);
                                 if (distance > 180) distance = 360 - distance;
 
                                 if (distance <= epsilon)
                                 {
                                     useGrayscale = false;
                                     break;
                                 }
                                 else if ((distance - epsilon) / saturationWindow < 1.0f)
                                 {
                                     useGrayscale = false;
                                     c = ColorFromHsb(
                                         pixelHue,
                                         c.GetSaturation() * (1.0f - ((distance - epsilon) / maxSaturationWindow)),
                                         c.GetBrightness());
                                     break;
                                 }
                             }
                         }
 
                         // Set the pixel color into the new image
                         if (useGrayscale) c = ToGrayscale(c);
                         fastColorizedImage.SetColor(x, y, c);
                     }
 
                     // Notify any listeners of our progress, if enough progress has been made
                     Interlocked.Add(ref pixelsProcessed, width);
                     OnProgressChanged((int)(100 * pixelsProcessed / (double)totalPixels));
                 };
 
                 // Copy over every single pixel, and possibly transform it in the process
                 if (parallel)
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 {
                     Parallel.For(0, height, processRow);
                 }
                 else
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 {
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                     for (int y = 0; y < height; y++) processRow(y);
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                 }
             }
 
             // We're done creating the image.  Return it.
             return colorizedImage;
         }
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             return colorizedImage;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="207" endline="216"><![CDATA[
 
         /// <summary>Notifies any ProgressChanged subscribers of a progress update.</summary>
         /// <param name="progressPercentage">The progress percentage.</param>
         private void OnProgressChanged(int progressPercentage)
         {
             if (ProgressChanged != null)
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 ProgressChanged(this, new ProgressChangedEventArgs(progressPercentage, null));
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="217" endline="225"><![CDATA[
 
         /// <summary>Converts a color to grayscale.</summary>
         /// <param name="c">The color to convert.</param>
         /// <returns>The grayscale color.</returns>
         private static Color ToGrayscale(Color c)
         {
             int luminance = (int)(0.299 * c.R + 0.587 * c.G + 0.114 * c.B);
             return Color.FromArgb(luminance, luminance, luminance);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="226" endline="293"><![CDATA[
 
         /// <summary>HSB to RGB color conversion.</summary>
         /// <param name="h">The color's hue.</param>
         /// <param name="s">The color's saturation.</param>
         /// <param name="b">The color's brightness.</param>
         /// <returns>The RGB color for the supplied HSB values.</returns>
         /// <remarks>
         /// Based on Chris Jackson's conversion routine from
         /// http
         /// </remarks>
         private static Color ColorFromHsb(float h, float s, float b)
         {
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             if (0f > h || 360f < h) throw new ArgumentOutOfRangeException("h");
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             if (0f > s || 1f < s) throw new ArgumentOutOfRangeException("s");
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             if (0f > b || 1f < b) throw new ArgumentOutOfRangeException("b");
 
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             if (0 == s) return Color.FromArgb((int)(b * 255), (int)(b * 255), (int)(b * 255));
 
             float fMax, fMid, fMin;
             int iSextant, iMax, iMid, iMin;
 
             if (0.5 < b)
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 fMax = b - (b * s) + s;
                 fMin = b + (b * s) - s;
             }
             else
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 fMax = b + (b * s);
                 fMin = b - (b * s);
             }
 
             iSextant = (int)(h / 60f);
             if (300f <= h)
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 h -= 360f;
             }
             h /= 60f;
             h -= 2f * (float)Math.Floor(((iSextant + 1f) % 6f) / 2f);
             if (0 == iSextant % 2)
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 fMid = h * (fMax - fMin) + fMin;
             }
             else
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
             {
                 fMid = fMin - h * (fMax - fMin);
             }
 
             iMax = (int)(fMax * 255);
             iMid = (int)(fMid * 255);
             iMin = (int)(fMin * 255);
 
             switch (iSextant)
             {
                 case 1
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
     }
 }
                     return Color.FromArgb(iMid, iMax, iMin);
                 case 2
                     return Color.FromArgb(iMin, iMax, iMid);
                 case 3
                     return Color.FromArgb(iMin, iMid, iMax);
                 case 4
                     return Color.FromArgb(iMid, iMin, iMax);
                 case 5
                     return Color.FromArgb(iMax, iMin, iMid);
                 default
                     return Color.FromArgb(iMax, iMid, iMin);
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\ImageColorizer\ImageColorizer_CSharp\ImageManipulation.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
