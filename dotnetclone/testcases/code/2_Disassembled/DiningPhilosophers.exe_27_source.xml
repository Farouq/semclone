<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\Application.g.vb" startline="49" endline="55"><![CDATA[
         Public Sub InitializeComponent()
             
             #ExternalSource("..\..\Application.xaml",4)
             Me.StartupUri = New System.Uri("MainWindow.xaml", System.UriKind.Relative)
             
             #End ExternalSource
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\Application.g.vb" startline="56" endline="66"><![CDATA[
         
         '''<summary>
         '''Application Entry Point.
         '''</summary>
         <System.STAThreadAttribute(),  _
          System.Diagnostics.DebuggerNonUserCodeAttribute()>  _
         Public Shared Sub Main()
             Dim app As DiningPhilosophers.App = New DiningPhilosophers.App()
             app.InitializeComponent
             app.Run
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\Application.g.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\CircularPanel.vb" startline="13" endline="25"><![CDATA[
 		Protected Overrides Function MeasureOverride(ByVal availableSize As Size) As Size
 			Dim maxChildSize = New Size()
             For Each child As UIElement In InternalChildren
                 child.Measure(availableSize)
                 If maxChildSize.Width < child.DesiredSize.Width Then
                     maxChildSize.Width = child.DesiredSize.Width
                 End If
                 If maxChildSize.Height < child.DesiredSize.Height Then
                     maxChildSize.Height = child.DesiredSize.Height
                 End If
             Next child
 			Return maxChildSize
 		End Function
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
             For Each child As UIElement In InternalChildren
                 child.Measure(availableSize)
                 If maxChildSize.Width < child.DesiredSize.Width Then
                     maxChildSize.Width = child.DesiredSize.Width
                 End If
                 If maxChildSize.Height < child.DesiredSize.Height Then
                     maxChildSize.Height = child.DesiredSize.Height
                 End If
             Next child
 			Return maxChildSize
 		End Function
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
                 child.Measure(availableSize)
                 If maxChildSize.Width < child.DesiredSize.Width Then
                     maxChildSize.Width = child.DesiredSize.Width
                 End If
                 If maxChildSize.Height < child.DesiredSize.Height Then
                     maxChildSize.Height = child.DesiredSize.Height
                 End If
             Next child
 			Return maxChildSize
 		End Function
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
                     maxChildSize.Width = child.DesiredSize.Width
                 End If
                 If maxChildSize.Height < child.DesiredSize.Height Then
                     maxChildSize.Height = child.DesiredSize.Height
                 End If
             Next child
 			Return maxChildSize
 		End Function
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
                     maxChildSize.Height = child.DesiredSize.Height
                 End If
             Next child
 			Return maxChildSize
 		End Function
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
 			Return maxChildSize
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\CircularPanel.vb" startline="26" endline="45"><![CDATA[
 
 		Protected Overrides Function ArrangeOverride(ByVal finalSize As Size) As Size
 			Dim children = InternalChildren.OfType(Of UIElement)().ToArray()
 			If children.Length > 0 Then
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
                 Dim midPanel = New Point(finalSize.Width / 2, finalSize.Height / 2)
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
 				Dim radius = New Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2)
                 Dim arcRadiansPerChild = Math.PI * 2 / children.Length
 
                 Dim curPos = 0
 				For Each child In children
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
 					Dim childAngleInRadians = curPos * arcRadiansPerChild
                     Dim childPosition = New Point((Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
                                                   (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)))
 					child.Arrange(New Rect(childPosition, child.DesiredSize))
 					curPos += 1
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
 				Next child
 			End If
 			Return finalSize
 		End Function
 	End Class
 End Namespace
 			End If
 			Return finalSize
 		End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\CircularPanel.vb" startline="31" endline="31"><![CDATA[
 				Dim maxChild = New Size(children.Max(Function(u) u.DesiredSize.Width), children.Max(Function(u) u.DesiredSize.Height))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\CircularPanel.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="33" endline="46"><![CDATA[
         Public Sub New()
             ' Initialize the component's layout.
             InitializeComponent()
 
             ' Grab a TaskFactory for creating Tasks that run on the UI.
             _ui = New TaskFactory(TaskScheduler.FromCurrentSynchronizationContext())
 
             ' Initialize the philosophers, and then run them.
             ConfigurePhilosophers()
 
             ' Uncomment one of the following three lines.
             RunWithSemaphoresSyncWithOrderedForks() ' 1. use synchronous semaphores, with ordered forks.
             'RunWithSemaphoresSyncWithWaitAll()  ' 2. use synchronous semaphores, with WaitAll.
         End Sub
 
 #Region "Colors"
         ''' <summary>A brush for rendering thinking philosophers.</summary>
         Private _think As Brush = Brushes.Yellow
         ''' <summary>A brush for rendering eating philosophers.</summary>
         Private _eat As Brush = Brushes.Green
         ''' <summary>A brush for rendering waiting philosophers.</summary>
         Private _wait As Brush = Brushes.Red
 #End Region
 
 #Region "Helpers"
         ''' <summary>Initialize the philosophers.</summary>
         ''' <param name="numPhilosophers">The number of philosophers to initialize.</param>
         Private Sub ConfigurePhilosophers()
             _philosophers = (
              From i In Enumerable.Range(0, NUM_PHILOSOPHERS)
              Select New Ellipse With {.Height = 75, .Width = 75, .Fill = Brushes.Red, .Stroke = Brushes.Black}).ToArray()
             For Each philosopher In _philosophers
                 circularPanel1.Children.Add(philosopher)
             Next philosopher
         End Sub
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         Private _think As Brush = Brushes.Yellow
         ''' <summary>A brush for rendering eating philosophers.</summary>
         Private _eat As Brush = Brushes.Green
         ''' <summary>A brush for rendering waiting philosophers.</summary>
         Private _wait As Brush = Brushes.Red
             InitializeComponent()
 
             ' Grab a TaskFactory for creating Tasks that run on the UI.
             _ui = New TaskFactory(TaskScheduler.FromCurrentSynchronizationContext())
 
             ' Initialize the philosophers, and then run them.
             ConfigurePhilosophers()
 
             ' Uncomment one of the following three lines.
             RunWithSemaphoresSyncWithOrderedForks() ' 1. use synchronous semaphores, with ordered forks.
             'RunWithSemaphoresSyncWithWaitAll()  ' 2. use synchronous semaphores, with WaitAll.
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="47" endline="67"><![CDATA[
 
 #Region "Colors"
         ''' <summary>A brush for rendering thinking philosophers.</summary>
         Private _think As Brush = Brushes.Yellow
         ''' <summary>A brush for rendering eating philosophers.</summary>
         Private _eat As Brush = Brushes.Green
         ''' <summary>A brush for rendering waiting philosophers.</summary>
         Private _wait As Brush = Brushes.Red
 #End Region
 
 #Region "Helpers"
         ''' <summary>Initialize the philosophers.</summary>
         ''' <param name="numPhilosophers">The number of philosophers to initialize.</param>
         Private Sub ConfigurePhilosophers()
             _philosophers = (
              From i In Enumerable.Range(0, NUM_PHILOSOPHERS)
              Select New Ellipse With {.Height = 75, .Width = 75, .Fill = Brushes.Red, .Stroke = Brushes.Black}).ToArray()
             For Each philosopher In _philosophers
                 circularPanel1.Children.Add(philosopher)
             Next philosopher
         End Sub
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 circularPanel1.Children.Add(philosopher)
             Next philosopher
         End Sub
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
             Next philosopher
         End Sub
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="68" endline="88"><![CDATA[
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="89" endline="101"><![CDATA[
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="102" endline="135"><![CDATA[
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="136" endline="148"><![CDATA[
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="149" endline="178"><![CDATA[
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithWaitAll(ByVal forks() As Semaphore, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
             GetForkIds(index, forks.Length, fork1Id, fork2Id, False)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _think).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 WaitHandle.WaitAll({fork1, fork2})
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
     End Class
 End Namespace
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\MainWindow.g.vb" startline="61" endline="72"><![CDATA[
         Public Sub InitializeComponent() Implements System.Windows.Markup.IComponentConnector.InitializeComponent
             If _contentLoaded Then
                 Return
             End If
             _contentLoaded = true
             Dim resourceLocater As System.Uri = New System.Uri("/DiningPhilosophers;component/mainwindow.xaml", System.UriKind.Relative)
             
             #ExternalSource("..\..\MainWindow.xaml",1)
             System.Windows.Application.LoadComponent(Me, resourceLocater)
             
             #End ExternalSource
         End Sub
         
         <System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811
         Friend Function _CreateDelegate(ByVal delegateType As System.Type, ByVal handler As String) As System.[Delegate]
             Return System.[Delegate].CreateDelegate(delegateType, Me, handler)
         End Function
         
         <System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
          System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never),  _
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800
         Sub System_Windows_Markup_IComponentConnector_Connect(ByVal connectionId As Integer, ByVal target As Object) Implements System.Windows.Markup.IComponentConnector.Connect
             If (connectionId = 1) Then
                 Me.circularPanel1 = CType(target,DiningPhilosophers.CircularPanel)
                 Return
             End If
             Me._contentLoaded = true
         End Sub
     End Class
 End Namespace
 
                 Return
             End If
             _contentLoaded = true
             Dim resourceLocater As System.Uri = New System.Uri("/DiningPhilosophers;component/mainwindow.xaml", System.UriKind.Relative)
             
             #ExternalSource("..\..\MainWindow.xaml",1)
             System.Windows.Application.LoadComponent(Me, resourceLocater)
             
             #End ExternalSource
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\MainWindow.g.vb" startline="73" endline="78"><![CDATA[
         
         <System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811
         Friend Function _CreateDelegate(ByVal delegateType As System.Type, ByVal handler As String) As System.[Delegate]
             Return System.[Delegate].CreateDelegate(delegateType, Me, handler)
         End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\obj\Debug\MainWindow.g.vb" startline="79" endline="91"><![CDATA[
         
         <System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
          System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never),  _
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Design", "CA1033
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Maintainability", "CA1502
          System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1800
         Sub System_Windows_Markup_IComponentConnector_Connect(ByVal connectionId As Integer, ByVal target As Object) Implements System.Windows.Markup.IComponentConnector.Connect
             If (connectionId = 1) Then
                 Me.circularPanel1 = CType(target,DiningPhilosophers.CircularPanel)
                 Return
             End If
             Me._contentLoaded = true
         End Sub
     End Class
 End Namespace
 
                 Me.circularPanel1 = CType(target,DiningPhilosophers.CircularPanel)
                 Return
             End If
             Me._contentLoaded = true
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="63" endline="63"><![CDATA[
              Select New Ellipse With {.Height = 75, .Width = 75, .Fill = Brushes.Red, .Stroke = Brushes.Black}).ToArray()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="64" endline="96"><![CDATA[
             For Each philosopher In _philosophers
                 circularPanel1.Children.Add(philosopher)
             Next philosopher
         End Sub
 
         ''' <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
         ''' <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
         ''' <param name="numForks">The number of forks that exist.</param>
         ''' <param name="left">The ID of the philosopher's left fork.</param>
         ''' <param name="right">The ID of the philosopher's right fork.</param>
         ''' <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
         Private Sub GetForkIds(ByVal philosopherIndex As Integer, ByVal numForks As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef left As Integer,
                                <System.Runtime.InteropServices.Out()> ByRef right As Integer, ByVal sort As Boolean)
             ' The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
             ' the latter can wrap around.  We need to ensure they're always acquired in the right order, to
             ' prevent deadlock, so order them.
             left = philosopherIndex
             right = (philosopherIndex + 1) Mod numForks
             If sort AndAlso left > right Then
                 Dim tmp = left
                 left = right
                 right = tmp
             End If
         End Sub
 #End Region
 
 #Region "Synchronous, Ordered"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithOrderedForks()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New SemaphoreSlim(1, 1)).ToArray()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\MainWindow.xaml.vb" startline="97" endline="143"><![CDATA[
             For i = 0 To _philosophers.Length - 1
                 Dim index = i
                 Task.Factory.StartNew(Sub() RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning)
             Next i
         End Sub
 
         ''' <summary>Runs a philosopher synchronously.</summary>
         ''' <param name="forks">The forks, represented as semaphores.</param>
         ''' <param name="index">The philosopher's index number.</param>
         Private Sub RunPhilosopherSyncWithOrderedForks(ByVal forks() As SemaphoreSlim, ByVal index As Integer)
             ' Assign forks.
             Dim fork1Id, fork2Id As Integer
             GetForkIds(index, forks.Length, fork1Id, fork2Id, True)
             Dim fork1 = forks(fork1Id), fork2 = forks(fork2Id)
 
             ' Think and Eat, repeatedly.
             Dim rand = New Random(index)
             While True
                 ' Think (Yellow).
                 _ui.StartNew(Sub()
                                  _philosophers(index).Fill = _think
                              End Sub).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Wait for forks (Red).
                 fork1.Wait()
 
                 _ui.StartNew(Sub() _philosophers(index).Fill = _wait).Wait()
                 fork2.Wait()
 
                 ' Eat (Green).
                 _ui.StartNew(Sub() _philosophers(index).Fill = _eat).Wait()
                 Thread.Sleep(rand.Next(10) * TIMESCALE)
 
                 ' Done with forks.
                 fork1.Release()
                 fork2.Release()
             End While
         End Sub
 #End Region
 
 #Region "Synchronous, WaitAll"
         ''' <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
         Private Sub RunWithSemaphoresSyncWithWaitAll()
             Dim forks = (
              From i In Enumerable.Range(0, _philosophers.Length)
              Select New Semaphore(1, 1)).ToArray()
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Resources.Designer.vb" startline="38" endline="44"><![CDATA[
 			Get
 				If (resourceMan Is Nothing) Then
 					Dim temp As New Global.System.Resources.ResourceManager("Resources", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
 		End Property
 	End Module
 End Namespace
 					Dim temp As New Global.System.Resources.ResourceManager("Resources", GetType(Resources).Assembly)
 					resourceMan = temp
 				End If
 				Return resourceMan
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Resources.Designer.vb" startline="45" endline="55"><![CDATA[
 		End Property
 
 		''' <summary>
 		'''   Overrides the current thread's CurrentUICulture property for all
 		'''   resource lookups using this strongly typed resource class.
 		''' </summary>
 		<Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>
 		Friend Property Culture() As Global.System.Globalization.CultureInfo
 			Get
 				Return resourceCulture
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Resources.Designer.vb" startline="56" endline="58"><![CDATA[
 			Set(ByVal value As System.Globalization.CultureInfo)
 				resourceCulture = value
 			End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="18" endline="18"><![CDATA[
 		Private Shared defaultInstance As Settings = (CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New Settings()), Settings))
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="19" endline="23"><![CDATA[
 
 		Public Shared ReadOnly Property [Default]() As Settings
 			Get
 				Return defaultInstance
 			End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
