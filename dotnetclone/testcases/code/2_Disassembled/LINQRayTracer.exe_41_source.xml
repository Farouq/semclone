<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Program.cs" startline="19" endline="23"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Program.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Settings.Designer.cs" startline="21" endline="23"><![CDATA[
             get {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Settings.Designer.cs" startline="18" endline="26"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
         
         public static Settings Default {
             get {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="8" endline="25"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public MainForm()
         {
             InitializeComponent();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="26" endline="38"><![CDATA[
 
         private TaskScheduler _uiScheduler;
         private int _width, _height;
         private Bitmap _image;
         private Rectangle _rect;
         private bool _parallel;
         private Stopwatch _sw;
         private CancellationTokenSource _cancellation;
 
         private void MainForm_Load(object sender, EventArgs e)
         {
             _uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="39" endline="76"><![CDATA[
 
         private void btnRender_Click(object sender, EventArgs e)
         {
             if (_cancellation == null)
             {
                 btnRender.Text = "Cancel";
                 rbLINQ.Enabled = false;
                 rbPLINQ.Enabled = false;
 
                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
 
                 Image oldBmp = pbImage.Image;
                 pbImage.Image = _image;
                 if (oldBmp != null) oldBmp.Dispose();
 
                 _parallel = rbPLINQ.Checked;
                 _cancellation = new CancellationTokenSource();
                 _sw = Stopwatch.StartNew();
 
                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
                 background.ContinueWith(_ =>
                 {
                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
                     btnRender.Enabled = true;
                     btnRender.Text = "Render";
                     rbLINQ.Enabled = true;
                     rbPLINQ.Enabled = true;
                     _cancellation = null;
                 }, _uiScheduler);
             }
             else
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
         {
             if (_cancellation == null)
             {
                 btnRender.Text = "Cancel";
                 rbLINQ.Enabled = false;
                 rbPLINQ.Enabled = false;
 
                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
 
                 Image oldBmp = pbImage.Image;
                 pbImage.Image = _image;
                 if (oldBmp != null) oldBmp.Dispose();
 
                 _parallel = rbPLINQ.Checked;
                 _cancellation = new CancellationTokenSource();
                 _sw = Stopwatch.StartNew();
 
                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
                 background.ContinueWith(_ =>
                 {
                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
                     btnRender.Enabled = true;
                     btnRender.Text = "Render";
                     rbLINQ.Enabled = true;
                     rbPLINQ.Enabled = true;
                     _cancellation = null;
                 }, _uiScheduler);
             }
             else
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
             {
                 btnRender.Text = "Cancel";
                 rbLINQ.Enabled = false;
                 rbPLINQ.Enabled = false;
 
                 _width = _height = Math.Min(pbImage.Width, pbImage.Height);
                 _image = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
                 _rect = new Rectangle(0, 0, _width, _height);
 
                 Image oldBmp = pbImage.Image;
                 pbImage.Image = _image;
                 if (oldBmp != null) oldBmp.Dispose();
 
                 _parallel = rbPLINQ.Checked;
                 _cancellation = new CancellationTokenSource();
                 _sw = Stopwatch.StartNew();
 
                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
                 background.ContinueWith(_ =>
                 {
                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
                     btnRender.Enabled = true;
                     btnRender.Text = "Render";
                     rbLINQ.Enabled = true;
                     rbPLINQ.Enabled = true;
                     _cancellation = null;
                 }, _uiScheduler);
             }
             else
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
                 if (oldBmp != null) oldBmp.Dispose();
 
                 _parallel = rbPLINQ.Checked;
                 _cancellation = new CancellationTokenSource();
                 _sw = Stopwatch.StartNew();
 
                 var background = Task.Factory.StartNew(BackgroundRender, _cancellation.Token, _cancellation.Token);
                 background.ContinueWith(_ =>
                 {
                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
                     btnRender.Enabled = true;
                     btnRender.Text = "Render";
                     rbLINQ.Enabled = true;
                     rbPLINQ.Enabled = true;
                     _cancellation = null;
                 }, _uiScheduler);
             }
             else
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="77" endline="94"><![CDATA[
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.pbImage = new System.Windows.Forms.PictureBox();
             this.rbLINQ = new System.Windows.Forms.RadioButton();
             this.rbPLINQ = new System.Windows.Forms.RadioButton();
             this.btnRender = new System.Windows.Forms.Button();
             this.lbTimeToComplete = new System.Windows.Forms.Label();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
             this.SuspendLayout();
             // 
             // pbImage
             // 
             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbImage.BackColor = System.Drawing.Color.Black;
             this.pbImage.Location = new System.Drawing.Point(13, 13);
             this.pbImage.Name = "pbImage";
             this.pbImage.Size = new System.Drawing.Size(359, 352);
             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
             this.pbImage.TabIndex = 0;
             this.pbImage.TabStop = false;
             // 
             // rbLINQ
             // 
             this.rbLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.rbLINQ.AutoSize = true;
             this.rbLINQ.Location = new System.Drawing.Point(12, 374);
             this.rbLINQ.Name = "rbLINQ";
             this.rbLINQ.Size = new System.Drawing.Size(75, 17);
             this.rbLINQ.TabIndex = 1;
             this.rbLINQ.TabStop = true;
             this.rbLINQ.Text = "Sequential";
             this.rbLINQ.UseVisualStyleBackColor = true;
             // 
             // rbPLINQ
             // 
             this.rbPLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.rbPLINQ.AutoSize = true;
             this.rbPLINQ.Location = new System.Drawing.Point(93, 374);
             this.rbPLINQ.Name = "rbPLINQ";
             this.rbPLINQ.Size = new System.Drawing.Size(59, 17);
             this.rbPLINQ.TabIndex = 2;
             this.rbPLINQ.TabStop = true;
             this.rbPLINQ.Text = "Parallel";
             this.rbPLINQ.UseVisualStyleBackColor = true;
             // 
             // btnRender
             // 
             this.btnRender.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.btnRender.Location = new System.Drawing.Point(158, 371);
             this.btnRender.Name = "btnRender";
             this.btnRender.Size = new System.Drawing.Size(75, 23);
             this.btnRender.TabIndex = 3;
             this.btnRender.Text = "Render";
             this.btnRender.UseVisualStyleBackColor = true;
             this.btnRender.Click += new System.EventHandler(this.btnRender_Click);
             // 
             // lbTimeToComplete
             // 
             this.lbTimeToComplete.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.lbTimeToComplete.AutoSize = true;
             this.lbTimeToComplete.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lbTimeToComplete.Location = new System.Drawing.Point(240, 376);
             this.lbTimeToComplete.Name = "lbTimeToComplete";
             this.lbTimeToComplete.Size = new System.Drawing.Size(0, 13);
             this.lbTimeToComplete.TabIndex = 4;
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(388, 401);
             this.Controls.Add(this.lbTimeToComplete);
             this.Controls.Add(this.btnRender);
             this.Controls.Add(this.rbPLINQ);
             this.Controls.Add(this.rbLINQ);
             this.Controls.Add(this.pbImage);
             this.Name = "MainForm";
             this.Text = "LINQ Ray Tracer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
 
         #endregion
 
         private System.Windows.Forms.PictureBox pbImage;
         private System.Windows.Forms.RadioButton rbLINQ;
         private System.Windows.Forms.RadioButton rbPLINQ;
         private System.Windows.Forms.Button btnRender;
         private System.Windows.Forms.Label lbTimeToComplete;
     }
 }
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.Designer.cs" startline="22" endline="114"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.pbImage = new System.Windows.Forms.PictureBox();
             this.rbLINQ = new System.Windows.Forms.RadioButton();
             this.rbPLINQ = new System.Windows.Forms.RadioButton();
             this.btnRender = new System.Windows.Forms.Button();
             this.lbTimeToComplete = new System.Windows.Forms.Label();
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).BeginInit();
             this.SuspendLayout();
             // 
             // pbImage
             // 
             this.pbImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbImage.BackColor = System.Drawing.Color.Black;
             this.pbImage.Location = new System.Drawing.Point(13, 13);
             this.pbImage.Name = "pbImage";
             this.pbImage.Size = new System.Drawing.Size(359, 352);
             this.pbImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
             this.pbImage.TabIndex = 0;
             this.pbImage.TabStop = false;
             // 
             // rbLINQ
             // 
             this.rbLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.rbLINQ.AutoSize = true;
             this.rbLINQ.Location = new System.Drawing.Point(12, 374);
             this.rbLINQ.Name = "rbLINQ";
             this.rbLINQ.Size = new System.Drawing.Size(75, 17);
             this.rbLINQ.TabIndex = 1;
             this.rbLINQ.TabStop = true;
             this.rbLINQ.Text = "Sequential";
             this.rbLINQ.UseVisualStyleBackColor = true;
             // 
             // rbPLINQ
             // 
             this.rbPLINQ.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.rbPLINQ.AutoSize = true;
             this.rbPLINQ.Location = new System.Drawing.Point(93, 374);
             this.rbPLINQ.Name = "rbPLINQ";
             this.rbPLINQ.Size = new System.Drawing.Size(59, 17);
             this.rbPLINQ.TabIndex = 2;
             this.rbPLINQ.TabStop = true;
             this.rbPLINQ.Text = "Parallel";
             this.rbPLINQ.UseVisualStyleBackColor = true;
             // 
             // btnRender
             // 
             this.btnRender.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.btnRender.Location = new System.Drawing.Point(158, 371);
             this.btnRender.Name = "btnRender";
             this.btnRender.Size = new System.Drawing.Size(75, 23);
             this.btnRender.TabIndex = 3;
             this.btnRender.Text = "Render";
             this.btnRender.UseVisualStyleBackColor = true;
             this.btnRender.Click += new System.EventHandler(this.btnRender_Click);
             // 
             // lbTimeToComplete
             // 
             this.lbTimeToComplete.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
             this.lbTimeToComplete.AutoSize = true;
             this.lbTimeToComplete.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
             this.lbTimeToComplete.Location = new System.Drawing.Point(240, 376);
             this.lbTimeToComplete.Name = "lbTimeToComplete";
             this.lbTimeToComplete.Size = new System.Drawing.Size(0, 13);
             this.lbTimeToComplete.TabIndex = 4;
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(388, 401);
             this.Controls.Add(this.lbTimeToComplete);
             this.Controls.Add(this.btnRender);
             this.Controls.Add(this.rbPLINQ);
             this.Controls.Add(this.rbLINQ);
             this.Controls.Add(this.pbImage);
             this.Name = "MainForm";
             this.Text = "LINQ Ray Tracer";
             this.Load += new System.EventHandler(this.MainForm_Load);
             ((System.ComponentModel.ISupportInitialize)(this.pbImage)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="62" endline="96"><![CDATA[
                 {
                     lbTimeToComplete.Text = _sw.Elapsed.ToString();
                     btnRender.Enabled = true;
                     btnRender.Text = "Render";
                     rbLINQ.Enabled = true;
                     rbPLINQ.Enabled = true;
                     _cancellation = null;
                 }, _uiScheduler);
             }
             else
             {
                 btnRender.Enabled = false;
                 _cancellation.Cancel();
             }
         }
 
         private void BackgroundRender(object state)
         {
             var cancellationToken = (CancellationToken)state;
             RayTracer rayTracer = new RayTracer(_width, _height, (rgb) =>
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\MainForm.cs" startline="82" endline="96"><![CDATA[
             {
                 Task.Factory.StartNew(() =>
                 {
                     var bmpData = _image.LockBits(_rect, ImageLockMode.WriteOnly, _image.PixelFormat);
                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
                     _image.UnlockBits(bmpData);
                     pbImage.Refresh();
                 }, CancellationToken.None, TaskCreationOptions.AttachedToParent, _uiScheduler);
             });
 
             if (_parallel) rayTracer.RenderParallel(rayTracer.DefaultScene, cancellationToken);
             else rayTracer.RenderSequential(rayTracer.DefaultScene, cancellationToken);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="220" endline="34"><![CDATA[
         internal readonly Scene DefaultScene =
         public RayTracer(int screenWidth, int screenHeight, Action<int[]> updateImageHandler)
         {
             this.screenWidth = screenWidth;
             this.screenHeight = screenHeight;
             this.updateImageHandler = updateImageHandler;
             this.rowsPerUpdate = screenHeight / 30;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="35" endline="46"><![CDATA[
 
         private class Wrap<T>
         {
             public readonly Func<Wrap<T>, T> It;
             public Wrap(Func<Wrap<T>, T> it) { It = it; }
         }
 
         public static Func<T, U> Y<T, U>(Func<Func<T, U>, Func<T, U>> f)
         {
             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
         }
 
         class TraceRayArgs
         {
             public readonly Ray Ray;
             public readonly Scene Scene;
             public readonly int Depth;
 
             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
         }
 
         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in Enumerable.Range(0, screenHeight)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
         {
             Func<Wrap<Func<T, U>>, Func<T, U>> g = wx => f(wx.It(wx));
             return g(new Wrap<Func<T, U>>(wx => f(y => wx.It(wx)(y))));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="47" endline="136"><![CDATA[
 
         class TraceRayArgs
         {
             public readonly Ray Ray;
             public readonly Scene Scene;
             public readonly int Depth;
 
             public TraceRayArgs(Ray ray, Scene scene, int depth) { Ray = ray; Scene = scene; Depth = depth; }
         }
 
         internal void RenderSequential(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in Enumerable.Range(0, screenHeight)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in Enumerable.Range(0, screenHeight)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="137" endline="218"><![CDATA[
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="63" endline="503"><![CDATA[
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             foreach (var row in pixelsQuery)
             {
                 cancellationToken.ThrowIfCancellationRequested();
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 rowsProcessed++;
                 if (rowsProcessed % rowsPerUpdate == 0 ||
                     rowsProcessed >= screenHeight) updateImageHandler(rgb);
             }
         }
 
         internal void RenderParallel(Scene scene, CancellationToken cancellationToken)
         {
             int[] rgb = new int[screenWidth * screenHeight];
 
             var pixelsQuery =
                 from y in 
                     Enumerable.Range(0, screenHeight).AsParallel()
                     .WithCancellation(cancellationToken)
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="146" endline="503"><![CDATA[
                 let recenterY = -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
                 select from x in Enumerable.Range(0, screenWidth)
                        let recenterX = (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
                        let point =
                            Vector.Norm(Vector.Plus(scene.Camera.Forward,
                                                    Vector.Plus(Vector.Times(recenterX, scene.Camera.Right),
                                                                Vector.Times(recenterY, scene.Camera.Up))))
                        let ray = new Ray() { Start = scene.Camera.Pos, Dir = point }
                        let computeTraceRay = (Func<Func<TraceRayArgs, Color>, Func<TraceRayArgs, Color>>)
                         (f => traceRayArgs =>
                          (from isect in
                               from thing in traceRayArgs.Scene.Things
                               select thing.Intersect(traceRayArgs.Ray)
                           where isect != null
                           orderby isect.Dist
                           let d = isect.Ray.Dir
                           let pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start)
                           let normal = isect.Thing.Normal(pos)
                           let reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
                           let naturalColors =
                               from light in traceRayArgs.Scene.Lights
                               let ldis = Vector.Minus(light.Pos, pos)
                               let livec = Vector.Norm(ldis)
                               let testRay = new Ray() { Start = pos, Dir = livec }
                               let testIsects = from inter in
                                                    from thing in traceRayArgs.Scene.Things
                                                    select thing.Intersect(testRay)
                                                where inter != null
                                                orderby inter.Dist
                                                select inter
                               let testIsect = testIsects.FirstOrDefault()
                               let neatIsect = testIsect == null ? 0 
                               let isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0))
                               where !isInShadow
                               let illum = Vector.Dot(livec, normal)
                               let lcolor = illum > 0 ? Color.Times(illum, light.Color) 
                               let specular = Vector.Dot(livec, Vector.Norm(reflectDir))
                               let scolor = specular > 0
                                              ? Color.Times(Math.Pow(specular, isect.Thing.Surface.Roughness),
                                                            light.Color)
                                              
                               select Color.Plus(Color.Times(isect.Thing.Surface.Diffuse(pos), lcolor),
                                                 Color.Times(isect.Thing.Surface.Specular(pos), scolor))
                           let reflectPos = Vector.Plus(pos, Vector.Times(.001, reflectDir))
                           let reflectColor = traceRayArgs.Depth >= MaxDepth
                                               ? Color.Make(.5, .5, .5)
                                               
                                                             f(new TraceRayArgs(new Ray()
                                                             {
                                                                 Start = reflectPos,
                                                                 Dir = reflectDir
                                                             },
                                                                                traceRayArgs.Scene,
                                                                                traceRayArgs.Depth + 1)))
                           select naturalColors.Aggregate(reflectColor,
                                                          (color, natColor) => Color.Plus(color, natColor))
                          ).DefaultIfEmpty(Color.Background).First())
                        let traceRay = Y(computeTraceRay)
                        select new { X = x, Y = y, Color = traceRay(new TraceRayArgs(ray, scene, 0)) };
 
             int rowsProcessed = 0;
 
             pixelsQuery.ForAll(row =>
             {
                 foreach (var pixel in row)
                 {
                     rgb[pixel.X + (pixel.Y * screenWidth)] = pixel.Color.ToInt32();
                 }
                 int processed = Interlocked.Increment(ref rowsProcessed);
                 if (processed % rowsPerUpdate == 0 ||
                     processed >= screenHeight) updateImageHandler(rgb);
             });
         }
 
         internal readonly Scene DefaultScene =
             new Scene()
             {
                 Things = new SceneObject[] { 
                                 new Plane() {
                                     Norm = Vector.Make(0,1,0),
                                     Offset = 0,
                                     Surface = Surfaces.CheckerBoard
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(0,1,0),
                                     Radius = 1,
                                     Surface = Surfaces.Shiny
                                 },
                                 new Sphere() {
                                     Center = Vector.Make(-1,.5,1.5),
                                     Radius = .5,
                                     Surface = Surfaces.Shiny
                                 }},
                 Lights = new Light[] { 
                                 new Light() {
                                     Pos = Vector.Make(-2,2.5,0),
                                     Color = Color.Make(.49,.07,.07)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,1.5),
                                     Color = Color.Make(.07,.07,.49)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(1.5,2.5,-1.5),
                                     Color = Color.Make(.07,.49,.071)
                                 },
                                 new Light() {
                                     Pos = Vector.Make(0,3.5,0),
                                     Color = Color.Make(.21,.21,.35)
                                 }},
                 Camera = Camera.Create(Vector.Make(3, 2, 4), Vector.Make(-1, .5, 0))
             };
     }
 
     static class Surfaces
     {
         // Only works with X-Z plane.
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="263" endline="503"><![CDATA[
         public static readonly Surface CheckerBoard =
             new Surface()
             {
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="266" endline="503"><![CDATA[
                 Diffuse = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? Color.Make(1, 1, 1)
                                     
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="269" endline="503"><![CDATA[
                 Specular = pos => Color.Make(1, 1, 1),
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="270" endline="503"><![CDATA[
                 Reflect = pos => ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
                                     ? .1
                                     
                 Roughness = 150
             };
 
 
         public static readonly Surface Shiny =
             new Surface()
             {
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="280" endline="503"><![CDATA[
                 Diffuse = pos => Color.Make(1, 1, 1),
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="281" endline="503"><![CDATA[
                 Specular = pos => Color.Make(.5, .5, .5),
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="282" endline="503"><![CDATA[
                 Reflect = pos => .6,
                 Roughness = 50
             };
     }
 
     class Vector
     {
         public readonly double X;
         public readonly double Y;
         public readonly double Z;
 
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="293" endline="293"><![CDATA[
         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="294" endline="295"><![CDATA[
 
         public static Vector Make(double x, double y, double z) { return new Vector(x, y, z); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="296" endline="299"><![CDATA[
         public static Vector Times(double n, Vector v)
         {
             return new Vector(v.X * n, v.Y * n, v.Z * n);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="300" endline="303"><![CDATA[
         public static Vector Minus(Vector v1, Vector v2)
         {
             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="304" endline="307"><![CDATA[
         public static Vector Plus(Vector v1, Vector v2)
         {
             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="308" endline="311"><![CDATA[
         public static double Dot(Vector v1, Vector v2)
         {
             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="312" endline="312"><![CDATA[
         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="313" endline="318"><![CDATA[
         public static Vector Norm(Vector v)
         {
             double mag = Mag(v);
             double div = mag == 0 ? double.PositiveInfinity 
             return Times(div, v);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="319" endline="324"><![CDATA[
         public static Vector Cross(Vector v1, Vector v2)
         {
             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="325" endline="328"><![CDATA[
         public static bool Equals(Vector v1, Vector v2)
         {
             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="329" endline="337"><![CDATA[
     }
 
     public class Color
     {
         public double R;
         public double G;
         public double B;
 
         public Color(double r, double g, double b) { R = r; G = g; B = b; }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="338" endline="339"><![CDATA[
 
         public static Color Make(double r, double g, double b) { return new Color(r, g, b); }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="340" endline="344"><![CDATA[
 
         public static Color Times(double n, Color v)
         {
             return new Color(n * v.R, n * v.G, n * v.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="345" endline="348"><![CDATA[
         public static Color Times(Color v1, Color v2)
         {
             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="349" endline="353"><![CDATA[
 
         public static Color Plus(Color v1, Color v2)
         {
             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="354" endline="357"><![CDATA[
         public static Color Minus(Color v1, Color v2)
         {
             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="358" endline="365"><![CDATA[
 
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="366" endline="370"><![CDATA[
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="371" endline="379"><![CDATA[
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="359" endline="503"><![CDATA[
         public static readonly Color Background = Make(0, 0, 0);
         public static readonly Color DefaultColor = Make(0, 0, 0);
 
         private double Legalize(double d)
         {
             return d > 1 ? 1 
         }
 
         public System.Drawing.Color ToDrawingColor()
         {
             return System.Drawing.Color.FromArgb((int)(Legalize(R) * 255), (int)(Legalize(G) * 255), (int)(Legalize(B) * 255));
         }
 
         public Int32 ToInt32()
         {
             return
                 (255 << 24) |
                 ((int)(Legalize(R) * 255)) << 16 |
                 ((int)(Legalize(G) * 255)) << 8 |
                 ((int)(Legalize(B) * 255));
         }
     }
 
     class Ray
     {
         public Vector Start;
         public Vector Dir;
     }
 
     class ISect
     {
         public SceneObject Thing;
         public Ray Ray;
         public double Dist;
     }
 
     class Surface
     {
         public Func<Vector, Color> Diffuse;
         public Func<Vector, Color> Specular;
         public Func<Vector, double> Reflect;
         public double Roughness;
     }
 
     class Camera
     {
         public Vector Pos;
         public Vector Forward;
         public Vector Up;
         public Vector Right;
 
         public static Camera Create(Vector pos, Vector lookAt)
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="411" endline="418"><![CDATA[
         {
             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
             Vector down = new Vector(0, -1, 0);
             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
 
             return new Camera() { Pos = pos, Forward = forward, Up = up, Right = right };
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="419" endline="460"><![CDATA[
     }
 
     class Light
     {
         public Vector Pos;
         public Color Color;
     }
 
     abstract class SceneObject
     {
         public Surface Surface;
         public abstract ISect Intersect(Ray ray);
         public abstract Vector Normal(Vector pos);
     }
 
     class Sphere 
     {
         public Vector Center;
         public double Radius;
 
         public override ISect Intersect(Ray ray)
         {
             Vector eo = Vector.Minus(Center, ray.Start);
             double v = Vector.Dot(eo, ray.Dir);
             double dist;
             if (v < 0)
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
             {
                 dist = 0;
             }
             else
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
             {
                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
                 dist = disc < 0 ? 0 
             }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
             if (dist == 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = dist
                    };
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="461" endline="465"><![CDATA[
 
         public override Vector Normal(Vector pos)
         {
             return Vector.Norm(Vector.Minus(pos, Center));
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="466" endline="483"><![CDATA[
     }
 
     class Plane 
     {
         public Vector Norm;
         public double Offset;
 
         public override ISect Intersect(Ray ray)
         {
             double denom = Vector.Dot(Norm, ray.Dir);
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
     }
 
     class Scene
     {
         public SceneObject[] Things;
         public Light[] Lights;
         public Camera Camera;
 
         public IEnumerable<ISect> Intersect(Ray r)
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
     }
 }
             if (denom > 0) return null;
             return new ISect()
                    {
                        Thing = this,
                        Ray = ray,
                        Dist = (Vector.Dot(Norm, ray.Start) + Offset) / (-denom)
                    };
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="484" endline="488"><![CDATA[
 
         public override Vector Normal(Vector pos)
         {
             return Norm;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="498" endline="501"><![CDATA[
         {
             return from thing in Things
                    select thing.Intersect(r);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\LINQRayTracer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="31" endline="33"><![CDATA[
         [global
         internal Resources() {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="34" endline="47"><![CDATA[
         
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
             get {
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
             set {
                 resourceCulture = value;
             }
         }
     }
 }
                 if (object.ReferenceEquals(resourceMan, null)) {
                     global
                             "es", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="48" endline="58"><![CDATA[
         }
         
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
             get {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="59" endline="61"><![CDATA[
             set {
                 resourceCulture = value;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\LINQRayTracer\LINQRayTracer_CSharp\Properties\Resources.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
