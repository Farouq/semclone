<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Application.Designer.vb" startline="25" endline="31"><![CDATA[
         Public Sub New()
             MyBase.New(Global.Microsoft.VisualBasic.ApplicationServices.AuthenticationMode.Windows)
             Me.IsSingleInstance = false
             Me.EnableVisualStyles = true
             Me.SaveMySettingsOnExit = false
             Me.ShutDownStyle = Global.Microsoft.VisualBasic.ApplicationServices.ShutdownMode.AfterMainFormCloses
         End Sub
         
         <Global.System.Diagnostics.DebuggerStepThroughAttribute()>  _
         Protected Overrides Sub OnCreateMainForm()
             Me.MainForm = Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Main
         End Sub
     End Class
 End Namespace
             Me.IsSingleInstance = false
             Me.EnableVisualStyles = true
             Me.SaveMySettingsOnExit = false
             Me.ShutDownStyle = Global.Microsoft.VisualBasic.ApplicationServices.ShutdownMode.AfterMainFormCloses
         End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Application.Designer.vb" startline="32" endline="36"><![CDATA[
         
         <Global.System.Diagnostics.DebuggerStepThroughAttribute()>  _
         Protected Overrides Sub OnCreateMainForm()
             Me.MainForm = Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Main
         End Sub
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="17d14f5c-a337-4978-8281-53493378c1071.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Camera.vb" startline="15" endline="20"><![CDATA[
     Public Sub New(ByVal position As Vector, ByVal forward As Vector, ByVal up As Vector, ByVal right As Vector)
         Me.Position = position
         Me.Forward = forward
         Me.Up = up
         Me.Right = right
     End Sub
 
     Public Shared Function Create(ByVal pos As Vector, ByVal lookat As Vector) As Camera
         Dim forward = Vector.Norm(Vector.Minus(lookat, pos))
         Dim down = New Vector(0, -1, 0)
         Dim right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)))
         Dim up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)))
         Return New Camera(pos, forward, up, right)
     End Function
 End Class
         Me.Position = position
         Me.Forward = forward
         Me.Up = up
         Me.Right = right
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Camera.vb" startline="21" endline="28"><![CDATA[
 
     Public Shared Function Create(ByVal pos As Vector, ByVal lookat As Vector) As Camera
         Dim forward = Vector.Norm(Vector.Minus(lookat, pos))
         Dim down = New Vector(0, -1, 0)
         Dim right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)))
         Dim up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)))
         Return New Camera(pos, forward, up, right)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="44" endline="45"><![CDATA[
     Public Shared ReadOnly Background As Color = New Color(0, 0, 0)
     Public Shared ReadOnly DefaultColor As Color = New Color(0, 0, 0)
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="14" endline="18"><![CDATA[
     Public Sub New(ByVal r As Double, ByVal g As Double, ByVal b As Double)
         Me.R = r
         Me.G = g
         Me.B = b
     End Sub
 
     Public Sub New(ByVal str As String)
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.R = Double.Parse(nums(0))
         Me.G = Double.Parse(nums(1))
         Me.B = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal c As Color) As Color
         Return New Color(n * c.R, n * c.G, n * c.B)
     End Function
 
     Public Shared Function Times(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R * c2.R, c1.G * c2.G, c1.B * c2.B)
     End Function
 
     Public Shared Function Plus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R + c2.R, c1.G + c2.G, c1.B + c2.B)
     End Function
 
     Public Shared Function Minus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R - c2.R, c1.G - c2.G, c1.B - c2.B)
     End Function
 
     Public Shared ReadOnly Background As Color = New Color(0, 0, 0)
     Public Shared ReadOnly DefaultColor As Color = New Color(0, 0, 0)
 
     Public Shared Function Legalize(ByVal d As Double) As Double
         Return If(d > 1, 1, d)
     End Function
 
     Public Shared Function ToByte(ByVal d As Double) As Byte
         Return CType(255 * Legalize(d), Byte)
     End Function
 
     Public Shared Function ToInt32(ByVal c As Double) As Int32
         Dim r = CType(255 * c, Int32)
         Return If(r > 255, 255, r)
     End Function
 
     Public Function ToInt32() As Int32
         Return ToInt32(B) Or ToInt32(G) << 8 Or ToInt32(R) << 16 Or CType(255 << 24, Int32)
     End Function
 
     Friend Function ToDrawingColor() As System.Drawing.Color
         Return System.Drawing.Color.FromArgb(ToInt32())
     End Function
 
     Public Sub ChangeHue(ByVal hue As Double)
 
         Dim S = 0.9
         Dim L = ((System.Drawing.Color.FromArgb(ToInt32()).GetBrightness() - 0.5) * 0.5) + 0.5
         Dim H = hue
 
         If L = 0 Then
             R = 0.0
             G = 0.0
             B = 0.0
         ElseIf S = 0 Then
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
         Me.R = r
         Me.G = g
         Me.B = b
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="19" endline="26"><![CDATA[
 
     Public Sub New(ByVal str As String)
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.R = Double.Parse(nums(0))
         Me.G = Double.Parse(nums(1))
         Me.B = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal c As Color) As Color
         Return New Color(n * c.R, n * c.G, n * c.B)
     End Function
 
     Public Shared Function Times(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R * c2.R, c1.G * c2.G, c1.B * c2.B)
     End Function
 
     Public Shared Function Plus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R + c2.R, c1.G + c2.G, c1.B + c2.B)
     End Function
 
     Public Shared Function Minus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R - c2.R, c1.G - c2.G, c1.B - c2.B)
     End Function
 
     Public Shared ReadOnly Background As Color = New Color(0, 0, 0)
     Public Shared ReadOnly DefaultColor As Color = New Color(0, 0, 0)
 
     Public Shared Function Legalize(ByVal d As Double) As Double
         Return If(d > 1, 1, d)
     End Function
 
     Public Shared Function ToByte(ByVal d As Double) As Byte
         Return CType(255 * Legalize(d), Byte)
     End Function
 
     Public Shared Function ToInt32(ByVal c As Double) As Int32
         Dim r = CType(255 * c, Int32)
         Return If(r > 255, 255, r)
     End Function
 
     Public Function ToInt32() As Int32
         Return ToInt32(B) Or ToInt32(G) << 8 Or ToInt32(R) << 16 Or CType(255 << 24, Int32)
     End Function
 
     Friend Function ToDrawingColor() As System.Drawing.Color
         Return System.Drawing.Color.FromArgb(ToInt32())
     End Function
 
     Public Sub ChangeHue(ByVal hue As Double)
 
         Dim S = 0.9
         Dim L = ((System.Drawing.Color.FromArgb(ToInt32()).GetBrightness() - 0.5) * 0.5) + 0.5
         Dim H = hue
 
         If L = 0 Then
             R = 0.0
             G = 0.0
             B = 0.0
         ElseIf S = 0 Then
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.R = Double.Parse(nums(0))
         Me.G = Double.Parse(nums(1))
         Me.B = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal c As Color) As Color
         Return New Color(n * c.R, n * c.G, n * c.B)
     End Function
 
     Public Shared Function Times(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R * c2.R, c1.G * c2.G, c1.B * c2.B)
     End Function
 
     Public Shared Function Plus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R + c2.R, c1.G + c2.G, c1.B + c2.B)
     End Function
 
     Public Shared Function Minus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R - c2.R, c1.G - c2.G, c1.B - c2.B)
     End Function
 
     Public Shared ReadOnly Background As Color = New Color(0, 0, 0)
     Public Shared ReadOnly DefaultColor As Color = New Color(0, 0, 0)
 
     Public Shared Function Legalize(ByVal d As Double) As Double
         Return If(d > 1, 1, d)
     End Function
 
     Public Shared Function ToByte(ByVal d As Double) As Byte
         Return CType(255 * Legalize(d), Byte)
     End Function
 
     Public Shared Function ToInt32(ByVal c As Double) As Int32
         Dim r = CType(255 * c, Int32)
         Return If(r > 255, 255, r)
     End Function
 
     Public Function ToInt32() As Int32
         Return ToInt32(B) Or ToInt32(G) << 8 Or ToInt32(R) << 16 Or CType(255 << 24, Int32)
     End Function
 
     Friend Function ToDrawingColor() As System.Drawing.Color
         Return System.Drawing.Color.FromArgb(ToInt32())
     End Function
 
     Public Sub ChangeHue(ByVal hue As Double)
 
         Dim S = 0.9
         Dim L = ((System.Drawing.Color.FromArgb(ToInt32()).GetBrightness() - 0.5) * 0.5) + 0.5
         Dim H = hue
 
         If L = 0 Then
             R = 0.0
             G = 0.0
             B = 0.0
         ElseIf S = 0 Then
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.R = Double.Parse(nums(0))
         Me.G = Double.Parse(nums(1))
         Me.B = Double.Parse(nums(2))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="27" endline="30"><![CDATA[
 
     Public Shared Function Times(ByVal n As Double, ByVal c As Color) As Color
         Return New Color(n * c.R, n * c.G, n * c.B)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="31" endline="34"><![CDATA[
 
     Public Shared Function Times(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R * c2.R, c1.G * c2.G, c1.B * c2.B)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="35" endline="38"><![CDATA[
 
     Public Shared Function Plus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R + c2.R, c1.G + c2.G, c1.B + c2.B)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="39" endline="42"><![CDATA[
 
     Public Shared Function Minus(ByVal c1 As Color, ByVal c2 As Color) As Color
         Return New Color(c1.R - c2.R, c1.G - c2.G, c1.B - c2.B)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="43" endline="49"><![CDATA[
 
     Public Shared ReadOnly Background As Color = New Color(0, 0, 0)
     Public Shared ReadOnly DefaultColor As Color = New Color(0, 0, 0)
 
     Public Shared Function Legalize(ByVal d As Double) As Double
         Return If(d > 1, 1, d)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="50" endline="53"><![CDATA[
 
     Public Shared Function ToByte(ByVal d As Double) As Byte
         Return CType(255 * Legalize(d), Byte)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="54" endline="58"><![CDATA[
 
     Public Shared Function ToInt32(ByVal c As Double) As Int32
         Dim r = CType(255 * c, Int32)
         Return If(r > 255, 255, r)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="59" endline="62"><![CDATA[
 
     Public Function ToInt32() As Int32
         Return ToInt32(B) Or ToInt32(G) << 8 Or ToInt32(R) << 16 Or CType(255 << 24, Int32)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="63" endline="66"><![CDATA[
 
     Friend Function ToDrawingColor() As System.Drawing.Color
         Return System.Drawing.Color.FromArgb(ToInt32())
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Color.vb" startline="67" endline="107"><![CDATA[
 
     Public Sub ChangeHue(ByVal hue As Double)
 
         Dim S = 0.9
         Dim L = ((System.Drawing.Color.FromArgb(ToInt32()).GetBrightness() - 0.5) * 0.5) + 0.5
         Dim H = hue
 
         If L = 0 Then
             R = 0.0
             G = 0.0
             B = 0.0
         ElseIf S = 0 Then
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
             R = 0.0
             G = 0.0
             B = 0.0
         ElseIf S = 0 Then
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
             R = L
             G = L
             B = L
         Else
             Dim temp2 = If(L <= 0.5, L * (1.0 + S), L + S - (L * S))
             Dim temp1 = 2.0 * L - temp2
 
             Dim t3 = New Double() {H + 1.0 / 3.0, H, H - 1.0 / 3.0}
             Dim clr = New Double() {0, 0, 0}
 
             For i = 0 To 2
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
                 If (t3(i) < 0) Then t3(i) += 1.0
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
                 If (t3(i) > 1) Then t3(i) -= 1.0
                 If (6.0 * t3(i) < 1.0) Then
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
                     clr(i) = temp1 + (temp2 - temp1) * t3(i) * 6.0
                 ElseIf (2.0 * t3(i) < 1.0) Then
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
                     clr(i) = temp2
                 ElseIf (3.0 * t3(i) < 2.0) Then
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
                     clr(i) = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3(i)) * 6.0)
                 Else
                     clr(i) = temp1
                 End If
             Next
 
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
 End Structure
             R = clr(0)
             G = clr(1)
             B = clr(2)
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\ISect.vb" startline="14" endline="18"><![CDATA[
     Public Sub New(ByVal thing As SceneObject, ByVal ray As Ray, ByVal dist As Double)
         Me.Thing = thing
         Me.Ray = ray
         Me.Dist = dist
     End Sub
 End Class
         Me.Thing = thing
         Me.Ray = ray
         Me.Dist = dist
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Light.vb" startline="13" endline="16"><![CDATA[
     Public Sub New(ByVal position As Vector, ByVal color As Color)
         Me.Position = position
         Me.Color = color
     End Sub
 End Class
         Me.Position = position
         Me.Color = color
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="21" endline="21"><![CDATA[
     Private _degreeOfParallelism As Int32 = Environment.ProcessorCount
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="7" endline="15"><![CDATA[
     Protected Overrides Sub Dispose(ByVal disposing As Boolean)
         Try
             If disposing AndAlso components IsNot Nothing Then
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.lblNumProcs = New System.Windows.Forms.Label()
         Me.tbNumProcs = New System.Windows.Forms.TrackBar()
         Me.chkShowThreads = New System.Windows.Forms.CheckBox()
         Me.chkParallel = New System.Windows.Forms.CheckBox()
         Me.btnStartStop = New System.Windows.Forms.Button()
         Me.pbRenderedImage = New System.Windows.Forms.PictureBox()
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lblNumProcs
         '
         Me.lblNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lblNumProcs.AutoSize = True
         Me.lblNumProcs.Enabled = False
         Me.lblNumProcs.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lblNumProcs.Location = New System.Drawing.Point(294, 428)
         Me.lblNumProcs.Name = "lblNumProcs"
         Me.lblNumProcs.Size = New System.Drawing.Size(14, 13)
         Me.lblNumProcs.TabIndex = 29
         Me.lblNumProcs.Text = "1"
         '
         'tbNumProcs
         '
         Me.tbNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.tbNumProcs.Enabled = False
         Me.tbNumProcs.Location = New System.Drawing.Point(303, 418)
         Me.tbNumProcs.Maximum = 24
         Me.tbNumProcs.Minimum = 1
         Me.tbNumProcs.Name = "tbNumProcs"
         Me.tbNumProcs.Size = New System.Drawing.Size(178, 45)
         Me.tbNumProcs.TabIndex = 28
         Me.tbNumProcs.Value = 1
         '
         'chkShowThreads
         '
         Me.chkShowThreads.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkShowThreads.AutoSize = True
         Me.chkShowThreads.Enabled = False
         Me.chkShowThreads.Location = New System.Drawing.Point(173, 423)
         Me.chkShowThreads.Name = "chkShowThreads"
         Me.chkShowThreads.Size = New System.Drawing.Size(95, 17)
         Me.chkShowThreads.TabIndex = 27
         Me.chkShowThreads.Text = "Show Threads"
         Me.chkShowThreads.UseVisualStyleBackColor = True
         '
         'chkParallel
         '
         Me.chkParallel.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkParallel.AutoSize = True
         Me.chkParallel.Location = New System.Drawing.Point(107, 423)
         Me.chkParallel.Name = "chkParallel"
         Me.chkParallel.Size = New System.Drawing.Size(60, 17)
         Me.chkParallel.TabIndex = 26
         Me.chkParallel.Text = "Parallel"
         Me.chkParallel.UseVisualStyleBackColor = True
         '
         'btnStartStop
         '
         Me.btnStartStop.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.btnStartStop.Location = New System.Drawing.Point(12, 418)
         Me.btnStartStop.Name = "btnStartStop"
         Me.btnStartStop.Size = New System.Drawing.Size(88, 23)
         Me.btnStartStop.TabIndex = 25
         Me.btnStartStop.Text = "Start"
         Me.btnStartStop.UseVisualStyleBackColor = True
         '
         'pbRenderedImage
         '
         Me.pbRenderedImage.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.pbRenderedImage.BackColor = System.Drawing.Color.Black
         Me.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.pbRenderedImage.Location = New System.Drawing.Point(12, 12)
         Me.pbRenderedImage.Name = "pbRenderedImage"
         Me.pbRenderedImage.Size = New System.Drawing.Size(469, 400)
         Me.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage
         Me.pbRenderedImage.TabIndex = 24
         Me.pbRenderedImage.TabStop = False
         '
         'Main
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(495, 459)
         Me.Controls.Add(Me.lblNumProcs)
         Me.Controls.Add(Me.tbNumProcs)
         Me.Controls.Add(Me.chkShowThreads)
         Me.Controls.Add(Me.chkParallel)
         Me.Controls.Add(Me.btnStartStop)
         Me.Controls.Add(Me.pbRenderedImage)
         Me.Name = "Main"
         Me.Text = "Ray Tracer"
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
     Private WithEvents lblNumProcs As System.Windows.Forms.Label
     Private WithEvents tbNumProcs As System.Windows.Forms.TrackBar
     Friend WithEvents chkShowThreads As System.Windows.Forms.CheckBox
     Friend WithEvents chkParallel As System.Windows.Forms.CheckBox
     Private WithEvents btnStartStop As System.Windows.Forms.Button
     Private WithEvents pbRenderedImage As System.Windows.Forms.PictureBox
 End Class
                 components.Dispose()
             End If
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.lblNumProcs = New System.Windows.Forms.Label()
         Me.tbNumProcs = New System.Windows.Forms.TrackBar()
         Me.chkShowThreads = New System.Windows.Forms.CheckBox()
         Me.chkParallel = New System.Windows.Forms.CheckBox()
         Me.btnStartStop = New System.Windows.Forms.Button()
         Me.pbRenderedImage = New System.Windows.Forms.PictureBox()
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lblNumProcs
         '
         Me.lblNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lblNumProcs.AutoSize = True
         Me.lblNumProcs.Enabled = False
         Me.lblNumProcs.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lblNumProcs.Location = New System.Drawing.Point(294, 428)
         Me.lblNumProcs.Name = "lblNumProcs"
         Me.lblNumProcs.Size = New System.Drawing.Size(14, 13)
         Me.lblNumProcs.TabIndex = 29
         Me.lblNumProcs.Text = "1"
         '
         'tbNumProcs
         '
         Me.tbNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.tbNumProcs.Enabled = False
         Me.tbNumProcs.Location = New System.Drawing.Point(303, 418)
         Me.tbNumProcs.Maximum = 24
         Me.tbNumProcs.Minimum = 1
         Me.tbNumProcs.Name = "tbNumProcs"
         Me.tbNumProcs.Size = New System.Drawing.Size(178, 45)
         Me.tbNumProcs.TabIndex = 28
         Me.tbNumProcs.Value = 1
         '
         'chkShowThreads
         '
         Me.chkShowThreads.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkShowThreads.AutoSize = True
         Me.chkShowThreads.Enabled = False
         Me.chkShowThreads.Location = New System.Drawing.Point(173, 423)
         Me.chkShowThreads.Name = "chkShowThreads"
         Me.chkShowThreads.Size = New System.Drawing.Size(95, 17)
         Me.chkShowThreads.TabIndex = 27
         Me.chkShowThreads.Text = "Show Threads"
         Me.chkShowThreads.UseVisualStyleBackColor = True
         '
         'chkParallel
         '
         Me.chkParallel.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkParallel.AutoSize = True
         Me.chkParallel.Location = New System.Drawing.Point(107, 423)
         Me.chkParallel.Name = "chkParallel"
         Me.chkParallel.Size = New System.Drawing.Size(60, 17)
         Me.chkParallel.TabIndex = 26
         Me.chkParallel.Text = "Parallel"
         Me.chkParallel.UseVisualStyleBackColor = True
         '
         'btnStartStop
         '
         Me.btnStartStop.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.btnStartStop.Location = New System.Drawing.Point(12, 418)
         Me.btnStartStop.Name = "btnStartStop"
         Me.btnStartStop.Size = New System.Drawing.Size(88, 23)
         Me.btnStartStop.TabIndex = 25
         Me.btnStartStop.Text = "Start"
         Me.btnStartStop.UseVisualStyleBackColor = True
         '
         'pbRenderedImage
         '
         Me.pbRenderedImage.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.pbRenderedImage.BackColor = System.Drawing.Color.Black
         Me.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.pbRenderedImage.Location = New System.Drawing.Point(12, 12)
         Me.pbRenderedImage.Name = "pbRenderedImage"
         Me.pbRenderedImage.Size = New System.Drawing.Size(469, 400)
         Me.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage
         Me.pbRenderedImage.TabIndex = 24
         Me.pbRenderedImage.TabStop = False
         '
         'Main
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(495, 459)
         Me.Controls.Add(Me.lblNumProcs)
         Me.Controls.Add(Me.tbNumProcs)
         Me.Controls.Add(Me.chkShowThreads)
         Me.Controls.Add(Me.chkParallel)
         Me.Controls.Add(Me.btnStartStop)
         Me.Controls.Add(Me.pbRenderedImage)
         Me.Name = "Main"
         Me.Text = "Ray Tracer"
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
     Private WithEvents lblNumProcs As System.Windows.Forms.Label
     Private WithEvents tbNumProcs As System.Windows.Forms.TrackBar
     Friend WithEvents chkShowThreads As System.Windows.Forms.CheckBox
     Friend WithEvents chkParallel As System.Windows.Forms.CheckBox
     Private WithEvents btnStartStop As System.Windows.Forms.Button
     Private WithEvents pbRenderedImage As System.Windows.Forms.PictureBox
 End Class
         Finally
             MyBase.Dispose(disposing)
         End Try
     End Sub
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.lblNumProcs = New System.Windows.Forms.Label()
         Me.tbNumProcs = New System.Windows.Forms.TrackBar()
         Me.chkShowThreads = New System.Windows.Forms.CheckBox()
         Me.chkParallel = New System.Windows.Forms.CheckBox()
         Me.btnStartStop = New System.Windows.Forms.Button()
         Me.pbRenderedImage = New System.Windows.Forms.PictureBox()
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lblNumProcs
         '
         Me.lblNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lblNumProcs.AutoSize = True
         Me.lblNumProcs.Enabled = False
         Me.lblNumProcs.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lblNumProcs.Location = New System.Drawing.Point(294, 428)
         Me.lblNumProcs.Name = "lblNumProcs"
         Me.lblNumProcs.Size = New System.Drawing.Size(14, 13)
         Me.lblNumProcs.TabIndex = 29
         Me.lblNumProcs.Text = "1"
         '
         'tbNumProcs
         '
         Me.tbNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.tbNumProcs.Enabled = False
         Me.tbNumProcs.Location = New System.Drawing.Point(303, 418)
         Me.tbNumProcs.Maximum = 24
         Me.tbNumProcs.Minimum = 1
         Me.tbNumProcs.Name = "tbNumProcs"
         Me.tbNumProcs.Size = New System.Drawing.Size(178, 45)
         Me.tbNumProcs.TabIndex = 28
         Me.tbNumProcs.Value = 1
         '
         'chkShowThreads
         '
         Me.chkShowThreads.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkShowThreads.AutoSize = True
         Me.chkShowThreads.Enabled = False
         Me.chkShowThreads.Location = New System.Drawing.Point(173, 423)
         Me.chkShowThreads.Name = "chkShowThreads"
         Me.chkShowThreads.Size = New System.Drawing.Size(95, 17)
         Me.chkShowThreads.TabIndex = 27
         Me.chkShowThreads.Text = "Show Threads"
         Me.chkShowThreads.UseVisualStyleBackColor = True
         '
         'chkParallel
         '
         Me.chkParallel.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkParallel.AutoSize = True
         Me.chkParallel.Location = New System.Drawing.Point(107, 423)
         Me.chkParallel.Name = "chkParallel"
         Me.chkParallel.Size = New System.Drawing.Size(60, 17)
         Me.chkParallel.TabIndex = 26
         Me.chkParallel.Text = "Parallel"
         Me.chkParallel.UseVisualStyleBackColor = True
         '
         'btnStartStop
         '
         Me.btnStartStop.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.btnStartStop.Location = New System.Drawing.Point(12, 418)
         Me.btnStartStop.Name = "btnStartStop"
         Me.btnStartStop.Size = New System.Drawing.Size(88, 23)
         Me.btnStartStop.TabIndex = 25
         Me.btnStartStop.Text = "Start"
         Me.btnStartStop.UseVisualStyleBackColor = True
         '
         'pbRenderedImage
         '
         Me.pbRenderedImage.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.pbRenderedImage.BackColor = System.Drawing.Color.Black
         Me.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.pbRenderedImage.Location = New System.Drawing.Point(12, 12)
         Me.pbRenderedImage.Name = "pbRenderedImage"
         Me.pbRenderedImage.Size = New System.Drawing.Size(469, 400)
         Me.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage
         Me.pbRenderedImage.TabIndex = 24
         Me.pbRenderedImage.TabStop = False
         '
         'Main
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(495, 459)
         Me.Controls.Add(Me.lblNumProcs)
         Me.Controls.Add(Me.tbNumProcs)
         Me.Controls.Add(Me.chkShowThreads)
         Me.Controls.Add(Me.chkParallel)
         Me.Controls.Add(Me.btnStartStop)
         Me.Controls.Add(Me.pbRenderedImage)
         Me.Name = "Main"
         Me.Text = "Ray Tracer"
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
     Private WithEvents lblNumProcs As System.Windows.Forms.Label
     Private WithEvents tbNumProcs As System.Windows.Forms.TrackBar
     Friend WithEvents chkShowThreads As System.Windows.Forms.CheckBox
     Friend WithEvents chkParallel As System.Windows.Forms.CheckBox
     Private WithEvents btnStartStop As System.Windows.Forms.Button
     Private WithEvents pbRenderedImage As System.Windows.Forms.PictureBox
 End Class
         End Try
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="16" endline="125"><![CDATA[
 
     'Required by the Windows Form Designer
     Private components As System.ComponentModel.IContainer
 
     'NOTE
     'It can be modified using the Windows Form Designer.  
     'Do not modify it using the code editor.
     <System.Diagnostics.DebuggerStepThrough()> _
     Private Sub InitializeComponent()
         Me.lblNumProcs = New System.Windows.Forms.Label()
         Me.tbNumProcs = New System.Windows.Forms.TrackBar()
         Me.chkShowThreads = New System.Windows.Forms.CheckBox()
         Me.chkParallel = New System.Windows.Forms.CheckBox()
         Me.btnStartStop = New System.Windows.Forms.Button()
         Me.pbRenderedImage = New System.Windows.Forms.PictureBox()
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).BeginInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).BeginInit()
         Me.SuspendLayout()
         '
         'lblNumProcs
         '
         Me.lblNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.lblNumProcs.AutoSize = True
         Me.lblNumProcs.Enabled = False
         Me.lblNumProcs.Font = New System.Drawing.Font("Microsoft Sans Serif", 8.25!, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, CType(0, Byte))
         Me.lblNumProcs.Location = New System.Drawing.Point(294, 428)
         Me.lblNumProcs.Name = "lblNumProcs"
         Me.lblNumProcs.Size = New System.Drawing.Size(14, 13)
         Me.lblNumProcs.TabIndex = 29
         Me.lblNumProcs.Text = "1"
         '
         'tbNumProcs
         '
         Me.tbNumProcs.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.tbNumProcs.Enabled = False
         Me.tbNumProcs.Location = New System.Drawing.Point(303, 418)
         Me.tbNumProcs.Maximum = 24
         Me.tbNumProcs.Minimum = 1
         Me.tbNumProcs.Name = "tbNumProcs"
         Me.tbNumProcs.Size = New System.Drawing.Size(178, 45)
         Me.tbNumProcs.TabIndex = 28
         Me.tbNumProcs.Value = 1
         '
         'chkShowThreads
         '
         Me.chkShowThreads.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkShowThreads.AutoSize = True
         Me.chkShowThreads.Enabled = False
         Me.chkShowThreads.Location = New System.Drawing.Point(173, 423)
         Me.chkShowThreads.Name = "chkShowThreads"
         Me.chkShowThreads.Size = New System.Drawing.Size(95, 17)
         Me.chkShowThreads.TabIndex = 27
         Me.chkShowThreads.Text = "Show Threads"
         Me.chkShowThreads.UseVisualStyleBackColor = True
         '
         'chkParallel
         '
         Me.chkParallel.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.chkParallel.AutoSize = True
         Me.chkParallel.Location = New System.Drawing.Point(107, 423)
         Me.chkParallel.Name = "chkParallel"
         Me.chkParallel.Size = New System.Drawing.Size(60, 17)
         Me.chkParallel.TabIndex = 26
         Me.chkParallel.Text = "Parallel"
         Me.chkParallel.UseVisualStyleBackColor = True
         '
         'btnStartStop
         '
         Me.btnStartStop.Anchor = CType((System.Windows.Forms.AnchorStyles.Bottom Or System.Windows.Forms.AnchorStyles.Left), System.Windows.Forms.AnchorStyles)
         Me.btnStartStop.Location = New System.Drawing.Point(12, 418)
         Me.btnStartStop.Name = "btnStartStop"
         Me.btnStartStop.Size = New System.Drawing.Size(88, 23)
         Me.btnStartStop.TabIndex = 25
         Me.btnStartStop.Text = "Start"
         Me.btnStartStop.UseVisualStyleBackColor = True
         '
         'pbRenderedImage
         '
         Me.pbRenderedImage.Anchor = CType((((System.Windows.Forms.AnchorStyles.Top Or System.Windows.Forms.AnchorStyles.Bottom) _
                     Or System.Windows.Forms.AnchorStyles.Left) _
                     Or System.Windows.Forms.AnchorStyles.Right), System.Windows.Forms.AnchorStyles)
         Me.pbRenderedImage.BackColor = System.Drawing.Color.Black
         Me.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None
         Me.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D
         Me.pbRenderedImage.Location = New System.Drawing.Point(12, 12)
         Me.pbRenderedImage.Name = "pbRenderedImage"
         Me.pbRenderedImage.Size = New System.Drawing.Size(469, 400)
         Me.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage
         Me.pbRenderedImage.TabIndex = 24
         Me.pbRenderedImage.TabStop = False
         '
         'Main
         '
         Me.AutoScaleDimensions = New System.Drawing.SizeF(6.0!, 13.0!)
         Me.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font
         Me.ClientSize = New System.Drawing.Size(495, 459)
         Me.Controls.Add(Me.lblNumProcs)
         Me.Controls.Add(Me.tbNumProcs)
         Me.Controls.Add(Me.chkShowThreads)
         Me.Controls.Add(Me.chkParallel)
         Me.Controls.Add(Me.btnStartStop)
         Me.Controls.Add(Me.pbRenderedImage)
         Me.Name = "Main"
         Me.Text = "Ray Tracer"
         CType(Me.tbNumProcs, System.ComponentModel.ISupportInitialize).EndInit()
         CType(Me.pbRenderedImage, System.ComponentModel.ISupportInitialize).EndInit()
         Me.ResumeLayout(False)
         Me.PerformLayout()
 
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="29" endline="53"><![CDATA[
     Private Sub btnStartStop_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles btnStartStop.Click
         ' If we already have the rendering task created, then we're currently running.
         ' In that case, stop the renderer.
         If _cancellation IsNot Nothing Then
             btnStartStop.Enabled = False
             _cancellation.Cancel()
         Else
             ' Set up the image in the picture box and start the rendering loop with a new rendering task
             ConfigureImage()
             _showThreads = chkShowThreads.Checked
             _cancellation = New CancellationTokenSource()
             Dim token = _cancellation.Token
             Task.Factory.StartNew(AddressOf RenderLoop, token, token).
                 ContinueWith(Sub(c)
                                  chkParallel.Enabled = True
                                  chkShowThreads.Enabled = chkParallel.Checked
                                  btnStartStop.Enabled = True
                                  btnStartStop.Text = "Start"
                                  _cancellation = Nothing
                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
             chkShowThreads.Enabled = False
             chkParallel.Enabled = False
             btnStartStop.Text = "Stop"
         End If
     End Sub
 
     Private Function FixUpFormAfterRendering() As Boolean
         btnStartStop.Enabled = True
         chkParallel.Enabled = True
         btnStartStop.Text = "Start"
         Return True
     End Function
 
     Private Sub ConfigureImage()
         ' If we need to create a new bitmap, do so
         If _bitmap Is Nothing OrElse _bitmap.Width <> pbRenderedImage.Width OrElse _bitmap.Height <> pbRenderedImage.Height Then
             ' Dispose of the old one if one exists
             If _bitmap IsNot Nothing Then
                 pbRenderedImage.Image = Nothing
                 _bitmap.Dispose()
             End If
 
             ' We always render a square even if the window isn't square
             Dim min = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height)
             _width = min
             _height = min
 
             ' Resize the rendering arrays accordingly
             _freeBuffers = New ObjectPool(Of Int32())(Function() New Int32(_width * _height - 1) {})
 
             ' Create a new Bitmap and set it into the picture box
             _bitmap = New Bitmap(_width, _height, PixelFormat.Format32bppRgb)
             _rect = New Rectangle(0, 0, _width, _height)
             pbRenderedImage.Image = _bitmap
         End If
     End Sub
 
     Private Sub RenderLoop(ByVal boxedToken As Object)
 
         Dim token = DirectCast(boxedToken, CancellationToken)
 
         ' Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
         Dim rayTracer = New RayTracer(_width, _height)
         Dim scene = rayTracer.DefaultScene
         Dim sphere2 = DirectCast(scene.Things(0), Sphere) ' The first item is assumed to be our sphere
         Dim baseY = sphere2.Radius
         sphere2.Center.Y = sphere2.Radius
 
         ' Timing determines how fast the ball bounces as well as diagnostics frames/second info
         Dim renderingTime = New Stopwatch()
         Dim totalTime = Stopwatch.StartNew()
 
         ' Keep rendering until the rendering task has been canceled
         While True
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
             btnStartStop.Enabled = False
             _cancellation.Cancel()
         Else
             ' Set up the image in the picture box and start the rendering loop with a new rendering task
             ConfigureImage()
             _showThreads = chkShowThreads.Checked
             _cancellation = New CancellationTokenSource()
             Dim token = _cancellation.Token
             Task.Factory.StartNew(AddressOf RenderLoop, token, token).
                 ContinueWith(Sub(c)
                                  chkParallel.Enabled = True
                                  chkShowThreads.Enabled = chkParallel.Checked
                                  btnStartStop.Enabled = True
                                  btnStartStop.Text = "Start"
                                  _cancellation = Nothing
                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
             chkShowThreads.Enabled = False
             chkParallel.Enabled = False
             btnStartStop.Text = "Stop"
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="54" endline="60"><![CDATA[
 
     Private Function FixUpFormAfterRendering() As Boolean
         btnStartStop.Enabled = True
         chkParallel.Enabled = True
         btnStartStop.Text = "Start"
         Return True
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="61" endline="84"><![CDATA[
 
     Private Sub ConfigureImage()
         ' If we need to create a new bitmap, do so
         If _bitmap Is Nothing OrElse _bitmap.Width <> pbRenderedImage.Width OrElse _bitmap.Height <> pbRenderedImage.Height Then
             ' Dispose of the old one if one exists
             If _bitmap IsNot Nothing Then
                 pbRenderedImage.Image = Nothing
                 _bitmap.Dispose()
             End If
 
             ' We always render a square even if the window isn't square
             Dim min = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height)
             _width = min
             _height = min
 
             ' Resize the rendering arrays accordingly
             _freeBuffers = New ObjectPool(Of Int32())(Function() New Int32(_width * _height - 1) {})
 
             ' Create a new Bitmap and set it into the picture box
             _bitmap = New Bitmap(_width, _height, PixelFormat.Format32bppRgb)
             _rect = New Rectangle(0, 0, _width, _height)
             pbRenderedImage.Image = _bitmap
         End If
     End Sub
 
     Private Sub RenderLoop(ByVal boxedToken As Object)
 
         Dim token = DirectCast(boxedToken, CancellationToken)
 
         ' Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
         Dim rayTracer = New RayTracer(_width, _height)
         Dim scene = rayTracer.DefaultScene
         Dim sphere2 = DirectCast(scene.Things(0), Sphere) ' The first item is assumed to be our sphere
         Dim baseY = sphere2.Radius
         sphere2.Center.Y = sphere2.Radius
 
         ' Timing determines how fast the ball bounces as well as diagnostics frames/second info
         Dim renderingTime = New Stopwatch()
         Dim totalTime = Stopwatch.StartNew()
 
         ' Keep rendering until the rendering task has been canceled
         While True
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
             If _bitmap IsNot Nothing Then
                 pbRenderedImage.Image = Nothing
                 _bitmap.Dispose()
             End If
 
             ' We always render a square even if the window isn't square
             Dim min = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height)
             _width = min
             _height = min
 
             ' Resize the rendering arrays accordingly
             _freeBuffers = New ObjectPool(Of Int32())(Function() New Int32(_width * _height - 1) {})
 
             ' Create a new Bitmap and set it into the picture box
             _bitmap = New Bitmap(_width, _height, PixelFormat.Format32bppRgb)
             _rect = New Rectangle(0, 0, _width, _height)
             pbRenderedImage.Image = _bitmap
         End If
     End Sub
 
     Private Sub RenderLoop(ByVal boxedToken As Object)
 
         Dim token = DirectCast(boxedToken, CancellationToken)
 
         ' Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
         Dim rayTracer = New RayTracer(_width, _height)
         Dim scene = rayTracer.DefaultScene
         Dim sphere2 = DirectCast(scene.Things(0), Sphere) ' The first item is assumed to be our sphere
         Dim baseY = sphere2.Radius
         sphere2.Center.Y = sphere2.Radius
 
         ' Timing determines how fast the ball bounces as well as diagnostics frames/second info
         Dim renderingTime = New Stopwatch()
         Dim totalTime = Stopwatch.StartNew()
 
         ' Keep rendering until the rendering task has been canceled
         While True
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
                 pbRenderedImage.Image = Nothing
                 _bitmap.Dispose()
             End If
 
             ' We always render a square even if the window isn't square
             Dim min = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height)
             _width = min
             _height = min
 
             ' Resize the rendering arrays accordingly
             _freeBuffers = New ObjectPool(Of Int32())(Function() New Int32(_width * _height - 1) {})
 
             ' Create a new Bitmap and set it into the picture box
             _bitmap = New Bitmap(_width, _height, PixelFormat.Format32bppRgb)
             _rect = New Rectangle(0, 0, _width, _height)
             pbRenderedImage.Image = _bitmap
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="85" endline="143"><![CDATA[
 
     Private Sub RenderLoop(ByVal boxedToken As Object)
 
         Dim token = DirectCast(boxedToken, CancellationToken)
 
         ' Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
         Dim rayTracer = New RayTracer(_width, _height)
         Dim scene = rayTracer.DefaultScene
         Dim sphere2 = DirectCast(scene.Things(0), Sphere) ' The first item is assumed to be our sphere
         Dim baseY = sphere2.Radius
         sphere2.Center.Y = sphere2.Radius
 
         ' Timing determines how fast the ball bounces as well as diagnostics frames/second info
         Dim renderingTime = New Stopwatch()
         Dim totalTime = Stopwatch.StartNew()
 
         ' Keep rendering until the rendering task has been canceled
         While True
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
         While True
             token.ThrowIfCancellationRequested()
 
             ' Get the next buffer
             Dim rgb = _freeBuffers.GetObject()
 
             ' Determine the new position of the sphere based on the current time elapsed
             Dim dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000))
             sphere2.Center.Y = baseY + dy2
 
             ' Render the scene
             renderingTime.Reset()
             renderingTime.Start()
             Try
                 Dim options = New ParallelOptions() With {.MaxDegreeOfParallelism = _degreeOfParallelism, .CancellationToken = _cancellation.Token}
                 If Not _parallel Then
                     rayTracer.RenderSequential(scene, rgb)
                 ElseIf _showThreads Then
                     rayTracer.RenderParallelShowingThreads(scene, rgb, options)
                 Else
                     rayTracer.RenderParallel(scene, rgb, options)
                 End If
             Catch ex As OperationCanceledException
             End Try
             renderingTime.Stop()
 
             ' Update the bitmap in the UI thread
             Dim framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds)
             Dim a = Sub()
                         ' Copy the pixel array into the bitmap
                         Dim bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat)
                         Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length)
                         _bitmap.UnlockBits(bmpData)
                         _freeBuffers.PutObject(rgb)
 
                         ' Refresh the UI
                         pbRenderedImage.Invalidate()
                         Text = "Ray Tracer - FPS
                     End Sub
             BeginInvoke(a)
         End While
     End Sub
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
 End Class
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="144" endline="150"><![CDATA[
 
     Private Sub chkParallel_CheckedChanged(ByVal sender As Object, ByVal e As EventArgs) Handles chkParallel.CheckedChanged
         _parallel = chkParallel.Checked
         lblNumProcs.Enabled = chkParallel.Checked
         tbNumProcs.Enabled = chkParallel.Checked
         chkShowThreads.Enabled = chkParallel.Checked
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="151" endline="155"><![CDATA[
 
     Private Sub tbNumProcs_ValueChanged(ByVal sender As Object, ByVal e As EventArgs) Handles tbNumProcs.ValueChanged
         lblNumProcs.Text = tbNumProcs.Value.ToString()
         _degreeOfParallelism = tbNumProcs.Value
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="156" endline="162"><![CDATA[
 
     Private Sub MainForm_Load(ByVal sender As Object, ByVal e As EventArgs) Handles MyBase.Load
         tbNumProcs.Minimum = 1
         tbNumProcs.Maximum = Environment.ProcessorCount
         tbNumProcs.Value = tbNumProcs.Maximum
         lblNumProcs.Text = tbNumProcs.Value.ToString()
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="42" endline="48"><![CDATA[
                 ContinueWith(Sub(c)
                                  chkParallel.Enabled = True
                                  chkShowThreads.Enabled = chkParallel.Checked
                                  btnStartStop.Enabled = True
                                  btnStartStop.Text = "Start"
                                  _cancellation = Nothing
                              End Sub, TaskScheduler.FromCurrentSynchronizationContext())
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Main.vb" startline="49" endline="77"><![CDATA[
             chkShowThreads.Enabled = False
             chkParallel.Enabled = False
             btnStartStop.Text = "Stop"
         End If
     End Sub
 
     Private Function FixUpFormAfterRendering() As Boolean
         btnStartStop.Enabled = True
         chkParallel.Enabled = True
         btnStartStop.Text = "Start"
         Return True
     End Function
 
     Private Sub ConfigureImage()
         ' If we need to create a new bitmap, do so
         If _bitmap Is Nothing OrElse _bitmap.Width <> pbRenderedImage.Width OrElse _bitmap.Height <> pbRenderedImage.Height Then
             ' Dispose of the old one if one exists
             If _bitmap IsNot Nothing Then
                 pbRenderedImage.Image = Nothing
                 _bitmap.Dispose()
             End If
 
             ' We always render a square even if the window isn't square
             Dim min = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height)
             _width = min
             _height = min
 
             ' Resize the rendering arrays accordingly
             _freeBuffers = New ObjectPool(Of Int32())(Function() New Int32(_width * _height - 1) {})
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Resources.Designer.vb" startline="40" endline="46"><![CDATA[
             Get
                 If Object.ReferenceEquals(resourceMan, Nothing) Then
                     Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Resources", GetType(Resources).Assembly)
                     resourceMan = temp
                 End If
                 Return resourceMan
             End Get
         End Property
         
         '''<summary>
         '''  Overrides the current thread's CurrentUICulture property for all
         '''  resource lookups using this strongly typed resource class.
         '''</summary>
         <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend Property Culture() As Global.System.Globalization.CultureInfo
             Get
                 Return resourceCulture
             End Get
             Set
                 resourceCulture = value
             End Set
         End Property
     End Module
 End Namespace
                     Dim temp As Global.System.Resources.ResourceManager = New Global.System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Resources", GetType(Resources).Assembly)
                     resourceMan = temp
                 End If
                 Return resourceMan
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Resources.Designer.vb" startline="47" endline="57"><![CDATA[
         End Property
         
         '''<summary>
         '''  Overrides the current thread's CurrentUICulture property for all
         '''  resource lookups using this strongly typed resource class.
         '''</summary>
         <Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)>  _
         Friend Property Culture() As Global.System.Globalization.CultureInfo
             Get
                 Return resourceCulture
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Resources.Designer.vb" startline="58" endline="60"><![CDATA[
             Set
                 resourceCulture = value
             End Set
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Settings.Designer.vb" startline="23" endline="29"><![CDATA[
         Private Shared defaultInstance As MySettings = CType(Global.System.Configuration.ApplicationSettingsBase.Synchronized(New MySettings()),MySettings)
         
 #Region "My.Settings Auto-Save Functionality"
 #If _MyType = "WindowsForms" Then
     Private Shared addedHandler As Boolean
 
     Private Shared addedHandlerLockObject As New Object
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Settings.Designer.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Settings.Designer.vb" startline="30" endline="36"><![CDATA[
 
     <Global.System.Diagnostics.DebuggerNonUserCodeAttribute(), Global.System.ComponentModel.EditorBrowsableAttribute(Global.System.ComponentModel.EditorBrowsableState.Advanced)> _
     Private Shared Sub AutoSaveSettings(ByVal sender As Global.System.Object, ByVal e As Global.System.EventArgs)
         If My.Application.SaveMySettingsOnExit Then
             My.Settings.Save()
         End If
     End Sub
 #End If
 #End Region
         
         Public Shared ReadOnly Property [Default]() As MySettings
             Get
                 
 #If _MyType = "WindowsForms" Then
                If Not addedHandler Then
                     SyncLock addedHandlerLockObject
                         If Not addedHandler Then
                             AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
                             addedHandler = True
                         End If
                     End SyncLock
                 End If
 #End If
                 Return defaultInstance
             End Get
         End Property
     End Class
 End Namespace
 
 Namespace My
     
     <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
         
         <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings
             Get
                 Return Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings.Default
             End Get
         End Property
     End Module
 End Namespace
             My.Settings.Save()
         End If
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Settings.Designer.vb" startline="37" endline="54"><![CDATA[
 #End If
 #End Region
         
         Public Shared ReadOnly Property [Default]() As MySettings
             Get
                 
 #If _MyType = "WindowsForms" Then
                If Not addedHandler Then
                     SyncLock addedHandlerLockObject
                         If Not addedHandler Then
                             AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
                             addedHandler = True
                         End If
                     End SyncLock
                 End If
 #End If
                 Return defaultInstance
             End Get
         End Property
     End Class
 End Namespace
 
 Namespace My
     
     <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
         
         <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings
             Get
                 Return Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings.Default
             End Get
         End Property
     End Module
 End Namespace
                     SyncLock addedHandlerLockObject
                         If Not addedHandler Then
                             AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
                             addedHandler = True
                         End If
                     End SyncLock
                 End If
 #End If
                 Return defaultInstance
             End Get
         End Property
     End Class
 End Namespace
 
 Namespace My
     
     <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
         
         <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings
             Get
                 Return Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings.Default
             End Get
         End Property
     End Module
 End Namespace
                             AddHandler My.Application.Shutdown, AddressOf AutoSaveSettings
                             addedHandler = True
                         End If
                     End SyncLock
                 End If
 #End If
                 Return defaultInstance
             End Get
         End Property
     End Class
 End Namespace
 
 Namespace My
     
     <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
         
         <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings
             Get
                 Return Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings.Default
             End Get
         End Property
     End Module
 End Namespace
                 End If
 #End If
                 Return defaultInstance
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\My Project\Settings.Designer.vb" startline="55" endline="70"><![CDATA[
         End Property
     End Class
 End Namespace
 
 Namespace My
     
     <Global.Microsoft.VisualBasic.HideModuleNameAttribute(),  _
      Global.System.Diagnostics.DebuggerNonUserCodeAttribute(),  _
      Global.System.Runtime.CompilerServices.CompilerGeneratedAttribute()>  _
     Friend Module MySettingsProperty
         
         <Global.System.ComponentModel.Design.HelpKeywordAttribute("My.Settings")>  _
         Friend ReadOnly Property Settings() As Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings
             Get
                 Return Global.Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.My.MySettings.Default
             End Get
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Plane.vb" startline="14" endline="18"><![CDATA[
     Public Sub New(ByVal norm As Vector, ByVal offset As Double, ByVal surface As Surface)
         MyBase.New(surface)
         Me.Norm = norm
         Me.Offset = offset
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Plane.vb" startline="19" endline="24"><![CDATA[
 
     Public Overrides Function Intersect(ByVal ray As Ray) As ISect
         Dim denom = Vector.Dot(Norm, ray.Direction)
         If denom > 0 Then Return Nothing
         Return New ISect(Me, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom))
     End Function
 
     Public Overrides Function Normal(ByVal position As Vector) As Vector
         Return Norm
     End Function
 
 End Class
         If denom > 0 Then Return Nothing
         Return New ISect(Me, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Plane.vb" startline="25" endline="28"><![CDATA[
 
     Public Overrides Function Normal(ByVal position As Vector) As Vector
         Return Norm
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Ray.vb" startline="14" endline="17"><![CDATA[
     Public Sub New(ByVal start As Vector, ByVal dir As Vector)
         Me.Start = start
         Me.Direction = dir
     End Sub
 
 End Structure
         Me.Start = start
         Me.Direction = dir
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="18" endline="21"><![CDATA[
     Public Sub New(ByVal screenWidth As Integer, ByVal screenHeight As Integer)
         Me.screenWidth = screenWidth
         Me.screenHeight = screenHeight
     End Sub
 
     Friend Sub RenderSequential(ByVal scene As Scene, ByVal rgb As Int32())
         ' Renders the scene sequentially using a standard Visual Basic For loop
         For y = 0 To screenHeight - 1
             Dim stride = y * screenWidth
             Dim camera = scene.Camera
             For x = 0 To screenWidth - 1
                 Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                 rgb(x + stride) = color.ToInt32()
             Next
         Next
     End Sub
 
     Friend Sub RenderParallel(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         ' Renders the scene in parallel using a Parallel Extensions Parallel.For
         Parallel.For(0, screenHeight, options,
             Sub(y)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     rgb(x + stride) = color.ToInt32()
                 Next
             End Sub)
     End Sub
 
     Friend Sub RenderParallelShowingThreads(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
         Me.screenWidth = screenWidth
         Me.screenHeight = screenHeight
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="22" endline="33"><![CDATA[
 
     Friend Sub RenderSequential(ByVal scene As Scene, ByVal rgb As Int32())
         ' Renders the scene sequentially using a standard Visual Basic For loop
         For y = 0 To screenHeight - 1
             Dim stride = y * screenWidth
             Dim camera = scene.Camera
             For x = 0 To screenWidth - 1
                 Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                 rgb(x + stride) = color.ToInt32()
             Next
         Next
     End Sub
 
     Friend Sub RenderParallel(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         ' Renders the scene in parallel using a Parallel Extensions Parallel.For
         Parallel.For(0, screenHeight, options,
             Sub(y)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     rgb(x + stride) = color.ToInt32()
                 Next
             End Sub)
     End Sub
 
     Friend Sub RenderParallelShowingThreads(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Next
     End Sub
 
     Friend Sub RenderParallel(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         ' Renders the scene in parallel using a Parallel Extensions Parallel.For
         Parallel.For(0, screenHeight, options,
             Sub(y)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     rgb(x + stride) = color.ToInt32()
                 Next
             End Sub)
     End Sub
 
     Friend Sub RenderParallelShowingThreads(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="34" endline="46"><![CDATA[
 
     Friend Sub RenderParallel(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         ' Renders the scene in parallel using a Parallel Extensions Parallel.For
         Parallel.For(0, screenHeight, options,
             Sub(y)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     rgb(x + stride) = color.ToInt32()
                 Next
             End Sub)
     End Sub
 
     Friend Sub RenderParallelShowingThreads(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Parallel.For(0, screenHeight, options,
             Sub(y)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     rgb(x + stride) = color.ToInt32()
                 Next
             End Sub)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="47" endline="64"><![CDATA[
 
     Friend Sub RenderParallelShowingThreads(ByVal scene As Scene, ByVal rgb As Int32(), ByVal options As ParallelOptions)
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Dim id = 0
         Parallel.For(0, screenHeight, options, Function() GetHueShift(Interlocked.Increment(id)),
             Function(y, state, hue)
                 Dim stride = y * screenWidth
                 Dim camera = scene.Camera
                 For x = 0 To screenWidth - 1
                     Dim color = TraceRay(New Ray(camera.Position, GetPoint(x, y, camera)), scene, 0)
                     color.ChangeHue(hue)
                     rgb(x + stride) = color.ToInt32()
                 Next
                 Return hue
             End Function,
             Sub(hue)
                 Interlocked.Decrement(id)
             End Sub)
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="65" endline="78"><![CDATA[
 
     Private _numToHueShiftLookup As New Dictionary(Of Integer, Double)
     Private _rand As New Random()
 
     Private Function GetHueShift(ByVal id As Integer) As Double
         Dim shift As Double
         SyncLock _numToHueShiftLookup
             If Not _numToHueShiftLookup.TryGetValue(id, shift) Then
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
                 shift = _rand.NextDouble()
                 _numToHueShiftLookup.Add(id, shift)
             End If
         End SyncLock
         Return shift
     End Function
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Return shift
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="79" endline="95"><![CDATA[
 
     Friend ReadOnly DefaultScene As Scene = CreateDefaultScene()
 
     Private Shared Function CreateDefaultScene() As Scene
         Dim things = New SceneObject() {
                   New Sphere(New Vector(-0.5, 1, 1.5), 0.5, Surfaces.MatteShiny),
                   New Sphere(New Vector(0, 1, -0.25), 1, Surfaces.Shiny),
                   New Plane(New Vector(0, 1, 0), 0, Surfaces.CheckerBoard)}
 
         Dim lights = New Light() {
               New Light(New Vector(-2, 2.5, 0), New Color(0.5, 0.45, 0.41)),
               New Light(New Vector(2, 4.5, 2), New Color(0.99, 0.95, 0.8))}
 
         Dim eye = Camera.Create(New Vector(2.75, 2, 3.75), New Vector(-0.6, 0.5, 0))
 
         Return New Scene(things, lights, eye)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="96" endline="106"><![CDATA[
 
     Private Function MinIntersection(ByVal ray As Ray, ByVal scene As Scene) As ISect
         Dim min As ISect = Nothing
         For Each obj In scene.Things
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
             Dim isect = obj.Intersect(ray)
             If isect IsNot Nothing Then
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
                 If min Is Nothing OrElse min.Dist > isect.Dist Then min = isect
             End If
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Next
         Return min
     End Function
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Return min
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="107" endline="112"><![CDATA[
 
     Private Function TestRay(ByVal ray As Ray, ByVal scene As Scene) As Double
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         If sect Is Nothing Then Return 0
         Return sect.Dist
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="113" endline="118"><![CDATA[
 
     Private Function TraceRay(ByVal ray As Ray, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim sect = MinIntersection(ray, scene)
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         If sect Is Nothing Then Return Color.Background
         Return Shade(sect, scene, depth)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="119" endline="137"><![CDATA[
 
     Private Function GetNaturalColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene) As Color
         Dim ret = New Color(0, 0, 0)
         For Each light In scene.Lights
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
             Dim ldis = Vector.Minus(light.Position, pos)
             Dim livec = Vector.Norm(ldis)
             Dim neatIsect = TestRay(New Ray(pos, livec), scene)
             Dim isInShadow = Not (neatIsect > Vector.Mag(ldis) OrElse neatIsect = 0)
             If Not isInShadow Then
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
                 Dim illum = Vector.Dot(livec, norm)
                 Dim lcolor = If(illum > 0, Color.Times(illum, light.Color), New Color(0, 0, 0))
                 Dim specular = Vector.Dot(livec, Vector.Norm(rd))
                 Dim scolor = If(specular > 0, Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color), New Color(0, 0, 0))
                 ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
                                                  Color.Times(thing.Surface.Specular(pos), scolor)))
             End If
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Next
         Return ret
     End Function
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         Return ret
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="138" endline="141"><![CDATA[
 
     Private Function GetReflectionColor(ByVal thing As SceneObject, ByVal pos As Vector, ByVal norm As Vector, ByVal rd As Vector, ByVal scene As Scene, ByVal depth As Integer) As Color
         Return Color.Times(thing.Surface.Reflect(pos), TraceRay(New Ray(pos, rd), scene, depth + 1))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="142" endline="151"><![CDATA[
 
     Private Function Shade(ByVal isect As ISect, ByVal scene As Scene, ByVal depth As Integer) As Color
         Dim d = isect.Ray.Direction
         Dim pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Direction), isect.Ray.Start)
         Dim normal = isect.Thing.Normal(pos)
         Dim reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal))
         Dim ret = Color.Plus(Color.DefaultColor, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene))
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
 End Class
         If depth >= MaxDepth Then Return Color.Plus(ret, New Color(0.5, 0.5, 0.5))
         Return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(0.001, reflectDir)), normal, reflectDir, scene, depth))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="152" endline="155"><![CDATA[
 
     Private Function RecenterX(ByVal x As Double) As Double
         Return (x - (screenWidth / 2.0)) / (2.0 * screenWidth)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="156" endline="159"><![CDATA[
 
     Private Function RecenterY(ByVal y As Double) As Double
         Return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Raytracer.vb" startline="160" endline="164"><![CDATA[
 
     Private Function GetPoint(ByVal x As Double, ByVal y As Double, ByVal camera As Camera) As Vector
         Return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
                                                                    Vector.Times(RecenterY(y), camera.Up))))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Scene.vb" startline="16" endline="20"><![CDATA[
     Public Sub New(ByVal things As SceneObject(), ByVal lights As Light(), ByVal camera As Camera)
         Me.Things = things
         Me.Lights = lights
         Me.Camera = camera
     End Sub
 
     Public Function Intersect(ByVal r As Ray) As IEnumerable(Of ISect)
         Dim objects = New List(Of ISect)()
         For Each obj In Things
             objects.Add(obj.Intersect(r))
         Next
         Return objects
     End Function
 End Class
         Me.Things = things
         Me.Lights = lights
         Me.Camera = camera
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Scene.vb" startline="21" endline="28"><![CDATA[
 
     Public Function Intersect(ByVal r As Ray) As IEnumerable(Of ISect)
         Dim objects = New List(Of ISect)()
         For Each obj In Things
             objects.Add(obj.Intersect(r))
         Next
         Return objects
     End Function
 End Class
             objects.Add(obj.Intersect(r))
         Next
         Return objects
     End Function
 End Class
         Next
         Return objects
     End Function
 End Class
         Return objects
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Scene.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Scene.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\SceneObject.vb" startline="14" endline="16"><![CDATA[
     Public Sub New(ByVal surface As Surface)
         Me.Surface = surface
     End Sub
 End Class
         Me.Surface = surface
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Sphere.vb" startline="15" endline="19"><![CDATA[
     Public Sub New(ByVal center As Vector, ByVal radius As Double, ByVal surface As Surface)
         MyBase.New(surface)
         Me.Center = center
         Me.Radius = radius
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Sphere.vb" startline="20" endline="33"><![CDATA[
 
     Public Overrides Function Intersect(ByVal ray As Ray) As ISect
         Dim eo = Vector.Minus(Center, ray.Start)
         Dim v = Vector.Dot(eo, ray.Direction)
         Dim dist As Double
         If v < 0 Then
             dist = 0
         Else
             Dim disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2))
             dist = If(disc < 0, 0, v - Math.Sqrt(disc))
         End If
         If dist = 0 Then Return Nothing
         Return New ISect(Me, ray, dist)
     End Function
 
     Public Overrides Function Normal(ByVal position As Vector) As Vector
         Return Vector.Norm(Vector.Minus(position, Center))
     End Function
 End Class
             dist = 0
         Else
             Dim disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2))
             dist = If(disc < 0, 0, v - Math.Sqrt(disc))
         End If
         If dist = 0 Then Return Nothing
         Return New ISect(Me, ray, dist)
     End Function
 
     Public Overrides Function Normal(ByVal position As Vector) As Vector
         Return Vector.Norm(Vector.Minus(position, Center))
     End Function
 End Class
         If dist = 0 Then Return Nothing
         Return New ISect(Me, ray, dist)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Sphere.vb" startline="34" endline="37"><![CDATA[
 
     Public Overrides Function Normal(ByVal position As Vector) As Vector
         Return Vector.Norm(Vector.Minus(position, Center))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surface.vb" startline="15" endline="21"><![CDATA[
     Public Sub New(ByVal diffuse As Func(Of Vector, Color), ByVal specular As Func(Of Vector, Color),
                    ByVal reflect As Func(Of Vector, Double), ByVal roughness As Double)
         Me.Diffuse = diffuse
         Me.Specular = specular
         Me.Reflect = reflect
         Me.Roughness = roughness
     End Sub
 End Class
         Me.Diffuse = diffuse
         Me.Specular = specular
         Me.Reflect = reflect
         Me.Roughness = roughness
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="11" endline="23"><![CDATA[
     Public Shared ReadOnly CheckerBoard As Surface = New Surface(
         Function(pos) If(((Math.Floor(pos.Z) + Math.Floor(pos.X)) Mod 2 <> 0), New Color(1, 1, 1), New Color(0.02, 0.0, 0.14)),
         Function(pos) New Color(1, 1, 1),
         Function(pos) If(((Math.Floor(pos.Z) + Math.Floor(pos.X)) Mod 2 <> 0), 0.1, 0.5),
         150)
 
     Public Shared ReadOnly Shiny As Surface = New Surface(
         Function(pos) New Color(1, 1, 1),
         Function(pos) New Color(0.5, 0.5, 0.5),
         Function(pos) 0.7,
         250)
 
     Public Shared ReadOnly MatteShiny As Surface = New Surface(
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="12" endline="12"><![CDATA[
         Function(pos) If(((Math.Floor(pos.Z) + Math.Floor(pos.X)) Mod 2 <> 0), New Color(1, 1, 1), New Color(0.02, 0.0, 0.14)),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="13" endline="13"><![CDATA[
         Function(pos) New Color(1, 1, 1),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="14" endline="14"><![CDATA[
         Function(pos) If(((Math.Floor(pos.Z) + Math.Floor(pos.X)) Mod 2 <> 0), 0.1, 0.5),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="15" endline="18"><![CDATA[
         150)
 
     Public Shared ReadOnly Shiny As Surface = New Surface(
         Function(pos) New Color(1, 1, 1),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="19" endline="19"><![CDATA[
         Function(pos) New Color(0.5, 0.5, 0.5),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="20" endline="20"><![CDATA[
         Function(pos) 0.7,
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="21" endline="24"><![CDATA[
         250)
 
     Public Shared ReadOnly MatteShiny As Surface = New Surface(
         Function(pos) New Color(1, 1, 1),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="25" endline="25"><![CDATA[
         Function(pos) New Color(0.25, 0.25, 0.25),
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Surfaces.vb" startline="26" endline="26"><![CDATA[
         Function(pos) 0.7,
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="14" endline="18"><![CDATA[
     Public Sub New(ByVal x As Double, ByVal y As Double, ByVal z As Double)
         Me.X = x
         Me.Y = y
         Me.Z = z
     End Sub
 
     Public Sub New(ByVal str As String)
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.X = Double.Parse(nums(0))
         Me.Y = Double.Parse(nums(1))
         Me.Z = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal v As Vector) As Vector
         Return New Vector(v.X * n, v.Y * n, v.Z * n)
     End Function
 
     Public Shared Function Minus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z)
     End Function
 
     Public Shared Function Plus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z)
     End Function
 
     Public Shared Function Dot(ByVal v1 As Vector, ByVal v2 As Vector) As Double
         Return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z)
     End Function
 
     Public Shared Function Mag(ByVal v As Vector) As Double
         Return Math.Sqrt(Dot(v, v))
     End Function
 
     Public Shared Function Norm(ByVal v As Vector) As Vector
         Dim magnitude = Mag(v)
         Dim div = If(magnitude = 0, Double.PositiveInfinity, 1 / magnitude)
         Return Times(div, v)
     End Function
 
     Public Shared Function Cross(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                           ((v1.Z * v2.X) - (v1.X * v2.Z)),
                           ((v1.X * v2.Y) - (v1.Y * v2.X)))
     End Function
 End Structure
         Me.X = x
         Me.Y = y
         Me.Z = z
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="19" endline="26"><![CDATA[
 
     Public Sub New(ByVal str As String)
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.X = Double.Parse(nums(0))
         Me.Y = Double.Parse(nums(1))
         Me.Z = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal v As Vector) As Vector
         Return New Vector(v.X * n, v.Y * n, v.Z * n)
     End Function
 
     Public Shared Function Minus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z)
     End Function
 
     Public Shared Function Plus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z)
     End Function
 
     Public Shared Function Dot(ByVal v1 As Vector, ByVal v2 As Vector) As Double
         Return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z)
     End Function
 
     Public Shared Function Mag(ByVal v As Vector) As Double
         Return Math.Sqrt(Dot(v, v))
     End Function
 
     Public Shared Function Norm(ByVal v As Vector) As Vector
         Dim magnitude = Mag(v)
         Dim div = If(magnitude = 0, Double.PositiveInfinity, 1 / magnitude)
         Return Times(div, v)
     End Function
 
     Public Shared Function Cross(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                           ((v1.Z * v2.X) - (v1.X * v2.Z)),
                           ((v1.X * v2.Y) - (v1.Y * v2.X)))
     End Function
 End Structure
         Dim nums = str.Split(CChar(","))
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.X = Double.Parse(nums(0))
         Me.Y = Double.Parse(nums(1))
         Me.Z = Double.Parse(nums(2))
     End Sub
 
     Public Shared Function Times(ByVal n As Double, ByVal v As Vector) As Vector
         Return New Vector(v.X * n, v.Y * n, v.Z * n)
     End Function
 
     Public Shared Function Minus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z)
     End Function
 
     Public Shared Function Plus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z)
     End Function
 
     Public Shared Function Dot(ByVal v1 As Vector, ByVal v2 As Vector) As Double
         Return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z)
     End Function
 
     Public Shared Function Mag(ByVal v As Vector) As Double
         Return Math.Sqrt(Dot(v, v))
     End Function
 
     Public Shared Function Norm(ByVal v As Vector) As Vector
         Dim magnitude = Mag(v)
         Dim div = If(magnitude = 0, Double.PositiveInfinity, 1 / magnitude)
         Return Times(div, v)
     End Function
 
     Public Shared Function Cross(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                           ((v1.Z * v2.X) - (v1.X * v2.Z)),
                           ((v1.X * v2.Y) - (v1.Y * v2.X)))
     End Function
 End Structure
         If nums.Length <> 3 Then Throw New ArgumentException("str")
         Me.X = Double.Parse(nums(0))
         Me.Y = Double.Parse(nums(1))
         Me.Z = Double.Parse(nums(2))
     End Sub
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="27" endline="30"><![CDATA[
 
     Public Shared Function Times(ByVal n As Double, ByVal v As Vector) As Vector
         Return New Vector(v.X * n, v.Y * n, v.Z * n)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="31" endline="34"><![CDATA[
 
     Public Shared Function Minus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="35" endline="38"><![CDATA[
 
     Public Shared Function Plus(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="39" endline="42"><![CDATA[
 
     Public Shared Function Dot(ByVal v1 As Vector, ByVal v2 As Vector) As Double
         Return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="43" endline="46"><![CDATA[
 
     Public Shared Function Mag(ByVal v As Vector) As Double
         Return Math.Sqrt(Dot(v, v))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="47" endline="52"><![CDATA[
 
     Public Shared Function Norm(ByVal v As Vector) As Vector
         Dim magnitude = Mag(v)
         Dim div = If(magnitude = 0, Double.PositiveInfinity, 1 / magnitude)
         Return Times(div, v)
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="53" endline="58"><![CDATA[
 
     Public Shared Function Cross(ByVal v1 As Vector, ByVal v2 As Vector) As Vector
         Return New Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
                           ((v1.Z * v2.X) - (v1.X * v2.Z)),
                           ((v1.X * v2.Y) - (v1.Y * v2.X)))
     End Function
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_VisualBasic\Vector.vb" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
</source_elements></project>
