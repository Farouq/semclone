<project><name></name><description></description><prog_language></prog_language><source_elements>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Program.cs" startline="19" endline="23"><![CDATA[
         {
             Application.EnableVisualStyles();
             Application.SetCompatibleTextRenderingDefault(false);
             Application.Run(new MainForm());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs" startline="15" endline="21"><![CDATA[
         {
             if (disposing && (components != null))
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             this.pbPartitionedImage = new System.Windows.Forms.PictureBox();
             this.btnVisualize = new System.Windows.Forms.Button();
             this.lvPartitioningMethods = new System.Windows.Forms.ListView();
             this.lvWorkloads = new System.Windows.Forms.ListView();
             this.label1 = new System.Windows.Forms.Label();
             this.label2 = new System.Windows.Forms.Label();
             this.lblTime = new System.Windows.Forms.Label();
             this.tbWorkFactor = new System.Windows.Forms.TrackBar();
             this.label3 = new System.Windows.Forms.Label();
             this.rbParallelFor = new System.Windows.Forms.RadioButton();
             this.rbParallelForEach = new System.Windows.Forms.RadioButton();
             this.rbPLINQ = new System.Windows.Forms.RadioButton();
             this.groupBox1 = new System.Windows.Forms.GroupBox();
             this.label4 = new System.Windows.Forms.Label();
             this.tbCores = new System.Windows.Forms.TrackBar();
             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).BeginInit();
             this.groupBox1.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).BeginInit();
             this.SuspendLayout();
             // 
             // pbPartitionedImage
             // 
             this.pbPartitionedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbPartitionedImage.BackColor = System.Drawing.Color.Black;
             this.pbPartitionedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbPartitionedImage.Location = new System.Drawing.Point(12, 12);
             this.pbPartitionedImage.Name = "pbPartitionedImage";
             this.pbPartitionedImage.Size = new System.Drawing.Size(539, 522);
             this.pbPartitionedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
             this.pbPartitionedImage.TabIndex = 0;
             this.pbPartitionedImage.TabStop = false;
             // 
             // btnVisualize
             // 
             this.btnVisualize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.btnVisualize.Location = new System.Drawing.Point(557, 490);
             this.btnVisualize.Name = "btnVisualize";
             this.btnVisualize.Size = new System.Drawing.Size(75, 23);
             this.btnVisualize.TabIndex = 1;
             this.btnVisualize.Text = "Visualize";
             this.btnVisualize.UseVisualStyleBackColor = true;
             this.btnVisualize.Click += new System.EventHandler(this.btnVisualize_Click);
             // 
             // lvPartitioningMethods
             // 
             this.lvPartitioningMethods.Activation = System.Windows.Forms.ItemActivation.OneClick;
             this.lvPartitioningMethods.Alignment = System.Windows.Forms.ListViewAlignment.Default;
             this.lvPartitioningMethods.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lvPartitioningMethods.AutoArrange = false;
             this.lvPartitioningMethods.Enabled = false;
             this.lvPartitioningMethods.FullRowSelect = true;
             this.lvPartitioningMethods.GridLines = true;
             this.lvPartitioningMethods.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
             this.lvPartitioningMethods.Location = new System.Drawing.Point(559, 127);
             this.lvPartitioningMethods.MultiSelect = false;
             this.lvPartitioningMethods.Name = "lvPartitioningMethods";
             this.lvPartitioningMethods.ShowGroups = false;
             this.lvPartitioningMethods.Size = new System.Drawing.Size(126, 150);
             this.lvPartitioningMethods.TabIndex = 2;
             this.lvPartitioningMethods.UseCompatibleStateImageBehavior = false;
             this.lvPartitioningMethods.View = System.Windows.Forms.View.List;
             // 
             // lvWorkloads
             // 
             this.lvWorkloads.Activation = System.Windows.Forms.ItemActivation.OneClick;
             this.lvWorkloads.Alignment = System.Windows.Forms.ListViewAlignment.Default;
             this.lvWorkloads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lvWorkloads.AutoArrange = false;
             this.lvWorkloads.FullRowSelect = true;
             this.lvWorkloads.GridLines = true;
             this.lvWorkloads.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
             this.lvWorkloads.HideSelection = false;
             this.lvWorkloads.Location = new System.Drawing.Point(559, 296);
             this.lvWorkloads.MultiSelect = false;
             this.lvWorkloads.Name = "lvWorkloads";
             this.lvWorkloads.ShowGroups = false;
             this.lvWorkloads.Size = new System.Drawing.Size(126, 77);
             this.lvWorkloads.TabIndex = 3;
             this.lvWorkloads.UseCompatibleStateImageBehavior = false;
             this.lvWorkloads.View = System.Windows.Forms.View.List;
             // 
             // label1
             // 
             this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label1.AutoSize = true;
             this.label1.Location = new System.Drawing.Point(556, 280);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(53, 13);
             this.label1.TabIndex = 4;
             this.label1.Text = "Workload";
             // 
             // label2
             // 
             this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label2.AutoSize = true;
             this.label2.Location = new System.Drawing.Point(557, 111);
             this.label2.Name = "label2";
             this.label2.Size = new System.Drawing.Size(59, 13);
             this.label2.TabIndex = 5;
             this.label2.Text = "Partitioning";
             // 
             // lblTime
             // 
             this.lblTime.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lblTime.AutoSize = true;
             this.lblTime.Location = new System.Drawing.Point(556, 516);
             this.lblTime.Name = "lblTime";
             this.lblTime.Size = new System.Drawing.Size(36, 13);
             this.lblTime.TabIndex = 6;
             this.lblTime.Text = "Time
             // 
             // tbWorkFactor
             // 
             this.tbWorkFactor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.tbWorkFactor.LargeChange = 1;
             this.tbWorkFactor.Location = new System.Drawing.Point(558, 408);
             this.tbWorkFactor.Maximum = 1000;
             this.tbWorkFactor.Minimum = 1;
             this.tbWorkFactor.Name = "tbWorkFactor";
             this.tbWorkFactor.Size = new System.Drawing.Size(123, 45);
             this.tbWorkFactor.TabIndex = 7;
             this.tbWorkFactor.TickFrequency = 100;
             this.tbWorkFactor.TickStyle = System.Windows.Forms.TickStyle.None;
             this.tbWorkFactor.Value = 1;
             this.tbWorkFactor.ValueChanged += new System.EventHandler(this.tbWorkFactor_ValueChanged);
             // 
             // label3
             // 
             this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label3.AutoSize = true;
             this.label3.Location = new System.Drawing.Point(557, 385);
             this.label3.Name = "label3";
             this.label3.Size = new System.Drawing.Size(66, 13);
             this.label3.TabIndex = 8;
             this.label3.Text = "Work Factor";
             // 
             // rbParallelFor
             // 
             this.rbParallelFor.AutoSize = true;
             this.rbParallelFor.Checked = true;
             this.rbParallelFor.Location = new System.Drawing.Point(7, 18);
             this.rbParallelFor.Name = "rbParallelFor";
             this.rbParallelFor.Size = new System.Drawing.Size(77, 17);
             this.rbParallelFor.TabIndex = 9;
             this.rbParallelFor.TabStop = true;
             this.rbParallelFor.Text = "Parallel.For";
             this.rbParallelFor.UseVisualStyleBackColor = true;
             this.rbParallelFor.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // rbParallelForEach
             // 
             this.rbParallelForEach.AutoSize = true;
             this.rbParallelForEach.Location = new System.Drawing.Point(6, 41);
             this.rbParallelForEach.Name = "rbParallelForEach";
             this.rbParallelForEach.Size = new System.Drawing.Size(102, 17);
             this.rbParallelForEach.TabIndex = 10;
             this.rbParallelForEach.TabStop = true;
             this.rbParallelForEach.Text = "Parallel.ForEach";
             this.rbParallelForEach.UseVisualStyleBackColor = true;
             this.rbParallelForEach.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // rbPLINQ
             // 
             this.rbPLINQ.AutoSize = true;
             this.rbPLINQ.Location = new System.Drawing.Point(6, 64);
             this.rbPLINQ.Name = "rbPLINQ";
             this.rbPLINQ.Size = new System.Drawing.Size(57, 17);
             this.rbPLINQ.TabIndex = 11;
             this.rbPLINQ.TabStop = true;
             this.rbPLINQ.Text = "PLINQ";
             this.rbPLINQ.UseVisualStyleBackColor = true;
             this.rbPLINQ.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // groupBox1
             // 
             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.groupBox1.Controls.Add(this.rbParallelForEach);
             this.groupBox1.Controls.Add(this.rbPLINQ);
             this.groupBox1.Controls.Add(this.rbParallelFor);
             this.groupBox1.Location = new System.Drawing.Point(557, 12);
             this.groupBox1.Name = "groupBox1";
             this.groupBox1.Size = new System.Drawing.Size(130, 91);
             this.groupBox1.TabIndex = 12;
             this.groupBox1.TabStop = false;
             this.groupBox1.Text = "API";
             // 
             // label4
             // 
             this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label4.AutoSize = true;
             this.label4.Location = new System.Drawing.Point(556, 436);
             this.label4.Name = "label4";
             this.label4.Size = new System.Drawing.Size(34, 13);
             this.label4.TabIndex = 14;
             this.label4.Text = "Cores";
             // 
             // tbCores
             // 
             this.tbCores.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.tbCores.LargeChange = 1;
             this.tbCores.Location = new System.Drawing.Point(557, 459);
             this.tbCores.Maximum = 100;
             this.tbCores.Minimum = 1;
             this.tbCores.Name = "tbCores";
             this.tbCores.Size = new System.Drawing.Size(123, 45);
             this.tbCores.TabIndex = 13;
             this.tbCores.TickStyle = System.Windows.Forms.TickStyle.None;
             this.tbCores.Value = 1;
             this.tbCores.ValueChanged += new System.EventHandler(this.tbCores_ValueChanged);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(695, 547);
             this.Controls.Add(this.btnVisualize);
             this.Controls.Add(this.label4);
             this.Controls.Add(this.tbCores);
             this.Controls.Add(this.groupBox1);
             this.Controls.Add(this.label3);
             this.Controls.Add(this.tbWorkFactor);
             this.Controls.Add(this.lblTime);
             this.Controls.Add(this.label2);
             this.Controls.Add(this.label1);
             this.Controls.Add(this.lvWorkloads);
             this.Controls.Add(this.lvPartitioningMethods);
             this.Controls.Add(this.pbPartitionedImage);
             this.Name = "MainForm";
             this.Text = "Visualize Partitioning";
             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).EndInit();
             this.groupBox1.ResumeLayout(false);
             this.groupBox1.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
 
         #endregion
 
         private System.Windows.Forms.PictureBox pbPartitionedImage;
         private System.Windows.Forms.Button btnVisualize;
         private System.Windows.Forms.ListView lvPartitioningMethods;
         private System.Windows.Forms.ListView lvWorkloads;
         private System.Windows.Forms.Label label1;
         private System.Windows.Forms.Label label2;
         private System.Windows.Forms.Label lblTime;
         private System.Windows.Forms.TrackBar tbWorkFactor;
         private System.Windows.Forms.Label label3;
         private System.Windows.Forms.RadioButton rbParallelFor;
         private System.Windows.Forms.RadioButton rbParallelForEach;
         private System.Windows.Forms.RadioButton rbPLINQ;
         private System.Windows.Forms.GroupBox groupBox1;
         private System.Windows.Forms.Label label4;
         private System.Windows.Forms.TrackBar tbCores;
         private System.Windows.Forms.ToolTip toolTip1;
     }
 }
 
             {
                 components.Dispose();
             }
             base.Dispose(disposing);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs" startline="22" endline="273"><![CDATA[
 
         #region Windows Form Designer generated code
 
         /// <summary>
         /// Required method for Designer support - do not modify
         /// the contents of this method with the code editor.
         /// </summary>
         private void InitializeComponent()
         {
             this.components = new System.ComponentModel.Container();
             this.pbPartitionedImage = new System.Windows.Forms.PictureBox();
             this.btnVisualize = new System.Windows.Forms.Button();
             this.lvPartitioningMethods = new System.Windows.Forms.ListView();
             this.lvWorkloads = new System.Windows.Forms.ListView();
             this.label1 = new System.Windows.Forms.Label();
             this.label2 = new System.Windows.Forms.Label();
             this.lblTime = new System.Windows.Forms.Label();
             this.tbWorkFactor = new System.Windows.Forms.TrackBar();
             this.label3 = new System.Windows.Forms.Label();
             this.rbParallelFor = new System.Windows.Forms.RadioButton();
             this.rbParallelForEach = new System.Windows.Forms.RadioButton();
             this.rbPLINQ = new System.Windows.Forms.RadioButton();
             this.groupBox1 = new System.Windows.Forms.GroupBox();
             this.label4 = new System.Windows.Forms.Label();
             this.tbCores = new System.Windows.Forms.TrackBar();
             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).BeginInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).BeginInit();
             this.groupBox1.SuspendLayout();
             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).BeginInit();
             this.SuspendLayout();
             // 
             // pbPartitionedImage
             // 
             this.pbPartitionedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                         | System.Windows.Forms.AnchorStyles.Left)
                         | System.Windows.Forms.AnchorStyles.Right)));
             this.pbPartitionedImage.BackColor = System.Drawing.Color.Black;
             this.pbPartitionedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
             this.pbPartitionedImage.Location = new System.Drawing.Point(12, 12);
             this.pbPartitionedImage.Name = "pbPartitionedImage";
             this.pbPartitionedImage.Size = new System.Drawing.Size(539, 522);
             this.pbPartitionedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
             this.pbPartitionedImage.TabIndex = 0;
             this.pbPartitionedImage.TabStop = false;
             // 
             // btnVisualize
             // 
             this.btnVisualize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.btnVisualize.Location = new System.Drawing.Point(557, 490);
             this.btnVisualize.Name = "btnVisualize";
             this.btnVisualize.Size = new System.Drawing.Size(75, 23);
             this.btnVisualize.TabIndex = 1;
             this.btnVisualize.Text = "Visualize";
             this.btnVisualize.UseVisualStyleBackColor = true;
             this.btnVisualize.Click += new System.EventHandler(this.btnVisualize_Click);
             // 
             // lvPartitioningMethods
             // 
             this.lvPartitioningMethods.Activation = System.Windows.Forms.ItemActivation.OneClick;
             this.lvPartitioningMethods.Alignment = System.Windows.Forms.ListViewAlignment.Default;
             this.lvPartitioningMethods.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lvPartitioningMethods.AutoArrange = false;
             this.lvPartitioningMethods.Enabled = false;
             this.lvPartitioningMethods.FullRowSelect = true;
             this.lvPartitioningMethods.GridLines = true;
             this.lvPartitioningMethods.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
             this.lvPartitioningMethods.Location = new System.Drawing.Point(559, 127);
             this.lvPartitioningMethods.MultiSelect = false;
             this.lvPartitioningMethods.Name = "lvPartitioningMethods";
             this.lvPartitioningMethods.ShowGroups = false;
             this.lvPartitioningMethods.Size = new System.Drawing.Size(126, 150);
             this.lvPartitioningMethods.TabIndex = 2;
             this.lvPartitioningMethods.UseCompatibleStateImageBehavior = false;
             this.lvPartitioningMethods.View = System.Windows.Forms.View.List;
             // 
             // lvWorkloads
             // 
             this.lvWorkloads.Activation = System.Windows.Forms.ItemActivation.OneClick;
             this.lvWorkloads.Alignment = System.Windows.Forms.ListViewAlignment.Default;
             this.lvWorkloads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lvWorkloads.AutoArrange = false;
             this.lvWorkloads.FullRowSelect = true;
             this.lvWorkloads.GridLines = true;
             this.lvWorkloads.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
             this.lvWorkloads.HideSelection = false;
             this.lvWorkloads.Location = new System.Drawing.Point(559, 296);
             this.lvWorkloads.MultiSelect = false;
             this.lvWorkloads.Name = "lvWorkloads";
             this.lvWorkloads.ShowGroups = false;
             this.lvWorkloads.Size = new System.Drawing.Size(126, 77);
             this.lvWorkloads.TabIndex = 3;
             this.lvWorkloads.UseCompatibleStateImageBehavior = false;
             this.lvWorkloads.View = System.Windows.Forms.View.List;
             // 
             // label1
             // 
             this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label1.AutoSize = true;
             this.label1.Location = new System.Drawing.Point(556, 280);
             this.label1.Name = "label1";
             this.label1.Size = new System.Drawing.Size(53, 13);
             this.label1.TabIndex = 4;
             this.label1.Text = "Workload";
             // 
             // label2
             // 
             this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label2.AutoSize = true;
             this.label2.Location = new System.Drawing.Point(557, 111);
             this.label2.Name = "label2";
             this.label2.Size = new System.Drawing.Size(59, 13);
             this.label2.TabIndex = 5;
             this.label2.Text = "Partitioning";
             // 
             // lblTime
             // 
             this.lblTime.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.lblTime.AutoSize = true;
             this.lblTime.Location = new System.Drawing.Point(556, 516);
             this.lblTime.Name = "lblTime";
             this.lblTime.Size = new System.Drawing.Size(36, 13);
             this.lblTime.TabIndex = 6;
             this.lblTime.Text = "Time
             // 
             // tbWorkFactor
             // 
             this.tbWorkFactor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.tbWorkFactor.LargeChange = 1;
             this.tbWorkFactor.Location = new System.Drawing.Point(558, 408);
             this.tbWorkFactor.Maximum = 1000;
             this.tbWorkFactor.Minimum = 1;
             this.tbWorkFactor.Name = "tbWorkFactor";
             this.tbWorkFactor.Size = new System.Drawing.Size(123, 45);
             this.tbWorkFactor.TabIndex = 7;
             this.tbWorkFactor.TickFrequency = 100;
             this.tbWorkFactor.TickStyle = System.Windows.Forms.TickStyle.None;
             this.tbWorkFactor.Value = 1;
             this.tbWorkFactor.ValueChanged += new System.EventHandler(this.tbWorkFactor_ValueChanged);
             // 
             // label3
             // 
             this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label3.AutoSize = true;
             this.label3.Location = new System.Drawing.Point(557, 385);
             this.label3.Name = "label3";
             this.label3.Size = new System.Drawing.Size(66, 13);
             this.label3.TabIndex = 8;
             this.label3.Text = "Work Factor";
             // 
             // rbParallelFor
             // 
             this.rbParallelFor.AutoSize = true;
             this.rbParallelFor.Checked = true;
             this.rbParallelFor.Location = new System.Drawing.Point(7, 18);
             this.rbParallelFor.Name = "rbParallelFor";
             this.rbParallelFor.Size = new System.Drawing.Size(77, 17);
             this.rbParallelFor.TabIndex = 9;
             this.rbParallelFor.TabStop = true;
             this.rbParallelFor.Text = "Parallel.For";
             this.rbParallelFor.UseVisualStyleBackColor = true;
             this.rbParallelFor.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // rbParallelForEach
             // 
             this.rbParallelForEach.AutoSize = true;
             this.rbParallelForEach.Location = new System.Drawing.Point(6, 41);
             this.rbParallelForEach.Name = "rbParallelForEach";
             this.rbParallelForEach.Size = new System.Drawing.Size(102, 17);
             this.rbParallelForEach.TabIndex = 10;
             this.rbParallelForEach.TabStop = true;
             this.rbParallelForEach.Text = "Parallel.ForEach";
             this.rbParallelForEach.UseVisualStyleBackColor = true;
             this.rbParallelForEach.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // rbPLINQ
             // 
             this.rbPLINQ.AutoSize = true;
             this.rbPLINQ.Location = new System.Drawing.Point(6, 64);
             this.rbPLINQ.Name = "rbPLINQ";
             this.rbPLINQ.Size = new System.Drawing.Size(57, 17);
             this.rbPLINQ.TabIndex = 11;
             this.rbPLINQ.TabStop = true;
             this.rbPLINQ.Text = "PLINQ";
             this.rbPLINQ.UseVisualStyleBackColor = true;
             this.rbPLINQ.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
             // 
             // groupBox1
             // 
             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.groupBox1.Controls.Add(this.rbParallelForEach);
             this.groupBox1.Controls.Add(this.rbPLINQ);
             this.groupBox1.Controls.Add(this.rbParallelFor);
             this.groupBox1.Location = new System.Drawing.Point(557, 12);
             this.groupBox1.Name = "groupBox1";
             this.groupBox1.Size = new System.Drawing.Size(130, 91);
             this.groupBox1.TabIndex = 12;
             this.groupBox1.TabStop = false;
             this.groupBox1.Text = "API";
             // 
             // label4
             // 
             this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.label4.AutoSize = true;
             this.label4.Location = new System.Drawing.Point(556, 436);
             this.label4.Name = "label4";
             this.label4.Size = new System.Drawing.Size(34, 13);
             this.label4.TabIndex = 14;
             this.label4.Text = "Cores";
             // 
             // tbCores
             // 
             this.tbCores.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
             this.tbCores.LargeChange = 1;
             this.tbCores.Location = new System.Drawing.Point(557, 459);
             this.tbCores.Maximum = 100;
             this.tbCores.Minimum = 1;
             this.tbCores.Name = "tbCores";
             this.tbCores.Size = new System.Drawing.Size(123, 45);
             this.tbCores.TabIndex = 13;
             this.tbCores.TickStyle = System.Windows.Forms.TickStyle.None;
             this.tbCores.Value = 1;
             this.tbCores.ValueChanged += new System.EventHandler(this.tbCores_ValueChanged);
             // 
             // MainForm
             // 
             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
             this.ClientSize = new System.Drawing.Size(695, 547);
             this.Controls.Add(this.btnVisualize);
             this.Controls.Add(this.label4);
             this.Controls.Add(this.tbCores);
             this.Controls.Add(this.groupBox1);
             this.Controls.Add(this.label3);
             this.Controls.Add(this.tbWorkFactor);
             this.Controls.Add(this.lblTime);
             this.Controls.Add(this.label2);
             this.Controls.Add(this.label1);
             this.Controls.Add(this.lvWorkloads);
             this.Controls.Add(this.lvPartitioningMethods);
             this.Controls.Add(this.pbPartitionedImage);
             this.Name = "MainForm";
             this.Text = "Visualize Partitioning";
             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).EndInit();
             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).EndInit();
             this.groupBox1.ResumeLayout(false);
             this.groupBox1.PerformLayout();
             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).EndInit();
             this.ResumeLayout(false);
             this.PerformLayout();
 
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="8" endline="54"><![CDATA[
         private System.ComponentModel.IContainer components = null;
         public MainForm()
         {
             InitializeComponent();
 
             // Configure the workloads and the color palette.  The partitioning methods initialization will be done
             // when the radio button is changed to Parallel.ForEach or PLINQ.  The color palette will be
             // initialized when the cores trackbar changes value.
             InitializeWorkloads();
 
             // Configure number of cores
             tbCores.Minimum = 1;
             tbCores.Maximum = Environment.ProcessorCount * 2;
             tbCores.Value = Environment.ProcessorCount;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="55" endline="62"><![CDATA[
 
         /// <summary>Initializes the color palette to use when rendering threads.</summary>
         private void InitializeColorPalette()
         {
             Random random = new Random(8); // Change seed value to change the palette used
             _colors = (from i in Enumerable.Range(0, tbCores.Value)
                        select Color.FromArgb(random.Next(128) + 127, random.Next(128) + 127, random.Next(128) + 127)).ToArray();
         }
 
         /// <summary>Initializes the workloads list view.</summary>
         private void InitializeWorkloads()
         {
             lvWorkloads.Items.Clear();
             var workloads = new List<Tuple<string, Func<int, int, int>>>();
 
             // NOTE
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
         {
             Random random = new Random(8); // Change seed value to change the palette used
             _colors = (from i in Enumerable.Range(0, tbCores.Value)
                        select Color.FromArgb(random.Next(128) + 127, random.Next(128) + 127, random.Next(128) + 127)).ToArray();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="63" endline="78"><![CDATA[
 
         /// <summary>Initializes the workloads list view.</summary>
         private void InitializeWorkloads()
         {
             lvWorkloads.Items.Clear();
             var workloads = new List<Tuple<string, Func<int, int, int>>>();
 
             // NOTE
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             lvWorkloads.Items[0].Selected = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="79" endline="128"><![CDATA[
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             lvPartitioningMethods.Items[0].Selected = true;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="129" endline="219"><![CDATA[
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="220" endline="229"><![CDATA[
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
             return value;
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="230" endline="242"><![CDATA[
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="243" endline="251"><![CDATA[
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="252" endline="256"><![CDATA[
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="71" endline="258"><![CDATA[
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="72" endline="258"><![CDATA[
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="73" endline="258"><![CDATA[
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="74" endline="258"><![CDATA[
             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
             
             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
             lvWorkloads.Items[0].Selected = true;
         }
 
         /// <summary>Initializes the partitioning methods list view.</summary>
         private void InitializePartitioningMethods()
         {
             lvPartitioningMethods.Items.Clear();
             bool usingPLINQ = rbPLINQ.Checked;
             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
 
             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
             // which Parallel.ForEach does not provide.
             if (usingPLINQ)
             {
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="92" endline="258"><![CDATA[
                     "Static", e => Partitioner.Create(e, false)));
             }
 
             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="97" endline="258"><![CDATA[
                 "Load Balance", e => Partitioner.Create(e, true)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="99" endline="258"><![CDATA[
                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="101" endline="258"><![CDATA[
                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="103" endline="258"><![CDATA[
                 "Guided", e => ChunkPartitioner.Create(e, prev =>
                 {
                     if (prev <= 0) return e.Length <= 1 ? 1 
                     var next = prev / 2;
                     return next <= 0 ? prev 
                 })));
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="110" endline="258"><![CDATA[
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="112" endline="258"><![CDATA[
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="120" endline="258"><![CDATA[
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="122" endline="258"><![CDATA[
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs" startline="110" endline="258"><![CDATA[
                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 
             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
 
             // Special-case some PLINQ-only hashing
             if (usingPLINQ)
             {
                 // The actual enabling of these partitioning schemes is done later, as they can't 
                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningStripe, e => Partitioner.Create(e)));
                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
                     PartitioningHash, e => Partitioner.Create(e)));
             }
 
             // Dump the partitioners into the list view
             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
             lvPartitioningMethods.Items[0].Selected = true;
         }
 
         /// <summary>Visualize the partitioning.</summary>
         private void btnVisualize_Click(object sender, EventArgs e)
         {
             int numProcs = tbCores.Value;
             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
             _workFactor = tbWorkFactor.Value;
 
             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
             if (!useParallelFor)
             {
                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
             }
 
             // Make sure a workload was selected and use it
             if (lvWorkloads.SelectedItems.Count == 0) return;
             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
 
             // Create a new Bitmap to store the rendered output
             var bmp = new Bitmap(width, height);
 
             // Disable the start button and kick off the background work
             btnVisualize.Enabled = false;
             Task.Factory.StartNew(() =>
             {
                 int nextId = -1; // assign each thread a unique id
                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
 
                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
                 {
                     var sw = Stopwatch.StartNew(); // time the operation
                     if (useParallelFor)
                     {
                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                         {
                             int id = threadId.Value;
                             DoWork(selectedWorkload.Item2(height, i));
                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                         });
                     }
                     else
                     {
                         // Create the partitioner to be used
                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
 
                         if (useParallelForEach)
                         {
                             // Run the work with Parallel.ForEach
                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                         else // PLINQ
                         {
                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
                             // to get PLINQ to use that partitioning approach.
                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
                             source.ForAll(i =>
                             {
                                 int id = threadId.Value;
                                 DoWork(selectedWorkload.Item2(height, i));
                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
                             });
                         }
                     }
 
                     // Return the total time from the task
                     return sw.Elapsed;
                 }
 
                 // When the work completes, run the following on the UI thread
             }).ContinueWith(t =>
             {
                 // Dispose of the old image (if there was one) and display the new one
                 var old = pbPartitionedImage.Image;
                 pbPartitionedImage.Image = bmp;
                 if (old != null) old.Dispose();
 
                 // Re-enable controls on the form and display the elapsed time
                 btnVisualize.Enabled = true;
                 lblTime.Text = "Time
             }, TaskScheduler.FromCurrentSynchronizationContext());
         }
 
         /// <summary>Does an amount of work relative to the amount requested.</summary>
         /// <param name="workAmount">The amount of work to perform.</param>
         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
         private static int DoWork(int workAmount)
         {
             int value = 1;
             for (int i = 0; i < workAmount; i++) value *= workAmount;
             return value;
         }
 
         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
         /// <param name="sender">The radio button.</param>
         /// <param name="e">The event args.</param>
         private void rbAPI_CheckedChanged(object sender, EventArgs e)
         {
             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
 
             // Recreate partitioning methods every time a radio button is checked,
             // as which API is selected determines which partitioning methods are available
             InitializePartitioningMethods();
         }
 
         private void tbCores_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
             InitializeColorPalette();
             int worker, io;
             ThreadPool.GetMinThreads(out worker, out io);
             ThreadPool.SetMinThreads(tbCores.Value, io);
         }
 
         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
         {
             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs" startline="37" endline="39"><![CDATA[
         private static Random _randomnessSeed = new Random();
         /// <summary>A thread-safe source of randomness for all threads that need random values.</summary>
         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs" startline="39" endline="39"><![CDATA[
         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Settings.Designer.cs" startline="25" endline="27"><![CDATA[
             {
                 return defaultInstance;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Settings.Designer.cs" startline="2147483647" endline="2147483647"><![CDATA[
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Settings.Designer.cs" startline="20" endline="30"><![CDATA[
         private static Settings defaultInstance = ((Settings)(global
 
         public static Settings Default
         {
             get
             {
                 return defaultInstance;
             }
         }
     }
 }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs" startline="32" endline="35"><![CDATA[
         [global
         internal Resources()
         {
         }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs" startline="36" endline="51"><![CDATA[
 
         /// <summary>
         ///   Returns the cached ResourceManager instance used by this class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 if ((resourceMan == null))
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
             set
             {
                 resourceCulture = value;
             }
         }
     }
 }
                 {
                     global
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs" startline="52" endline="64"><![CDATA[
         }
 
         /// <summary>
         ///   Overrides the current thread's CurrentUICulture property for all
         ///   resource lookups using this strongly typed resource class.
         /// </summary>
         [global
         internal static global
         {
             get
             {
                 return resourceCulture;
             }
]]></source>
<source file="C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs" startline="65" endline="68"><![CDATA[
             set
             {
                 resourceCulture = value;
             }
]]></source>
</source_elements></project>
