
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly Raytracer
{
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 32 32 34 65 38 64 36 38 2D 38 61 31 39   // ..$224e8d68-8a19
                                                                                                  2D 34 66 62 65 2D 61 61 30 32 2D 66 31 64 61 32   // -4fbe-aa02-f1da2
                                                                                                  65 66 35 61 31 33 63 00 00 )                      // ef5a13c..
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 10 52 61 79 74 72 61 63 65 72 5F 43 53 68   // ...Raytracer_CSh
                                                                                              61 72 70 00 00 )                                  // arp..

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 10 52 61 79 74 72 61 63 65 72 5F 43 53 68   // ...Raytracer_CSh
                                                                                                61 72 70 00 00 )                                  // arp..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm.resources
{
  // Offset: 0x000000B8 Length: 0x000000B4
}
.module Raytracer.exe
// MVID: {48142600-3DAA-43AF-8AFD-58DA5D753708}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x01200000


// =============== CLASS MEMBERS DECLARATION ===================

.class private abstract auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Surface
  .method public hidebysig newslot abstract virtual 
          instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
  } // end of method SceneObject::Intersect

  .method public hidebysig newslot abstract virtual 
          instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
  } // end of method SceneObject::Normal

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface surface) cil managed
  {
    // Code size       17 (0x11)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\SceneObject.cs' 
//000017:         public SceneObject(Surface surface) { Surface = surface; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_000f:  nop
    IL_0010:  ret
  } // end of method SceneObject::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane
       extends Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
{
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Norm
  .field public float64 Offset
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector norm,
                               float64 offset,
                               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface surface) cil managed
  {
    // Code size       25 (0x19)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Plane.cs' 
//000016:         public Plane(Vector norm, double offset, Surface surface) : base(surface) { Norm = norm; Offset = offset; }
    IL_0000:  ldarg.0
    IL_0001:  ldarg.3
    IL_0002:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface)
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  ldarg.0
    IL_000a:  ldarg.1
    IL_000b:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0010:  ldarg.0
    IL_0011:  ldarg.2
    IL_0012:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Offset
    IL_0017:  nop
    IL_0018:  ret
  } // end of method Plane::.ctor

  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
    // Code size       87 (0x57)
    .maxstack  4
    .locals init ([0] float64 denom,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000,
             [2] bool CS$4$0001)
//000017: 
//000018:         public override ISect Intersect(Ray ray)
//000019:         {
    IL_0000:  nop
//000020:             double denom = Vector.Dot(Norm, ray.Dir);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0007:  ldarga.s   ray
    IL_0009:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_000e:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0013:  stloc.0
//000021:             if (denom > 0) return ISect.Null;
    IL_0014:  ldloc.0
    IL_0015:  ldc.r8     0.0
    IL_001e:  cgt
    IL_0020:  ldc.i4.0
    IL_0021:  ceq
    IL_0023:  stloc.2
//000022:             return new ISect(this, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom));
//000023:         }
//000024: 
//000025:         public override Vector Normal(Vector pos)
//000026:         {
//000027:             return Norm;
//000028:         }
//000029:     }
//000030: }
    IL_0024:  ldloc.2
    IL_0025:  brtrue.s   IL_002f

//000021:             if (denom > 0) return ISect.Null;
    IL_0027:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Null
    IL_002c:  stloc.1
    IL_002d:  br.s       IL_0055

//000022:             return new ISect(this, ray, (Vector.Dot(Norm, ray.Start) + Offset) / (-denom));
    IL_002f:  ldarg.0
    IL_0030:  ldarg.1
    IL_0031:  ldarg.0
    IL_0032:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0037:  ldarga.s   ray
    IL_0039:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_003e:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0043:  ldarg.0
    IL_0044:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Offset
    IL_0049:  add
    IL_004a:  ldloc.0
    IL_004b:  neg
    IL_004c:  div
    IL_004d:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                   float64)
    IL_0052:  stloc.1
    IL_0053:  br.s       IL_0055

//000023:         }
    IL_0055:  ldloc.1
    IL_0056:  ret
  } // end of method Plane::Intersect

  .method public hidebysig virtual instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000024: 
//000025:         public override Vector Normal(Vector pos)
//000026:         {
    IL_0000:  nop
//000027:             return Norm;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::Norm
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000028:         }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method Plane::Normal

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect
       extends [mscorlib]System.Object
{
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Thing
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Ray
  .field public float64 Dist
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Null
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray,
                               float64 dist) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\ISect.cs' 
//000018:         public ISect(SceneObject thing, Ray ray, double dist) { Thing = thing; Ray = ray; Dist = dist; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_001d:  nop
    IL_001e:  ret
  } // end of method ISect::.ctor

  .method public hidebysig static bool  IsNull(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect sect) cil managed
  {
    // Code size       10 (0xa)
    .maxstack  2
    .locals init ([0] bool CS$1$0000)
//000019: 
//000020:         public static bool IsNull(ISect sect) { return sect == null; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldnull
    IL_0003:  ceq
    IL_0005:  stloc.0
    IL_0006:  br.s       IL_0008

    IL_0008:  ldloc.0
    IL_0009:  ret
  } // end of method ISect::IsNull

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
//000021:         public readonly static ISect Null = null;
    IL_0000:  ldnull
    IL_0001:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Null
//000022:     }
//000023: }
    IL_0006:  ret
  } // end of method ISect::.cctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect

.class public auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32[] rgb
    .field public float64 framesPerSecond
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass6'::.ctor

    .method public hidebysig instance void 
            '<RenderLoop>b__5'() cil managed
    {
      // Code size       170 (0xaa)
      .maxstack  4
      .locals init ([0] class [System.Drawing]System.Drawing.Imaging.BitmapData bmpData)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs' 
//000130:                 {
      IL_0000:  nop
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0007:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
      IL_000c:  ldarg.0
      IL_000d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0012:  ldfld      valuetype [System.Drawing]System.Drawing.Rectangle Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_rect
      IL_0017:  ldc.i4.2
      IL_0018:  ldarg.0
      IL_0019:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_001e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
      IL_0023:  callvirt   instance valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat [System.Drawing]System.Drawing.Image::get_PixelFormat()
      IL_0028:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_002d:  stloc.0
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
      IL_002e:  ldarg.0
      IL_002f:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
      IL_0034:  ldc.i4.0
      IL_0035:  ldloc.0
      IL_0036:  callvirt   instance native int [System.Drawing]System.Drawing.Imaging.BitmapData::get_Scan0()
      IL_003b:  ldarg.0
      IL_003c:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
      IL_0041:  ldlen
      IL_0042:  conv.i4
      IL_0043:  call       void [mscorlib]System.Runtime.InteropServices.Marshal::Copy(int32[],
                                                                                       int32,
                                                                                       native int,
                                                                                       int32)
      IL_0048:  nop
//000134:                     _bitmap.UnlockBits(bmpData);
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_004f:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
      IL_0054:  ldloc.0
      IL_0055:  callvirt   instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
      IL_005a:  nop
//000135:                     _freeBuffers.PutObject(rgb);
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0061:  ldfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_freeBuffers
      IL_0066:  ldarg.0
      IL_0067:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
      IL_006c:  callvirt   instance void class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]>::PutObject(!0)
      IL_0071:  nop
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
      IL_0072:  ldarg.0
      IL_0073:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0078:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
      IL_007d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Invalidate()
      IL_0082:  nop
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
      IL_0083:  ldarg.0
      IL_0084:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
      IL_0089:  ldstr      "Ray Tracer - FPS: "
      IL_008e:  ldarg.0
      IL_008f:  ldflda     float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::framesPerSecond
      IL_0094:  ldstr      "F1"
      IL_0099:  call       instance string [mscorlib]System.Double::ToString(string)
      IL_009e:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_00a3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_00a8:  nop
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
      IL_00a9:  ret
    } // end of method '<>c__DisplayClass6'::'<RenderLoop>b__5'

  } // end of class '<>c__DisplayClass6'

  .field private bool _showThreads
  .field private bool _parallel
  .field private int32 _degreeOfParallelism
  .field private class [mscorlib]System.Threading.CancellationTokenSource _cancellation
  .field private int32 _width
  .field private int32 _height
  .field private class [System.Drawing]System.Drawing.Bitmap _bitmap
  .field private valuetype [System.Drawing]System.Drawing.Rectangle _rect
  .field private class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]> _freeBuffers
  .field private class [System]System.ComponentModel.IContainer components
  .field assembly class [System.Windows.Forms]System.Windows.Forms.CheckBox chkParallel
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnStartStop
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pbRenderedImage
  .field assembly class [System.Windows.Forms]System.Windows.Forms.CheckBox chkShowThreads
  .field private class [System.Windows.Forms]System.Windows.Forms.TrackBar tbNumProcs
  .field private class [System.Windows.Forms]System.Windows.Forms.Label lblNumProcs
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       35 (0x23)
    .maxstack  8
//000027:         private int _degreeOfParallelism = Environment.ProcessorCount;
    IL_0000:  ldarg.0
    IL_0001:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
    IL_0006:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_degreeOfParallelism
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.Designer.cs' 
//000008:         private System.ComponentModel.IContainer components = null;
    IL_000b:  ldarg.0
    IL_000c:  ldnull
    IL_000d:  stfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs' 
//000023:         public MainForm() { InitializeComponent(); }
    IL_0012:  ldarg.0
    IL_0013:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_0018:  nop
    IL_0019:  nop
    IL_001a:  ldarg.0
    IL_001b:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::InitializeComponent()
    IL_0020:  nop
    IL_0021:  nop
    IL_0022:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          btnStartStop_Click(object sender,
                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       209 (0xd1)
    .maxstack  4
    .locals init ([0] class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task> 'CS$<>9__CachedAnonymousMethodDelegate1',
             [1] bool CS$4$0000)
//000024: 
//000025:         private bool _showThreads;
//000026:         private bool _parallel;
//000027:         private int _degreeOfParallelism = Environment.ProcessorCount;
//000028:         private CancellationTokenSource _cancellation;
//000029: 
//000030:         private int _width, _height;
//000031:         private Bitmap _bitmap;
//000032:         private Rectangle _rect;
//000033:         private ObjectPool<int[]> _freeBuffers;
//000034: 
//000035:         private void btnStartStop_Click(object sender, EventArgs e)
//000036:         {
//000037:             // If we already have the rendering task created, then we're currently running.
//000038:             // In that case, stop the renderer.
//000039:             if (_cancellation != null)
//000040:             {
//000041:                 btnStartStop.Enabled = false;
//000042:                 _cancellation.Cancel();
//000043:             }
//000044:             else
//000045:             {
//000046:                 // Set up the image in the picture box and start the rendering loop with a new rendering task
//000047:                 ConfigureImage();
//000048:                 _showThreads = chkShowThreads.Checked;
//000049:                 _cancellation = new CancellationTokenSource();
//000050:                 Task.Factory.StartNew(RenderLoop, 
//000051:                     _cancellation.Token, _cancellation.Token).
//000052:                     ContinueWith(delegate
//000053:                 {
//000054:                     chkParallel.Enabled = true;
//000055:                     chkShowThreads.Enabled = chkParallel.Checked;
//000056:                     btnStartStop.Enabled = true;
//000057:                     btnStartStop.Text = "Start";
//000058:                     _cancellation = null;
//000059:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000060:                 
//000061:                 chkShowThreads.Enabled = false;
//000062:                 chkParallel.Enabled = false;
//000063:                 btnStartStop.Text = "Stop";
//000064:             }
//000065:         }
//000066: 
//000067:         private void ConfigureImage()
//000068:         {
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0000:  ldnull
    IL_0001:  stloc.0
//000036:         {
    IL_0002:  nop
//000037:             // If we already have the rendering task created, then we're currently running.
//000038:             // In that case, stop the renderer.
//000039:             if (_cancellation != null)
    IL_0003:  ldarg.0
    IL_0004:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  stloc.1
//000040:             {
//000041:                 btnStartStop.Enabled = false;
//000042:                 _cancellation.Cancel();
//000043:             }
//000044:             else
//000045:             {
//000046:                 // Set up the image in the picture box and start the rendering loop with a new rendering task
//000047:                 ConfigureImage();
//000048:                 _showThreads = chkShowThreads.Checked;
//000049:                 _cancellation = new CancellationTokenSource();
//000050:                 Task.Factory.StartNew(RenderLoop, 
//000051:                     _cancellation.Token, _cancellation.Token).
//000052:                     ContinueWith(delegate
//000053:                 {
//000054:                     chkParallel.Enabled = true;
//000055:                     chkShowThreads.Enabled = chkParallel.Checked;
//000056:                     btnStartStop.Enabled = true;
//000057:                     btnStartStop.Text = "Start";
//000058:                     _cancellation = null;
//000059:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000060:                 
//000061:                 chkShowThreads.Enabled = false;
//000062:                 chkParallel.Enabled = false;
//000063:                 btnStartStop.Text = "Stop";
//000064:             }
//000065:         }
//000066: 
//000067:         private void ConfigureImage()
//000068:         {
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_000d:  ldloc.1
    IL_000e:  brtrue.s   IL_0030

//000040:             {
    IL_0010:  nop
//000041:                 btnStartStop.Enabled = false;
    IL_0011:  ldarg.0
    IL_0012:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_0017:  ldc.i4.0
    IL_0018:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_001d:  nop
//000042:                 _cancellation.Cancel();
    IL_001e:  ldarg.0
    IL_001f:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_0024:  callvirt   instance void [mscorlib]System.Threading.CancellationTokenSource::Cancel()
    IL_0029:  nop
//000043:             }
    IL_002a:  nop
//000044:             else
//000045:             {
//000046:                 // Set up the image in the picture box and start the rendering loop with a new rendering task
//000047:                 ConfigureImage();
//000048:                 _showThreads = chkShowThreads.Checked;
//000049:                 _cancellation = new CancellationTokenSource();
//000050:                 Task.Factory.StartNew(RenderLoop, 
//000051:                     _cancellation.Token, _cancellation.Token).
//000052:                     ContinueWith(delegate
//000053:                 {
//000054:                     chkParallel.Enabled = true;
//000055:                     chkShowThreads.Enabled = chkParallel.Checked;
//000056:                     btnStartStop.Enabled = true;
//000057:                     btnStartStop.Text = "Start";
//000058:                     _cancellation = null;
//000059:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000060:                 
//000061:                 chkShowThreads.Enabled = false;
//000062:                 chkParallel.Enabled = false;
//000063:                 btnStartStop.Text = "Stop";
//000064:             }
//000065:         }
//000066: 
//000067:         private void ConfigureImage()
//000068:         {
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_002b:  br         IL_00cf

//000045:             {
    IL_0030:  nop
//000046:                 // Set up the image in the picture box and start the rendering loop with a new rendering task
//000047:                 ConfigureImage();
    IL_0031:  ldarg.0
    IL_0032:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::ConfigureImage()
    IL_0037:  nop
//000048:                 _showThreads = chkShowThreads.Checked;
    IL_0038:  ldarg.0
    IL_0039:  ldarg.0
    IL_003a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_003f:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
    IL_0044:  stfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_showThreads
//000049:                 _cancellation = new CancellationTokenSource();
    IL_0049:  ldarg.0
    IL_004a:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
    IL_004f:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
//000050:                 Task.Factory.StartNew(RenderLoop, 
    IL_0054:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0059:  ldarg.0
    IL_005a:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::RenderLoop(object)
    IL_0060:  newobj     instance void class [mscorlib]System.Action`1<object>::.ctor(object,
                                                                                      native int)
    IL_0065:  ldarg.0
    IL_0066:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_006b:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_0070:  box        [mscorlib]System.Threading.CancellationToken
    IL_0075:  ldarg.0
    IL_0076:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_007b:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_0080:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action`1<object>,
                                                                                                                                     object,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0085:  ldloc.0
    IL_0086:  brtrue.s   IL_0097

    IL_0088:  ldarg.0
    IL_0089:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<btnStartStop_Click>b__0'(class [mscorlib]System.Threading.Tasks.Task)
    IL_008f:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>::.ctor(object,
                                                                                                                           native int)
    IL_0094:  stloc.0
    IL_0095:  br.s       IL_0097

    IL_0097:  ldloc.0
    IL_0098:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_009d:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>,
                                                                                                                                  class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_00a2:  pop
//000051:                     _cancellation.Token, _cancellation.Token).
//000052:                     ContinueWith(delegate
//000053:                 {
//000054:                     chkParallel.Enabled = true;
//000055:                     chkShowThreads.Enabled = chkParallel.Checked;
//000056:                     btnStartStop.Enabled = true;
//000057:                     btnStartStop.Text = "Start";
//000058:                     _cancellation = null;
//000059:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000060:                 
//000061:                 chkShowThreads.Enabled = false;
    IL_00a3:  ldarg.0
    IL_00a4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_00a9:  ldc.i4.0
    IL_00aa:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00af:  nop
//000062:                 chkParallel.Enabled = false;
    IL_00b0:  ldarg.0
    IL_00b1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00b6:  ldc.i4.0
    IL_00b7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00bc:  nop
//000063:                 btnStartStop.Text = "Stop";
    IL_00bd:  ldarg.0
    IL_00be:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_00c3:  ldstr      "Stop"
    IL_00c8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_00cd:  nop
//000064:             }
    IL_00ce:  nop
//000065:         }
    IL_00cf:  nop
    IL_00d0:  ret
  } // end of method MainForm::btnStartStop_Click

  .method private hidebysig instance void 
          ConfigureImage() cil managed
  {
    // Code size       256 (0x100)
    .maxstack  6
    .locals init ([0] class [mscorlib]System.Func`1<int32[]> 'CS$<>9__CachedAnonymousMethodDelegate3',
             [1] bool CS$4$0000,
             [2] int32 CS$0$0001)
//000066: 
//000067:         private void ConfigureImage()
//000068:         {
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0000:  ldnull
    IL_0001:  stloc.0
//000068:         {
    IL_0002:  nop
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
    IL_0003:  ldarg.0
    IL_0004:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_0009:  brfalse.s  IL_003d

    IL_000b:  ldarg.0
    IL_000c:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_0011:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0016:  ldarg.0
    IL_0017:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_001c:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_0021:  bne.un.s   IL_003d

    IL_0023:  ldarg.0
    IL_0024:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_0029:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_002e:  ldarg.0
    IL_002f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0034:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0039:  ceq
    IL_003b:  br.s       IL_003e

    IL_003d:  ldc.i4.0
    IL_003e:  stloc.1
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_003f:  ldloc.1
    IL_0040:  brtrue     IL_00fe

//000071:             {
    IL_0045:  nop
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
    IL_0046:  ldarg.0
    IL_0047:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_004c:  ldnull
    IL_004d:  ceq
    IL_004f:  stloc.1
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0050:  ldloc.1
    IL_0051:  brtrue.s   IL_006e

//000074:                 {
    IL_0053:  nop
//000075:                     pbRenderedImage.Image = null;
    IL_0054:  ldarg.0
    IL_0055:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_005a:  ldnull
    IL_005b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0060:  nop
//000076:                     _bitmap.Dispose();
    IL_0061:  ldarg.0
    IL_0062:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_0067:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
    IL_006c:  nop
//000077:                 }
    IL_006d:  nop
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
    IL_006e:  ldarg.0
    IL_006f:  ldarg.0
    IL_0070:  ldarg.0
    IL_0071:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0076:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_007b:  ldarg.0
    IL_007c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0081:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_0086:  call       int32 [mscorlib]System.Math::Min(int32,
                                                          int32)
    IL_008b:  dup
    IL_008c:  stloc.2
    IL_008d:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_0092:  ldloc.2
    IL_0093:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
    IL_0098:  ldarg.0
    IL_0099:  ldloc.0
    IL_009a:  brtrue.s   IL_00ab

    IL_009c:  ldarg.0
    IL_009d:  ldftn      instance int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::'<ConfigureImage>b__2'()
    IL_00a3:  newobj     instance void class [mscorlib]System.Func`1<int32[]>::.ctor(object,
                                                                                     native int)
    IL_00a8:  stloc.0
    IL_00a9:  br.s       IL_00ab

    IL_00ab:  ldloc.0
    IL_00ac:  newobj     instance void class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]>::.ctor(class [mscorlib]System.Func`1<!0>)
    IL_00b1:  stfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_freeBuffers
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
    IL_00b6:  ldarg.0
    IL_00b7:  ldarg.0
    IL_00b8:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_00bd:  ldarg.0
    IL_00be:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_00c3:  ldc.i4     0x22009
    IL_00c8:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32,
                                                                                    valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_00cd:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
    IL_00d2:  ldarg.0
    IL_00d3:  ldc.i4.0
    IL_00d4:  ldc.i4.0
    IL_00d5:  ldarg.0
    IL_00d6:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_00db:  ldarg.0
    IL_00dc:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_00e1:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                       int32,
                                                                                       int32,
                                                                                       int32)
    IL_00e6:  stfld      valuetype [System.Drawing]System.Drawing.Rectangle Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_rect
//000088:                 pbRenderedImage.Image = _bitmap;
    IL_00eb:  ldarg.0
    IL_00ec:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_00f1:  ldarg.0
    IL_00f2:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_bitmap
    IL_00f7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_00fc:  nop
//000089:             }
    IL_00fd:  nop
//000090:         }
    IL_00fe:  nop
    IL_00ff:  ret
  } // end of method MainForm::ConfigureImage

  .method private hidebysig instance void 
          RenderLoop(object boxedToken) cil managed
  {
    // Code size       405 (0x195)
    .maxstack  4
    .locals init ([0] valuetype [mscorlib]System.Threading.CancellationToken cancellationToken,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer rayTracer,
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
             [3] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere sphere2,
             [4] float64 baseY,
             [5] class [System]System.Diagnostics.Stopwatch renderingTime,
             [6] class [System]System.Diagnostics.Stopwatch totalTime,
             [7] float64 dy2,
             [8] class [mscorlib]System.Threading.Tasks.ParallelOptions options,
             [9] class [mscorlib]System.Threading.Tasks.ParallelOptions '<>g__initLocal4',
             [10] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6' 'CS$<>8__locals7',
             [11] bool CS$4$0000)
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
    IL_0000:  nop
//000094:             var cancellationToken = (CancellationToken)boxedToken;
    IL_0001:  ldarg.1
    IL_0002:  unbox.any  [mscorlib]System.Threading.CancellationToken
    IL_0007:  stloc.0
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
    IL_0008:  ldarg.0
    IL_0009:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_000e:  ldarg.0
    IL_000f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_0014:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::.ctor(int32,
                                                                                                                       int32)
    IL_0019:  stloc.1
//000098:             var scene = rayTracer.DefaultScene;
    IL_001a:  ldloc.1
    IL_001b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::DefaultScene
    IL_0020:  stloc.2
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
    IL_0021:  ldloc.2
    IL_0022:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
    IL_0027:  ldc.i4.0
    IL_0028:  ldelem.ref
    IL_0029:  castclass  Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere
    IL_002e:  stloc.3
//000100:             var baseY = sphere2.Radius;
    IL_002f:  ldloc.3
    IL_0030:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_0035:  stloc.s    baseY
//000101:             sphere2.Center.Y = sphere2.Radius;
    IL_0037:  ldloc.3
    IL_0038:  ldflda     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_003d:  ldloc.3
    IL_003e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_0043:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
    IL_0048:  newobj     instance void [System]System.Diagnostics.Stopwatch::.ctor()
    IL_004d:  stloc.s    renderingTime
//000105:             var totalTime = Stopwatch.StartNew();
    IL_004f:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
    IL_0054:  stloc.s    totalTime
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0056:  br         IL_0181

    IL_005b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::.ctor()
    IL_0060:  stloc.s    'CS$<>8__locals7'
    IL_0062:  ldloc.s    'CS$<>8__locals7'
    IL_0064:  ldarg.0
    IL_0065:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<>4__this'
//000109:             {
    IL_006a:  nop
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
    IL_006b:  ldloc.s    'CS$<>8__locals7'
    IL_006d:  ldarg.0
    IL_006e:  ldfld      class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_freeBuffers
    IL_0073:  callvirt   instance !0 class [ParallelExtensionsExtras]System.Collections.Concurrent.ObjectPool`1<int32[]>::GetObject()
    IL_0078:  stfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
    IL_007d:  ldc.r8     0.80000000000000004
    IL_0086:  ldloc.s    totalTime
    IL_0088:  callvirt   instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
    IL_008d:  conv.r8
    IL_008e:  ldc.r8     3.1415926535897931
    IL_0097:  mul
    IL_0098:  ldc.r8     3000.
    IL_00a1:  div
    IL_00a2:  call       float64 [mscorlib]System.Math::Sin(float64)
    IL_00a7:  call       float64 [mscorlib]System.Math::Abs(float64)
    IL_00ac:  mul
    IL_00ad:  stloc.s    dy2
//000115:                 sphere2.Center.Y = baseY + dy2;
    IL_00af:  ldloc.3
    IL_00b0:  ldflda     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_00b5:  ldloc.s    baseY
    IL_00b7:  ldloc.s    dy2
    IL_00b9:  add
    IL_00ba:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
    IL_00bf:  ldloc.s    renderingTime
    IL_00c1:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Reset()
    IL_00c6:  nop
//000119:                 renderingTime.Start();
    IL_00c7:  ldloc.s    renderingTime
    IL_00c9:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Start()
    IL_00ce:  nop
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
    IL_00cf:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
    IL_00d4:  stloc.s    '<>g__initLocal4'
    IL_00d6:  ldloc.s    '<>g__initLocal4'
    IL_00d8:  ldarg.0
    IL_00d9:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_degreeOfParallelism
    IL_00de:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_MaxDegreeOfParallelism(int32)
    IL_00e3:  nop
    IL_00e4:  ldloc.s    '<>g__initLocal4'
    IL_00e6:  ldarg.0
    IL_00e7:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
    IL_00ec:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_00f1:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_CancellationToken(valuetype [mscorlib]System.Threading.CancellationToken)
    IL_00f6:  nop
    IL_00f7:  ldloc.s    '<>g__initLocal4'
    IL_00f9:  stloc.s    options
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
    IL_00fb:  ldarg.0
    IL_00fc:  ldfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_parallel
    IL_0101:  stloc.s    CS$4$0000
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0103:  ldloc.s    CS$4$0000
    IL_0105:  brtrue.s   IL_0118

//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
    IL_0107:  ldloc.1
    IL_0108:  ldloc.2
    IL_0109:  ldloc.s    'CS$<>8__locals7'
    IL_010b:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
    IL_0110:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RenderSequential(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                  int32[])
    IL_0115:  nop
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0116:  br.s       IL_014b

//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
    IL_0118:  ldarg.0
    IL_0119:  ldfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_showThreads
    IL_011e:  ldc.i4.0
    IL_011f:  ceq
    IL_0121:  stloc.s    CS$4$0000
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0123:  ldloc.s    CS$4$0000
    IL_0125:  brtrue.s   IL_013a

//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
    IL_0127:  ldloc.1
    IL_0128:  ldloc.2
    IL_0129:  ldloc.s    'CS$<>8__locals7'
    IL_012b:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
    IL_0130:  ldloc.s    options
    IL_0132:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RenderParallelShowingThreads(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                              int32[],
                                                                                                                                              class [mscorlib]System.Threading.Tasks.ParallelOptions)
    IL_0137:  nop
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0138:  br.s       IL_014b

//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
    IL_013a:  ldloc.1
    IL_013b:  ldloc.2
    IL_013c:  ldloc.s    'CS$<>8__locals7'
    IL_013e:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::rgb
    IL_0143:  ldloc.s    options
    IL_0145:  callvirt   instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RenderParallel(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                int32[],
                                                                                                                                class [mscorlib]System.Threading.Tasks.ParallelOptions)
    IL_014a:  nop
//000124:                 renderingTime.Stop();
    IL_014b:  ldloc.s    renderingTime
    IL_014d:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Stop()
    IL_0152:  nop
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
    IL_0153:  ldloc.s    'CS$<>8__locals7'
    IL_0155:  ldc.r8     1000.
    IL_015e:  ldloc.s    renderingTime
    IL_0160:  callvirt   instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
    IL_0165:  conv.r8
    IL_0166:  div
    IL_0167:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::framesPerSecond
//000129:                 BeginInvoke((Action)delegate
    IL_016c:  ldarg.0
    IL_016d:  ldloc.s    'CS$<>8__locals7'
    IL_016f:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm/'<>c__DisplayClass6'::'<RenderLoop>b__5'()
    IL_0175:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_017a:  call       instance class [mscorlib]System.IAsyncResult [System.Windows.Forms]System.Windows.Forms.Control::BeginInvoke(class [mscorlib]System.Delegate)
    IL_017f:  pop
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
    IL_0180:  nop
//000108:             while (!cancellationToken.IsCancellationRequested)
    IL_0181:  ldloca.s   cancellationToken
    IL_0183:  call       instance bool [mscorlib]System.Threading.CancellationToken::get_IsCancellationRequested()
    IL_0188:  ldc.i4.0
    IL_0189:  ceq
    IL_018b:  stloc.s    CS$4$0000
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_018d:  ldloc.s    CS$4$0000
    IL_018f:  brtrue     IL_005b

//000142:         }
    IL_0194:  ret
  } // end of method MainForm::RenderLoop

  .method private hidebysig instance void 
          chkParallel_CheckedChanged(object sender,
                                     class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       64 (0x40)
    .maxstack  6
    .locals init ([0] bool CS$0$0000)
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
    IL_0000:  nop
//000146:             _parallel = 
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0008:  ldarg.0
    IL_0009:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_001a:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
    IL_001f:  dup
    IL_0020:  stloc.0
    IL_0021:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0026:  nop
    IL_0027:  ldloc.0
    IL_0028:  dup
    IL_0029:  stloc.0
    IL_002a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_002f:  nop
    IL_0030:  ldloc.0
    IL_0031:  dup
    IL_0032:  stloc.0
    IL_0033:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0038:  nop
    IL_0039:  ldloc.0
    IL_003a:  stfld      bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_parallel
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
    IL_003f:  ret
  } // end of method MainForm::chkParallel_CheckedChanged

  .method private hidebysig instance void 
          tbNumProcs_ValueChanged(object sender,
                                  class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  2
    .locals init ([0] int32 CS$0$0000)
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
    IL_0000:  nop
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_000d:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0012:  stloc.0
    IL_0013:  ldloca.s   CS$0$0000
    IL_0015:  call       instance string [mscorlib]System.Int32::ToString()
    IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_001f:  nop
//000156:             _degreeOfParallelism = tbNumProcs.Value;
    IL_0020:  ldarg.0
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0027:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_002c:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_degreeOfParallelism
//000157:         }
    IL_0031:  ret
  } // end of method MainForm::tbNumProcs_ValueChanged

  .method private hidebysig instance void 
          MainForm_Load(object sender,
                        class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       86 (0x56)
    .maxstack  2
    .locals init ([0] int32 CS$0$0000)
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
    IL_0000:  nop
//000161:             tbNumProcs.Minimum = 1;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0007:  ldc.i4.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_000d:  nop
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0014:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
    IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_001e:  nop
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
    IL_001f:  ldarg.0
    IL_0020:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0025:  ldarg.0
    IL_0026:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_002b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Maximum()
    IL_0030:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0035:  nop
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
    IL_0036:  ldarg.0
    IL_0037:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_003c:  ldarg.0
    IL_003d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0042:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0047:  stloc.0
    IL_0048:  ldloca.s   CS$0$0000
    IL_004a:  call       instance string [mscorlib]System.Int32::ToString()
    IL_004f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0054:  nop
//000165:         }
    IL_0055:  ret
  } // end of method MainForm::MainForm_Load

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.chkParallel = new System.Windows.Forms.CheckBox();
//000032:             this.btnStartStop = new System.Windows.Forms.Button();
//000033:             this.pbRenderedImage = new System.Windows.Forms.PictureBox();
//000034:             this.chkShowThreads = new System.Windows.Forms.CheckBox();
//000035:             this.tbNumProcs = new System.Windows.Forms.TrackBar();
//000036:             this.lblNumProcs = new System.Windows.Forms.Label();
//000037:             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).BeginInit();
//000038:             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).BeginInit();
//000039:             this.SuspendLayout();
//000040:             // 
//000041:             // chkParallel
//000042:             // 
//000043:             this.chkParallel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000044:             this.chkParallel.AutoSize = true;
//000045:             this.chkParallel.Location = new System.Drawing.Point(108, 426);
//000046:             this.chkParallel.Name = "chkParallel";
//000047:             this.chkParallel.Size = new System.Drawing.Size(60, 17);
//000048:             this.chkParallel.TabIndex = 20;
//000049:             this.chkParallel.Text = "Parallel";
//000050:             this.chkParallel.UseVisualStyleBackColor = true;
//000051:             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
//000052:             // 
//000053:             // btnStartStop
//000054:             // 
//000055:             this.btnStartStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000056:             this.btnStartStop.Location = new System.Drawing.Point(13, 421);
//000057:             this.btnStartStop.Name = "btnStartStop";
//000058:             this.btnStartStop.Size = new System.Drawing.Size(88, 23);
//000059:             this.btnStartStop.TabIndex = 19;
//000060:             this.btnStartStop.Text = "Start";
//000061:             this.btnStartStop.UseVisualStyleBackColor = true;
//000062:             this.btnStartStop.Click += new System.EventHandler(this.btnStartStop_Click);
//000063:             // 
//000064:             // pbRenderedImage
//000065:             // 
//000066:             this.pbRenderedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000067:                         | System.Windows.Forms.AnchorStyles.Left)
//000068:                         | System.Windows.Forms.AnchorStyles.Right)));
//000069:             this.pbRenderedImage.BackColor = System.Drawing.Color.Black;
//000070:             this.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None;
//000071:             this.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
//000072:             this.pbRenderedImage.Location = new System.Drawing.Point(13, 15);
//000073:             this.pbRenderedImage.Name = "pbRenderedImage";
//000074:             this.pbRenderedImage.Size = new System.Drawing.Size(469, 400);
//000075:             this.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
//000076:             this.pbRenderedImage.TabIndex = 18;
//000077:             this.pbRenderedImage.TabStop = false;
//000078:             // 
//000079:             // chkShowThreads
//000080:             // 
//000081:             this.chkShowThreads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
//000082:             this.chkShowThreads.AutoSize = true;
//000083:             this.chkShowThreads.Enabled = false;
//000084:             this.chkShowThreads.Location = new System.Drawing.Point(174, 426);
//000085:             this.chkShowThreads.Name = "chkShowThreads";
//000086:             this.chkShowThreads.Size = new System.Drawing.Size(95, 17);
//000087:             this.chkShowThreads.TabIndex = 21;
//000088:             this.chkShowThreads.Text = "Show Threads";
//000089:             this.chkShowThreads.UseVisualStyleBackColor = true;
//000090:             // 
//000091:             // tbNumProcs
//000092:             // 
//000093:             this.tbNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
//000094:             this.tbNumProcs.Enabled = false;
//000095:             this.tbNumProcs.Location = new System.Drawing.Point(304, 421);
//000096:             this.tbNumProcs.Maximum = 24;
//000097:             this.tbNumProcs.Minimum = 1;
//000098:             this.tbNumProcs.Name = "tbNumProcs";
//000099:             this.tbNumProcs.Size = new System.Drawing.Size(178, 45);
//000100:             this.tbNumProcs.TabIndex = 22;
//000101:             this.tbNumProcs.Value = 1;
//000102:             this.tbNumProcs.ValueChanged += new System.EventHandler(this.tbNumProcs_ValueChanged);
//000103:             // 
//000104:             // lblNumProcs
//000105:             // 
//000106:             this.lblNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
//000107:             this.lblNumProcs.AutoSize = true;
//000108:             this.lblNumProcs.Enabled = false;
//000109:             this.lblNumProcs.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
//000110:             this.lblNumProcs.Location = new System.Drawing.Point(295, 431);
//000111:             this.lblNumProcs.Name = "lblNumProcs";
//000112:             this.lblNumProcs.Size = new System.Drawing.Size(14, 13);
//000113:             this.lblNumProcs.TabIndex = 23;
//000114:             this.lblNumProcs.Text = "1";
//000115:             // 
//000116:             // MainForm
//000117:             // 
//000118:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000119:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000120:             this.ClientSize = new System.Drawing.Size(495, 459);
//000121:             this.Controls.Add(this.lblNumProcs);
//000122:             this.Controls.Add(this.tbNumProcs);
//000123:             this.Controls.Add(this.chkShowThreads);
//000124:             this.Controls.Add(this.chkParallel);
//000125:             this.Controls.Add(this.btnStartStop);
//000126:             this.Controls.Add(this.pbRenderedImage);
//000127:             this.Name = "MainForm";
//000128:             this.Text = "Ray Tracer";
//000129:             this.Load += new System.EventHandler(this.MainForm_Load);
//000130:             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).EndInit();
//000131:             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).EndInit();
//000132:             this.ResumeLayout(false);
//000133:             this.PerformLayout();
//000134: 
//000135:         }
//000136: 
//000137:         #endregion
//000138: 
//000139:         internal System.Windows.Forms.CheckBox chkParallel;
//000140:         private System.Windows.Forms.Button btnStartStop;
//000141:         private System.Windows.Forms.PictureBox pbRenderedImage;
//000142:         internal System.Windows.Forms.CheckBox chkShowThreads;
//000143:         private System.Windows.Forms.TrackBar tbNumProcs;
//000144:         private System.Windows.Forms.Label lblNumProcs;
//000145:     }
//000146: }
//000147: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       1289 (0x509)
    .maxstack  7
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.chkParallel = new System.Windows.Forms.CheckBox();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::.ctor()
    IL_0007:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
//000032:             this.btnStartStop = new System.Windows.Forms.Button();
    IL_000c:  ldarg.0
    IL_000d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_0012:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
//000033:             this.pbRenderedImage = new System.Windows.Forms.PictureBox();
    IL_0017:  ldarg.0
    IL_0018:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_001d:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
//000034:             this.chkShowThreads = new System.Windows.Forms.CheckBox();
    IL_0022:  ldarg.0
    IL_0023:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::.ctor()
    IL_0028:  stfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
//000035:             this.tbNumProcs = new System.Windows.Forms.TrackBar();
    IL_002d:  ldarg.0
    IL_002e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_0033:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
//000036:             this.lblNumProcs = new System.Windows.Forms.Label();
    IL_0038:  ldarg.0
    IL_0039:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_003e:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
//000037:             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).BeginInit();
    IL_0043:  ldarg.0
    IL_0044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0049:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_004e:  nop
//000038:             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).BeginInit();
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0055:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_005a:  nop
//000039:             this.SuspendLayout();
    IL_005b:  ldarg.0
    IL_005c:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0061:  nop
//000040:             // 
//000041:             // chkParallel
//000042:             // 
//000043:             this.chkParallel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_0062:  ldarg.0
    IL_0063:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_0068:  ldc.i4.6
    IL_0069:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_006e:  nop
//000044:             this.chkParallel.AutoSize = true;
    IL_006f:  ldarg.0
    IL_0070:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_0075:  ldc.i4.1
    IL_0076:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_007b:  nop
//000045:             this.chkParallel.Location = new System.Drawing.Point(108, 426);
    IL_007c:  ldarg.0
    IL_007d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_0082:  ldc.i4.s   108
    IL_0084:  ldc.i4     0x1aa
    IL_0089:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_008e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0093:  nop
//000046:             this.chkParallel.Name = "chkParallel";
    IL_0094:  ldarg.0
    IL_0095:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_009a:  ldstr      "chkParallel"
    IL_009f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_00a4:  nop
//000047:             this.chkParallel.Size = new System.Drawing.Size(60, 17);
    IL_00a5:  ldarg.0
    IL_00a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00ab:  ldc.i4.s   60
    IL_00ad:  ldc.i4.s   17
    IL_00af:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_00b4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_00b9:  nop
//000048:             this.chkParallel.TabIndex = 20;
    IL_00ba:  ldarg.0
    IL_00bb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00c0:  ldc.i4.s   20
    IL_00c2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_00c7:  nop
//000049:             this.chkParallel.Text = "Parallel";
    IL_00c8:  ldarg.0
    IL_00c9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00ce:  ldstr      "Parallel"
    IL_00d3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_00d8:  nop
//000050:             this.chkParallel.UseVisualStyleBackColor = true;
    IL_00d9:  ldarg.0
    IL_00da:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00df:  ldc.i4.1
    IL_00e0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_00e5:  nop
//000051:             this.chkParallel.CheckedChanged += new System.EventHandler(this.chkParallel_CheckedChanged);
    IL_00e6:  ldarg.0
    IL_00e7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_00ec:  ldarg.0
    IL_00ed:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel_CheckedChanged(object,
                                                                                                                                           class [mscorlib]System.EventArgs)
    IL_00f3:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_00f8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.CheckBox::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_00fd:  nop
//000052:             // 
//000053:             // btnStartStop
//000054:             // 
//000055:             this.btnStartStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_00fe:  ldarg.0
    IL_00ff:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_0104:  ldc.i4.6
    IL_0105:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_010a:  nop
//000056:             this.btnStartStop.Location = new System.Drawing.Point(13, 421);
    IL_010b:  ldarg.0
    IL_010c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_0111:  ldc.i4.s   13
    IL_0113:  ldc.i4     0x1a5
    IL_0118:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_011d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0122:  nop
//000057:             this.btnStartStop.Name = "btnStartStop";
    IL_0123:  ldarg.0
    IL_0124:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_0129:  ldstr      "btnStartStop"
    IL_012e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0133:  nop
//000058:             this.btnStartStop.Size = new System.Drawing.Size(88, 23);
    IL_0134:  ldarg.0
    IL_0135:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_013a:  ldc.i4.s   88
    IL_013c:  ldc.i4.s   23
    IL_013e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0143:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0148:  nop
//000059:             this.btnStartStop.TabIndex = 19;
    IL_0149:  ldarg.0
    IL_014a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_014f:  ldc.i4.s   19
    IL_0151:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0156:  nop
//000060:             this.btnStartStop.Text = "Start";
    IL_0157:  ldarg.0
    IL_0158:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_015d:  ldstr      "Start"
    IL_0162:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0167:  nop
//000061:             this.btnStartStop.UseVisualStyleBackColor = true;
    IL_0168:  ldarg.0
    IL_0169:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_016e:  ldc.i4.1
    IL_016f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_0174:  nop
//000062:             this.btnStartStop.Click += new System.EventHandler(this.btnStartStop_Click);
    IL_0175:  ldarg.0
    IL_0176:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_017b:  ldarg.0
    IL_017c:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop_Click(object,
                                                                                                                                   class [mscorlib]System.EventArgs)
    IL_0182:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0187:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_018c:  nop
//000063:             // 
//000064:             // pbRenderedImage
//000065:             // 
//000066:             this.pbRenderedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_018d:  ldarg.0
    IL_018e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0193:  ldc.i4.s   15
    IL_0195:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_019a:  nop
//000067:                         | System.Windows.Forms.AnchorStyles.Left)
//000068:                         | System.Windows.Forms.AnchorStyles.Right)));
//000069:             this.pbRenderedImage.BackColor = System.Drawing.Color.Black;
    IL_019b:  ldarg.0
    IL_019c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01a1:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
    IL_01a6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_01ab:  nop
//000070:             this.pbRenderedImage.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None;
    IL_01ac:  ldarg.0
    IL_01ad:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01b2:  ldc.i4.0
    IL_01b3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackgroundImageLayout(valuetype [System.Windows.Forms]System.Windows.Forms.ImageLayout)
    IL_01b8:  nop
//000071:             this.pbRenderedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
    IL_01b9:  ldarg.0
    IL_01ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01bf:  ldc.i4.2
    IL_01c0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_01c5:  nop
//000072:             this.pbRenderedImage.Location = new System.Drawing.Point(13, 15);
    IL_01c6:  ldarg.0
    IL_01c7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01cc:  ldc.i4.s   13
    IL_01ce:  ldc.i4.s   15
    IL_01d0:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_01d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01da:  nop
//000073:             this.pbRenderedImage.Name = "pbRenderedImage";
    IL_01db:  ldarg.0
    IL_01dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01e1:  ldstr      "pbRenderedImage"
    IL_01e6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01eb:  nop
//000074:             this.pbRenderedImage.Size = new System.Drawing.Size(469, 400);
    IL_01ec:  ldarg.0
    IL_01ed:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_01f2:  ldc.i4     0x1d5
    IL_01f7:  ldc.i4     0x190
    IL_01fc:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0201:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0206:  nop
//000075:             this.pbRenderedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.CenterImage;
    IL_0207:  ldarg.0
    IL_0208:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_020d:  ldc.i4.3
    IL_020e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0213:  nop
//000076:             this.pbRenderedImage.TabIndex = 18;
    IL_0214:  ldarg.0
    IL_0215:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_021a:  ldc.i4.s   18
    IL_021c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_0221:  nop
//000077:             this.pbRenderedImage.TabStop = false;
    IL_0222:  ldarg.0
    IL_0223:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_0228:  ldc.i4.0
    IL_0229:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_022e:  nop
//000078:             // 
//000079:             // chkShowThreads
//000080:             // 
//000081:             this.chkShowThreads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
    IL_022f:  ldarg.0
    IL_0230:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0235:  ldc.i4.6
    IL_0236:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_023b:  nop
//000082:             this.chkShowThreads.AutoSize = true;
    IL_023c:  ldarg.0
    IL_023d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0242:  ldc.i4.1
    IL_0243:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0248:  nop
//000083:             this.chkShowThreads.Enabled = false;
    IL_0249:  ldarg.0
    IL_024a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_024f:  ldc.i4.0
    IL_0250:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0255:  nop
//000084:             this.chkShowThreads.Location = new System.Drawing.Point(174, 426);
    IL_0256:  ldarg.0
    IL_0257:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_025c:  ldc.i4     0xae
    IL_0261:  ldc.i4     0x1aa
    IL_0266:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_026b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0270:  nop
//000085:             this.chkShowThreads.Name = "chkShowThreads";
    IL_0271:  ldarg.0
    IL_0272:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0277:  ldstr      "chkShowThreads"
    IL_027c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0281:  nop
//000086:             this.chkShowThreads.Size = new System.Drawing.Size(95, 17);
    IL_0282:  ldarg.0
    IL_0283:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0288:  ldc.i4.s   95
    IL_028a:  ldc.i4.s   17
    IL_028c:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0291:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0296:  nop
//000087:             this.chkShowThreads.TabIndex = 21;
    IL_0297:  ldarg.0
    IL_0298:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_029d:  ldc.i4.s   21
    IL_029f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_02a4:  nop
//000088:             this.chkShowThreads.Text = "Show Threads";
    IL_02a5:  ldarg.0
    IL_02a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_02ab:  ldstr      "Show Threads"
    IL_02b0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_02b5:  nop
//000089:             this.chkShowThreads.UseVisualStyleBackColor = true;
    IL_02b6:  ldarg.0
    IL_02b7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_02bc:  ldc.i4.1
    IL_02bd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_02c2:  nop
//000090:             // 
//000091:             // tbNumProcs
//000092:             // 
//000093:             this.tbNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
    IL_02c3:  ldarg.0
    IL_02c4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_02c9:  ldc.i4.s   10
    IL_02cb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_02d0:  nop
//000094:             this.tbNumProcs.Enabled = false;
    IL_02d1:  ldarg.0
    IL_02d2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_02d7:  ldc.i4.0
    IL_02d8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_02dd:  nop
//000095:             this.tbNumProcs.Location = new System.Drawing.Point(304, 421);
    IL_02de:  ldarg.0
    IL_02df:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_02e4:  ldc.i4     0x130
    IL_02e9:  ldc.i4     0x1a5
    IL_02ee:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_02f3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_02f8:  nop
//000096:             this.tbNumProcs.Maximum = 24;
    IL_02f9:  ldarg.0
    IL_02fa:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_02ff:  ldc.i4.s   24
    IL_0301:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_0306:  nop
//000097:             this.tbNumProcs.Minimum = 1;
    IL_0307:  ldarg.0
    IL_0308:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_030d:  ldc.i4.1
    IL_030e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0313:  nop
//000098:             this.tbNumProcs.Name = "tbNumProcs";
    IL_0314:  ldarg.0
    IL_0315:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_031a:  ldstr      "tbNumProcs"
    IL_031f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0324:  nop
//000099:             this.tbNumProcs.Size = new System.Drawing.Size(178, 45);
    IL_0325:  ldarg.0
    IL_0326:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_032b:  ldc.i4     0xb2
    IL_0330:  ldc.i4.s   45
    IL_0332:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0337:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_033c:  nop
//000100:             this.tbNumProcs.TabIndex = 22;
    IL_033d:  ldarg.0
    IL_033e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0343:  ldc.i4.s   22
    IL_0345:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_034a:  nop
//000101:             this.tbNumProcs.Value = 1;
    IL_034b:  ldarg.0
    IL_034c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0351:  ldc.i4.1
    IL_0352:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0357:  nop
//000102:             this.tbNumProcs.ValueChanged += new System.EventHandler(this.tbNumProcs_ValueChanged);
    IL_0358:  ldarg.0
    IL_0359:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_035e:  ldarg.0
    IL_035f:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs_ValueChanged(object,
                                                                                                                                        class [mscorlib]System.EventArgs)
    IL_0365:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_036a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_036f:  nop
//000103:             // 
//000104:             // lblNumProcs
//000105:             // 
//000106:             this.lblNumProcs.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
    IL_0370:  ldarg.0
    IL_0371:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0376:  ldc.i4.s   10
    IL_0378:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_037d:  nop
//000107:             this.lblNumProcs.AutoSize = true;
    IL_037e:  ldarg.0
    IL_037f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0384:  ldc.i4.1
    IL_0385:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_038a:  nop
//000108:             this.lblNumProcs.Enabled = false;
    IL_038b:  ldarg.0
    IL_038c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0391:  ldc.i4.0
    IL_0392:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0397:  nop
//000109:             this.lblNumProcs.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
    IL_0398:  ldarg.0
    IL_0399:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_039e:  ldstr      "Microsoft Sans Serif"
    IL_03a3:  ldc.r4     8.25
    IL_03a8:  ldc.i4.1
    IL_03a9:  ldc.i4.3
    IL_03aa:  ldc.i4.0
    IL_03ab:  newobj     instance void [System.Drawing]System.Drawing.Font::.ctor(string,
                                                                                  float32,
                                                                                  valuetype [System.Drawing]System.Drawing.FontStyle,
                                                                                  valuetype [System.Drawing]System.Drawing.GraphicsUnit,
                                                                                  uint8)
    IL_03b0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Font(class [System.Drawing]System.Drawing.Font)
    IL_03b5:  nop
//000110:             this.lblNumProcs.Location = new System.Drawing.Point(295, 431);
    IL_03b6:  ldarg.0
    IL_03b7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_03bc:  ldc.i4     0x127
    IL_03c1:  ldc.i4     0x1af
    IL_03c6:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_03cb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_03d0:  nop
//000111:             this.lblNumProcs.Name = "lblNumProcs";
    IL_03d1:  ldarg.0
    IL_03d2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_03d7:  ldstr      "lblNumProcs"
    IL_03dc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_03e1:  nop
//000112:             this.lblNumProcs.Size = new System.Drawing.Size(14, 13);
    IL_03e2:  ldarg.0
    IL_03e3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_03e8:  ldc.i4.s   14
    IL_03ea:  ldc.i4.s   13
    IL_03ec:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_03f1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_03f6:  nop
//000113:             this.lblNumProcs.TabIndex = 23;
    IL_03f7:  ldarg.0
    IL_03f8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_03fd:  ldc.i4.s   23
    IL_03ff:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0404:  nop
//000114:             this.lblNumProcs.Text = "1";
    IL_0405:  ldarg.0
    IL_0406:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_040b:  ldstr      "1"
    IL_0410:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0415:  nop
//000115:             // 
//000116:             // MainForm
//000117:             // 
//000118:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0416:  ldarg.0
    IL_0417:  ldc.r4     6.
    IL_041c:  ldc.r4     13.
    IL_0421:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0426:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_042b:  nop
//000119:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_042c:  ldarg.0
    IL_042d:  ldc.i4.1
    IL_042e:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0433:  nop
//000120:             this.ClientSize = new System.Drawing.Size(495, 459);
    IL_0434:  ldarg.0
    IL_0435:  ldc.i4     0x1ef
    IL_043a:  ldc.i4     0x1cb
    IL_043f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0444:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_0449:  nop
//000121:             this.Controls.Add(this.lblNumProcs);
    IL_044a:  ldarg.0
    IL_044b:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0450:  ldarg.0
    IL_0451:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::lblNumProcs
    IL_0456:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_045b:  nop
//000122:             this.Controls.Add(this.tbNumProcs);
    IL_045c:  ldarg.0
    IL_045d:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0462:  ldarg.0
    IL_0463:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_0468:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_046d:  nop
//000123:             this.Controls.Add(this.chkShowThreads);
    IL_046e:  ldarg.0
    IL_046f:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0474:  ldarg.0
    IL_0475:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_047a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_047f:  nop
//000124:             this.Controls.Add(this.chkParallel);
    IL_0480:  ldarg.0
    IL_0481:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0486:  ldarg.0
    IL_0487:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_048c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0491:  nop
//000125:             this.Controls.Add(this.btnStartStop);
    IL_0492:  ldarg.0
    IL_0493:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0498:  ldarg.0
    IL_0499:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_049e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_04a3:  nop
//000126:             this.Controls.Add(this.pbRenderedImage);
    IL_04a4:  ldarg.0
    IL_04a5:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_04aa:  ldarg.0
    IL_04ab:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_04b0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_04b5:  nop
//000127:             this.Name = "MainForm";
    IL_04b6:  ldarg.0
    IL_04b7:  ldstr      "MainForm"
    IL_04bc:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_04c1:  nop
//000128:             this.Text = "Ray Tracer";
    IL_04c2:  ldarg.0
    IL_04c3:  ldstr      "Ray Tracer"
    IL_04c8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_04cd:  nop
//000129:             this.Load += new System.EventHandler(this.MainForm_Load);
    IL_04ce:  ldarg.0
    IL_04cf:  ldarg.0
    IL_04d0:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::MainForm_Load(object,
                                                                                                                              class [mscorlib]System.EventArgs)
    IL_04d6:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_04db:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::add_Load(class [mscorlib]System.EventHandler)
    IL_04e0:  nop
//000130:             ((System.ComponentModel.ISupportInitialize)(this.pbRenderedImage)).EndInit();
    IL_04e1:  ldarg.0
    IL_04e2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::pbRenderedImage
    IL_04e7:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_04ec:  nop
//000131:             ((System.ComponentModel.ISupportInitialize)(this.tbNumProcs)).EndInit();
    IL_04ed:  ldarg.0
    IL_04ee:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::tbNumProcs
    IL_04f3:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_04f8:  nop
//000132:             this.ResumeLayout(false);
    IL_04f9:  ldarg.0
    IL_04fa:  ldc.i4.0
    IL_04fb:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0500:  nop
//000133:             this.PerformLayout();
    IL_0501:  ldarg.0
    IL_0502:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_0507:  nop
//000134: 
//000135:         }
    IL_0508:  ret
  } // end of method MainForm::InitializeComponent

  .method private hidebysig instance void 
          '<btnStartStop_Click>b__0'(class [mscorlib]System.Threading.Tasks.Task A_1) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       75 (0x4b)
    .maxstack  2
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\MainForm.cs' 
//000053:                 {
    IL_0000:  nop
//000054:                     chkParallel.Enabled = true;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_0007:  ldc.i4.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_000d:  nop
//000055:                     chkShowThreads.Enabled = chkParallel.Checked;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkShowThreads
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.CheckBox Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::chkParallel
    IL_001a:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.CheckBox::get_Checked()
    IL_001f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0024:  nop
//000056:                     btnStartStop.Enabled = true;
    IL_0025:  ldarg.0
    IL_0026:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_002b:  ldc.i4.1
    IL_002c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0031:  nop
//000057:                     btnStartStop.Text = "Start";
    IL_0032:  ldarg.0
    IL_0033:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::btnStartStop
    IL_0038:  ldstr      "Start"
    IL_003d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0042:  nop
//000058:                     _cancellation = null;
    IL_0043:  ldarg.0
    IL_0044:  ldnull
    IL_0045:  stfld      class [mscorlib]System.Threading.CancellationTokenSource Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_cancellation
//000059:                 }, TaskScheduler.FromCurrentSynchronizationContext());
//000060:                 
//000061:                 chkShowThreads.Enabled = false;
//000062:                 chkParallel.Enabled = false;
//000063:                 btnStartStop.Text = "Stop";
//000064:             }
//000065:         }
//000066: 
//000067:         private void ConfigureImage()
//000068:         {
//000069:             // If we need to create a new bitmap, do so
//000070:             if (_bitmap == null || _bitmap.Width != pbRenderedImage.Width || _bitmap.Height != pbRenderedImage.Height)
//000071:             {
//000072:                 // Dispose of the old one if one exists
//000073:                 if (_bitmap != null)
//000074:                 {
//000075:                     pbRenderedImage.Image = null;
//000076:                     _bitmap.Dispose();
//000077:                 }
//000078: 
//000079:                 // We always render a square even if the window isn't square
//000080:                 _width = _height = Math.Min(pbRenderedImage.Width, pbRenderedImage.Height);
//000081: 
//000082:                 // Create a new object pool for the rendering arrays
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_004a:  ret
  } // end of method MainForm::'<btnStartStop_Click>b__0'

  .method private hidebysig instance int32[] 
          '<ConfigureImage>b__2'() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       23 (0x17)
    .maxstack  2
    .locals init ([0] int32[] CS$1$0000)
//000083:                 _freeBuffers = new ObjectPool<int[]>(() => new int[_width * _height]);
    IL_0000:  ldarg.0
    IL_0001:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_width
    IL_0006:  ldarg.0
    IL_0007:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::_height
    IL_000c:  mul
    IL_000d:  newarr     [mscorlib]System.Int32
    IL_0012:  stloc.0
    IL_0013:  br.s       IL_0015

//000084: 
//000085:                 // Create a new Bitmap and set it into the picture box
//000086:                 _bitmap = new Bitmap(_width, _height, PixelFormat.Format32bppRgb);
//000087:                 _rect = new Rectangle(0, 0, _width, _height);
//000088:                 pbRenderedImage.Image = _bitmap;
//000089:             }
//000090:         }
//000091: 
//000092:         private void RenderLoop(object boxedToken)
//000093:         {
//000094:             var cancellationToken = (CancellationToken)boxedToken;
//000095: 
//000096:             // Create a ray tracer, and create a reference to "sphere2" that we are going to bounce
//000097:             var rayTracer = new RayTracer(_width, _height);
//000098:             var scene = rayTracer.DefaultScene;
//000099:             var sphere2 = (Sphere)scene.Things[0]; // The first item is assumed to be our sphere
//000100:             var baseY = sphere2.Radius;
//000101:             sphere2.Center.Y = sphere2.Radius;
//000102: 
//000103:             // Timing determines how fast the ball bounces as well as diagnostics frames/second info
//000104:             var renderingTime = new Stopwatch();
//000105:             var totalTime = Stopwatch.StartNew();
//000106: 
//000107:             // Keep rendering until the rendering task has been canceled
//000108:             while (!cancellationToken.IsCancellationRequested)
//000109:             {
//000110:                 // Get the next buffer
//000111:                 var rgb = _freeBuffers.GetObject();
//000112: 
//000113:                 // Determine the new position of the sphere based on the current time elapsed
//000114:                 double dy2 = 0.8 * Math.Abs(Math.Sin(totalTime.ElapsedMilliseconds * Math.PI / 3000));
//000115:                 sphere2.Center.Y = baseY + dy2;
//000116: 
//000117:                 // Render the scene
//000118:                 renderingTime.Reset();
//000119:                 renderingTime.Start();
//000120:                     ParallelOptions options = new ParallelOptions { MaxDegreeOfParallelism = _degreeOfParallelism, CancellationToken = _cancellation.Token };
//000121:                     if (!_parallel) rayTracer.RenderSequential(scene, rgb);
//000122:                     else if (_showThreads) rayTracer.RenderParallelShowingThreads(scene, rgb, options);
//000123:                     else rayTracer.RenderParallel(scene, rgb, options);
//000124:                 renderingTime.Stop();
//000125: 
//000126:                 // Update the bitmap in the UI thread
//000127:                 //var framesPerSecond = (++frame * 1000.0 / renderingTime.ElapsedMilliseconds);
//000128:                 var framesPerSecond = (1000.0 / renderingTime.ElapsedMilliseconds);
//000129:                 BeginInvoke((Action)delegate
//000130:                 {
//000131:                     // Copy the pixel array into the bitmap
//000132:                     var bmpData = _bitmap.LockBits(_rect, ImageLockMode.WriteOnly, _bitmap.PixelFormat);
//000133:                     Marshal.Copy(rgb, 0, bmpData.Scan0, rgb.Length);
//000134:                     _bitmap.UnlockBits(bmpData);
//000135:                     _freeBuffers.PutObject(rgb);
//000136: 
//000137:                     // Refresh the UI
//000138:                     pbRenderedImage.Invalidate();
//000139:                     Text = "Ray Tracer - FPS: " + framesPerSecond.ToString("F1");
//000140:                 });
//000141:             }
//000142:         }
//000143: 
//000144:         private void chkParallel_CheckedChanged(object sender, EventArgs e)
//000145:         {
//000146:             _parallel = 
//000147:                 lblNumProcs.Enabled = 
//000148:                 tbNumProcs.Enabled = 
//000149:                 chkShowThreads.Enabled = 
//000150:                 chkParallel.Checked;
//000151:         }
//000152: 
//000153:         private void tbNumProcs_ValueChanged(object sender, EventArgs e)
//000154:         {
//000155:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000156:             _degreeOfParallelism = tbNumProcs.Value;
//000157:         }
//000158: 
//000159:         private void MainForm_Load(object sender, EventArgs e)
//000160:         {
//000161:             tbNumProcs.Minimum = 1;
//000162:             tbNumProcs.Maximum = Environment.ProcessorCount;
//000163:             tbNumProcs.Value = tbNumProcs.Maximum;
//000164:             lblNumProcs.Text = tbNumProcs.Value.ToString();
//000165:         }
//000166:     }
//000167: }
    IL_0015:  ldloc.0
    IL_0016:  ret
  } // end of method MainForm::'<ConfigureImage>b__2'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm

.class public sequential ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color
       extends [mscorlib]System.ValueType
{
  .field public float64 R
  .field public float64 G
  .field public float64 B
  .field public static initonly valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Background
  .field public static initonly valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color DefaultColor
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(float64 r,
                               float64 g,
                               float64 b) cil managed
  {
    // Code size       23 (0x17)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Color.cs' 
//000019:         public Color(double r, double g, double b) { R = r; G = g; B = b; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  ldarg.0
    IL_0009:  ldarg.2
    IL_000a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_000f:  ldarg.0
    IL_0010:  ldarg.3
    IL_0011:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0016:  ret
  } // end of method Color::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(string str) cil managed
  {
    // Code size       80 (0x50)
    .maxstack  4
    .locals init ([0] string[] nums,
             [1] char[] CS$0$0000,
             [2] bool CS$4$0001)
//000020:         public Color(string str)
//000021:         {
    IL_0000:  nop
//000022:             string[] nums = str.Split(',');
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.1
    IL_0003:  newarr     [mscorlib]System.Char
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldc.i4.0
    IL_000b:  ldc.i4.s   44
    IL_000d:  stelem.i2
    IL_000e:  ldloc.1
    IL_000f:  callvirt   instance string[] [mscorlib]System.String::Split(char[])
    IL_0014:  stloc.0
//000023:             if (nums.Length != 3) throw new ArgumentException();
    IL_0015:  ldloc.0
    IL_0016:  ldlen
    IL_0017:  conv.i4
    IL_0018:  ldc.i4.3
    IL_0019:  ceq
    IL_001b:  stloc.2
//000024:             R = double.Parse(nums[0]);
//000025:             G = double.Parse(nums[1]);
//000026:             B = double.Parse(nums[2]);
//000027:         }
//000028: 
//000029: 
//000030:         public static Color Times(double n, Color v)
//000031:         {
//000032:             return new Color(n * v.R, n * v.G, n * v.B);
//000033:         }
//000034:         public static Color Times(Color v1, Color v2)
//000035:         {
//000036:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
//000037:         }
//000038: 
//000039:         public static Color Plus(Color v1, Color v2)
//000040:         {
//000041:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
//000042:         }
//000043:         public static Color Minus(Color v1, Color v2)
//000044:         {
//000045:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
//000046:         }
//000047: 
//000048:         public static readonly Color Background = new Color(0, 0, 0);
//000049:         public static readonly Color DefaultColor = new Color(0, 0, 0);
//000050: 
//000051:         public static double Legalize(double d)
//000052:         {
//000053:             return d > 1 ? 1 : d;
//000054:         }
//000055: 
//000056:         public static byte ToByte(double c)
//000057:         {
//000058:             return (byte)(255 * Legalize(c));
//000059:         }
//000060: 
//000061:         public static Int32 ToInt32(double c)
//000062:         {
//000063:             Int32 r = (Int32)(255 * c);
//000064:             return (r > 255 ? 255 : r);
//000065:         }
//000066: 
//000067:         public Int32 ToInt32()
//000068:         {
//000069:             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
//000070:         }
//000071: 
//000072:         internal System.Drawing.Color ToDrawingColor()
//000073:         {
//000074:             return System.Drawing.Color.FromArgb(ToInt32());
//000075:         }
//000076: 
//000077:         public void ChangeHue(double hue)
//000078:         {
//000079:             double H, S, L;
//000080: 
//000081:             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
//000082:             S = c.GetSaturation();
//000083:             L = c.GetBrightness();
//000084:             H = c.GetHue();
//000085: 
//000086:             H = hue;
//000087:             S = 0.9;
//000088:             L = ((L - 0.5) * 0.5) + 0.5;
//000089: 
//000090:             if (L == 0)
//000091:             {
//000092:                 R = G = B = 0;
//000093:             }
//000094:             else
//000095:             {
//000096:                 if (S == 0)
//000097:                 {
//000098:                     R = G = B = L;
//000099:                 }
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_001c:  ldloc.2
    IL_001d:  brtrue.s   IL_0025

//000023:             if (nums.Length != 3) throw new ArgumentException();
    IL_001f:  newobj     instance void [mscorlib]System.ArgumentException::.ctor()
    IL_0024:  throw

//000024:             R = double.Parse(nums[0]);
    IL_0025:  ldarg.0
    IL_0026:  ldloc.0
    IL_0027:  ldc.i4.0
    IL_0028:  ldelem.ref
    IL_0029:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_002e:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
//000025:             G = double.Parse(nums[1]);
    IL_0033:  ldarg.0
    IL_0034:  ldloc.0
    IL_0035:  ldc.i4.1
    IL_0036:  ldelem.ref
    IL_0037:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_003c:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
//000026:             B = double.Parse(nums[2]);
    IL_0041:  ldarg.0
    IL_0042:  ldloc.0
    IL_0043:  ldc.i4.2
    IL_0044:  ldelem.ref
    IL_0045:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_004a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
//000027:         }
    IL_004f:  ret
  } // end of method Color::.ctor

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Times(float64 n,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v) cil managed
  {
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000028: 
//000029: 
//000030:         public static Color Times(double n, Color v)
//000031:         {
    IL_0000:  nop
//000032:             return new Color(n * v.R, n * v.G, n * v.B);
    IL_0001:  ldarg.0
    IL_0002:  ldarga.s   v
    IL_0004:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0009:  mul
    IL_000a:  ldarg.0
    IL_000b:  ldarga.s   v
    IL_000d:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0012:  mul
    IL_0013:  ldarg.0
    IL_0014:  ldarga.s   v
    IL_0016:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_001b:  mul
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000033:         }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Color::Times

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Times(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000034:         public static Color Times(Color v1, Color v2)
//000035:         {
    IL_0000:  nop
//000036:             return new Color(v1.R * v2.R, v1.G * v2.G, v1.B * v2.B);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000f:  mul
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001e:  mul
    IL_001f:  ldarga.s   v1
    IL_0021:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0026:  ldarga.s   v2
    IL_0028:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_002d:  mul
    IL_002e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0033:  stloc.0
    IL_0034:  br.s       IL_0036

//000037:         }
    IL_0036:  ldloc.0
    IL_0037:  ret
  } // end of method Color::Times

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000038: 
//000039:         public static Color Plus(Color v1, Color v2)
//000040:         {
    IL_0000:  nop
//000041:             return new Color(v1.R + v2.R, v1.G + v2.G, v1.B + v2.B);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000f:  add
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001e:  add
    IL_001f:  ldarga.s   v1
    IL_0021:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0026:  ldarga.s   v2
    IL_0028:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_002d:  add
    IL_002e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0033:  stloc.0
    IL_0034:  br.s       IL_0036

//000042:         }
    IL_0036:  ldloc.0
    IL_0037:  ret
  } // end of method Color::Plus

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v1,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color v2) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000043:         public static Color Minus(Color v1, Color v2)
//000044:         {
    IL_0000:  nop
//000045:             return new Color(v1.R - v2.R, v1.G - v2.G, v1.B - v2.B);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_000f:  sub
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_001e:  sub
    IL_001f:  ldarga.s   v1
    IL_0021:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0026:  ldarga.s   v2
    IL_0028:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_002d:  sub
    IL_002e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0033:  stloc.0
    IL_0034:  br.s       IL_0036

//000046:         }
    IL_0036:  ldloc.0
    IL_0037:  ret
  } // end of method Color::Minus

  .method public hidebysig static float64 
          Legalize(float64 d) cil managed
  {
    // Code size       30 (0x1e)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000047: 
//000048:         public static readonly Color Background = new Color(0, 0, 0);
//000049:         public static readonly Color DefaultColor = new Color(0, 0, 0);
//000050: 
//000051:         public static double Legalize(double d)
//000052:         {
    IL_0000:  nop
//000053:             return d > 1 ? 1 : d;
    IL_0001:  ldarg.0
    IL_0002:  ldc.r8     1.
    IL_000b:  bgt.s      IL_0010

    IL_000d:  ldarg.0
    IL_000e:  br.s       IL_0019

    IL_0010:  ldc.r8     1.
    IL_0019:  stloc.0
    IL_001a:  br.s       IL_001c

//000054:         }
    IL_001c:  ldloc.0
    IL_001d:  ret
  } // end of method Color::Legalize

  .method public hidebysig static uint8  ToByte(float64 c) cil managed
  {
    // Code size       23 (0x17)
    .maxstack  2
    .locals init ([0] uint8 CS$1$0000)
//000055: 
//000056:         public static byte ToByte(double c)
//000057:         {
    IL_0000:  nop
//000058:             return (byte)(255 * Legalize(c));
    IL_0001:  ldc.r8     255.
    IL_000a:  ldarg.0
    IL_000b:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Legalize(float64)
    IL_0010:  mul
    IL_0011:  conv.u1
    IL_0012:  stloc.0
    IL_0013:  br.s       IL_0015

//000059:         }
    IL_0015:  ldloc.0
    IL_0016:  ret
  } // end of method Color::ToByte

  .method public hidebysig static int32  ToInt32(float64 c) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  2
    .locals init ([0] int32 r,
             [1] int32 CS$1$0000)
//000060: 
//000061:         public static Int32 ToInt32(double c)
//000062:         {
    IL_0000:  nop
//000063:             Int32 r = (Int32)(255 * c);
    IL_0001:  ldc.r8     255.
    IL_000a:  ldarg.0
    IL_000b:  mul
    IL_000c:  conv.i4
    IL_000d:  stloc.0
//000064:             return (r > 255 ? 255 : r);
    IL_000e:  ldloc.0
    IL_000f:  ldc.i4     0xff
    IL_0014:  bgt.s      IL_0019

    IL_0016:  ldloc.0
    IL_0017:  br.s       IL_001e

    IL_0019:  ldc.i4     0xff
    IL_001e:  stloc.1
    IL_001f:  br.s       IL_0021

//000065:         }
    IL_0021:  ldloc.1
    IL_0022:  ret
  } // end of method Color::ToInt32

  .method public hidebysig instance int32 
          ToInt32() cil managed
  {
    // Code size       52 (0x34)
    .maxstack  3
    .locals init ([0] int32 CS$1$0000)
//000066: 
//000067:         public Int32 ToInt32()
//000068:         {
    IL_0000:  nop
//000069:             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_0007:  call       int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32(float64)
    IL_000c:  ldarg.0
    IL_000d:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0012:  call       int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32(float64)
    IL_0017:  ldc.i4.8
    IL_0018:  shl
    IL_0019:  or
    IL_001a:  ldarg.0
    IL_001b:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
    IL_0020:  call       int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32(float64)
    IL_0025:  ldc.i4.s   16
    IL_0027:  shl
    IL_0028:  or
    IL_0029:  ldc.i4     0xff000000
    IL_002e:  or
    IL_002f:  stloc.0
    IL_0030:  br.s       IL_0032

//000070:         }
    IL_0032:  ldloc.0
    IL_0033:  ret
  } // end of method Color::ToInt32

  .method assembly hidebysig instance valuetype [System.Drawing]System.Drawing.Color 
          ToDrawingColor() cil managed
  {
    // Code size       17 (0x11)
    .maxstack  1
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Color CS$1$0000)
//000071: 
//000072:         internal System.Drawing.Color ToDrawingColor()
//000073:         {
    IL_0000:  nop
//000074:             return System.Drawing.Color.FromArgb(ToInt32());
    IL_0001:  ldarg.0
    IL_0002:  call       instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
    IL_0007:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32)
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000075:         }
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method Color::ToDrawingColor

  .method public hidebysig instance void 
          ChangeHue(float64 hue) cil managed
  {
    // Code size       685 (0x2ad)
    .maxstack  7
    .locals init ([0] float64 H,
             [1] float64 S,
             [2] float64 L,
             [3] valuetype [System.Drawing]System.Drawing.Color c,
             [4] float64 temp2,
             [5] float64 temp1,
             [6] float64[] t3,
             [7] float64[] clr,
             [8] int32 i,
             [9] bool CS$4$0000,
             [10] float64 CS$0$0001,
             [11] float64[] CS$0$0002)
//000076: 
//000077:         public void ChangeHue(double hue)
//000078:         {
    IL_0000:  nop
//000079:             double H, S, L;
//000080: 
//000081:             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
    IL_0001:  ldarg.0
    IL_0002:  call       instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
    IL_0007:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32)
    IL_000c:  stloc.3
//000082:             S = c.GetSaturation();
    IL_000d:  ldloca.s   c
    IL_000f:  call       instance float32 [System.Drawing]System.Drawing.Color::GetSaturation()
    IL_0014:  conv.r8
    IL_0015:  stloc.1
//000083:             L = c.GetBrightness();
    IL_0016:  ldloca.s   c
    IL_0018:  call       instance float32 [System.Drawing]System.Drawing.Color::GetBrightness()
    IL_001d:  conv.r8
    IL_001e:  stloc.2
//000084:             H = c.GetHue();
    IL_001f:  ldloca.s   c
    IL_0021:  call       instance float32 [System.Drawing]System.Drawing.Color::GetHue()
    IL_0026:  conv.r8
    IL_0027:  stloc.0
//000085: 
//000086:             H = hue;
    IL_0028:  ldarg.1
    IL_0029:  stloc.0
//000087:             S = 0.9;
    IL_002a:  ldc.r8     0.90000000000000002
    IL_0033:  stloc.1
//000088:             L = ((L - 0.5) * 0.5) + 0.5;
    IL_0034:  ldloc.2
    IL_0035:  ldc.r8     0.5
    IL_003e:  sub
    IL_003f:  ldc.r8     0.5
    IL_0048:  mul
    IL_0049:  ldc.r8     0.5
    IL_0052:  add
    IL_0053:  stloc.2
//000089: 
//000090:             if (L == 0)
    IL_0054:  ldloc.2
    IL_0055:  ldc.r8     0.0
    IL_005e:  ceq
    IL_0060:  ldc.i4.0
    IL_0061:  ceq
    IL_0063:  stloc.s    CS$4$0000
//000091:             {
//000092:                 R = G = B = 0;
//000093:             }
//000094:             else
//000095:             {
//000096:                 if (S == 0)
//000097:                 {
//000098:                     R = G = B = L;
//000099:                 }
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0065:  ldloc.s    CS$4$0000
    IL_0067:  brtrue.s   IL_0095

//000091:             {
    IL_0069:  nop
//000092:                 R = G = B = 0;
    IL_006a:  ldarg.0
    IL_006b:  ldarg.0
    IL_006c:  ldarg.0
    IL_006d:  ldc.r8     0.0
    IL_0076:  dup
    IL_0077:  stloc.s    CS$0$0001
    IL_0079:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_007e:  ldloc.s    CS$0$0001
    IL_0080:  dup
    IL_0081:  stloc.s    CS$0$0001
    IL_0083:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_0088:  ldloc.s    CS$0$0001
    IL_008a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
//000093:             }
    IL_008f:  nop
//000094:             else
//000095:             {
//000096:                 if (S == 0)
//000097:                 {
//000098:                     R = G = B = L;
//000099:                 }
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0090:  br         IL_02ac

//000095:             {
    IL_0095:  nop
//000096:                 if (S == 0)
    IL_0096:  ldloc.1
    IL_0097:  ldc.r8     0.0
    IL_00a0:  ceq
    IL_00a2:  ldc.i4.0
    IL_00a3:  ceq
    IL_00a5:  stloc.s    CS$4$0000
//000097:                 {
//000098:                     R = G = B = L;
//000099:                 }
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_00a7:  ldloc.s    CS$4$0000
    IL_00a9:  brtrue.s   IL_00cf

//000097:                 {
    IL_00ab:  nop
//000098:                     R = G = B = L;
    IL_00ac:  ldarg.0
    IL_00ad:  ldarg.0
    IL_00ae:  ldarg.0
    IL_00af:  ldloc.2
    IL_00b0:  dup
    IL_00b1:  stloc.s    CS$0$0001
    IL_00b3:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
    IL_00b8:  ldloc.s    CS$0$0001
    IL_00ba:  dup
    IL_00bb:  stloc.s    CS$0$0001
    IL_00bd:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
    IL_00c2:  ldloc.s    CS$0$0001
    IL_00c4:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
//000099:                 }
    IL_00c9:  nop
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_00ca:  br         IL_02ab

//000101:                 {
    IL_00cf:  nop
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
    IL_00d0:  ldloc.2
    IL_00d1:  ldc.r8     0.5
    IL_00da:  ble.s      IL_00e5

    IL_00dc:  ldloc.2
    IL_00dd:  ldloc.1
    IL_00de:  add
    IL_00df:  ldloc.2
    IL_00e0:  ldloc.1
    IL_00e1:  mul
    IL_00e2:  sub
    IL_00e3:  br.s       IL_00f2

    IL_00e5:  ldloc.2
    IL_00e6:  ldc.r8     1.
    IL_00ef:  ldloc.1
    IL_00f0:  add
    IL_00f1:  mul
    IL_00f2:  stloc.s    temp2
//000103:                     double temp1 = 2.0 * L - temp2;
    IL_00f4:  ldc.r8     2.
    IL_00fd:  ldloc.2
    IL_00fe:  mul
    IL_00ff:  ldloc.s    temp2
    IL_0101:  sub
    IL_0102:  stloc.s    temp1
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
    IL_0104:  ldc.i4.3
    IL_0105:  newarr     [mscorlib]System.Double
    IL_010a:  stloc.s    CS$0$0002
    IL_010c:  ldloc.s    CS$0$0002
    IL_010e:  ldc.i4.0
    IL_010f:  ldloc.0
    IL_0110:  ldc.r8     0.33333333333333331
    IL_0119:  add
    IL_011a:  stelem.r8
    IL_011b:  ldloc.s    CS$0$0002
    IL_011d:  ldc.i4.1
    IL_011e:  ldloc.0
    IL_011f:  stelem.r8
    IL_0120:  ldloc.s    CS$0$0002
    IL_0122:  ldc.i4.2
    IL_0123:  ldloc.0
    IL_0124:  ldc.r8     0.33333333333333331
    IL_012d:  sub
    IL_012e:  stelem.r8
    IL_012f:  ldloc.s    CS$0$0002
    IL_0131:  stloc.s    t3
//000106:                     double[] clr = new double[] { 0, 0, 0 };
    IL_0133:  ldc.i4.3
    IL_0134:  newarr     [mscorlib]System.Double
    IL_0139:  stloc.s    CS$0$0002
    IL_013b:  ldloc.s    CS$0$0002
    IL_013d:  stloc.s    clr
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
    IL_013f:  ldc.i4.0
    IL_0140:  stloc.s    i
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0142:  br         IL_027e

//000109:                     {
    IL_0147:  nop
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
    IL_0148:  ldloc.s    t3
    IL_014a:  ldloc.s    i
    IL_014c:  ldelem.r8
    IL_014d:  ldc.r8     0.0
    IL_0156:  clt
    IL_0158:  ldc.i4.0
    IL_0159:  ceq
    IL_015b:  stloc.s    CS$4$0000
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_015d:  ldloc.s    CS$4$0000
    IL_015f:  brtrue.s   IL_017f

//000111:                         if (t3[i] < 0) t3[i] += 1.0;
    IL_0161:  ldloc.s    t3
    IL_0163:  ldloc.s    i
    IL_0165:  ldelema    [mscorlib]System.Double
    IL_016a:  dup
    IL_016b:  ldobj      [mscorlib]System.Double
    IL_0170:  ldc.r8     1.
    IL_0179:  add
    IL_017a:  stobj      [mscorlib]System.Double
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
    IL_017f:  ldloc.s    t3
    IL_0181:  ldloc.s    i
    IL_0183:  ldelem.r8
    IL_0184:  ldc.r8     1.
    IL_018d:  cgt
    IL_018f:  ldc.i4.0
    IL_0190:  ceq
    IL_0192:  stloc.s    CS$4$0000
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0194:  ldloc.s    CS$4$0000
    IL_0196:  brtrue.s   IL_01b6

//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
    IL_0198:  ldloc.s    t3
    IL_019a:  ldloc.s    i
    IL_019c:  ldelema    [mscorlib]System.Double
    IL_01a1:  dup
    IL_01a2:  ldobj      [mscorlib]System.Double
    IL_01a7:  ldc.r8     1.
    IL_01b0:  sub
    IL_01b1:  stobj      [mscorlib]System.Double
//000113:                         if (6.0 * t3[i] < 1.0)
    IL_01b6:  ldc.r8     6.
    IL_01bf:  ldloc.s    t3
    IL_01c1:  ldloc.s    i
    IL_01c3:  ldelem.r8
    IL_01c4:  mul
    IL_01c5:  ldc.r8     1.
    IL_01ce:  clt
    IL_01d0:  ldc.i4.0
    IL_01d1:  ceq
    IL_01d3:  stloc.s    CS$4$0000
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_01d5:  ldloc.s    CS$4$0000
    IL_01d7:  brtrue.s   IL_01f8

//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
    IL_01d9:  ldloc.s    clr
    IL_01db:  ldloc.s    i
    IL_01dd:  ldloc.s    temp1
    IL_01df:  ldloc.s    temp2
    IL_01e1:  ldloc.s    temp1
    IL_01e3:  sub
    IL_01e4:  ldloc.s    t3
    IL_01e6:  ldloc.s    i
    IL_01e8:  ldelem.r8
    IL_01e9:  mul
    IL_01ea:  ldc.r8     6.
    IL_01f3:  mul
    IL_01f4:  add
    IL_01f5:  stelem.r8
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_01f6:  br.s       IL_0277

//000115:                         else if (2.0 * t3[i] < 1.0)
    IL_01f8:  ldc.r8     2.
    IL_0201:  ldloc.s    t3
    IL_0203:  ldloc.s    i
    IL_0205:  ldelem.r8
    IL_0206:  mul
    IL_0207:  ldc.r8     1.
    IL_0210:  clt
    IL_0212:  ldc.i4.0
    IL_0213:  ceq
    IL_0215:  stloc.s    CS$4$0000
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0217:  ldloc.s    CS$4$0000
    IL_0219:  brtrue.s   IL_0224

//000116:                             clr[i] = temp2;
    IL_021b:  ldloc.s    clr
    IL_021d:  ldloc.s    i
    IL_021f:  ldloc.s    temp2
    IL_0221:  stelem.r8
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0222:  br.s       IL_0277

//000117:                         else if (3.0 * t3[i] < 2.0)
    IL_0224:  ldc.r8     3.
    IL_022d:  ldloc.s    t3
    IL_022f:  ldloc.s    i
    IL_0231:  ldelem.r8
    IL_0232:  mul
    IL_0233:  ldc.r8     2.
    IL_023c:  clt
    IL_023e:  ldc.i4.0
    IL_023f:  ceq
    IL_0241:  stloc.s    CS$4$0000
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0243:  ldloc.s    CS$4$0000
    IL_0245:  brtrue.s   IL_0270

//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
    IL_0247:  ldloc.s    clr
    IL_0249:  ldloc.s    i
    IL_024b:  ldloc.s    temp1
    IL_024d:  ldloc.s    temp2
    IL_024f:  ldloc.s    temp1
    IL_0251:  sub
    IL_0252:  ldc.r8     0.66666666666666663
    IL_025b:  ldloc.s    t3
    IL_025d:  ldloc.s    i
    IL_025f:  ldelem.r8
    IL_0260:  sub
    IL_0261:  mul
    IL_0262:  ldc.r8     6.
    IL_026b:  mul
    IL_026c:  add
    IL_026d:  stelem.r8
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_026e:  br.s       IL_0277

//000120:                             clr[i] = temp1;
    IL_0270:  ldloc.s    clr
    IL_0272:  ldloc.s    i
    IL_0274:  ldloc.s    temp1
    IL_0276:  stelem.r8
//000121:                     }
    IL_0277:  nop
//000108:                     for (int i = 0; i < 3; i++)
    IL_0278:  ldloc.s    i
    IL_027a:  ldc.i4.1
    IL_027b:  add
    IL_027c:  stloc.s    i
    IL_027e:  ldloc.s    i
    IL_0280:  ldc.i4.3
    IL_0281:  clt
    IL_0283:  stloc.s    CS$4$0000
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_0285:  ldloc.s    CS$4$0000
    IL_0287:  brtrue     IL_0147

//000123:                     R = clr[0];
    IL_028c:  ldarg.0
    IL_028d:  ldloc.s    clr
    IL_028f:  ldc.i4.0
    IL_0290:  ldelem.r8
    IL_0291:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::R
//000124:                     G = clr[1];
    IL_0296:  ldarg.0
    IL_0297:  ldloc.s    clr
    IL_0299:  ldc.i4.1
    IL_029a:  ldelem.r8
    IL_029b:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::G
//000125:                     B = clr[2];
    IL_02a0:  ldarg.0
    IL_02a1:  ldloc.s    clr
    IL_02a3:  ldc.i4.2
    IL_02a4:  ldelem.r8
    IL_02a5:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::B
//000126:                 }
    IL_02aa:  nop
//000127:             }
    IL_02ab:  nop
//000128:         }
    IL_02ac:  ret
  } // end of method Color::ChangeHue

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       75 (0x4b)
    .maxstack  4
//000048:         public static readonly Color Background = new Color(0, 0, 0);
    IL_0000:  ldc.r8     0.0
    IL_0009:  ldc.r8     0.0
    IL_0012:  ldc.r8     0.0
    IL_001b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0020:  stsfld     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Background
//000049:         public static readonly Color DefaultColor = new Color(0, 0, 0);
    IL_0025:  ldc.r8     0.0
    IL_002e:  ldc.r8     0.0
    IL_0037:  ldc.r8     0.0
    IL_0040:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0045:  stsfld     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::DefaultColor
//000050: 
//000051:         public static double Legalize(double d)
//000052:         {
//000053:             return d > 1 ? 1 : d;
//000054:         }
//000055: 
//000056:         public static byte ToByte(double c)
//000057:         {
//000058:             return (byte)(255 * Legalize(c));
//000059:         }
//000060: 
//000061:         public static Int32 ToInt32(double c)
//000062:         {
//000063:             Int32 r = (Int32)(255 * c);
//000064:             return (r > 255 ? 255 : r);
//000065:         }
//000066: 
//000067:         public Int32 ToInt32()
//000068:         {
//000069:             return (ToInt32(B) | ToInt32(G) << 8 | ToInt32(R) << 16 | 255 << 24);
//000070:         }
//000071: 
//000072:         internal System.Drawing.Color ToDrawingColor()
//000073:         {
//000074:             return System.Drawing.Color.FromArgb(ToInt32());
//000075:         }
//000076: 
//000077:         public void ChangeHue(double hue)
//000078:         {
//000079:             double H, S, L;
//000080: 
//000081:             System.Drawing.Color c = System.Drawing.Color.FromArgb(ToInt32());
//000082:             S = c.GetSaturation();
//000083:             L = c.GetBrightness();
//000084:             H = c.GetHue();
//000085: 
//000086:             H = hue;
//000087:             S = 0.9;
//000088:             L = ((L - 0.5) * 0.5) + 0.5;
//000089: 
//000090:             if (L == 0)
//000091:             {
//000092:                 R = G = B = 0;
//000093:             }
//000094:             else
//000095:             {
//000096:                 if (S == 0)
//000097:                 {
//000098:                     R = G = B = L;
//000099:                 }
//000100:                 else
//000101:                 {
//000102:                     double temp2 = ((L <= 0.5) ? L * (1.0 + S) : L + S - (L * S));
//000103:                     double temp1 = 2.0 * L - temp2;
//000104: 
//000105:                     double[] t3 = new double[] { H + 1.0 / 3.0, H, H - 1.0 / 3.0 };
//000106:                     double[] clr = new double[] { 0, 0, 0 };
//000107: 
//000108:                     for (int i = 0; i < 3; i++)
//000109:                     {
//000110: 
//000111:                         if (t3[i] < 0) t3[i] += 1.0;
//000112:                         if (t3[i] > 1) t3[i] -= 1.0;
//000113:                         if (6.0 * t3[i] < 1.0)
//000114:                             clr[i] = temp1 + (temp2 - temp1) * t3[i] * 6.0;
//000115:                         else if (2.0 * t3[i] < 1.0)
//000116:                             clr[i] = temp2;
//000117:                         else if (3.0 * t3[i] < 2.0)
//000118:                             clr[i] = (temp1 + (temp2 - temp1) * ((2.0 / 3.0) - t3[i]) * 6.0);
//000119:                         else
//000120:                             clr[i] = temp1;
//000121:                     }
//000122: 
//000123:                     R = clr[0];
//000124:                     G = clr[1];
//000125:                     B = clr[2];
//000126:                 }
//000127:             }
//000128:         }
//000129:     }
//000130: }
    IL_004a:  ret
  } // end of method Color::.cctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface
       extends [mscorlib]System.Object
{
  .field public class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Diffuse
  .field public class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Specular
  .field public class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Reflect
  .field public float64 Roughness
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Diffuse,
                               class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Specular,
                               class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Reflect,
                               float64 Roughness) cil managed
  {
    // Code size       39 (0x27)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surface.cs' 
//000020:         public Surface(Func<Vector, Color> Diffuse,
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000021:                         Func<Vector, Color> Specular,
//000022:                         Func<Vector, double> Reflect,
//000023:                         double Roughness)
//000024:         {
    IL_0007:  nop
//000025:             this.Diffuse = Diffuse;
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
//000026:             this.Specular = Specular;
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
//000027:             this.Reflect = Reflect;
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
//000028:             this.Roughness = Roughness;
    IL_001d:  ldarg.0
    IL_001e:  ldarg.s    Roughness
    IL_0020:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
//000029:         }
    IL_0025:  nop
    IL_0026:  ret
  } // end of method Surface::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
//000045:                 }
//000046:                 return resourceMan;
//000047:             }
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
//000057:                 return resourceCulture;
//000058:             }
//000059:             set {
//000060:                 resourceCulture = value;
//000061:             }
//000062:         }
//000063:     }
//000064: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resourc" +
    IL_0014:  ldstr      "Microsoft.ParallelComputingPlatform.ParallelExtens"
    + "ions.Samples.Properties.Resources"
    IL_0019:  ldtoken    Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                             "es", typeof(Resources).Assembly);
//000044:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
//000045:                 }
    IL_0034:  nop
//000046:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000047:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000048:         }
//000049:         
//000050:         /// <summary>
//000051:         ///   Overrides the current thread's CurrentUICulture property for all
//000052:         ///   resource lookups using this strongly typed resource class.
//000053:         /// </summary>
//000054:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000055:         internal static global::System.Globalization.CultureInfo Culture {
//000056:             get {
    IL_0000:  nop
//000057:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000058:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000059:             set {
    IL_0000:  nop
//000060:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::resourceCulture
//000061:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .set void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
    .get class [mscorlib]System.Globalization.CultureInfo Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources::get_Culture()
  } // end of property Resources::Culture
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Resources

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera
       extends [mscorlib]System.Object
{
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Pos
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Forward
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Up
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Right
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector forward,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector up,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector right) cil managed
  {
    // Code size       39 (0x27)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Camera.cs' 
//000019:         public Camera(Vector pos, Vector forward, Vector up, Vector right) { Pos = pos; Forward = forward; Up = up; Right = right; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Forward
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Up
    IL_001d:  ldarg.0
    IL_001e:  ldarg.s    right
    IL_0020:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Right
    IL_0025:  nop
    IL_0026:  ret
  } // end of method Camera::.ctor

  .method public hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera 
          Create(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                 valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector lookAt) cil managed
  {
    // Code size       119 (0x77)
    .maxstack  5
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector forward,
             [1] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector down,
             [2] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector right,
             [3] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector up,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera CS$1$0000)
//000020: 
//000021:         public static Camera Create(Vector pos, Vector lookAt)
//000022:         {
    IL_0000:  nop
//000023:             Vector forward = Vector.Norm(Vector.Minus(lookAt, pos));
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0008:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_000d:  stloc.0
//000024:             Vector down = new Vector(0, -1, 0);
    IL_000e:  ldloca.s   down
    IL_0010:  ldc.r8     0.0
    IL_0019:  ldc.r8     -1.
    IL_0022:  ldc.r8     0.0
    IL_002b:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0030:  nop
//000025:             Vector right = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, down)));
    IL_0031:  ldc.r8     1.5
    IL_003a:  ldloc.0
    IL_003b:  ldloc.1
    IL_003c:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Cross(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0041:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0046:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_004b:  stloc.2
//000026:             Vector up = Vector.Times(1.5, Vector.Norm(Vector.Cross(forward, right)));
    IL_004c:  ldc.r8     1.5
    IL_0055:  ldloc.0
    IL_0056:  ldloc.2
    IL_0057:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Cross(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005c:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0061:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0066:  stloc.3
//000027: 
//000028:             return new Camera(pos, forward, up, right);
    IL_0067:  ldarg.0
    IL_0068:  ldloc.0
    IL_0069:  ldloc.3
    IL_006a:  ldloc.2
    IL_006b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0070:  stloc.s    CS$1$0000
    IL_0072:  br.s       IL_0074

//000029:         }
    IL_0074:  ldloc.s    CS$1$0000
    IL_0076:  ret
  } // end of method Camera::Create

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera

.class private sequential ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector
       extends [mscorlib]System.ValueType
{
  .field public float64 X
  .field public float64 Y
  .field public float64 Z
  .field public static initonly valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Null
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(float64 x,
                               float64 y,
                               float64 z) cil managed
  {
    // Code size       23 (0x17)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Vector.cs' 
//000019:         public Vector(double x, double y, double z) { X = x; Y = y; Z = z; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarg.0
    IL_0009:  ldarg.2
    IL_000a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_000f:  ldarg.0
    IL_0010:  ldarg.3
    IL_0011:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0016:  ret
  } // end of method Vector::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(string str) cil managed
  {
    // Code size       80 (0x50)
    .maxstack  4
    .locals init ([0] string[] nums,
             [1] char[] CS$0$0000,
             [2] bool CS$4$0001)
//000020:         public Vector(string str)
//000021:         {
    IL_0000:  nop
//000022:             string[] nums = str.Split(',');
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.1
    IL_0003:  newarr     [mscorlib]System.Char
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldc.i4.0
    IL_000b:  ldc.i4.s   44
    IL_000d:  stelem.i2
    IL_000e:  ldloc.1
    IL_000f:  callvirt   instance string[] [mscorlib]System.String::Split(char[])
    IL_0014:  stloc.0
//000023:             if (nums.Length != 3) throw new ArgumentException();
    IL_0015:  ldloc.0
    IL_0016:  ldlen
    IL_0017:  conv.i4
    IL_0018:  ldc.i4.3
    IL_0019:  ceq
    IL_001b:  stloc.2
//000024:             X = double.Parse(nums[0]);
//000025:             Y = double.Parse(nums[1]);
//000026:             Z = double.Parse(nums[2]);
//000027:         }
//000028:         public static Vector Times(double n, Vector v)
//000029:         {
//000030:             return new Vector(v.X * n, v.Y * n, v.Z * n);
//000031:         }
//000032:         public static Vector Minus(Vector v1, Vector v2)
//000033:         {
//000034:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
//000035:         }
//000036:         public static Vector Plus(Vector v1, Vector v2)
//000037:         {
//000038:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
//000039:         }
//000040:         public static double Dot(Vector v1, Vector v2)
//000041:         {
//000042:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
//000043:         }
//000044:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
//000045:         public static Vector Norm(Vector v)
//000046:         {
//000047:             double mag = Mag(v);
//000048:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
//000049:             return Times(div, v);
//000050:         }
//000051:         public static Vector Cross(Vector v1, Vector v2)
//000052:         {
//000053:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
//000054:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000055:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000056:         }
//000057:         public static bool Equals(Vector v1, Vector v2)
//000058:         {
//000059:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
//000060:         }
//000061: 
//000062:         public readonly static Vector Null = new Vector(0, 0, 0);
//000063:     }
//000064: }
    IL_001c:  ldloc.2
    IL_001d:  brtrue.s   IL_0025

//000023:             if (nums.Length != 3) throw new ArgumentException();
    IL_001f:  newobj     instance void [mscorlib]System.ArgumentException::.ctor()
    IL_0024:  throw

//000024:             X = double.Parse(nums[0]);
    IL_0025:  ldarg.0
    IL_0026:  ldloc.0
    IL_0027:  ldc.i4.0
    IL_0028:  ldelem.ref
    IL_0029:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_002e:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
//000025:             Y = double.Parse(nums[1]);
    IL_0033:  ldarg.0
    IL_0034:  ldloc.0
    IL_0035:  ldc.i4.1
    IL_0036:  ldelem.ref
    IL_0037:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_003c:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
//000026:             Z = double.Parse(nums[2]);
    IL_0041:  ldarg.0
    IL_0042:  ldloc.0
    IL_0043:  ldc.i4.2
    IL_0044:  ldelem.ref
    IL_0045:  call       float64 [mscorlib]System.Double::Parse(string)
    IL_004a:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
//000027:         }
    IL_004f:  ret
  } // end of method Vector::.ctor

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Times(float64 n,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000028:         public static Vector Times(double n, Vector v)
//000029:         {
    IL_0000:  nop
//000030:             return new Vector(v.X * n, v.Y * n, v.Z * n);
    IL_0001:  ldarga.s   v
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarg.0
    IL_0009:  mul
    IL_000a:  ldarga.s   v
    IL_000c:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0011:  ldarg.0
    IL_0012:  mul
    IL_0013:  ldarga.s   v
    IL_0015:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_001a:  ldarg.0
    IL_001b:  mul
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000031:         }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Vector::Times

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000032:         public static Vector Minus(Vector v1, Vector v2)
//000033:         {
    IL_0000:  nop
//000034:             return new Vector(v1.X - v2.X, v1.Y - v2.Y, v1.Z - v2.Z);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000f:  sub
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001e:  sub
    IL_001f:  ldarga.s   v1
    IL_0021:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0026:  ldarga.s   v2
    IL_0028:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_002d:  sub
    IL_002e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0033:  stloc.0
    IL_0034:  br.s       IL_0036

//000035:         }
    IL_0036:  ldloc.0
    IL_0037:  ret
  } // end of method Vector::Minus

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000036:         public static Vector Plus(Vector v1, Vector v2)
//000037:         {
    IL_0000:  nop
//000038:             return new Vector(v1.X + v2.X, v1.Y + v2.Y, v1.Z + v2.Z);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000f:  add
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001e:  add
    IL_001f:  ldarga.s   v1
    IL_0021:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0026:  ldarga.s   v2
    IL_0028:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_002d:  add
    IL_002e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0033:  stloc.0
    IL_0034:  br.s       IL_0036

//000039:         }
    IL_0036:  ldloc.0
    IL_0037:  ret
  } // end of method Vector::Plus

  .method public hidebysig static float64 
          Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
              valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       53 (0x35)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000040:         public static double Dot(Vector v1, Vector v2)
//000041:         {
    IL_0000:  nop
//000042:             return (v1.X * v2.X) + (v1.Y * v2.Y) + (v1.Z * v2.Z);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000f:  mul
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001e:  mul
    IL_001f:  add
    IL_0020:  ldarga.s   v1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0027:  ldarga.s   v2
    IL_0029:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_002e:  mul
    IL_002f:  add
    IL_0030:  stloc.0
    IL_0031:  br.s       IL_0033

//000043:         }
    IL_0033:  ldloc.0
    IL_0034:  ret
  } // end of method Vector::Dot

  .method public hidebysig static float64 
          Mag(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       18 (0x12)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000044:         public static double Mag(Vector v) { return Math.Sqrt(Dot(v, v)); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0008:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_000d:  stloc.0
    IL_000e:  br.s       IL_0010

    IL_0010:  ldloc.0
    IL_0011:  ret
  } // end of method Vector::Mag

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v) cil managed
  {
    // Code size       55 (0x37)
    .maxstack  2
    .locals init ([0] float64 mag,
             [1] float64 'div',
             [2] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000045:         public static Vector Norm(Vector v)
//000046:         {
    IL_0000:  nop
//000047:             double mag = Mag(v);
    IL_0001:  ldarg.0
    IL_0002:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Mag(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0007:  stloc.0
//000048:             double div = mag == 0 ? double.PositiveInfinity : 1 / mag;
    IL_0008:  ldloc.0
    IL_0009:  ldc.r8     0.0
    IL_0012:  beq.s      IL_0021

    IL_0014:  ldc.r8     1.
    IL_001d:  ldloc.0
    IL_001e:  div
    IL_001f:  br.s       IL_002a

    IL_0021:  ldc.r8     (00 00 00 00 00 00 F0 7F)
    IL_002a:  stloc.1
//000049:             return Times(div, v);
    IL_002b:  ldloc.1
    IL_002c:  ldarg.0
    IL_002d:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0032:  stloc.2
    IL_0033:  br.s       IL_0035

//000050:         }
    IL_0035:  ldloc.2
    IL_0036:  ret
  } // end of method Vector::Norm

  .method public hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Cross(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       104 (0x68)
    .maxstack  5
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000051:         public static Vector Cross(Vector v1, Vector v2)
//000052:         {
    IL_0000:  nop
//000053:             return new Vector(((v1.Y * v2.Z) - (v1.Z * v2.Y)),
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_000f:  mul
    IL_0010:  ldarga.s   v1
    IL_0012:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0017:  ldarga.s   v2
    IL_0019:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001e:  mul
    IL_001f:  sub
    IL_0020:  ldarga.s   v1
    IL_0022:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0027:  ldarga.s   v2
    IL_0029:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_002e:  mul
    IL_002f:  ldarga.s   v1
    IL_0031:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0036:  ldarga.s   v2
    IL_0038:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_003d:  mul
    IL_003e:  sub
    IL_003f:  ldarga.s   v1
    IL_0041:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0046:  ldarga.s   v2
    IL_0048:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_004d:  mul
    IL_004e:  ldarga.s   v1
    IL_0050:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0055:  ldarga.s   v2
    IL_0057:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_005c:  mul
    IL_005d:  sub
    IL_005e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0063:  stloc.0
    IL_0064:  br.s       IL_0066

//000054:                               ((v1.Z * v2.X) - (v1.X * v2.Z)),
//000055:                               ((v1.X * v2.Y) - (v1.Y * v2.X)));
//000056:         }
    IL_0066:  ldloc.0
    IL_0067:  ret
  } // end of method Vector::Cross

  .method public hidebysig static bool  Equals(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v1,
                                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector v2) cil managed
  {
    // Code size       57 (0x39)
    .maxstack  2
    .locals init ([0] bool CS$1$0000)
//000057:         public static bool Equals(Vector v1, Vector v2)
//000058:         {
    IL_0000:  nop
//000059:             return (v1.X == v2.X) && (v1.Y == v2.Y) && (v1.Z == v2.Z);
    IL_0001:  ldarga.s   v1
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0008:  ldarga.s   v2
    IL_000a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_000f:  bne.un.s   IL_0033

    IL_0011:  ldarga.s   v1
    IL_0013:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_0018:  ldarga.s   v2
    IL_001a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Y
    IL_001f:  bne.un.s   IL_0033

    IL_0021:  ldarga.s   v1
    IL_0023:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0028:  ldarga.s   v2
    IL_002a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_002f:  ceq
    IL_0031:  br.s       IL_0034

    IL_0033:  ldc.i4.0
    IL_0034:  stloc.0
    IL_0035:  br.s       IL_0037

//000060:         }
    IL_0037:  ldloc.0
    IL_0038:  ret
  } // end of method Vector::Equals

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  8
//000061: 
//000062:         public readonly static Vector Null = new Vector(0, 0, 0);
    IL_0000:  ldc.r8     0.0
    IL_0009:  ldc.r8     0.0
    IL_0012:  ldc.r8     0.0
    IL_001b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0020:  stsfld     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Null
//000063:     }
//000064: }
    IL_0025:  ret
  } // end of method Vector::.cctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector

.class private abstract auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Program.cs' 
//000021:         {
    IL_0000:  nop
//000022:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000023:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000024:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000025:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Program

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .field private static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
    IL_000f:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings
          Default()
  {
    .get class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Properties.Settings

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<Intersect>d__0'
         extends [mscorlib]System.Object
         implements class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,
                    [mscorlib]System.Collections.IEnumerable,
                    class [mscorlib]System.Collections.Generic.IEnumerator`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>,
                    [mscorlib]System.Collections.IEnumerator,
                    [mscorlib]System.IDisposable
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field private class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect '<>2__current'
    .field private int32 '<>1__state'
    .field private int32 '<>l__initialThreadId'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene '<>4__this'
    .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray r
    .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray '<>3__r'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject '<obj>5__1'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] '<>7__wrap3'
    .field public int32 '<>7__wrap4'
    .method private hidebysig newslot virtual final 
            instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> 
            'System.Collections.Generic.IEnumerable<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.GetEnumerator'() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override  method instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::GetEnumerator()
      // Code size       86 (0x56)
      .maxstack  2
      .locals init (class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0' V_0,
               class [mscorlib]System.Collections.Generic.IEnumerator`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> V_1,
               bool V_2)
      IL_0000:  call       class [mscorlib]System.Threading.Thread [mscorlib]System.Threading.Thread::get_CurrentThread()
      IL_0005:  callvirt   instance int32 [mscorlib]System.Threading.Thread::get_ManagedThreadId()
      IL_000a:  ldarg.0
      IL_000b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>l__initialThreadId'
      IL_0010:  bne.un.s   IL_0021

      IL_0012:  ldarg.0
      IL_0013:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
      IL_0018:  ldc.i4.s   -2
      IL_001a:  ceq
      IL_001c:  ldc.i4.0
      IL_001d:  ceq
      IL_001f:  br.s       IL_0022

      IL_0021:  ldc.i4.1
      IL_0022:  stloc.2
      IL_0023:  ldloc.2
      IL_0024:  brtrue.s   IL_0031

      IL_0026:  ldarg.0
      IL_0027:  ldc.i4.0
      IL_0028:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
      IL_002d:  ldarg.0
      IL_002e:  stloc.0
      IL_002f:  br.s       IL_0044

      IL_0031:  ldc.i4.0
      IL_0032:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::.ctor(int32)
      IL_0037:  stloc.0
      IL_0038:  ldloc.0
      IL_0039:  ldarg.0
      IL_003a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>4__this'
      IL_003f:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>4__this'
      IL_0044:  ldloc.0
      IL_0045:  ldarg.0
      IL_0046:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>3__r'
      IL_004b:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::r
      IL_0050:  ldloc.0
      IL_0051:  stloc.1
      IL_0052:  br.s       IL_0054

      IL_0054:  ldloc.1
      IL_0055:  ret
    } // end of method '<Intersect>d__0'::'System.Collections.Generic.IEnumerable<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.GetEnumerator'

    .method private hidebysig newslot virtual final 
            instance class [mscorlib]System.Collections.IEnumerator 
            System.Collections.IEnumerable.GetEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerable::GetEnumerator
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (class [mscorlib]System.Collections.IEnumerator V_0)
      IL_0000:  ldarg.0
      IL_0001:  call       instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'System.Collections.Generic.IEnumerable<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.GetEnumerator'()
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<Intersect>d__0'::System.Collections.IEnumerable.GetEnumerator

    .method private hidebysig newslot virtual final 
            instance bool  MoveNext() cil managed
    {
      .override [mscorlib]System.Collections.IEnumerator::MoveNext
      // Code size       197 (0xc5)
      .maxstack  3
      .locals init ([0] bool CS$1$0000,
               [1] int32 CS$4$0001,
               [2] bool CS$4$0002)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Scene.cs' 
      .try
      {
        IL_0000:  ldarg.0
        IL_0001:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
        IL_0006:  stloc.1
        IL_0007:  ldloc.1
        IL_0008:  switch     ( 
                              IL_001d,
                              IL_001f,
                              IL_001b)
        IL_0019:  br.s       IL_001f

        IL_001b:  br.s       IL_0084

        IL_001d:  br.s       IL_0024

        IL_001f:  br         IL_00b6

        IL_0024:  ldarg.0
        IL_0025:  ldc.i4.m1
        IL_0026:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
//000022:         {
        IL_002b:  nop
//000023:             foreach (SceneObject obj in Things)
        IL_002c:  nop
//000024:             {
//000025:                 yield return obj.Intersect(r);
//000026:             }
//000027:         }
//000028:     }
//000029: }
        IL_002d:  ldarg.0
        IL_002e:  ldc.i4.1
        IL_002f:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
//000023:             foreach (SceneObject obj in Things)
        IL_0034:  ldarg.0
        IL_0035:  ldarg.0
        IL_0036:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>4__this'
        IL_003b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
        IL_0040:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap3'
//000024:             {
//000025:                 yield return obj.Intersect(r);
//000026:             }
//000027:         }
//000028:     }
//000029: }
        IL_0045:  ldarg.0
        IL_0046:  ldc.i4.0
        IL_0047:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap4'
        IL_004c:  br.s       IL_009a

//000023:             foreach (SceneObject obj in Things)
        IL_004e:  ldarg.0
        IL_004f:  ldarg.0
        IL_0050:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap3'
        IL_0055:  ldarg.0
        IL_0056:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap4'
        IL_005b:  ldelem.ref
        IL_005c:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<obj>5__1'
//000024:             {
        IL_0061:  nop
//000025:                 yield return obj.Intersect(r);
        IL_0062:  ldarg.0
        IL_0063:  ldarg.0
        IL_0064:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<obj>5__1'
        IL_0069:  ldarg.0
        IL_006a:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::r
        IL_006f:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
        IL_0074:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>2__current'
//000026:             }
//000027:         }
//000028:     }
//000029: }
        IL_0079:  ldarg.0
        IL_007a:  ldc.i4.2
        IL_007b:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
        IL_0080:  ldc.i4.1
        IL_0081:  stloc.0
        IL_0082:  leave.s    IL_00c2

        IL_0084:  ldarg.0
        IL_0085:  ldc.i4.1
        IL_0086:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
//000026:             }
        IL_008b:  nop
//000027:         }
//000028:     }
//000029: }
        IL_008c:  ldarg.0
        IL_008d:  ldarg.0
        IL_008e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap4'
        IL_0093:  ldc.i4.1
        IL_0094:  add
        IL_0095:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap4'
//000023:             foreach (SceneObject obj in Things)
        IL_009a:  ldarg.0
        IL_009b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap4'
        IL_00a0:  ldarg.0
        IL_00a1:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>7__wrap3'
        IL_00a6:  ldlen
        IL_00a7:  conv.i4
        IL_00a8:  clt
        IL_00aa:  stloc.2
//000024:             {
//000025:                 yield return obj.Intersect(r);
//000026:             }
//000027:         }
//000028:     }
//000029: }
        IL_00ab:  ldloc.2
        IL_00ac:  brtrue.s   IL_004e

        IL_00ae:  ldarg.0
        IL_00af:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>m__Finally2'()
        IL_00b4:  nop
//000027:         }
        IL_00b5:  nop
//000028:     }
//000029: }
        IL_00b6:  ldc.i4.0
        IL_00b7:  stloc.0
        IL_00b8:  leave.s    IL_00c2

      }  // end .try
      fault
      {
        IL_00ba:  ldarg.0
        IL_00bb:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::System.IDisposable.Dispose()
        IL_00c0:  nop
        IL_00c1:  endfinally
      }  // end handler
      IL_00c2:  nop
      IL_00c3:  ldloc.0
      IL_00c4:  ret
    } // end of method '<Intersect>d__0'::MoveNext

    .method private hidebysig newslot specialname virtual final 
            instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
            'System.Collections.Generic.IEnumerator<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.get_Current'() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override  method instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>::get_Current()
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect V_0)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>2__current'
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<Intersect>d__0'::'System.Collections.Generic.IEnumerator<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.get_Current'

    .method private hidebysig newslot virtual final 
            instance void  System.Collections.IEnumerator.Reset() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerator::Reset
      // Code size       6 (0x6)
      .maxstack  8
      IL_0000:  newobj     instance void [mscorlib]System.NotSupportedException::.ctor()
      IL_0005:  throw
    } // end of method '<Intersect>d__0'::System.Collections.IEnumerator.Reset

    .method private hidebysig newslot virtual final 
            instance void  System.IDisposable.Dispose() cil managed
    {
      .override [mscorlib]System.IDisposable::Dispose
      // Code size       39 (0x27)
      .maxstack  2
      .locals init ([0] int32 CS$4$0000)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
      IL_0006:  stloc.0
      IL_0007:  ldloc.0
      IL_0008:  ldc.i4.1
      IL_0009:  sub
      IL_000a:  switch     ( 
                            IL_001b,
                            IL_0019)
      IL_0017:  br.s       IL_001d

      IL_0019:  br.s       IL_001f

      IL_001b:  br.s       IL_001f

      IL_001d:  br.s       IL_0026

      IL_001f:  ldarg.0
      IL_0020:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>m__Finally2'()
      IL_0025:  nop
      IL_0026:  ret
    } // end of method '<Intersect>d__0'::System.IDisposable.Dispose

    .method private hidebysig newslot specialname virtual final 
            instance object  System.Collections.IEnumerator.get_Current() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerator::get_Current
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (object V_0)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>2__current'
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<Intersect>d__0'::System.Collections.IEnumerator.get_Current

    .method public hidebysig specialname rtspecialname 
            instance void  .ctor(int32 '<>1__state') cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       30 (0x1e)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
      IL_000d:  ldarg.0
      IL_000e:  call       class [mscorlib]System.Threading.Thread [mscorlib]System.Threading.Thread::get_CurrentThread()
      IL_0013:  callvirt   instance int32 [mscorlib]System.Threading.Thread::get_ManagedThreadId()
      IL_0018:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>l__initialThreadId'
      IL_001d:  ret
    } // end of method '<Intersect>d__0'::.ctor

    .method private hidebysig instance void 
            '<>m__Finally2'() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  ldc.i4.m1
      IL_0002:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>1__state'
      IL_0007:  ret
    } // end of method '<Intersect>d__0'::'<>m__Finally2'

    .property instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect
            'System.Collections.Generic.IEnumerator<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.Current'()
    {
      .get instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'System.Collections.Generic.IEnumerator<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.get_Current'()
    } // end of property '<Intersect>d__0'::'System.Collections.Generic.IEnumerator<Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect>.Current'
    .property instance object System.Collections.IEnumerator.Current()
    {
      .get instance object Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::System.Collections.IEnumerator.get_Current()
    } // end of property '<Intersect>d__0'::System.Collections.IEnumerator.Current
  } // end of class '<Intersect>d__0'

  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Things
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Lights
  .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Camera
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] things,
                               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] lights,
                               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  8
//000019:         public Scene(SceneObject[] things, Light[] lights, Camera camera) { Things = things; Lights = lights; Camera = camera; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Lights
    IL_0016:  ldarg.0
    IL_0017:  ldarg.3
    IL_0018:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
    IL_001d:  nop
    IL_001e:  ret
  } // end of method Scene::.ctor

  .method public hidebysig instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> 
          Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray r) cil managed
  {
    // Code size       28 (0x1c)
    .maxstack  2
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0' V_0,
             [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect> V_1)
    IL_0000:  ldc.i4.s   -2
    IL_0002:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::.ctor(int32)
    IL_0007:  stloc.0
    IL_0008:  ldloc.0
    IL_0009:  ldarg.0
    IL_000a:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>4__this'
    IL_000f:  ldloc.0
    IL_0010:  ldarg.1
    IL_0011:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene/'<Intersect>d__0'::'<>3__r'
    IL_0016:  ldloc.0
    IL_0017:  stloc.1
    IL_0018:  br.s       IL_001a

    IL_001a:  ldloc.1
    IL_001b:  ret
  } // end of method Scene::Intersect

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene

.class private abstract auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces
       extends [mscorlib]System.Object
{
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface CheckerBoard
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Shiny
  .field public static initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface MatteShiny
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate9'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegatea'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> 'CS$<>9__CachedAnonymousMethodDelegateb'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegatec'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegated'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> 'CS$<>9__CachedAnonymousMethodDelegatee'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegatef'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> 'CS$<>9__CachedAnonymousMethodDelegate10'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> 'CS$<>9__CachedAnonymousMethodDelegate11'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       337 (0x151)
    .maxstack  5
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Surfaces.cs' 
//000016:         public static readonly Surface CheckerBoard =
    IL_0000:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_0005:  brtrue.s   IL_001a

    IL_0007:  ldnull
    IL_0008:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__0'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_000e:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_0013:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_0018:  br.s       IL_001a

    IL_001a:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate9'
    IL_001f:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_0024:  brtrue.s   IL_0039

    IL_0026:  ldnull
    IL_0027:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__1'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_002d:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_0032:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_0037:  br.s       IL_0039

    IL_0039:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatea'
    IL_003e:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_0043:  brtrue.s   IL_0058

    IL_0045:  ldnull
    IL_0046:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__2'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_004c:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::.ctor(object,
                                                                                                                                                                     native int)
    IL_0051:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_0056:  br.s       IL_0058

    IL_0058:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegateb'
    IL_005d:  ldc.r8     150.
    IL_0066:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::.ctor(class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>,
                                                                                                                     float64)
    IL_006b:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::CheckerBoard
//000017:             new Surface(
//000018:                 delegate(Vector pos)
//000019:                 {
//000020:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000021:                  ? new Color(1, 1, 1)
//000022:                  : new Color(0.02, 0.0, 0.14);
//000023:                 },
//000024:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000025:                 delegate(Vector pos)
//000026:                 {
//000027:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000028:                  ? .1
//000029:                  : .5;
//000030:                 },
//000031:                 150);
//000032: 
//000033: 
//000034: 
//000035:         public static readonly Surface Shiny =
    IL_0070:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_0075:  brtrue.s   IL_008a

    IL_0077:  ldnull
    IL_0078:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__3'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_007e:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_0083:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_0088:  br.s       IL_008a

    IL_008a:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatec'
    IL_008f:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_0094:  brtrue.s   IL_00a9

    IL_0096:  ldnull
    IL_0097:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__4'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_009d:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_00a2:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_00a7:  br.s       IL_00a9

    IL_00a9:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegated'
    IL_00ae:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_00b3:  brtrue.s   IL_00c8

    IL_00b5:  ldnull
    IL_00b6:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__5'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00bc:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::.ctor(object,
                                                                                                                                                                     native int)
    IL_00c1:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_00c6:  br.s       IL_00c8

    IL_00c8:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_00cd:  ldc.r8     250.
    IL_00d6:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::.ctor(class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>,
                                                                                                                     float64)
    IL_00db:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::Shiny
//000036:             new Surface(
//000037:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
    IL_00e0:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00e5:  brtrue.s   IL_00fa

    IL_00e7:  ldnull
    IL_00e8:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__6'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00ee:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_00f3:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00f8:  br.s       IL_00fa

    IL_00fa:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00ff:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate10'
    IL_0104:  brtrue.s   IL_0119

    IL_0106:  ldnull
    IL_0107:  ldftn      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__7'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_010d:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::.ctor(object,
                                                                                                                                                                                                                                            native int)
    IL_0112:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate10'
    IL_0117:  br.s       IL_0119

    IL_0119:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate10'
    IL_011e:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate11'
    IL_0123:  brtrue.s   IL_0138

    IL_0125:  ldnull
    IL_0126:  ldftn      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'<.cctor>b__8'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_012c:  newobj     instance void class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::.ctor(object,
                                                                                                                                                                     native int)
    IL_0131:  stsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate11'
    IL_0136:  br.s       IL_0138

    IL_0138:  ldsfld     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::'CS$<>9__CachedAnonymousMethodDelegate11'
    IL_013d:  ldc.r8     250.
    IL_0146:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::.ctor(class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>,
                                                                                                                     class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>,
                                                                                                                     float64)
    IL_014b:  stsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::MatteShiny
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0150:  ret
  } // end of method Surfaces::.cctor

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__0'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       118 (0x76)
    .maxstack  5
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000019:                 {
    IL_0000:  nop
//000020:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
    IL_0001:  ldarga.s   pos
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0008:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_000d:  ldarga.s   pos
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0014:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_0019:  add
    IL_001a:  ldc.r8     2.
    IL_0023:  rem
    IL_0024:  ldc.r8     0.0
    IL_002d:  bne.un.s   IL_0051

    IL_002f:  ldc.r8     2.e-002
    IL_0038:  ldc.r8     0.0
    IL_0041:  ldc.r8     0.14000000000000001
    IL_004a:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_004f:  br.s       IL_0071

    IL_0051:  ldc.r8     1.
    IL_005a:  ldc.r8     1.
    IL_0063:  ldc.r8     1.
    IL_006c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0071:  stloc.0
    IL_0072:  br.s       IL_0074

//000021:                  ? new Color(1, 1, 1)
//000022:                  : new Color(0.02, 0.0, 0.14);
//000023:                 },
//000024:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000025:                 delegate(Vector pos)
//000026:                 {
//000027:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000028:                  ? .1
//000029:                  : .5;
//000030:                 },
//000031:                 150);
//000032: 
//000033: 
//000034: 
//000035:         public static readonly Surface Shiny =
//000036:             new Surface(
//000037:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0074:  ldloc.0
    IL_0075:  ret
  } // end of method Surfaces::'<.cctor>b__0'

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__1'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000024:                 delegate(Vector pos) { return new Color(1, 1, 1); },
    IL_0000:  nop
    IL_0001:  ldc.r8     1.
    IL_000a:  ldc.r8     1.
    IL_0013:  ldc.r8     1.
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000025:                 delegate(Vector pos)
//000026:                 {
//000027:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
//000028:                  ? .1
//000029:                  : .5;
//000030:                 },
//000031:                 150);
//000032: 
//000033: 
//000034: 
//000035:         public static readonly Surface Shiny =
//000036:             new Surface(
//000037:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Surfaces::'<.cctor>b__1'

  .method private hidebysig static float64 
          '<.cctor>b__2'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       72 (0x48)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000026:                 {
    IL_0000:  nop
//000027:                     return ((Math.Floor(pos.Z) + Math.Floor(pos.X)) % 2 != 0)
    IL_0001:  ldarga.s   pos
    IL_0003:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Z
    IL_0008:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_000d:  ldarga.s   pos
    IL_000f:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::X
    IL_0014:  call       float64 [mscorlib]System.Math::Floor(float64)
    IL_0019:  add
    IL_001a:  ldc.r8     2.
    IL_0023:  rem
    IL_0024:  ldc.r8     0.0
    IL_002d:  bne.un.s   IL_003a

    IL_002f:  ldc.r8     0.5
    IL_0038:  br.s       IL_0043

    IL_003a:  ldc.r8     0.10000000000000001
    IL_0043:  stloc.0
    IL_0044:  br.s       IL_0046

//000028:                  ? .1
//000029:                  : .5;
//000030:                 },
//000031:                 150);
//000032: 
//000033: 
//000034: 
//000035:         public static readonly Surface Shiny =
//000036:             new Surface(
//000037:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0046:  ldloc.0
    IL_0047:  ret
  } // end of method Surfaces::'<.cctor>b__2'

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__3'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000037:                 delegate(Vector pos) { return new Color(1, 1, 1); },
    IL_0000:  nop
    IL_0001:  ldc.r8     1.
    IL_000a:  ldc.r8     1.
    IL_0013:  ldc.r8     1.
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Surfaces::'<.cctor>b__3'

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__4'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000038:                 delegate(Vector pos) { return new Color(.5, .5, .5); },
    IL_0000:  nop
    IL_0001:  ldc.r8     0.5
    IL_000a:  ldc.r8     0.5
    IL_0013:  ldc.r8     0.5
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000039:                 delegate(Vector pos) { return .7; },
//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Surfaces::'<.cctor>b__4'

  .method private hidebysig static float64 
          '<.cctor>b__5'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       15 (0xf)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000039:                 delegate(Vector pos) { return .7; },
    IL_0000:  nop
    IL_0001:  ldc.r8     0.69999999999999996
    IL_000a:  stloc.0
    IL_000b:  br.s       IL_000d

//000040:                 250);
//000041: 
//000042:         public static readonly Surface MatteShiny =
//000043:             new Surface(
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_000d:  ldloc.0
    IL_000e:  ret
  } // end of method Surfaces::'<.cctor>b__5'

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__6'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000044:                 delegate(Vector pos) { return new Color(1, 1, 1); },
    IL_0000:  nop
    IL_0001:  ldc.r8     1.
    IL_000a:  ldc.r8     1.
    IL_0013:  ldc.r8     1.
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Surfaces::'<.cctor>b__6'

  .method private hidebysig static valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          '<.cctor>b__7'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000045:                 delegate(Vector pos) { return new Color(.25, .25, .25); },
    IL_0000:  nop
    IL_0001:  ldc.r8     0.25
    IL_000a:  ldc.r8     0.25
    IL_0013:  ldc.r8     0.25
    IL_001c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000046:                 delegate(Vector pos) { return .7; },
//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method Surfaces::'<.cctor>b__7'

  .method private hidebysig static float64 
          '<.cctor>b__8'(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       15 (0xf)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000046:                 delegate(Vector pos) { return .7; },
    IL_0000:  nop
    IL_0001:  ldc.r8     0.69999999999999996
    IL_000a:  stloc.0
    IL_000b:  br.s       IL_000d

//000047:                 250);
//000048: 
//000049:     }
//000050: }
    IL_000d:  ldloc.0
    IL_000e:  ret
  } // end of method Surfaces::'<.cctor>b__8'

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces

.class private auto ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer '<>4__this'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene
    .field public int32[] rgb
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1'::.ctor

    .method public hidebysig instance void 
            '<RenderParallel>b__0'(int32 y) cil managed
    {
      // Code size       121 (0x79)
      .maxstack  6
      .locals init ([0] int32 stride,
               [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera,
               [2] int32 x,
               [3] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color,
               [4] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Raytracer.cs' 
//000045:             {
      IL_0000:  nop
//000046:                 int stride = y * screenWidth;
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<>4__this'
      IL_0008:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_000d:  mul
      IL_000e:  stloc.0
//000047:                 Camera camera = scene.Camera;
      IL_000f:  ldarg.0
      IL_0010:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::scene
      IL_0015:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
      IL_001a:  stloc.1
//000048:                 for (int x = 0; x < screenWidth; x++)
      IL_001b:  ldc.i4.0
      IL_001c:  stloc.2
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_001d:  br.s       IL_0064

//000049:                 {
      IL_001f:  nop
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
      IL_0020:  ldarg.0
      IL_0021:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<>4__this'
      IL_0026:  ldloc.1
      IL_0027:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
      IL_002c:  ldarg.0
      IL_002d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<>4__this'
      IL_0032:  ldloc.2
      IL_0033:  conv.r8
      IL_0034:  ldarg.1
      IL_0035:  conv.r8
      IL_0036:  ldloc.1
      IL_0037:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetPoint(float64,
                                                                                                                                                                                                       float64,
                                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera)
      IL_003c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
      IL_0041:  ldarg.0
      IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::scene
      IL_0047:  ldc.i4.0
      IL_0048:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::TraceRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                      int32)
      IL_004d:  stloc.3
//000051:                     rgb[x + stride] = color.ToInt32();
      IL_004e:  ldarg.0
      IL_004f:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::rgb
      IL_0054:  ldloc.2
      IL_0055:  ldloc.0
      IL_0056:  add
      IL_0057:  ldloca.s   color
      IL_0059:  call       instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
      IL_005e:  stelem.i4
//000052:                 }
      IL_005f:  nop
//000048:                 for (int x = 0; x < screenWidth; x++)
      IL_0060:  ldloc.2
      IL_0061:  ldc.i4.1
      IL_0062:  add
      IL_0063:  stloc.2
      IL_0064:  ldloc.2
      IL_0065:  ldarg.0
      IL_0066:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<>4__this'
      IL_006b:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_0070:  clt
      IL_0072:  stloc.s    CS$4$0000
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_0074:  ldloc.s    CS$4$0000
      IL_0076:  brtrue.s   IL_001f

      IL_0078:  ret
    } // end of method '<>c__DisplayClass1'::'<RenderParallel>b__0'

  } // end of class '<>c__DisplayClass1'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 id
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer '<>4__this'
    .field public class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene
    .field public int32[] rgb
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass6'::.ctor

    .method public hidebysig instance float64 
            '<RenderParallelShowingThreads>b__3'() cil managed
    {
      // Code size       27 (0x1b)
      .maxstack  2
      .locals init ([0] float64 CS$1$0000)
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
      IL_0006:  ldarg.0
      IL_0007:  ldflda     int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::id
      IL_000c:  call       int32 [mscorlib]System.Threading.Interlocked::Increment(int32&)
      IL_0011:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetHueShift(int32)
      IL_0016:  stloc.0
      IL_0017:  br.s       IL_0019

//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_0019:  ldloc.0
      IL_001a:  ret
    } // end of method '<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__3'

    .method public hidebysig instance float64 
            '<RenderParallelShowingThreads>b__4'(int32 y,
                                                 class [mscorlib]System.Threading.Tasks.ParallelLoopState state,
                                                 float64 hue) cil managed
    {
      // Code size       137 (0x89)
      .maxstack  6
      .locals init ([0] int32 stride,
               [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera,
               [2] int32 x,
               [3] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color,
               [4] float64 CS$1$0000,
               [5] bool CS$4$0001)
//000060:             {
      IL_0000:  nop
//000061:                 int stride = y * screenWidth;
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
      IL_0008:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_000d:  mul
      IL_000e:  stloc.0
//000062:                 Camera camera = scene.Camera;
      IL_000f:  ldarg.0
      IL_0010:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::scene
      IL_0015:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
      IL_001a:  stloc.1
//000063:                 for (int x = 0; x < screenWidth; x++)
      IL_001b:  ldc.i4.0
      IL_001c:  stloc.2
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_001d:  br.s       IL_006d

//000064:                 {
      IL_001f:  nop
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
      IL_0020:  ldarg.0
      IL_0021:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
      IL_0026:  ldloc.1
      IL_0027:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
      IL_002c:  ldarg.0
      IL_002d:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
      IL_0032:  ldloc.2
      IL_0033:  conv.r8
      IL_0034:  ldarg.1
      IL_0035:  conv.r8
      IL_0036:  ldloc.1
      IL_0037:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetPoint(float64,
                                                                                                                                                                                                       float64,
                                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera)
      IL_003c:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
      IL_0041:  ldarg.0
      IL_0042:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::scene
      IL_0047:  ldc.i4.0
      IL_0048:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::TraceRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                      int32)
      IL_004d:  stloc.3
//000066:                     color.ChangeHue(hue);
      IL_004e:  ldloca.s   color
      IL_0050:  ldarg.3
      IL_0051:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ChangeHue(float64)
      IL_0056:  nop
//000067:                     rgb[x + stride] = color.ToInt32();
      IL_0057:  ldarg.0
      IL_0058:  ldfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::rgb
      IL_005d:  ldloc.2
      IL_005e:  ldloc.0
      IL_005f:  add
      IL_0060:  ldloca.s   color
      IL_0062:  call       instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
      IL_0067:  stelem.i4
//000068:                 }
      IL_0068:  nop
//000063:                 for (int x = 0; x < screenWidth; x++)
      IL_0069:  ldloc.2
      IL_006a:  ldc.i4.1
      IL_006b:  add
      IL_006c:  stloc.2
      IL_006d:  ldloc.2
      IL_006e:  ldarg.0
      IL_006f:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
      IL_0074:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
      IL_0079:  clt
      IL_007b:  stloc.s    CS$4$0001
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_007d:  ldloc.s    CS$4$0001
      IL_007f:  brtrue.s   IL_001f

//000069:                 return hue;
      IL_0081:  ldarg.3
      IL_0082:  stloc.s    CS$1$0000
      IL_0084:  br.s       IL_0086

//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_0086:  ldloc.s    CS$1$0000
      IL_0088:  ret
    } // end of method '<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__4'

    .method public hidebysig instance void 
            '<RenderParallelShowingThreads>b__5'(float64 hue) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  8
//000071:             hue => Interlocked.Decrement(ref id));
      IL_0000:  ldarg.0
      IL_0001:  ldflda     int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::id
      IL_0006:  call       int32 [mscorlib]System.Threading.Interlocked::Decrement(int32&)
      IL_000b:  pop
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_000c:  ret
    } // end of method '<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__5'

  } // end of class '<>c__DisplayClass6'

  .field private static literal int32 MaxDepth = int32(0x00000005)
  .field private int32 screenWidth
  .field private int32 screenHeight
  .field private class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> _numToHueShiftLookup
  .field private class [mscorlib]System.Random _rand
  .field assembly initonly class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene DefaultScene
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(int32 screenWidth,
                               int32 screenHeight) cil managed
  {
    // Code size       57 (0x39)
    .maxstack  8
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
    IL_0000:  ldarg.0
    IL_0001:  newobj     instance void class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::.ctor()
    IL_0006:  stfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_numToHueShiftLookup
//000075:         private Random _rand = new Random();
    IL_000b:  ldarg.0
    IL_000c:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_0011:  stfld      class [mscorlib]System.Random Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_rand
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
    IL_0016:  ldarg.0
    IL_0017:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::CreateDefaultScene()
    IL_001c:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::DefaultScene
//000022:         public RayTracer(int screenWidth, int screenHeight)
    IL_0021:  ldarg.0
    IL_0022:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0027:  nop
//000023:         {
    IL_0028:  nop
//000024:             this.screenWidth = screenWidth;
    IL_0029:  ldarg.0
    IL_002a:  ldarg.1
    IL_002b:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
//000025:             this.screenHeight = screenHeight;
    IL_0030:  ldarg.0
    IL_0031:  ldarg.2
    IL_0032:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
//000026:         }
    IL_0037:  nop
    IL_0038:  ret
  } // end of method RayTracer::.ctor

  .method assembly hidebysig instance void 
          RenderSequential(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                           int32[] rgb) cil managed
  {
    // Code size       112 (0x70)
    .maxstack  6
    .locals init ([0] int32 y,
             [1] int32 stride,
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera,
             [3] int32 x,
             [4] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color,
             [5] bool CS$4$0000)
//000027: 
//000028:         internal void RenderSequential(Scene scene, Int32[] rgb)
//000029:         {
    IL_0000:  nop
//000030:             for (int y = 0; y < screenHeight; y++)
    IL_0001:  ldc.i4.0
    IL_0002:  stloc.0
//000031:             {
//000032:                 int stride = y * screenWidth;
//000033:                 Camera camera = scene.Camera;
//000034:                 for (int x = 0; x < screenWidth; x++)
//000035:                 {
//000036:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000037:                     rgb[x + stride] = color.ToInt32();
//000038:                 }
//000039:             }
//000040:         }
//000041: 
//000042:         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
//000043:         {
//000044:             Parallel.For(0, screenHeight, options, y =>
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0003:  br.s       IL_0060

//000031:             {
    IL_0005:  nop
//000032:                 int stride = y * screenWidth;
    IL_0006:  ldloc.0
    IL_0007:  ldarg.0
    IL_0008:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_000d:  mul
    IL_000e:  stloc.1
//000033:                 Camera camera = scene.Camera;
    IL_000f:  ldarg.1
    IL_0010:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Camera
    IL_0015:  stloc.2
//000034:                 for (int x = 0; x < screenWidth; x++)
    IL_0016:  ldc.i4.0
    IL_0017:  stloc.3
//000035:                 {
//000036:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000037:                     rgb[x + stride] = color.ToInt32();
//000038:                 }
//000039:             }
//000040:         }
//000041: 
//000042:         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
//000043:         {
//000044:             Parallel.For(0, screenHeight, options, y =>
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0018:  br.s       IL_004c

//000035:                 {
    IL_001a:  nop
//000036:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
    IL_001b:  ldarg.0
    IL_001c:  ldloc.2
    IL_001d:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Pos
    IL_0022:  ldarg.0
    IL_0023:  ldloc.3
    IL_0024:  conv.r8
    IL_0025:  ldloc.0
    IL_0026:  conv.r8
    IL_0027:  ldloc.2
    IL_0028:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetPoint(float64,
                                                                                                                                                                                                     float64,
                                                                                                                                                                                                     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera)
    IL_002d:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                 valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0032:  ldarg.1
    IL_0033:  ldc.i4.0
    IL_0034:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::TraceRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                    int32)
    IL_0039:  stloc.s    color
//000037:                     rgb[x + stride] = color.ToInt32();
    IL_003b:  ldarg.2
    IL_003c:  ldloc.3
    IL_003d:  ldloc.1
    IL_003e:  add
    IL_003f:  ldloca.s   color
    IL_0041:  call       instance int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::ToInt32()
    IL_0046:  stelem.i4
//000038:                 }
    IL_0047:  nop
//000034:                 for (int x = 0; x < screenWidth; x++)
    IL_0048:  ldloc.3
    IL_0049:  ldc.i4.1
    IL_004a:  add
    IL_004b:  stloc.3
    IL_004c:  ldloc.3
    IL_004d:  ldarg.0
    IL_004e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_0053:  clt
    IL_0055:  stloc.s    CS$4$0000
//000035:                 {
//000036:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000037:                     rgb[x + stride] = color.ToInt32();
//000038:                 }
//000039:             }
//000040:         }
//000041: 
//000042:         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
//000043:         {
//000044:             Parallel.For(0, screenHeight, options, y =>
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0057:  ldloc.s    CS$4$0000
    IL_0059:  brtrue.s   IL_001a

//000039:             }
    IL_005b:  nop
//000030:             for (int y = 0; y < screenHeight; y++)
    IL_005c:  ldloc.0
    IL_005d:  ldc.i4.1
    IL_005e:  add
    IL_005f:  stloc.0
    IL_0060:  ldloc.0
    IL_0061:  ldarg.0
    IL_0062:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0067:  clt
    IL_0069:  stloc.s    CS$4$0000
//000031:             {
//000032:                 int stride = y * screenWidth;
//000033:                 Camera camera = scene.Camera;
//000034:                 for (int x = 0; x < screenWidth; x++)
//000035:                 {
//000036:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000037:                     rgb[x + stride] = color.ToInt32();
//000038:                 }
//000039:             }
//000040:         }
//000041: 
//000042:         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
//000043:         {
//000044:             Parallel.For(0, screenHeight, options, y =>
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_006b:  ldloc.s    CS$4$0000
    IL_006d:  brtrue.s   IL_0005

//000040:         }
    IL_006f:  ret
  } // end of method RayTracer::RenderSequential

  .method assembly hidebysig instance void 
          RenderParallel(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                         int32[] rgb,
                         class [mscorlib]System.Threading.Tasks.ParallelOptions options) cil managed
  {
    // Code size       56 (0x38)
    .maxstack  6
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1' 'CS$<>8__locals2')
//000041: 
//000042:         internal void RenderParallel(Scene scene, Int32[] rgb, ParallelOptions options)
//000043:         {
//000044:             Parallel.For(0, screenHeight, options, y =>
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::scene
    IL_000d:  ldloc.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::rgb
    IL_0014:  ldloc.0
    IL_0015:  ldarg.0
    IL_0016:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<>4__this'
//000043:         {
    IL_001b:  nop
//000044:             Parallel.For(0, screenHeight, options, y =>
    IL_001c:  ldc.i4.0
    IL_001d:  ldarg.0
    IL_001e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0023:  ldarg.3
    IL_0024:  ldloc.0
    IL_0025:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass1'::'<RenderParallel>b__0'(int32)
    IL_002b:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                     native int)
    IL_0030:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                      int32,
                                                                                                                                      class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                      class [mscorlib]System.Action`1<int32>)
    IL_0035:  pop
//000045:             {
//000046:                 int stride = y * screenWidth;
//000047:                 Camera camera = scene.Camera;
//000048:                 for (int x = 0; x < screenWidth; x++)
//000049:                 {
//000050:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000051:                     rgb[x + stride] = color.ToInt32();
//000052:                 }
//000053:             });
//000054:         }
    IL_0036:  nop
    IL_0037:  ret
  } // end of method RayTracer::RenderParallel

  .method assembly hidebysig instance void 
          RenderParallelShowingThreads(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                                       int32[] rgb,
                                       class [mscorlib]System.Threading.Tasks.ParallelOptions options) cil managed
  {
    // Code size       87 (0x57)
    .maxstack  8
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6' 'CS$<>8__locals7')
//000055: 
//000056:         internal void RenderParallelShowingThreads(Scene scene, Int32[] rgb, ParallelOptions options)
//000057:         {
//000058:             int id = 0;
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0000:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.1
    IL_0008:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::scene
    IL_000d:  ldloc.0
    IL_000e:  ldarg.2
    IL_000f:  stfld      int32[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::rgb
    IL_0014:  ldloc.0
    IL_0015:  ldarg.0
    IL_0016:  stfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<>4__this'
//000057:         {
    IL_001b:  nop
//000058:             int id = 0;
    IL_001c:  ldloc.0
    IL_001d:  ldc.i4.0
    IL_001e:  stfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::id
//000059:             Parallel.For<double>(0, screenHeight, options, () => GetHueShift(Interlocked.Increment(ref id)), (y, state, hue) =>
    IL_0023:  ldc.i4.0
    IL_0024:  ldarg.0
    IL_0025:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_002a:  ldarg.3
    IL_002b:  ldloc.0
    IL_002c:  ldftn      instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__3'()
    IL_0032:  newobj     instance void class [mscorlib]System.Func`1<float64>::.ctor(object,
                                                                                     native int)
    IL_0037:  ldloc.0
    IL_0038:  ldftn      instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__4'(int32,
                                                                                                                                                                              class [mscorlib]System.Threading.Tasks.ParallelLoopState,
                                                                                                                                                                              float64)
    IL_003e:  newobj     instance void class [mscorlib]System.Func`4<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState,float64,float64>::.ctor(object,
                                                                                                                                                            native int)
    IL_0043:  ldloc.0
    IL_0044:  ldftn      instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer/'<>c__DisplayClass6'::'<RenderParallelShowingThreads>b__5'(float64)
    IL_004a:  newobj     instance void class [mscorlib]System.Action`1<float64>::.ctor(object,
                                                                                       native int)
    IL_004f:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For<float64>(int32,
                                                                                                                                               int32,
                                                                                                                                               class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                               class [mscorlib]System.Func`1<!!0>,
                                                                                                                                               class [mscorlib]System.Func`4<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState,!!0,!!0>,
                                                                                                                                               class [mscorlib]System.Action`1<!!0>)
    IL_0054:  pop
//000060:             {
//000061:                 int stride = y * screenWidth;
//000062:                 Camera camera = scene.Camera;
//000063:                 for (int x = 0; x < screenWidth; x++)
//000064:                 {
//000065:                     Color color = TraceRay(new Ray(camera.Pos, GetPoint(x, y, camera)), scene, 0);
//000066:                     color.ChangeHue(hue);
//000067:                     rgb[x + stride] = color.ToInt32();
//000068:                 }
//000069:                 return hue;
//000070:             }, 
//000071:             hue => Interlocked.Decrement(ref id));
//000072:         }
    IL_0055:  nop
    IL_0056:  ret
  } // end of method RayTracer::RenderParallelShowingThreads

  .method private hidebysig instance float64 
          GetHueShift(int32 id) cil managed
  {
    // Code size       96 (0x60)
    .maxstack  3
    .locals init ([0] float64 shift,
             [1] bool '<>s__LockTaken8',
             [2] float64 CS$1$0000,
             [3] class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> CS$2$0001,
             [4] bool CS$4$0002)
//000073: 
//000074:         private Dictionary<int, double> _numToHueShiftLookup = new Dictionary<int, double>();
//000075:         private Random _rand = new Random();
//000076: 
//000077:         private double GetHueShift(int id)
//000078:         {
    IL_0000:  nop
//000079:             double shift;
//000080:             lock (_numToHueShiftLookup)
//000081:             {
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0001:  ldc.i4.0
    IL_0002:  stloc.1
//000080:             lock (_numToHueShiftLookup)
    .try
    {
      IL_0003:  ldarg.0
      IL_0004:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_numToHueShiftLookup
      IL_0009:  dup
      IL_000a:  stloc.3
      IL_000b:  ldloca.s   '<>s__LockTaken8'
      IL_000d:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                          bool&)
      IL_0012:  nop
//000081:             {
      IL_0013:  nop
//000082:                 if (!_numToHueShiftLookup.TryGetValue(id, out shift))
      IL_0014:  ldarg.0
      IL_0015:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_numToHueShiftLookup
      IL_001a:  ldarg.1
      IL_001b:  ldloca.s   shift
      IL_001d:  callvirt   instance bool class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::TryGetValue(!0,
                                                                                                                             !1&)
      IL_0022:  stloc.s    CS$4$0002
//000083:                 {
//000084:                     shift = _rand.NextDouble();
//000085:                     _numToHueShiftLookup.Add(id, shift);
//000086:                 }
//000087:             }
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_0024:  ldloc.s    CS$4$0002
      IL_0026:  brtrue.s   IL_0044

//000083:                 {
      IL_0028:  nop
//000084:                     shift = _rand.NextDouble();
      IL_0029:  ldarg.0
      IL_002a:  ldfld      class [mscorlib]System.Random Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_rand
      IL_002f:  callvirt   instance float64 [mscorlib]System.Random::NextDouble()
      IL_0034:  stloc.0
//000085:                     _numToHueShiftLookup.Add(id, shift);
      IL_0035:  ldarg.0
      IL_0036:  ldfld      class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::_numToHueShiftLookup
      IL_003b:  ldarg.1
      IL_003c:  ldloc.0
      IL_003d:  callvirt   instance void class [mscorlib]System.Collections.Generic.Dictionary`2<int32,float64>::Add(!0,
                                                                                                                     !1)
      IL_0042:  nop
//000086:                 }
      IL_0043:  nop
//000087:             }
      IL_0044:  nop
//000088:             return shift;
//000089:         }
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
//000095:             SceneObject[] things =  {
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
//000105: 
//000106:             return new Scene(things, lights, camera);
//000107:         }
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
//000112:             ISect min = ISect.Null;
//000113:             foreach (SceneObject obj in scene.Things)
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
      IL_0045:  leave.s    IL_0059

    }  // end .try
    finally
    {
      IL_0047:  ldloc.1
      IL_0048:  ldc.i4.0
      IL_0049:  ceq
      IL_004b:  stloc.s    CS$4$0002
      IL_004d:  ldloc.s    CS$4$0002
      IL_004f:  brtrue.s   IL_0058

      IL_0051:  ldloc.3
      IL_0052:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
      IL_0057:  nop
      IL_0058:  endfinally
    }  // end handler
    IL_0059:  nop
//000088:             return shift;
    IL_005a:  ldloc.0
    IL_005b:  stloc.2
    IL_005c:  br.s       IL_005e

//000089:         }
    IL_005e:  ldloc.2
    IL_005f:  ret
  } // end of method RayTracer::GetHueShift

  .method private hidebysig static class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene 
          CreateDefaultScene() cil managed
  {
    // Code size       417 (0x1a1)
    .maxstack  7
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] things,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] lights,
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera,
             [3] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene CS$1$0000,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] CS$0$0001,
             [5] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] CS$0$0002)
//000090: 
//000091:         internal readonly Scene DefaultScene = CreateDefaultScene();
//000092: 
//000093:         static Scene CreateDefaultScene()
//000094:         {
    IL_0000:  nop
//000095:             SceneObject[] things =  {
    IL_0001:  ldc.i4.3
    IL_0002:  newarr     Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
    IL_0007:  stloc.s    CS$0$0001
    IL_0009:  ldloc.s    CS$0$0001
    IL_000b:  ldc.i4.0
    IL_000c:  ldc.r8     -0.5
    IL_0015:  ldc.r8     1.
    IL_001e:  ldc.r8     1.5
    IL_0027:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_002c:  ldc.r8     0.5
    IL_0035:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::MatteShiny
    IL_003a:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    float64,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface)
    IL_003f:  stelem.ref
    IL_0040:  ldloc.s    CS$0$0001
    IL_0042:  ldc.i4.1
    IL_0043:  ldc.r8     0.0
    IL_004c:  ldc.r8     1.
    IL_0055:  ldc.r8     -0.25
    IL_005e:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0063:  ldc.r8     1.
    IL_006c:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::Shiny
    IL_0071:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                    float64,
                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface)
    IL_0076:  stelem.ref
    IL_0077:  ldloc.s    CS$0$0001
    IL_0079:  ldc.i4.2
    IL_007a:  ldc.r8     0.0
    IL_0083:  ldc.r8     1.
    IL_008c:  ldc.r8     0.0
    IL_0095:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_009a:  ldc.r8     0.0
    IL_00a3:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surfaces::CheckerBoard
    IL_00a8:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Plane::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                   float64,
                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface)
    IL_00ad:  stelem.ref
    IL_00ae:  ldloc.s    CS$0$0001
    IL_00b0:  stloc.0
//000096:                 new Sphere( new Vector(-0.5,1,1.5), 0.5, Surfaces.MatteShiny),
//000097:                 new Sphere( new Vector(0,1,-0.25), 1, Surfaces.Shiny),
//000098:                new Plane( new Vector(0,1,0), 0, Surfaces.CheckerBoard)
//000099:             };
//000100:             Light[] lights = {
    IL_00b1:  ldc.i4.2
    IL_00b2:  newarr     Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light
    IL_00b7:  stloc.s    CS$0$0002
    IL_00b9:  ldloc.s    CS$0$0002
    IL_00bb:  ldc.i4.0
    IL_00bc:  ldc.r8     -2.
    IL_00c5:  ldc.r8     2.5
    IL_00ce:  ldc.r8     0.0
    IL_00d7:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_00dc:  ldc.r8     0.5
    IL_00e5:  ldc.r8     0.45000000000000001
    IL_00ee:  ldc.r8     0.40999999999999998
    IL_00f7:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_00fc:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_0101:  stelem.ref
    IL_0102:  ldloc.s    CS$0$0002
    IL_0104:  ldc.i4.1
    IL_0105:  ldc.r8     2.
    IL_010e:  ldc.r8     4.5
    IL_0117:  ldc.r8     2.
    IL_0120:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_0125:  ldc.r8     0.98999999999999999
    IL_012e:  ldc.r8     0.94999999999999996
    IL_0137:  ldc.r8     0.80000000000000004
    IL_0140:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0145:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_014a:  stelem.ref
    IL_014b:  ldloc.s    CS$0$0002
    IL_014d:  stloc.1
//000101:                 new Light(new Vector(-2,2.5,0),new Color(.5,.45,.41)),
//000102:                 new Light(new Vector(2,4.5,2), new Color(.99,.95,.8))
//000103:             };
//000104:             Camera camera = Camera.Create(new Vector(2.75, 2, 3.75), new Vector(-0.6, .5, 0));
    IL_014e:  ldc.r8     2.75
    IL_0157:  ldc.r8     2.
    IL_0160:  ldc.r8     3.75
    IL_0169:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_016e:  ldc.r8     -0.59999999999999998
    IL_0177:  ldc.r8     0.5
    IL_0180:  ldc.r8     0.0
    IL_0189:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::.ctor(float64,
                                                                                                                    float64,
                                                                                                                    float64)
    IL_018e:  call       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Create(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0193:  stloc.2
//000105: 
//000106:             return new Scene(things, lights, camera);
    IL_0194:  ldloc.0
    IL_0195:  ldloc.1
    IL_0196:  ldloc.2
    IL_0197:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[],
                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[],
                                                                                                                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera)
    IL_019c:  stloc.3
    IL_019d:  br.s       IL_019f

//000107:         }
    IL_019f:  ldloc.3
    IL_01a0:  ret
  } // end of method RayTracer::CreateDefaultScene

  .method private hidebysig instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          MinIntersection(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray,
                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene) cil managed
  {
    // Code size       115 (0x73)
    .maxstack  2
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect min,
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject obj,
             [2] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect,
             [3] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] CS$6$0001,
             [5] int32 CS$7$0002,
             [6] bool CS$4$0003)
//000108: 
//000109: 
//000110:         private ISect MinIntersection(Ray ray, Scene scene)
//000111:         {
    IL_0000:  nop
//000112:             ISect min = ISect.Null;
    IL_0001:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Null
    IL_0006:  stloc.0
//000113:             foreach (SceneObject obj in scene.Things)
    IL_0007:  nop
    IL_0008:  ldarg.2
    IL_0009:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Things
    IL_000e:  stloc.s    CS$6$0001
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0010:  ldc.i4.0
    IL_0011:  stloc.s    CS$7$0002
    IL_0013:  br.s       IL_005f

//000113:             foreach (SceneObject obj in scene.Things)
    IL_0015:  ldloc.s    CS$6$0001
    IL_0017:  ldloc.s    CS$7$0002
    IL_0019:  ldelem.ref
    IL_001a:  stloc.1
//000114:             {
    IL_001b:  nop
//000115:                 ISect isect = obj.Intersect(ray);
    IL_001c:  ldloc.1
    IL_001d:  ldarg.1
    IL_001e:  callvirt   instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray)
    IL_0023:  stloc.2
//000116:                 if (!ISect.IsNull(isect))
    IL_0024:  ldloc.2
    IL_0025:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::IsNull(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
    IL_002a:  stloc.s    CS$4$0003
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_002c:  ldloc.s    CS$4$0003
    IL_002e:  brtrue.s   IL_0058

//000117:                 {
    IL_0030:  nop
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
    IL_0031:  ldloc.0
    IL_0032:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::IsNull(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
    IL_0037:  brtrue.s   IL_004c

    IL_0039:  ldloc.0
    IL_003a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_003f:  ldloc.2
    IL_0040:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_0045:  cgt
    IL_0047:  ldc.i4.0
    IL_0048:  ceq
    IL_004a:  br.s       IL_004d

    IL_004c:  ldc.i4.0
    IL_004d:  stloc.s    CS$4$0003
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_004f:  ldloc.s    CS$4$0003
    IL_0051:  brtrue.s   IL_0057

//000119:                     {
    IL_0053:  nop
//000120:                         min = isect;
    IL_0054:  ldloc.2
    IL_0055:  stloc.0
//000121:                     }
    IL_0056:  nop
//000122:                 }
    IL_0057:  nop
//000123:             }
    IL_0058:  nop
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0059:  ldloc.s    CS$7$0002
    IL_005b:  ldc.i4.1
    IL_005c:  add
    IL_005d:  stloc.s    CS$7$0002
//000113:             foreach (SceneObject obj in scene.Things)
    IL_005f:  ldloc.s    CS$7$0002
    IL_0061:  ldloc.s    CS$6$0001
    IL_0063:  ldlen
    IL_0064:  conv.i4
    IL_0065:  clt
    IL_0067:  stloc.s    CS$4$0003
//000114:             {
//000115:                 ISect isect = obj.Intersect(ray);
//000116:                 if (!ISect.IsNull(isect))
//000117:                 {
//000118:                     if (ISect.IsNull(min) || min.Dist > isect.Dist)
//000119:                     {
//000120:                         min = isect;
//000121:                     }
//000122:                 }
//000123:             }
//000124:             return min;
//000125:         }
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
//000129:             ISect isect = MinIntersection(ray, scene);
//000130:             if (ISect.IsNull(isect))
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0069:  ldloc.s    CS$4$0003
    IL_006b:  brtrue.s   IL_0015

//000124:             return min;
    IL_006d:  ldloc.0
    IL_006e:  stloc.3
    IL_006f:  br.s       IL_0071

//000125:         }
    IL_0071:  ldloc.3
    IL_0072:  ret
  } // end of method RayTracer::MinIntersection

  .method private hidebysig instance float64 
          TestRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray,
                  class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene) cil managed
  {
    // Code size       46 (0x2e)
    .maxstack  3
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect,
             [1] float64 CS$1$0000,
             [2] bool CS$4$0001)
//000126: 
//000127:         private double TestRay(Ray ray, Scene scene)
//000128:         {
    IL_0000:  nop
//000129:             ISect isect = MinIntersection(ray, scene);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  call       instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::MinIntersection(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene)
    IL_0009:  stloc.0
//000130:             if (ISect.IsNull(isect))
    IL_000a:  ldloc.0
    IL_000b:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::IsNull(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
    IL_0010:  ldc.i4.0
    IL_0011:  ceq
    IL_0013:  stloc.2
//000131:                 return 0;
//000132:             return isect.Dist;
//000133:         }
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
//000137:             ISect isect = MinIntersection(ray, scene);
//000138:             if (ISect.IsNull(isect))
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0014:  ldloc.2
    IL_0015:  brtrue.s   IL_0023

//000131:                 return 0;
    IL_0017:  ldc.r8     0.0
    IL_0020:  stloc.1
    IL_0021:  br.s       IL_002c

//000132:             return isect.Dist;
    IL_0023:  ldloc.0
    IL_0024:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_0029:  stloc.1
    IL_002a:  br.s       IL_002c

//000133:         }
    IL_002c:  ldloc.1
    IL_002d:  ret
  } // end of method RayTracer::TestRay

  .method private hidebysig instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          TraceRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray,
                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                   int32 depth) cil managed
  {
    // Code size       45 (0x2d)
    .maxstack  4
    .locals init ([0] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect,
             [1] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000,
             [2] bool CS$4$0001)
//000134: 
//000135:         private Color TraceRay(Ray ray, Scene scene, int depth)
//000136:         {
    IL_0000:  nop
//000137:             ISect isect = MinIntersection(ray, scene);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  call       instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::MinIntersection(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                       class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene)
    IL_0009:  stloc.0
//000138:             if (ISect.IsNull(isect))
    IL_000a:  ldloc.0
    IL_000b:  call       bool Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::IsNull(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect)
    IL_0010:  ldc.i4.0
    IL_0011:  ceq
    IL_0013:  stloc.2
//000139:                 return Color.Background;
//000140:             return Shade(isect, scene, depth);
//000141:         }
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
//000145:             Color ret = new Color(0, 0, 0);
//000146:             foreach (Light light in scene.Lights)
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0014:  ldloc.2
    IL_0015:  brtrue.s   IL_001f

//000139:                 return Color.Background;
    IL_0017:  ldsfld     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Background
    IL_001c:  stloc.1
    IL_001d:  br.s       IL_002b

//000140:             return Shade(isect, scene, depth);
    IL_001f:  ldarg.0
    IL_0020:  ldloc.0
    IL_0021:  ldarg.2
    IL_0022:  ldarg.3
    IL_0023:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::Shade(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect,
                                                                                                                                                                                                 class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                 int32)
    IL_0028:  stloc.1
    IL_0029:  br.s       IL_002b

//000141:         }
    IL_002b:  ldloc.1
    IL_002c:  ret
  } // end of method RayTracer::TraceRay

  .method private hidebysig instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          GetNaturalColor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing,
                          valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                          valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector norm,
                          valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector rd,
                          class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene) cil managed
  {
    // Code size       398 (0x18e)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 'ret',
             [1] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light light,
             [2] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector ldis,
             [3] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector livec,
             [4] float64 neatIsect,
             [5] bool isInShadow,
             [6] float64 illum,
             [7] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color lcolor,
             [8] float64 specular,
             [9] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color scolor,
             [10] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000,
             [11] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] CS$6$0001,
             [12] int32 CS$7$0002,
             [13] bool CS$4$0003)
//000142: 
//000143:         private Color GetNaturalColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene)
//000144:         {
    IL_0000:  nop
//000145:             Color ret = new Color(0, 0, 0);
    IL_0001:  ldloca.s   'ret'
    IL_0003:  ldc.r8     0.0
    IL_000c:  ldc.r8     0.0
    IL_0015:  ldc.r8     0.0
    IL_001e:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0023:  nop
//000146:             foreach (Light light in scene.Lights)
    IL_0024:  nop
    IL_0025:  ldarg.s    scene
    IL_0027:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light[] Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene::Lights
    IL_002c:  stloc.s    CS$6$0001
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_002e:  ldc.i4.0
    IL_002f:  stloc.s    CS$7$0002
    IL_0031:  br         IL_0175

//000146:             foreach (Light light in scene.Lights)
    IL_0036:  ldloc.s    CS$6$0001
    IL_0038:  ldloc.s    CS$7$0002
    IL_003a:  ldelem.ref
    IL_003b:  stloc.1
//000147:             {
    IL_003c:  nop
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
    IL_003d:  ldloc.1
    IL_003e:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_0043:  ldarg.2
    IL_0044:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0049:  stloc.2
//000149:                 Vector livec = Vector.Norm(ldis);
    IL_004a:  ldloc.2
    IL_004b:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0050:  stloc.3
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
    IL_0051:  ldarg.0
    IL_0052:  ldarg.2
    IL_0053:  ldloc.3
    IL_0054:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                 valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0059:  ldarg.s    scene
    IL_005b:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::TestRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                            class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene)
    IL_0060:  stloc.s    neatIsect
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
    IL_0062:  ldloc.s    neatIsect
    IL_0064:  ldloc.2
    IL_0065:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Mag(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_006a:  bgt.s      IL_007e

    IL_006c:  ldloc.s    neatIsect
    IL_006e:  ldc.r8     0.0
    IL_0077:  ceq
    IL_0079:  ldc.i4.0
    IL_007a:  ceq
    IL_007c:  br.s       IL_007f

    IL_007e:  ldc.i4.0
    IL_007f:  stloc.s    isInShadow
//000152:                 if (!isInShadow)
    IL_0081:  ldloc.s    isInShadow
    IL_0083:  stloc.s    CS$4$0003
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0085:  ldloc.s    CS$4$0003
    IL_0087:  brtrue     IL_016e

//000153:                 {
    IL_008c:  nop
//000154:                     double illum = Vector.Dot(livec, norm);
    IL_008d:  ldloc.3
    IL_008e:  ldarg.3
    IL_008f:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0094:  stloc.s    illum
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
    IL_0096:  ldloc.s    illum
    IL_0098:  ldc.r8     0.0
    IL_00a1:  bgt.s      IL_00c5

    IL_00a3:  ldc.r8     0.0
    IL_00ac:  ldc.r8     0.0
    IL_00b5:  ldc.r8     0.0
    IL_00be:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_00c3:  br.s       IL_00d2

    IL_00c5:  ldloc.s    illum
    IL_00c7:  ldloc.1
    IL_00c8:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_00cd:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_00d2:  stloc.s    lcolor
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
    IL_00d4:  ldloc.3
    IL_00d5:  ldarg.s    rd
    IL_00d7:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00dc:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00e1:  stloc.s    specular
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
    IL_00e3:  ldloc.s    specular
    IL_00e5:  ldc.r8     0.0
    IL_00ee:  bgt.s      IL_0112

    IL_00f0:  ldc.r8     0.0
    IL_00f9:  ldc.r8     0.0
    IL_0102:  ldc.r8     0.0
    IL_010b:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_0110:  br.s       IL_012f

    IL_0112:  ldloc.s    specular
    IL_0114:  ldarg.1
    IL_0115:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_011a:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Roughness
    IL_011f:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                            float64)
    IL_0124:  ldloc.1
    IL_0125:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_012a:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_012f:  stloc.s    scolor
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
    IL_0131:  ldloc.0
    IL_0132:  ldarg.1
    IL_0133:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_0138:  ldfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Diffuse
    IL_013d:  ldarg.2
    IL_013e:  callvirt   instance !1 class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
    IL_0143:  ldloc.s    lcolor
    IL_0145:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_014a:  ldarg.1
    IL_014b:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_0150:  ldfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Specular
    IL_0155:  ldarg.2
    IL_0156:  callvirt   instance !1 class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color>::Invoke(!0)
    IL_015b:  ldloc.s    scolor
    IL_015d:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_0162:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_0167:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_016c:  stloc.0
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
    IL_016d:  nop
//000161:             }
    IL_016e:  nop
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_016f:  ldloc.s    CS$7$0002
    IL_0171:  ldc.i4.1
    IL_0172:  add
    IL_0173:  stloc.s    CS$7$0002
//000146:             foreach (Light light in scene.Lights)
    IL_0175:  ldloc.s    CS$7$0002
    IL_0177:  ldloc.s    CS$6$0001
    IL_0179:  ldlen
    IL_017a:  conv.i4
    IL_017b:  clt
    IL_017d:  stloc.s    CS$4$0003
//000147:             {
//000148:                 Vector ldis = Vector.Minus(light.Pos, pos);
//000149:                 Vector livec = Vector.Norm(ldis);
//000150:                 double neatIsect = TestRay(new Ray(pos, livec), scene);
//000151:                 bool isInShadow = !((neatIsect > Vector.Mag(ldis)) || (neatIsect == 0));
//000152:                 if (!isInShadow)
//000153:                 {
//000154:                     double illum = Vector.Dot(livec, norm);
//000155:                     Color lcolor = illum > 0 ? Color.Times(illum, light.Color) : new Color(0, 0, 0);
//000156:                     double specular = Vector.Dot(livec, Vector.Norm(rd));
//000157:                     Color scolor = specular > 0 ? Color.Times(Math.Pow(specular, thing.Surface.Roughness), light.Color) : new Color(0, 0, 0);
//000158:                     ret = Color.Plus(ret, Color.Plus(Color.Times(thing.Surface.Diffuse(pos), lcolor),
//000159:                                                      Color.Times(thing.Surface.Specular(pos), scolor)));
//000160:                 }
//000161:             }
//000162:             return ret;
//000163:         }
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
//000168:         }
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
//000172:             Vector d = isect.Ray.Dir;
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
//000174:             Vector normal = isect.Thing.Normal(pos);
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
//000176:             Color ret = Color.DefaultColor;
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
//000178:             if (depth >= MaxDepth)
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_017f:  ldloc.s    CS$4$0003
    IL_0181:  brtrue     IL_0036

//000162:             return ret;
    IL_0186:  ldloc.0
    IL_0187:  stloc.s    CS$1$0000
    IL_0189:  br.s       IL_018b

//000163:         }
    IL_018b:  ldloc.s    CS$1$0000
    IL_018d:  ret
  } // end of method RayTracer::GetNaturalColor

  .method private hidebysig instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          GetReflectionColor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject thing,
                             valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                             valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector norm,
                             valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector rd,
                             class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                             int32 depth) cil managed
  {
    // Code size       48 (0x30)
    .maxstack  6
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000)
//000164: 
//000165:         private Color GetReflectionColor(SceneObject thing, Vector pos, Vector norm, Vector rd, Scene scene, int depth)
//000166:         {
    IL_0000:  nop
//000167:             return Color.Times(thing.Surface.Reflect(pos), TraceRay(new Ray(pos, rd), scene, depth + 1));
    IL_0001:  ldarg.1
    IL_0002:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Surface
    IL_0007:  ldfld      class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64> Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface::Reflect
    IL_000c:  ldarg.2
    IL_000d:  callvirt   instance !1 class [mscorlib]System.Func`2<valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,float64>::Invoke(!0)
    IL_0012:  ldarg.0
    IL_0013:  ldarg.2
    IL_0014:  ldarg.s    rd
    IL_0016:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::.ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                 valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_001b:  ldarg.s    scene
    IL_001d:  ldarg.s    depth
    IL_001f:  ldc.i4.1
    IL_0020:  add
    IL_0021:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::TraceRay(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                                                                                                    class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                    int32)
    IL_0026:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Times(float64,
                                                                                                                                                                                    valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_002b:  stloc.0
    IL_002c:  br.s       IL_002e

//000168:         }
    IL_002e:  ldloc.0
    IL_002f:  ret
  } // end of method RayTracer::GetReflectionColor

  .method private hidebysig instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 
          Shade(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect isect,
                class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene scene,
                int32 depth) cil managed
  {
    // Code size       232 (0xe8)
    .maxstack  8
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector d,
             [1] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
             [2] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector normal,
             [3] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector reflectDir,
             [4] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color 'ret',
             [5] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color CS$1$0000,
             [6] bool CS$4$0001)
//000169: 
//000170:         private Color Shade(ISect isect, Scene scene, int depth)
//000171:         {
    IL_0000:  nop
//000172:             Vector d = isect.Ray.Dir;
    IL_0001:  ldarg.1
    IL_0002:  ldflda     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_0007:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_000c:  stloc.0
//000173:             Vector pos = Vector.Plus(Vector.Times(isect.Dist, isect.Ray.Dir), isect.Ray.Start);
    IL_000d:  ldarg.1
    IL_000e:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Dist
    IL_0013:  ldarg.1
    IL_0014:  ldflda     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_0019:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_001e:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0023:  ldarg.1
    IL_0024:  ldflda     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Ray
    IL_0029:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_002e:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0033:  stloc.1
//000174:             Vector normal = isect.Thing.Normal(pos);
    IL_0034:  ldarg.1
    IL_0035:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_003a:  ldloc.1
    IL_003b:  callvirt   instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::Normal(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0040:  stloc.2
//000175:             Vector reflectDir = Vector.Minus(d, Vector.Times(2 * Vector.Dot(normal, d), normal));
    IL_0041:  ldloc.0
    IL_0042:  ldc.r8     2.
    IL_004b:  ldloc.2
    IL_004c:  ldloc.0
    IL_004d:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0052:  mul
    IL_0053:  ldloc.2
    IL_0054:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0059:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_005e:  stloc.3
//000176:             Color ret = Color.DefaultColor;
    IL_005f:  ldsfld     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::DefaultColor
    IL_0064:  stloc.s    'ret'
//000177:             ret = Color.Plus(ret, GetNaturalColor(isect.Thing, pos, normal, reflectDir, scene));
    IL_0066:  ldloc.s    'ret'
    IL_0068:  ldarg.0
    IL_0069:  ldarg.1
    IL_006a:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_006f:  ldloc.1
    IL_0070:  ldloc.2
    IL_0071:  ldloc.3
    IL_0072:  ldarg.2
    IL_0073:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetNaturalColor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,
                                                                                                                                                                                                           valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                           valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                           valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                           class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene)
    IL_0078:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_007d:  stloc.s    'ret'
//000178:             if (depth >= MaxDepth)
    IL_007f:  ldarg.3
    IL_0080:  ldc.i4.5
    IL_0081:  clt
    IL_0083:  stloc.s    CS$4$0001
//000179:             {
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
//000183:         }
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
//000188:         }
//000189:         private double RecenterY(double y)
//000190:         {
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
//000192:         }
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
//000199:     }
//000200: }
    IL_0085:  ldloc.s    CS$4$0001
    IL_0087:  brtrue.s   IL_00b5

//000179:             {
    IL_0089:  nop
//000180:                 return Color.Plus(ret, new Color(.5, .5, .5));
    IL_008a:  ldloc.s    'ret'
    IL_008c:  ldc.r8     0.5
    IL_0095:  ldc.r8     0.5
    IL_009e:  ldc.r8     0.5
    IL_00a7:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::.ctor(float64,
                                                                                                                   float64,
                                                                                                                   float64)
    IL_00ac:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_00b1:  stloc.s    CS$1$0000
    IL_00b3:  br.s       IL_00e5

//000181:             }
//000182:             return Color.Plus(ret, GetReflectionColor(isect.Thing, Vector.Plus(pos, Vector.Times(.001, reflectDir)), normal, reflectDir, scene, depth));
    IL_00b5:  ldloc.s    'ret'
    IL_00b7:  ldarg.0
    IL_00b8:  ldarg.1
    IL_00b9:  ldfld      class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Thing
    IL_00be:  ldloc.1
    IL_00bf:  ldc.r8     1.e-003
    IL_00c8:  ldloc.3
    IL_00c9:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00ce:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_00d3:  ldloc.2
    IL_00d4:  ldloc.3
    IL_00d5:  ldarg.2
    IL_00d6:  ldarg.3
    IL_00d7:  call       instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::GetReflectionColor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,
                                                                                                                                                                                                              valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                              valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                              valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                                              class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Scene,
                                                                                                                                                                                                              int32)
    IL_00dc:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color,
                                                                                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color)
    IL_00e1:  stloc.s    CS$1$0000
    IL_00e3:  br.s       IL_00e5

//000183:         }
    IL_00e5:  ldloc.s    CS$1$0000
    IL_00e7:  ret
  } // end of method RayTracer::Shade

  .method private hidebysig instance float64 
          RecenterX(float64 x) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000184: 
//000185:         private double RecenterX(double x)
//000186:         {
    IL_0000:  nop
//000187:             return (x - (screenWidth / 2.0)) / (2.0 * screenWidth);
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_0008:  conv.r8
    IL_0009:  ldc.r8     2.
    IL_0012:  div
    IL_0013:  sub
    IL_0014:  ldc.r8     2.
    IL_001d:  ldarg.0
    IL_001e:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenWidth
    IL_0023:  conv.r8
    IL_0024:  mul
    IL_0025:  div
    IL_0026:  stloc.0
    IL_0027:  br.s       IL_0029

//000188:         }
    IL_0029:  ldloc.0
    IL_002a:  ret
  } // end of method RayTracer::RecenterX

  .method private hidebysig instance float64 
          RecenterY(float64 y) cil managed
  {
    // Code size       44 (0x2c)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000189:         private double RecenterY(double y)
//000190:         {
    IL_0000:  nop
//000191:             return -(y - (screenHeight / 2.0)) / (2.0 * screenHeight);
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0008:  conv.r8
    IL_0009:  ldc.r8     2.
    IL_0012:  div
    IL_0013:  sub
    IL_0014:  neg
    IL_0015:  ldc.r8     2.
    IL_001e:  ldarg.0
    IL_001f:  ldfld      int32 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::screenHeight
    IL_0024:  conv.r8
    IL_0025:  mul
    IL_0026:  div
    IL_0027:  stloc.0
    IL_0028:  br.s       IL_002a

//000192:         }
    IL_002a:  ldloc.0
    IL_002b:  ret
  } // end of method RayTracer::RecenterY

  .method private hidebysig instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          GetPoint(float64 x,
                   float64 y,
                   class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera camera) cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000193: 
//000194:         private Vector GetPoint(double x, double y, Camera camera)
//000195:         {
    IL_0000:  nop
//000196:             return Vector.Norm(Vector.Plus(camera.Forward, Vector.Plus(Vector.Times(RecenterX(x), camera.Right),
    IL_0001:  ldarg.3
    IL_0002:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Forward
    IL_0007:  ldarg.0
    IL_0008:  ldarg.1
    IL_0009:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RecenterX(float64)
    IL_000e:  ldarg.3
    IL_000f:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Right
    IL_0014:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0019:  ldarg.0
    IL_001a:  ldarg.2
    IL_001b:  call       instance float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer::RecenterY(float64)
    IL_0020:  ldarg.3
    IL_0021:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Camera::Up
    IL_0026:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Times(float64,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_002b:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0030:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Plus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                     valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0035:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_003a:  stloc.0
    IL_003b:  br.s       IL_003d

//000197:                                                                        Vector.Times(RecenterY(y), camera.Up))));
//000198:         }
    IL_003d:  ldloc.0
    IL_003e:  ret
  } // end of method RayTracer::GetPoint

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.RayTracer

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere
       extends Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject
{
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Center
  .field public float64 Radius
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector center,
                               float64 radius,
                               class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface surface) cil managed
  {
    // Code size       25 (0x19)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Sphere.cs' 
//000018:         public Sphere(Vector center, double radius, Surface surface) : base(surface) { Center = center; Radius = radius; }
    IL_0000:  ldarg.0
    IL_0001:  ldarg.3
    IL_0002:  call       instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Surface)
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  ldarg.0
    IL_000a:  ldarg.1
    IL_000b:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_0010:  ldarg.0
    IL_0011:  ldarg.2
    IL_0012:  stfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_0017:  nop
    IL_0018:  ret
  } // end of method Sphere::.ctor

  .method public hidebysig virtual instance class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect 
          Intersect(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray ray) cil managed
  {
    // Code size       193 (0xc1)
    .maxstack  4
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector eo,
             [1] float64 v,
             [2] float64 dist,
             [3] float64 disc,
             [4] class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect CS$1$0000,
             [5] bool CS$4$0001)
//000019: 
//000020:         public override ISect Intersect(Ray ray)
//000021:         {
    IL_0000:  nop
//000022:             Vector eo = Vector.Minus(Center, ray.Start);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_0007:  ldarga.s   ray
    IL_0009:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_000e:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0013:  stloc.0
//000023:             double v = Vector.Dot(eo, ray.Dir);
    IL_0014:  ldloc.0
    IL_0015:  ldarga.s   ray
    IL_0017:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_001c:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0021:  stloc.1
//000024:             double dist;
//000025:             if (v < 0)
    IL_0022:  ldloc.1
    IL_0023:  ldc.r8     0.0
    IL_002c:  clt
    IL_002e:  ldc.i4.0
    IL_002f:  ceq
    IL_0031:  stloc.s    CS$4$0001
//000026:             {
//000027:                 dist = 0;
//000028:             }
//000029:             else
//000030:             {
//000031:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000032:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000033:             }
//000034:             if (dist == 0) return ISect.Null;
//000035:             return new ISect(this, ray, dist);
//000036:         }
//000037: 
//000038:         public override Vector Normal(Vector pos)
//000039:         {
//000040:             return Vector.Norm(Vector.Minus(pos, Center));
//000041:         }
//000042:     }
//000043: }
    IL_0033:  ldloc.s    CS$4$0001
    IL_0035:  brtrue.s   IL_0045

//000026:             {
    IL_0037:  nop
//000027:                 dist = 0;
    IL_0038:  ldc.r8     0.0
    IL_0041:  stloc.2
//000028:             }
    IL_0042:  nop
//000029:             else
//000030:             {
//000031:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
//000032:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
//000033:             }
//000034:             if (dist == 0) return ISect.Null;
//000035:             return new ISect(this, ray, dist);
//000036:         }
//000037: 
//000038:         public override Vector Normal(Vector pos)
//000039:         {
//000040:             return Vector.Norm(Vector.Minus(pos, Center));
//000041:         }
//000042:     }
//000043: }
    IL_0043:  br.s       IL_0094

//000030:             {
    IL_0045:  nop
//000031:                 double disc = Math.Pow(Radius, 2) - (Vector.Dot(eo, eo) - Math.Pow(v, 2));
    IL_0046:  ldarg.0
    IL_0047:  ldfld      float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Radius
    IL_004c:  ldc.r8     2.
    IL_0055:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                            float64)
    IL_005a:  ldloc.0
    IL_005b:  ldloc.0
    IL_005c:  call       float64 Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Dot(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                            valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0061:  ldloc.1
    IL_0062:  ldc.r8     2.
    IL_006b:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                            float64)
    IL_0070:  sub
    IL_0071:  sub
    IL_0072:  stloc.3
//000032:                 dist = disc < 0 ? 0 : v - Math.Sqrt(disc);
    IL_0073:  ldloc.3
    IL_0074:  ldc.r8     0.0
    IL_007d:  blt.s      IL_0089

    IL_007f:  ldloc.1
    IL_0080:  ldloc.3
    IL_0081:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_0086:  sub
    IL_0087:  br.s       IL_0092

    IL_0089:  ldc.r8     0.0
    IL_0092:  stloc.2
//000033:             }
    IL_0093:  nop
//000034:             if (dist == 0) return ISect.Null;
    IL_0094:  ldloc.2
    IL_0095:  ldc.r8     0.0
    IL_009e:  ceq
    IL_00a0:  ldc.i4.0
    IL_00a1:  ceq
    IL_00a3:  stloc.s    CS$4$0001
//000035:             return new ISect(this, ray, dist);
//000036:         }
//000037: 
//000038:         public override Vector Normal(Vector pos)
//000039:         {
//000040:             return Vector.Norm(Vector.Minus(pos, Center));
//000041:         }
//000042:     }
//000043: }
    IL_00a5:  ldloc.s    CS$4$0001
    IL_00a7:  brtrue.s   IL_00b2

//000034:             if (dist == 0) return ISect.Null;
    IL_00a9:  ldsfld     class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::Null
    IL_00ae:  stloc.s    CS$1$0000
    IL_00b0:  br.s       IL_00be

//000035:             return new ISect(this, ray, dist);
    IL_00b2:  ldarg.0
    IL_00b3:  ldarg.1
    IL_00b4:  ldloc.2
    IL_00b5:  newobj     instance void Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.ISect::.ctor(class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.SceneObject,
                                                                                                                   valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray,
                                                                                                                   float64)
    IL_00ba:  stloc.s    CS$1$0000
    IL_00bc:  br.s       IL_00be

//000036:         }
    IL_00be:  ldloc.s    CS$1$0000
    IL_00c0:  ret
  } // end of method Sphere::Intersect

  .method public hidebysig virtual instance valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector 
          Normal(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos) cil managed
  {
    // Code size       23 (0x17)
    .maxstack  2
    .locals init ([0] valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector CS$1$0000)
//000037: 
//000038:         public override Vector Normal(Vector pos)
//000039:         {
    IL_0000:  nop
//000040:             return Vector.Norm(Vector.Minus(pos, Center));
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere::Center
    IL_0008:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Minus(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector,
                                                                                                                                                                                      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_000d:  call       valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector::Norm(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector)
    IL_0012:  stloc.0
    IL_0013:  br.s       IL_0015

//000041:         }
    IL_0015:  ldloc.0
    IL_0016:  ret
  } // end of method Sphere::Normal

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Sphere

.class private auto ansi beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light
       extends [mscorlib]System.Object
{
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Pos
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Color
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector pos,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color color) cil managed
  {
    // Code size       24 (0x18)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Light.cs' 
//000016:         public Light(Vector pos, Color color) { Pos = pos; Color = color; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Pos
    IL_000f:  ldarg.0
    IL_0010:  ldarg.2
    IL_0011:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Color Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light::Color
    IL_0016:  nop
    IL_0017:  ret
  } // end of method Light::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Light

.class private sequential ansi sealed beforefieldinit Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray
       extends [mscorlib]System.ValueType
{
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Start
  .field public valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Dir
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector start,
                               valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector dir) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Raytracer\Raytracer_CSharp\Ray.cs' 
//000016:         public Ray(Vector start, Vector dir) { Start = start; Dir = dir; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Start
    IL_0008:  ldarg.0
    IL_0009:  ldarg.2
    IL_000a:  stfld      valuetype Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Vector Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray::Dir
    IL_000f:  ret
  } // end of method Ray::.ctor

} // end of class Microsoft.ParallelComputingPlatform.ParallelExtensions.Samples.Ray


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
