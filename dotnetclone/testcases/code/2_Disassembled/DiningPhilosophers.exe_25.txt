
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern PresentationFramework
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly extern System.Xaml
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern PresentationCore
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly extern WindowsBase
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly extern System.Core
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly DiningPhilosophers
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 29 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ..).NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 2C 50 72   // ,Version=v4.0,Pr
                                                                                                        6F 66 69 6C 65 3D 43 6C 69 65 6E 74 01 00 54 0E   // ofile=Client..T.
                                                                                                        14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C 61   // .FrameworkDispla
                                                                                                        79 4E 61 6D 65 1F 2E 4E 45 54 20 46 72 61 6D 65   // yName..NET Frame
                                                                                                        77 6F 72 6B 20 34 20 43 6C 69 65 6E 74 20 50 72   // work 4 Client Pr
                                                                                                        6F 66 69 6C 65 )                                  // ofile
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 12 44 69 6E 69 6E 67 50 68 69 6C 6F 73 6F   // ...DiningPhiloso
                                                                                              70 68 65 72 73 00 00 )                            // phers..
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 12 44 69 6E 69 6E 67 50 68 69 6C 6F 73 6F   // ...DiningPhiloso
                                                                                                70 68 65 72 73 00 00 )                            // phers..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [PresentationFramework]System.Windows.ThemeInfoAttribute::.ctor(valuetype [PresentationFramework]System.Windows.ResourceDictionaryLocation,
                                                                                        valuetype [PresentationFramework]System.Windows.ResourceDictionaryLocation) = ( 01 00 00 00 00 00 01 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public DiningPhilosophers.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public DiningPhilosophers.g.resources
{
  // Offset: 0x000000B8 Length: 0x000004C3
}
.module DiningPhilosophers.exe
// MVID: {9AEDBD38-242D-400C-902F-6275963DA94B}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x00300000


// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi sealed beforefieldinit DiningPhilosophers.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .field private static class DiningPhilosophers.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class DiningPhilosophers.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class DiningPhilosophers.Properties.Settings CS$1$0000)
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\Properties\Settings.Designer.cs' 
//000025:             {
    IL_0000:  nop
//000026:                 return defaultInstance;
    IL_0001:  ldsfld     class DiningPhilosophers.Properties.Settings DiningPhilosophers.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000027:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000020:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void DiningPhilosophers.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  DiningPhilosophers.Properties.Settings
    IL_000f:  stsfld     class DiningPhilosophers.Properties.Settings DiningPhilosophers.Properties.Settings::defaultInstance
//000021: 
//000022:         public static Settings Default
//000023:         {
//000024:             get
//000025:             {
//000026:                 return defaultInstance;
//000027:             }
//000028:         }
//000029:     }
//000030: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class DiningPhilosophers.Properties.Settings
          Default()
  {
    .get class DiningPhilosophers.Properties.Settings DiningPhilosophers.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class DiningPhilosophers.Properties.Settings

.class public auto ansi beforefieldinit DiningPhilosophers.MainWindow
       extends [PresentationFramework]System.Windows.Window
       implements [System.Xaml]System.Windows.Markup.IComponentConnector
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 16 50 72 65 73 65 6E 74 61 74 69 6F 6E 42   // ...PresentationB
                                                                                                  75 69 6C 64 54 61 73 6B 73 07 34 2E 30 2E 30 2E   // uildTasks.4.0.0.
                                                                                                  30 00 00 )                                        // 0..
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [mscorlib]System.Threading.SemaphoreSlim[] forks
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass6'::.ctor

  } // end of class '<>c__DisplayClass6'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass8'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class DiningPhilosophers.MainWindow/'<>c__DisplayClass6' 'CS$<>8__locals7'
    .field public int32 index
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass8'::.ctor

    .method public hidebysig instance void 
            '<RunWithSemaphoresSyncWithOrderedForks>b__4'() cil managed
    {
      // Code size       35 (0x23)
      .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\MainWindow.xaml.cs' 
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass6' DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::'CS$<>8__locals7'
      IL_0006:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass6'::'<>4__this'
      IL_000b:  ldarg.0
      IL_000c:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass6' DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::'CS$<>8__locals7'
      IL_0011:  ldfld      class [mscorlib]System.Threading.SemaphoreSlim[] DiningPhilosophers.MainWindow/'<>c__DisplayClass6'::forks
      IL_0016:  ldarg.0
      IL_0017:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::index
      IL_001c:  call       instance void DiningPhilosophers.MainWindow::RunPhilosopherSyncWithOrderedForks(class [mscorlib]System.Threading.SemaphoreSlim[],
                                                                                                           int32)
      IL_0021:  nop
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0022:  ret
    } // end of method '<>c__DisplayClass8'::'<RunWithSemaphoresSyncWithOrderedForks>b__4'

  } // end of class '<>c__DisplayClass8'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass10'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .field public int32 index
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass10'::.ctor

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithOrderedForks>b__a'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_think
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__a'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithOrderedForks>b__b'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_wait
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__b'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithOrderedForks>b__c'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_eat
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__c'

  } // end of class '<>c__DisplayClass10'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass15'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System]System.Threading.Semaphore[] forks
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass15'::.ctor

  } // end of class '<>c__DisplayClass15'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass17'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class DiningPhilosophers.MainWindow/'<>c__DisplayClass15' 'CS$<>8__locals16'
    .field public int32 index
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass17'::.ctor

    .method public hidebysig instance void 
            '<RunWithSemaphoresSyncWithWaitAll>b__13'() cil managed
    {
      // Code size       35 (0x23)
      .maxstack  8
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass15' DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::'CS$<>8__locals16'
      IL_0006:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass15'::'<>4__this'
      IL_000b:  ldarg.0
      IL_000c:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass15' DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::'CS$<>8__locals16'
      IL_0011:  ldfld      class [System]System.Threading.Semaphore[] DiningPhilosophers.MainWindow/'<>c__DisplayClass15'::forks
      IL_0016:  ldarg.0
      IL_0017:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::index
      IL_001c:  call       instance void DiningPhilosophers.MainWindow::RunPhilosopherSyncWithWaitAll(class [System]System.Threading.Semaphore[],
                                                                                                      int32)
      IL_0021:  nop
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0022:  ret
    } // end of method '<>c__DisplayClass17'::'<RunWithSemaphoresSyncWithWaitAll>b__13'

  } // end of class '<>c__DisplayClass17'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1f'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .field public int32 index
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1f'::.ctor

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithWaitAll>b__19'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_think
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__19'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithWaitAll>b__1a'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_wait
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__1a'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherSyncWithWaitAll>b__1b'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_eat
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__1b'

  } // end of class '<>c__DisplayClass1f'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass2d'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .field public int32 index
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass2d'::.ctor

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherAsync>b__23'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_think
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__23'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherAsync>b__25'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_wait
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__25'

    .method public hidebysig instance class [PresentationCore]System.Windows.Media.Brush 
            '<RunPhilosopherAsync>b__26'() cil managed
    {
      // Code size       43 (0x2b)
      .maxstack  3
      .locals init ([0] class [PresentationCore]System.Windows.Media.Brush CS$1$0000,
               [1] class [PresentationCore]System.Windows.Media.Brush CS$0$0001)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0006:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
      IL_000b:  ldarg.0
      IL_000c:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_0011:  ldelem.ref
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
      IL_0018:  ldfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_eat
      IL_001d:  dup
      IL_001e:  stloc.1
      IL_001f:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
      IL_0024:  nop
      IL_0025:  ldloc.1
      IL_0026:  stloc.0
      IL_0027:  br.s       IL_0029

//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0029:  ldloc.0
      IL_002a:  ret
    } // end of method '<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__26'

  } // end of class '<>c__DisplayClass2d'

  .class auto ansi sealed nested private beforefieldinit '<RunPhilosopherAsync>d__2f'
         extends [mscorlib]System.Object
         implements class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Threading.Tasks.Task>,
                    [mscorlib]System.Collections.IEnumerable,
                    class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Threading.Tasks.Task>,
                    [mscorlib]System.Collections.IEnumerator,
                    [mscorlib]System.IDisposable
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field private class [mscorlib]System.Threading.Tasks.Task '<>2__current'
    .field private int32 '<>1__state'
    .field private int32 '<>l__initialThreadId'
    .field public class DiningPhilosophers.MainWindow '<>4__this'
    .field public class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] forks
    .field public class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] '<>3__forks'
    .field public int32 index
    .field public int32 '<>3__index'
    .field public int32 '<fork1Id>5__30'
    .field public int32 '<fork2Id>5__31'
    .field public class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore '<fork1>5__32'
    .field public class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore '<fork2>5__33'
    .field public class [mscorlib]System.Random '<rand>5__34'
    .field public class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate28'
    .field public class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate2a'
    .field public class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate2b'
    .field public class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' 'CS$<>8__locals2e'
    .method private hidebysig newslot virtual final 
            instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Threading.Tasks.Task> 
            'System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>.GetEnumerator'() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override  method instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Threading.Tasks.Task>::GetEnumerator()
      // Code size       98 (0x62)
      .maxstack  2
      .locals init (class DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f' V_0,
               class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Threading.Tasks.Task> V_1,
               bool V_2)
      IL_0000:  call       class [mscorlib]System.Threading.Thread [mscorlib]System.Threading.Thread::get_CurrentThread()
      IL_0005:  callvirt   instance int32 [mscorlib]System.Threading.Thread::get_ManagedThreadId()
      IL_000a:  ldarg.0
      IL_000b:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>l__initialThreadId'
      IL_0010:  bne.un.s   IL_0021

      IL_0012:  ldarg.0
      IL_0013:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_0018:  ldc.i4.s   -2
      IL_001a:  ceq
      IL_001c:  ldc.i4.0
      IL_001d:  ceq
      IL_001f:  br.s       IL_0022

      IL_0021:  ldc.i4.1
      IL_0022:  stloc.2
      IL_0023:  ldloc.2
      IL_0024:  brtrue.s   IL_0031

      IL_0026:  ldarg.0
      IL_0027:  ldc.i4.0
      IL_0028:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_002d:  ldarg.0
      IL_002e:  stloc.0
      IL_002f:  br.s       IL_0044

      IL_0031:  ldc.i4.0
      IL_0032:  newobj     instance void DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::.ctor(int32)
      IL_0037:  stloc.0
      IL_0038:  ldloc.0
      IL_0039:  ldarg.0
      IL_003a:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_003f:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_0044:  ldloc.0
      IL_0045:  ldarg.0
      IL_0046:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>3__forks'
      IL_004b:  stfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::forks
      IL_0050:  ldloc.0
      IL_0051:  ldarg.0
      IL_0052:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>3__index'
      IL_0057:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::index
      IL_005c:  ldloc.0
      IL_005d:  stloc.1
      IL_005e:  br.s       IL_0060

      IL_0060:  ldloc.1
      IL_0061:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::'System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>.GetEnumerator'

    .method private hidebysig newslot virtual final 
            instance class [mscorlib]System.Collections.IEnumerator 
            System.Collections.IEnumerable.GetEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerable::GetEnumerator
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (class [mscorlib]System.Collections.IEnumerator V_0)
      IL_0000:  ldarg.0
      IL_0001:  call       instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Threading.Tasks.Task> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>.GetEnumerator'()
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::System.Collections.IEnumerable.GetEnumerator

    .method private hidebysig newslot virtual final 
            instance bool  MoveNext() cil managed
    {
      .override [mscorlib]System.Collections.IEnumerator::MoveNext
      // Code size       801 (0x321)
      .maxstack  6
      .locals init ([0] bool CS$1$0000,
               [1] int32 CS$4$0001,
               [2] bool CS$4$0002)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_0006:  stloc.1
      IL_0007:  ldloc.1
      IL_0008:  switch     ( 
                            IL_0052,
                            IL_002f,
                            IL_0034,
                            IL_0039,
                            IL_003e,
                            IL_0043,
                            IL_0048,
                            IL_004d)
      IL_002d:  br.s       IL_0054

      IL_002f:  br         IL_015c

      IL_0034:  br         IL_01b3

      IL_0039:  br         IL_01d9

      IL_003e:  br         IL_022b

      IL_0043:  br         IL_0251

      IL_0048:  br         IL_02a0

      IL_004d:  br         IL_02f4

      IL_0052:  br.s       IL_0059

      IL_0054:  br         IL_031b

      IL_0059:  ldarg.0
      IL_005a:  ldc.i4.m1
      IL_005b:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_0060:  ldarg.0
      IL_0061:  ldnull
      IL_0062:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate28'
      IL_0067:  ldarg.0
      IL_0068:  ldnull
      IL_0069:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2a'
      IL_006e:  ldarg.0
      IL_006f:  ldnull
      IL_0070:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2b'
      IL_0075:  ldarg.0
      IL_0076:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::.ctor()
      IL_007b:  stfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_0080:  ldarg.0
      IL_0081:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_0086:  ldarg.0
      IL_0087:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::index
      IL_008c:  stfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_0091:  ldarg.0
      IL_0092:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_0097:  ldarg.0
      IL_0098:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_009d:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<>4__this'
//000198:         {
      IL_00a2:  nop
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
      IL_00a3:  ldarg.0
      IL_00a4:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_00a9:  ldarg.0
      IL_00aa:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_00af:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_00b4:  ldarg.0
      IL_00b5:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::forks
      IL_00ba:  ldlen
      IL_00bb:  conv.i4
      IL_00bc:  ldarg.0
      IL_00bd:  ldflda     int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork1Id>5__30'
      IL_00c2:  ldarg.0
      IL_00c3:  ldflda     int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork2Id>5__31'
      IL_00c8:  ldc.i4.1
      IL_00c9:  callvirt   instance void DiningPhilosophers.MainWindow::GetForkIds(int32,
                                                                                   int32,
                                                                                   int32&,
                                                                                   int32&,
                                                                                   bool)
      IL_00ce:  nop
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
      IL_00cf:  ldarg.0
      IL_00d0:  ldarg.0
      IL_00d1:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::forks
      IL_00d6:  ldarg.0
      IL_00d7:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork1Id>5__30'
      IL_00dc:  ldelem.ref
      IL_00dd:  stfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork1>5__32'
      IL_00e2:  ldarg.0
      IL_00e3:  ldarg.0
      IL_00e4:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::forks
      IL_00e9:  ldarg.0
      IL_00ea:  ldfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork2Id>5__31'
      IL_00ef:  ldelem.ref
      IL_00f0:  stfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork2>5__33'
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
      IL_00f5:  ldarg.0
      IL_00f6:  ldarg.0
      IL_00f7:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_00fc:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::index
      IL_0101:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
      IL_0106:  stfld      class [mscorlib]System.Random DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<rand>5__34'
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_010b:  br         IL_0314

//000207:             {
      IL_0110:  nop
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
      IL_0111:  ldarg.0
      IL_0112:  ldarg.0
      IL_0113:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_0118:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
      IL_011d:  ldarg.0
      IL_011e:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate28'
      IL_0123:  brtrue.s   IL_013e

      IL_0125:  ldarg.0
      IL_0126:  ldarg.0
      IL_0127:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_012c:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__23'()
      IL_0132:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                  native int)
      IL_0137:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate28'
      IL_013c:  br.s       IL_013e

      IL_013e:  ldarg.0
      IL_013f:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate28'
      IL_0144:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
      IL_0149:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_014e:  ldarg.0
      IL_014f:  ldc.i4.1
      IL_0150:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_0155:  ldc.i4.1
      IL_0156:  stloc.0
      IL_0157:  br         IL_031f

      IL_015c:  ldarg.0
      IL_015d:  ldc.i4.m1
      IL_015e:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
      IL_0163:  ldarg.0
      IL_0164:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
      IL_0169:  ldarg.0
      IL_016a:  ldfld      class [mscorlib]System.Random DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<rand>5__34'
      IL_016f:  ldc.i4.s   10
      IL_0171:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0176:  ldc.i4     0xc8
      IL_017b:  mul
      IL_017c:  ldsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate29'
      IL_0181:  brtrue.s   IL_0196

      IL_0183:  ldnull
      IL_0184:  ldftn      void DiningPhilosophers.MainWindow::'<RunPhilosopherAsync>b__24'()
      IL_018a:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_018f:  stsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate29'
      IL_0194:  br.s       IL_0196

      IL_0196:  ldsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate29'
      IL_019b:  call       class [mscorlib]System.Threading.Tasks.Task [ParallelExtensionsExtras]System.Threading.Tasks.TaskFactoryExtensions::StartNewDelayed(class [mscorlib]System.Threading.Tasks.TaskFactory,
                                                                                                                                                               int32,
                                                                                                                                                               class [mscorlib]System.Action)
      IL_01a0:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_01a5:  ldarg.0
      IL_01a6:  ldc.i4.2
      IL_01a7:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_01ac:  ldc.i4.1
      IL_01ad:  stloc.0
      IL_01ae:  br         IL_031f

      IL_01b3:  ldarg.0
      IL_01b4:  ldc.i4.m1
      IL_01b5:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000213:                 yield return fork1.WaitAsync();
      IL_01ba:  ldarg.0
      IL_01bb:  ldarg.0
      IL_01bc:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork1>5__32'
      IL_01c1:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore::WaitAsync()
      IL_01c6:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_01cb:  ldarg.0
      IL_01cc:  ldc.i4.3
      IL_01cd:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_01d2:  ldc.i4.1
      IL_01d3:  stloc.0
      IL_01d4:  br         IL_031f

      IL_01d9:  ldarg.0
      IL_01da:  ldc.i4.m1
      IL_01db:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
      IL_01e0:  ldarg.0
      IL_01e1:  ldarg.0
      IL_01e2:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_01e7:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
      IL_01ec:  ldarg.0
      IL_01ed:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2a'
      IL_01f2:  brtrue.s   IL_020d

      IL_01f4:  ldarg.0
      IL_01f5:  ldarg.0
      IL_01f6:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_01fb:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__25'()
      IL_0201:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                  native int)
      IL_0206:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2a'
      IL_020b:  br.s       IL_020d

      IL_020d:  ldarg.0
      IL_020e:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2a'
      IL_0213:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
      IL_0218:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_021d:  ldarg.0
      IL_021e:  ldc.i4.4
      IL_021f:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_0224:  ldc.i4.1
      IL_0225:  stloc.0
      IL_0226:  br         IL_031f

      IL_022b:  ldarg.0
      IL_022c:  ldc.i4.m1
      IL_022d:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000215:                 yield return fork2.WaitAsync();
      IL_0232:  ldarg.0
      IL_0233:  ldarg.0
      IL_0234:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork2>5__33'
      IL_0239:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore::WaitAsync()
      IL_023e:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0243:  ldarg.0
      IL_0244:  ldc.i4.5
      IL_0245:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_024a:  ldc.i4.1
      IL_024b:  stloc.0
      IL_024c:  br         IL_031f

      IL_0251:  ldarg.0
      IL_0252:  ldc.i4.m1
      IL_0253:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
      IL_0258:  ldarg.0
      IL_0259:  ldarg.0
      IL_025a:  ldfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
      IL_025f:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
      IL_0264:  ldarg.0
      IL_0265:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2b'
      IL_026a:  brtrue.s   IL_0285

      IL_026c:  ldarg.0
      IL_026d:  ldarg.0
      IL_026e:  ldfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass2d' DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>8__locals2e'
      IL_0273:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass2d'::'<RunPhilosopherAsync>b__26'()
      IL_0279:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                  native int)
      IL_027e:  stfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2b'
      IL_0283:  br.s       IL_0285

      IL_0285:  ldarg.0
      IL_0286:  ldfld      class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'CS$<>9__CachedAnonymousMethodDelegate2b'
      IL_028b:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
      IL_0290:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0295:  ldarg.0
      IL_0296:  ldc.i4.6
      IL_0297:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_029c:  ldc.i4.1
      IL_029d:  stloc.0
      IL_029e:  br.s       IL_031f

      IL_02a0:  ldarg.0
      IL_02a1:  ldc.i4.m1
      IL_02a2:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
      IL_02a7:  ldarg.0
      IL_02a8:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
      IL_02ad:  ldarg.0
      IL_02ae:  ldfld      class [mscorlib]System.Random DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<rand>5__34'
      IL_02b3:  ldc.i4.s   10
      IL_02b5:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_02ba:  ldc.i4     0xc8
      IL_02bf:  mul
      IL_02c0:  ldsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2c'
      IL_02c5:  brtrue.s   IL_02da

      IL_02c7:  ldnull
      IL_02c8:  ldftn      void DiningPhilosophers.MainWindow::'<RunPhilosopherAsync>b__27'()
      IL_02ce:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_02d3:  stsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2c'
      IL_02d8:  br.s       IL_02da

      IL_02da:  ldsfld     class [mscorlib]System.Action DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2c'
      IL_02df:  call       class [mscorlib]System.Threading.Tasks.Task [ParallelExtensionsExtras]System.Threading.Tasks.TaskFactoryExtensions::StartNewDelayed(class [mscorlib]System.Threading.Tasks.TaskFactory,
                                                                                                                                                               int32,
                                                                                                                                                               class [mscorlib]System.Action)
      IL_02e4:  stfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_02e9:  ldarg.0
      IL_02ea:  ldc.i4.7
      IL_02eb:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_02f0:  ldc.i4.1
      IL_02f1:  stloc.0
      IL_02f2:  br.s       IL_031f

      IL_02f4:  ldarg.0
      IL_02f5:  ldc.i4.m1
      IL_02f6:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
//000222:                 fork1.Release();
      IL_02fb:  ldarg.0
      IL_02fc:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork1>5__32'
      IL_0301:  callvirt   instance void [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore::Release()
      IL_0306:  nop
//000223:                 fork2.Release();
      IL_0307:  ldarg.0
      IL_0308:  ldfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<fork2>5__33'
      IL_030d:  callvirt   instance void [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore::Release()
      IL_0312:  nop
//000224:             }
      IL_0313:  nop
//000206:             while (true)
      IL_0314:  ldc.i4.1
      IL_0315:  stloc.2
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
      IL_0316:  br         IL_0110

      IL_031b:  ldc.i4.0
      IL_031c:  stloc.0
      IL_031d:  br.s       IL_031f

      IL_031f:  ldloc.0
      IL_0320:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::MoveNext

    .method private hidebysig newslot specialname virtual final 
            instance class [mscorlib]System.Threading.Tasks.Task 
            'System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.get_Current'() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override  method instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Threading.Tasks.Task>::get_Current()
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (class [mscorlib]System.Threading.Tasks.Task V_0)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::'System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.get_Current'

    .method private hidebysig newslot virtual final 
            instance void  System.Collections.IEnumerator.Reset() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerator::Reset
      // Code size       6 (0x6)
      .maxstack  8
      IL_0000:  newobj     instance void [mscorlib]System.NotSupportedException::.ctor()
      IL_0005:  throw
    } // end of method '<RunPhilosopherAsync>d__2f'::System.Collections.IEnumerator.Reset

    .method private hidebysig newslot virtual final 
            instance void  System.IDisposable.Dispose() cil managed
    {
      .override [mscorlib]System.IDisposable::Dispose
      // Code size       2 (0x2)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::System.IDisposable.Dispose

    .method private hidebysig newslot specialname virtual final 
            instance object  System.Collections.IEnumerator.get_Current() cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      .override [mscorlib]System.Collections.IEnumerator::get_Current
      // Code size       11 (0xb)
      .maxstack  1
      .locals init (object V_0)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>2__current'
      IL_0006:  stloc.0
      IL_0007:  br.s       IL_0009

      IL_0009:  ldloc.0
      IL_000a:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::System.Collections.IEnumerator.get_Current

    .method public hidebysig specialname rtspecialname 
            instance void  .ctor(int32 '<>1__state') cil managed
    {
      .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       30 (0x1e)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>1__state'
      IL_000d:  ldarg.0
      IL_000e:  call       class [mscorlib]System.Threading.Thread [mscorlib]System.Threading.Thread::get_CurrentThread()
      IL_0013:  callvirt   instance int32 [mscorlib]System.Threading.Thread::get_ManagedThreadId()
      IL_0018:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>l__initialThreadId'
      IL_001d:  ret
    } // end of method '<RunPhilosopherAsync>d__2f'::.ctor

    .property instance class [mscorlib]System.Threading.Tasks.Task
            'System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.Current'()
    {
      .get instance class [mscorlib]System.Threading.Tasks.Task DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.get_Current'()
    } // end of property '<RunPhilosopherAsync>d__2f'::'System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.Current'
    .property instance object System.Collections.IEnumerator.Current()
    {
      .get instance object DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::System.Collections.IEnumerator.get_Current()
    } // end of property '<RunPhilosopherAsync>d__2f'::System.Collections.IEnumerator.Current
  } // end of class '<RunPhilosopherAsync>d__2f'

  .field private static literal int32 NUM_PHILOSOPHERS = int32(0x00000005)
  .field private static literal int32 TIMESCALE = int32(0x000000C8)
  .field private class [PresentationFramework]System.Windows.Shapes.Ellipse[] _philosophers
  .field private class [mscorlib]System.Threading.Tasks.TaskFactory _ui
  .field private class [PresentationCore]System.Windows.Media.Brush _think
  .field private class [PresentationCore]System.Windows.Media.Brush _eat
  .field private class [PresentationCore]System.Windows.Media.Brush _wait
  .field assembly class DiningPhilosophers.CircularPanel circularPanel1
  .field private bool _contentLoaded
  .field private static class [mscorlib]System.Func`2<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse> 'CS$<>9__CachedAnonymousMethodDelegate2'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32,class [mscorlib]System.Threading.SemaphoreSlim> 'CS$<>9__CachedAnonymousMethodDelegate5'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32,class [System]System.Threading.Semaphore> 'CS$<>9__CachedAnonymousMethodDelegate14'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore> 'CS$<>9__CachedAnonymousMethodDelegate22'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Action 'CS$<>9__CachedAnonymousMethodDelegate29'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Action 'CS$<>9__CachedAnonymousMethodDelegate2c'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       80 (0x50)
    .maxstack  3
//000053:         private Brush _think = Brushes.Yellow;
    IL_0000:  ldarg.0
    IL_0001:  call       class [PresentationCore]System.Windows.Media.SolidColorBrush [PresentationCore]System.Windows.Media.Brushes::get_Yellow()
    IL_0006:  stfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_think
//000054:         /// <summary>A brush for rendering eating philosophers.</summary>
//000055:         private Brush _eat = Brushes.Green;
    IL_000b:  ldarg.0
    IL_000c:  call       class [PresentationCore]System.Windows.Media.SolidColorBrush [PresentationCore]System.Windows.Media.Brushes::get_Green()
    IL_0011:  stfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_eat
//000056:         /// <summary>A brush for rendering waiting philosophers.</summary>
//000057:         private Brush _wait = Brushes.Red;
    IL_0016:  ldarg.0
    IL_0017:  call       class [PresentationCore]System.Windows.Media.SolidColorBrush [PresentationCore]System.Windows.Media.Brushes::get_Red()
    IL_001c:  stfld      class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow::_wait
//000034:         public MainWindow()
    IL_0021:  ldarg.0
    IL_0022:  call       instance void [PresentationFramework]System.Windows.Window::.ctor()
    IL_0027:  nop
//000035:         {
    IL_0028:  nop
//000036:             // Initialize the component's layout
//000037:             InitializeComponent();
    IL_0029:  ldarg.0
    IL_002a:  call       instance void DiningPhilosophers.MainWindow::InitializeComponent()
    IL_002f:  nop
//000038: 
//000039:             // Grab a TaskFactory for creating Tasks that run on the UI.
//000040:             _ui = new TaskFactory(TaskScheduler.FromCurrentSynchronizationContext());
    IL_0030:  ldarg.0
    IL_0031:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_0036:  newobj     instance void [mscorlib]System.Threading.Tasks.TaskFactory::.ctor(class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_003b:  stfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
//000041: 
//000042:             // Initialize the philosophers, and then run them.
//000043:             ConfigurePhilosophers();
    IL_0040:  ldarg.0
    IL_0041:  call       instance void DiningPhilosophers.MainWindow::ConfigurePhilosophers()
    IL_0046:  nop
//000044: 
//000045:             // Uncomment one of the following three lines
//000046:             RunWithSemaphoresSyncWithOrderedForks();  // 1. use synchronous semaphores, with ordered forks
    IL_0047:  ldarg.0
    IL_0048:  call       instance void DiningPhilosophers.MainWindow::RunWithSemaphoresSyncWithOrderedForks()
    IL_004d:  nop
//000047:             //RunWithSemaphoresSyncWithWaitAll();  // 2. use synchronous semaphores, with WaitAll
//000048:             //RunWithSemaphoresAsync(); // 3. use asynchronous semaphores
//000049:         }
    IL_004e:  nop
    IL_004f:  ret
  } // end of method MainWindow::.ctor

  .method private hidebysig instance void 
          ConfigurePhilosophers() cil managed
  {
    // Code size       104 (0x68)
    .maxstack  5
    .locals init ([0] class [PresentationFramework]System.Windows.Shapes.Ellipse philosopher,
             [1] class [PresentationFramework]System.Windows.Shapes.Ellipse[] CS$6$0000,
             [2] int32 CS$7$0001,
             [3] bool CS$4$0002)
//000050: 
//000051:         #region Colors
//000052:         /// <summary>A brush for rendering thinking philosophers.</summary>
//000053:         private Brush _think = Brushes.Yellow;
//000054:         /// <summary>A brush for rendering eating philosophers.</summary>
//000055:         private Brush _eat = Brushes.Green;
//000056:         /// <summary>A brush for rendering waiting philosophers.</summary>
//000057:         private Brush _wait = Brushes.Red;
//000058:         #endregion
//000059: 
//000060:         #region Helpers
//000061:         /// <summary>Initialize the philosophers.</summary>
//000062:         /// <param name="numPhilosophers">The number of philosophers to initialize.</param>
//000063:         private void ConfigurePhilosophers()
//000064:         {
    IL_0000:  nop
//000065:             _philosophers = (from i in Enumerable.Range(0, NUM_PHILOSOPHERS) select new Ellipse { Height = 75, Width = 75, Fill = Brushes.Red, Stroke = Brushes.Black }).ToArray();
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4.0
    IL_0003:  ldc.i4.5
    IL_0004:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_0009:  ldsfld     class [mscorlib]System.Func`2<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_000e:  brtrue.s   IL_0023

    IL_0010:  ldnull
    IL_0011:  ldftn      class [PresentationFramework]System.Windows.Shapes.Ellipse DiningPhilosophers.MainWindow::'<ConfigurePhilosophers>b__1'(int32)
    IL_0017:  newobj     instance void class [mscorlib]System.Func`2<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse>::.ctor(object,
                                                                                                                                              native int)
    IL_001c:  stsfld     class [mscorlib]System.Func`2<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0021:  br.s       IL_0023

    IL_0023:  ldsfld     class [mscorlib]System.Func`2<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0028:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class [PresentationFramework]System.Windows.Shapes.Ellipse>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                     class [mscorlib]System.Func`2<!!0,!!1>)
    IL_002d:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<class [PresentationFramework]System.Windows.Shapes.Ellipse>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0032:  stfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
//000066:             foreach (var philosopher in _philosophers) circularPanel1.Children.Add(philosopher);
    IL_0037:  nop
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_003e:  stloc.1
//000067:         }
//000068: 
//000069:         /// <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
//000070:         /// <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
//000071:         /// <param name="numForks">The number of forks that exist.</param>
//000072:         /// <param name="left">The ID of the philosopher's left fork.</param>
//000073:         /// <param name="right">The ID of the philosopher's right fork.</param>
//000074:         /// <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
//000075:         private void GetForkIds(int philosopherIndex, int numForks, out int left, out int right, bool sort)
//000076:         {
//000077:             // The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
//000078:             // the latter can wrap around.  We need to ensure they're always acquired in the right order, to
//000079:             // prevent deadlock, so order them.
//000080:             left = philosopherIndex;
//000081:             right = (philosopherIndex + 1) % numForks;
//000082:             if (sort && left > right)
//000083:             {
//000084:                 int tmp = left;
//000085:                 left = right;
//000086:                 right = tmp;
//000087:             }
//000088:         }
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_003f:  ldc.i4.0
    IL_0040:  stloc.2
    IL_0041:  br.s       IL_005d

//000066:             foreach (var philosopher in _philosophers) circularPanel1.Children.Add(philosopher);
    IL_0043:  ldloc.1
    IL_0044:  ldloc.2
    IL_0045:  ldelem.ref
    IL_0046:  stloc.0
    IL_0047:  ldarg.0
    IL_0048:  ldfld      class DiningPhilosophers.CircularPanel DiningPhilosophers.MainWindow::circularPanel1
    IL_004d:  callvirt   instance class [PresentationFramework]System.Windows.Controls.UIElementCollection [PresentationFramework]System.Windows.Controls.Panel::get_Children()
    IL_0052:  ldloc.0
    IL_0053:  callvirt   instance int32 [PresentationFramework]System.Windows.Controls.UIElementCollection::Add(class [PresentationCore]System.Windows.UIElement)
    IL_0058:  pop
//000067:         }
//000068: 
//000069:         /// <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
//000070:         /// <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
//000071:         /// <param name="numForks">The number of forks that exist.</param>
//000072:         /// <param name="left">The ID of the philosopher's left fork.</param>
//000073:         /// <param name="right">The ID of the philosopher's right fork.</param>
//000074:         /// <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
//000075:         private void GetForkIds(int philosopherIndex, int numForks, out int left, out int right, bool sort)
//000076:         {
//000077:             // The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
//000078:             // the latter can wrap around.  We need to ensure they're always acquired in the right order, to
//000079:             // prevent deadlock, so order them.
//000080:             left = philosopherIndex;
//000081:             right = (philosopherIndex + 1) % numForks;
//000082:             if (sort && left > right)
//000083:             {
//000084:                 int tmp = left;
//000085:                 left = right;
//000086:                 right = tmp;
//000087:             }
//000088:         }
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0059:  ldloc.2
    IL_005a:  ldc.i4.1
    IL_005b:  add
    IL_005c:  stloc.2
//000066:             foreach (var philosopher in _philosophers) circularPanel1.Children.Add(philosopher);
    IL_005d:  ldloc.2
    IL_005e:  ldloc.1
    IL_005f:  ldlen
    IL_0060:  conv.i4
    IL_0061:  clt
    IL_0063:  stloc.3
//000067:         }
//000068: 
//000069:         /// <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
//000070:         /// <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
//000071:         /// <param name="numForks">The number of forks that exist.</param>
//000072:         /// <param name="left">The ID of the philosopher's left fork.</param>
//000073:         /// <param name="right">The ID of the philosopher's right fork.</param>
//000074:         /// <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
//000075:         private void GetForkIds(int philosopherIndex, int numForks, out int left, out int right, bool sort)
//000076:         {
//000077:             // The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
//000078:             // the latter can wrap around.  We need to ensure they're always acquired in the right order, to
//000079:             // prevent deadlock, so order them.
//000080:             left = philosopherIndex;
//000081:             right = (philosopherIndex + 1) % numForks;
//000082:             if (sort && left > right)
//000083:             {
//000084:                 int tmp = left;
//000085:                 left = right;
//000086:                 right = tmp;
//000087:             }
//000088:         }
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0064:  ldloc.3
    IL_0065:  brtrue.s   IL_0043

//000067:         }
    IL_0067:  ret
  } // end of method MainWindow::ConfigurePhilosophers

  .method private hidebysig instance void 
          GetForkIds(int32 philosopherIndex,
                     int32 numForks,
                     [out] int32& left,
                     [out] int32& right,
                     bool sort) cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init ([0] int32 tmp,
             [1] bool CS$4$0000)
//000068: 
//000069:         /// <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
//000070:         /// <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
//000071:         /// <param name="numForks">The number of forks that exist.</param>
//000072:         /// <param name="left">The ID of the philosopher's left fork.</param>
//000073:         /// <param name="right">The ID of the philosopher's right fork.</param>
//000074:         /// <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
//000075:         private void GetForkIds(int philosopherIndex, int numForks, out int left, out int right, bool sort)
//000076:         {
    IL_0000:  nop
//000077:             // The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
//000078:             // the latter can wrap around.  We need to ensure they're always acquired in the right order, to
//000079:             // prevent deadlock, so order them.
//000080:             left = philosopherIndex;
    IL_0001:  ldarg.3
    IL_0002:  ldarg.1
    IL_0003:  stind.i4
//000081:             right = (philosopherIndex + 1) % numForks;
    IL_0004:  ldarg.s    right
    IL_0006:  ldarg.1
    IL_0007:  ldc.i4.1
    IL_0008:  add
    IL_0009:  ldarg.2
    IL_000a:  rem
    IL_000b:  stind.i4
//000082:             if (sort && left > right)
    IL_000c:  ldarg.s    sort
    IL_000e:  brfalse.s  IL_001c

    IL_0010:  ldarg.3
    IL_0011:  ldind.i4
    IL_0012:  ldarg.s    right
    IL_0014:  ldind.i4
    IL_0015:  cgt
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  br.s       IL_001d

    IL_001c:  ldc.i4.1
    IL_001d:  stloc.1
//000083:             {
//000084:                 int tmp = left;
//000085:                 left = right;
//000086:                 right = tmp;
//000087:             }
//000088:         }
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_001e:  ldloc.1
    IL_001f:  brtrue.s   IL_002f

//000083:             {
    IL_0021:  nop
//000084:                 int tmp = left;
    IL_0022:  ldarg.3
    IL_0023:  ldind.i4
    IL_0024:  stloc.0
//000085:                 left = right;
    IL_0025:  ldarg.3
    IL_0026:  ldarg.s    right
    IL_0028:  ldind.i4
    IL_0029:  stind.i4
//000086:                 right = tmp;
    IL_002a:  ldarg.s    right
    IL_002c:  ldloc.0
    IL_002d:  stind.i4
//000087:             }
    IL_002e:  nop
//000088:         }
    IL_002f:  ret
  } // end of method MainWindow::GetForkIds

  .method private hidebysig instance void 
          RunWithSemaphoresSyncWithOrderedForks() cil managed
  {
    // Code size       146 (0x92)
    .maxstack  5
    .locals init ([0] int32 i,
             [1] class DiningPhilosophers.MainWindow/'<>c__DisplayClass8' 'CS$<>8__locals9',
             [2] class DiningPhilosophers.MainWindow/'<>c__DisplayClass6' 'CS$<>8__locals7',
             [3] bool CS$4$0000)
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0000:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass6'::.ctor()
    IL_0005:  stloc.2
    IL_0006:  ldloc.2
    IL_0007:  ldarg.0
    IL_0008:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass6'::'<>4__this'
//000094:         {
    IL_000d:  nop
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
    IL_000e:  ldloc.2
    IL_000f:  ldc.i4.0
    IL_0010:  ldarg.0
    IL_0011:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_0016:  ldlen
    IL_0017:  conv.i4
    IL_0018:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_001d:  ldsfld     class [mscorlib]System.Func`2<int32,class [mscorlib]System.Threading.SemaphoreSlim> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate5'
    IL_0022:  brtrue.s   IL_0037

    IL_0024:  ldnull
    IL_0025:  ldftn      class [mscorlib]System.Threading.SemaphoreSlim DiningPhilosophers.MainWindow::'<RunWithSemaphoresSyncWithOrderedForks>b__3'(int32)
    IL_002b:  newobj     instance void class [mscorlib]System.Func`2<int32,class [mscorlib]System.Threading.SemaphoreSlim>::.ctor(object,
                                                                                                                                  native int)
    IL_0030:  stsfld     class [mscorlib]System.Func`2<int32,class [mscorlib]System.Threading.SemaphoreSlim> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate5'
    IL_0035:  br.s       IL_0037

    IL_0037:  ldsfld     class [mscorlib]System.Func`2<int32,class [mscorlib]System.Threading.SemaphoreSlim> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate5'
    IL_003c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class [mscorlib]System.Threading.SemaphoreSlim>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0041:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<class [mscorlib]System.Threading.SemaphoreSlim>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0046:  stfld      class [mscorlib]System.Threading.SemaphoreSlim[] DiningPhilosophers.MainWindow/'<>c__DisplayClass6'::forks
//000096:             for (int i = 0; i < _philosophers.Length; i++)
    IL_004b:  ldc.i4.0
    IL_004c:  stloc.0
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_004d:  br.s       IL_0081

    IL_004f:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::.ctor()
    IL_0054:  stloc.1
    IL_0055:  ldloc.1
    IL_0056:  ldloc.2
    IL_0057:  stfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass6' DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::'CS$<>8__locals7'
//000097:             {
    IL_005c:  nop
//000098:                 int index = i;
    IL_005d:  ldloc.1
    IL_005e:  ldloc.0
    IL_005f:  stfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::index
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
    IL_0064:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0069:  ldloc.1
    IL_006a:  ldftn      instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass8'::'<RunWithSemaphoresSyncWithOrderedForks>b__4'()
    IL_0070:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0075:  ldc.i4.2
    IL_0076:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.Tasks.TaskCreationOptions)
    IL_007b:  pop
//000100:             }
    IL_007c:  nop
//000096:             for (int i = 0; i < _philosophers.Length; i++)
    IL_007d:  ldloc.0
    IL_007e:  ldc.i4.1
    IL_007f:  add
    IL_0080:  stloc.0
    IL_0081:  ldloc.0
    IL_0082:  ldarg.0
    IL_0083:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_0088:  ldlen
    IL_0089:  conv.i4
    IL_008a:  clt
    IL_008c:  stloc.3
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_008d:  ldloc.3
    IL_008e:  brtrue.s   IL_004f

//000101:         }
    IL_0090:  nop
    IL_0091:  ret
  } // end of method MainWindow::RunWithSemaphoresSyncWithOrderedForks

  .method private hidebysig instance void 
          RunPhilosopherSyncWithOrderedForks(class [mscorlib]System.Threading.SemaphoreSlim[] forks,
                                             int32 index) cil managed
  {
    // Code size       282 (0x11a)
    .maxstack  6
    .locals init ([0] int32 fork1Id,
             [1] int32 fork2Id,
             [2] class [mscorlib]System.Threading.SemaphoreSlim fork1,
             [3] class [mscorlib]System.Threading.SemaphoreSlim fork2,
             [4] class [mscorlib]System.Random rand,
             [5] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegated',
             [6] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegatee',
             [7] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegatef',
             [8] class DiningPhilosophers.MainWindow/'<>c__DisplayClass10' 'CS$<>8__locals11',
             [9] bool CS$4$0000)
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0000:  ldnull
    IL_0001:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegated'
    IL_0003:  ldnull
    IL_0004:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_0006:  ldnull
    IL_0007:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_0009:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::.ctor()
    IL_000e:  stloc.s    'CS$<>8__locals11'
    IL_0010:  ldloc.s    'CS$<>8__locals11'
    IL_0012:  ldarg.2
    IL_0013:  stfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
    IL_0018:  ldloc.s    'CS$<>8__locals11'
    IL_001a:  ldarg.0
    IL_001b:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<>4__this'
//000107:         {
    IL_0020:  nop
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
    IL_0021:  ldarg.0
    IL_0022:  ldloc.s    'CS$<>8__locals11'
    IL_0024:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
    IL_0029:  ldarg.1
    IL_002a:  ldlen
    IL_002b:  conv.i4
    IL_002c:  ldloca.s   fork1Id
    IL_002e:  ldloca.s   fork2Id
    IL_0030:  ldc.i4.1
    IL_0031:  call       instance void DiningPhilosophers.MainWindow::GetForkIds(int32,
                                                                                 int32,
                                                                                 int32&,
                                                                                 int32&,
                                                                                 bool)
    IL_0036:  nop
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
    IL_0037:  ldarg.1
    IL_0038:  ldloc.0
    IL_0039:  ldelem.ref
    IL_003a:  stloc.2
    IL_003b:  ldarg.1
    IL_003c:  ldloc.1
    IL_003d:  ldelem.ref
    IL_003e:  stloc.3
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
    IL_003f:  ldloc.s    'CS$<>8__locals11'
    IL_0041:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::index
    IL_0046:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
    IL_004b:  stloc.s    rand
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_004d:  br         IL_0112

//000116:             {
    IL_0052:  nop
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
    IL_0053:  ldarg.0
    IL_0054:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_0059:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegated'
    IL_005b:  brtrue.s   IL_006e

    IL_005d:  ldloc.s    'CS$<>8__locals11'
    IL_005f:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__a'()
    IL_0065:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_006a:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegated'
    IL_006c:  br.s       IL_006e

    IL_006e:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegated'
    IL_0070:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_0075:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_007a:  nop
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
    IL_007b:  ldloc.s    rand
    IL_007d:  ldc.i4.s   10
    IL_007f:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_0084:  ldc.i4     0xc8
    IL_0089:  mul
    IL_008a:  call       void [mscorlib]System.Threading.Thread::Sleep(int32)
    IL_008f:  nop
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
    IL_0090:  ldloc.2
    IL_0091:  callvirt   instance void [mscorlib]System.Threading.SemaphoreSlim::Wait()
    IL_0096:  nop
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
    IL_0097:  ldarg.0
    IL_0098:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_009d:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_009f:  brtrue.s   IL_00b2

    IL_00a1:  ldloc.s    'CS$<>8__locals11'
    IL_00a3:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__b'()
    IL_00a9:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_00ae:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_00b0:  br.s       IL_00b2

    IL_00b2:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
    IL_00b4:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_00b9:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_00be:  nop
//000124:                 fork2.Wait();
    IL_00bf:  ldloc.3
    IL_00c0:  callvirt   instance void [mscorlib]System.Threading.SemaphoreSlim::Wait()
    IL_00c5:  nop
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
    IL_00c6:  ldarg.0
    IL_00c7:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_00cc:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00ce:  brtrue.s   IL_00e1

    IL_00d0:  ldloc.s    'CS$<>8__locals11'
    IL_00d2:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass10'::'<RunPhilosopherSyncWithOrderedForks>b__c'()
    IL_00d8:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_00dd:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00df:  br.s       IL_00e1

    IL_00e1:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatef'
    IL_00e3:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_00e8:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_00ed:  nop
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
    IL_00ee:  ldloc.s    rand
    IL_00f0:  ldc.i4.s   10
    IL_00f2:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_00f7:  ldc.i4     0xc8
    IL_00fc:  mul
    IL_00fd:  call       void [mscorlib]System.Threading.Thread::Sleep(int32)
    IL_0102:  nop
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
    IL_0103:  ldloc.2
    IL_0104:  callvirt   instance int32 [mscorlib]System.Threading.SemaphoreSlim::Release()
    IL_0109:  pop
//000132:                 fork2.Release();
    IL_010a:  ldloc.3
    IL_010b:  callvirt   instance int32 [mscorlib]System.Threading.SemaphoreSlim::Release()
    IL_0110:  pop
//000133:             }
    IL_0111:  nop
//000115:             while (true)
    IL_0112:  ldc.i4.1
    IL_0113:  stloc.s    CS$4$0000
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0115:  br         IL_0052
  } // end of method MainWindow::RunPhilosopherSyncWithOrderedForks

  .method private hidebysig instance void 
          RunWithSemaphoresSyncWithWaitAll() cil managed
  {
    // Code size       146 (0x92)
    .maxstack  5
    .locals init ([0] int32 i,
             [1] class DiningPhilosophers.MainWindow/'<>c__DisplayClass17' 'CS$<>8__locals18',
             [2] class DiningPhilosophers.MainWindow/'<>c__DisplayClass15' 'CS$<>8__locals16',
             [3] bool CS$4$0000)
    IL_0000:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass15'::.ctor()
    IL_0005:  stloc.2
    IL_0006:  ldloc.2
    IL_0007:  ldarg.0
    IL_0008:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass15'::'<>4__this'
//000140:         {
    IL_000d:  nop
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
    IL_000e:  ldloc.2
    IL_000f:  ldc.i4.0
    IL_0010:  ldarg.0
    IL_0011:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_0016:  ldlen
    IL_0017:  conv.i4
    IL_0018:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_001d:  ldsfld     class [mscorlib]System.Func`2<int32,class [System]System.Threading.Semaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate14'
    IL_0022:  brtrue.s   IL_0037

    IL_0024:  ldnull
    IL_0025:  ldftn      class [System]System.Threading.Semaphore DiningPhilosophers.MainWindow::'<RunWithSemaphoresSyncWithWaitAll>b__12'(int32)
    IL_002b:  newobj     instance void class [mscorlib]System.Func`2<int32,class [System]System.Threading.Semaphore>::.ctor(object,
                                                                                                                            native int)
    IL_0030:  stsfld     class [mscorlib]System.Func`2<int32,class [System]System.Threading.Semaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate14'
    IL_0035:  br.s       IL_0037

    IL_0037:  ldsfld     class [mscorlib]System.Func`2<int32,class [System]System.Threading.Semaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate14'
    IL_003c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class [System]System.Threading.Semaphore>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                   class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0041:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<class [System]System.Threading.Semaphore>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0046:  stfld      class [System]System.Threading.Semaphore[] DiningPhilosophers.MainWindow/'<>c__DisplayClass15'::forks
//000142:             for (int i = 0; i < _philosophers.Length; i++)
    IL_004b:  ldc.i4.0
    IL_004c:  stloc.0
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_004d:  br.s       IL_0081

    IL_004f:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::.ctor()
    IL_0054:  stloc.1
    IL_0055:  ldloc.1
    IL_0056:  ldloc.2
    IL_0057:  stfld      class DiningPhilosophers.MainWindow/'<>c__DisplayClass15' DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::'CS$<>8__locals16'
//000143:             {
    IL_005c:  nop
//000144:                 int index = i;
    IL_005d:  ldloc.1
    IL_005e:  ldloc.0
    IL_005f:  stfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::index
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
    IL_0064:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0069:  ldloc.1
    IL_006a:  ldftn      instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass17'::'<RunWithSemaphoresSyncWithWaitAll>b__13'()
    IL_0070:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0075:  ldc.i4.2
    IL_0076:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.Tasks.TaskCreationOptions)
    IL_007b:  pop
//000146:             }
    IL_007c:  nop
//000142:             for (int i = 0; i < _philosophers.Length; i++)
    IL_007d:  ldloc.0
    IL_007e:  ldc.i4.1
    IL_007f:  add
    IL_0080:  stloc.0
    IL_0081:  ldloc.0
    IL_0082:  ldarg.0
    IL_0083:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_0088:  ldlen
    IL_0089:  conv.i4
    IL_008a:  clt
    IL_008c:  stloc.3
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_008d:  ldloc.3
    IL_008e:  brtrue.s   IL_004f

//000147:         }
    IL_0090:  nop
    IL_0091:  ret
  } // end of method MainWindow::RunWithSemaphoresSyncWithWaitAll

  .method private hidebysig instance void 
          RunPhilosopherSyncWithWaitAll(class [System]System.Threading.Semaphore[] forks,
                                        int32 index) cil managed
  {
    // Code size       294 (0x126)
    .maxstack  6
    .locals init ([0] int32 fork1Id,
             [1] int32 fork2Id,
             [2] class [System]System.Threading.Semaphore fork1,
             [3] class [System]System.Threading.Semaphore fork2,
             [4] class [mscorlib]System.Random rand,
             [5] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate1c',
             [6] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate1d',
             [7] class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush> 'CS$<>9__CachedAnonymousMethodDelegate1e',
             [8] class DiningPhilosophers.MainWindow/'<>c__DisplayClass1f' 'CS$<>8__locals20',
             [9] class [System]System.Threading.Semaphore[] CS$0$0000,
             [10] bool CS$4$0001)
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0000:  ldnull
    IL_0001:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_0003:  ldnull
    IL_0004:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_0006:  ldnull
    IL_0007:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1e'
    IL_0009:  newobj     instance void DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::.ctor()
    IL_000e:  stloc.s    'CS$<>8__locals20'
    IL_0010:  ldloc.s    'CS$<>8__locals20'
    IL_0012:  ldarg.2
    IL_0013:  stfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
    IL_0018:  ldloc.s    'CS$<>8__locals20'
    IL_001a:  ldarg.0
    IL_001b:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<>4__this'
//000153:         {
    IL_0020:  nop
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
    IL_0021:  ldarg.0
    IL_0022:  ldloc.s    'CS$<>8__locals20'
    IL_0024:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
    IL_0029:  ldarg.1
    IL_002a:  ldlen
    IL_002b:  conv.i4
    IL_002c:  ldloca.s   fork1Id
    IL_002e:  ldloca.s   fork2Id
    IL_0030:  ldc.i4.0
    IL_0031:  call       instance void DiningPhilosophers.MainWindow::GetForkIds(int32,
                                                                                 int32,
                                                                                 int32&,
                                                                                 int32&,
                                                                                 bool)
    IL_0036:  nop
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
    IL_0037:  ldarg.1
    IL_0038:  ldloc.0
    IL_0039:  ldelem.ref
    IL_003a:  stloc.2
    IL_003b:  ldarg.1
    IL_003c:  ldloc.1
    IL_003d:  ldelem.ref
    IL_003e:  stloc.3
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
    IL_003f:  ldloc.s    'CS$<>8__locals20'
    IL_0041:  ldfld      int32 DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::index
    IL_0046:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
    IL_004b:  stloc.s    rand
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_004d:  br         IL_011e

//000162:             {
    IL_0052:  nop
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
    IL_0053:  ldarg.0
    IL_0054:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_0059:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_005b:  brtrue.s   IL_006e

    IL_005d:  ldloc.s    'CS$<>8__locals20'
    IL_005f:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__19'()
    IL_0065:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_006a:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_006c:  br.s       IL_006e

    IL_006e:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_0070:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_0075:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_007a:  nop
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
    IL_007b:  ldloc.s    rand
    IL_007d:  ldc.i4.s   10
    IL_007f:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_0084:  ldc.i4     0xc8
    IL_0089:  mul
    IL_008a:  call       void [mscorlib]System.Threading.Thread::Sleep(int32)
    IL_008f:  nop
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
    IL_0090:  ldarg.0
    IL_0091:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_0096:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_0098:  brtrue.s   IL_00ab

    IL_009a:  ldloc.s    'CS$<>8__locals20'
    IL_009c:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__1a'()
    IL_00a2:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_00a7:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_00a9:  br.s       IL_00ab

    IL_00ab:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_00ad:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_00b2:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_00b7:  nop
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
    IL_00b8:  ldc.i4.2
    IL_00b9:  newarr     [System]System.Threading.Semaphore
    IL_00be:  stloc.s    CS$0$0000
    IL_00c0:  ldloc.s    CS$0$0000
    IL_00c2:  ldc.i4.0
    IL_00c3:  ldloc.2
    IL_00c4:  stelem.ref
    IL_00c5:  ldloc.s    CS$0$0000
    IL_00c7:  ldc.i4.1
    IL_00c8:  ldloc.3
    IL_00c9:  stelem.ref
    IL_00ca:  ldloc.s    CS$0$0000
    IL_00cc:  call       bool [mscorlib]System.Threading.WaitHandle::WaitAll(class [mscorlib]System.Threading.WaitHandle[])
    IL_00d1:  pop
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
    IL_00d2:  ldarg.0
    IL_00d3:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory DiningPhilosophers.MainWindow::_ui
    IL_00d8:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1e'
    IL_00da:  brtrue.s   IL_00ed

    IL_00dc:  ldloc.s    'CS$<>8__locals20'
    IL_00de:  ldftn      instance class [PresentationCore]System.Windows.Media.Brush DiningPhilosophers.MainWindow/'<>c__DisplayClass1f'::'<RunPhilosopherSyncWithWaitAll>b__1b'()
    IL_00e4:  newobj     instance void class [mscorlib]System.Func`1<class [PresentationCore]System.Windows.Media.Brush>::.ctor(object,
                                                                                                                                native int)
    IL_00e9:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate1e'
    IL_00eb:  br.s       IL_00ed

    IL_00ed:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate1e'
    IL_00ef:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<class [PresentationCore]System.Windows.Media.Brush>(class [mscorlib]System.Func`1<!!0>)
    IL_00f4:  callvirt   instance void [mscorlib]System.Threading.Tasks.Task::Wait()
    IL_00f9:  nop
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
    IL_00fa:  ldloc.s    rand
    IL_00fc:  ldc.i4.s   10
    IL_00fe:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_0103:  ldc.i4     0xc8
    IL_0108:  mul
    IL_0109:  call       void [mscorlib]System.Threading.Thread::Sleep(int32)
    IL_010e:  nop
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
    IL_010f:  ldloc.2
    IL_0110:  callvirt   instance int32 [System]System.Threading.Semaphore::Release()
    IL_0115:  pop
//000177:                 fork2.Release();
    IL_0116:  ldloc.3
    IL_0117:  callvirt   instance int32 [System]System.Threading.Semaphore::Release()
    IL_011c:  pop
//000178:             }
    IL_011d:  nop
//000161:             while (true)
    IL_011e:  ldc.i4.1
    IL_011f:  stloc.s    CS$4$0001
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0121:  br         IL_0052
  } // end of method MainWindow::RunPhilosopherSyncWithWaitAll

  .method private hidebysig instance void 
          RunWithSemaphoresAsync() cil managed
  {
    // Code size       102 (0x66)
    .maxstack  4
    .locals init ([0] class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] forks,
             [1] int32 i,
             [2] bool CS$4$0000)
//000185:         {
    IL_0000:  nop
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
    IL_0001:  ldc.i4.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_0008:  ldlen
    IL_0009:  conv.i4
    IL_000a:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_000f:  ldsfld     class [mscorlib]System.Func`2<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate22'
    IL_0014:  brtrue.s   IL_0029

    IL_0016:  ldnull
    IL_0017:  ldftn      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore DiningPhilosophers.MainWindow::'<RunWithSemaphoresAsync>b__21'(int32)
    IL_001d:  newobj     instance void class [mscorlib]System.Func`2<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore>::.ctor(object,
                                                                                                                                                         native int)
    IL_0022:  stsfld     class [mscorlib]System.Func`2<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate22'
    IL_0027:  br.s       IL_0029

    IL_0029:  ldsfld     class [mscorlib]System.Func`2<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore> DiningPhilosophers.MainWindow::'CS$<>9__CachedAnonymousMethodDelegate22'
    IL_002e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0033:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0038:  stloc.0
//000187:             for (int i = 0; i < _philosophers.Length; i++)
    IL_0039:  ldc.i4.0
    IL_003a:  stloc.1
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_003b:  br.s       IL_0056

//000188:             {
    IL_003d:  nop
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
    IL_003e:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_0043:  ldarg.0
    IL_0044:  ldloc.0
    IL_0045:  ldloc.1
    IL_0046:  call       instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Threading.Tasks.Task> DiningPhilosophers.MainWindow::RunPhilosopherAsync(class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[],
                                                                                                                                                                                           int32)
    IL_004b:  call       class [mscorlib]System.Threading.Tasks.Task [ParallelExtensionsExtras]System.Threading.Tasks.TaskFactoryExtensions::Iterate(class [mscorlib]System.Threading.Tasks.TaskFactory,
                                                                                                                                                     class [mscorlib]System.Collections.Generic.IEnumerable`1<object>)
    IL_0050:  pop
//000190:             }
    IL_0051:  nop
//000187:             for (int i = 0; i < _philosophers.Length; i++)
    IL_0052:  ldloc.1
    IL_0053:  ldc.i4.1
    IL_0054:  add
    IL_0055:  stloc.1
    IL_0056:  ldloc.1
    IL_0057:  ldarg.0
    IL_0058:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse[] DiningPhilosophers.MainWindow::_philosophers
    IL_005d:  ldlen
    IL_005e:  conv.i4
    IL_005f:  clt
    IL_0061:  stloc.2
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0062:  ldloc.2
    IL_0063:  brtrue.s   IL_003d

//000191:         }
    IL_0065:  ret
  } // end of method MainWindow::RunWithSemaphoresAsync

  .method private hidebysig instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Threading.Tasks.Task> 
          RunPhilosopherAsync(class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] forks,
                              int32 index) cil managed
  {
    // Code size       35 (0x23)
    .maxstack  2
    .locals init ([0] class DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f' V_0,
             [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Threading.Tasks.Task> V_1)
    IL_0000:  ldc.i4.s   -2
    IL_0002:  newobj     instance void DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::.ctor(int32)
    IL_0007:  stloc.0
    IL_0008:  ldloc.0
    IL_0009:  ldarg.0
    IL_000a:  stfld      class DiningPhilosophers.MainWindow DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>4__this'
    IL_000f:  ldloc.0
    IL_0010:  ldarg.1
    IL_0011:  stfld      class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore[] DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>3__forks'
    IL_0016:  ldloc.0
    IL_0017:  ldarg.2
    IL_0018:  stfld      int32 DiningPhilosophers.MainWindow/'<RunPhilosopherAsync>d__2f'::'<>3__index'
    IL_001d:  ldloc.0
    IL_001e:  stloc.1
    IL_001f:  br.s       IL_0021

    IL_0021:  ldloc.1
    IL_0022:  ret
  } // end of method MainWindow::RunPhilosopherAsync

  .method public hidebysig newslot virtual final 
          instance void  InitializeComponent() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       45 (0x2d)
    .maxstack  3
    .locals init ([0] class [System]System.Uri resourceLocater,
             [1] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool DiningPhilosophers.MainWindow::_contentLoaded
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  stloc.1
    IL_000b:  ldloc.1
    IL_000c:  brtrue.s   IL_0011

    IL_000e:  nop
    IL_000f:  br.s       IL_002c

    IL_0011:  ldarg.0
    IL_0012:  ldc.i4.1
    IL_0013:  stfld      bool DiningPhilosophers.MainWindow::_contentLoaded
    IL_0018:  ldstr      "/DiningPhilosophers;component/mainwindow.xaml"
    IL_001d:  ldc.i4.2
    IL_001e:  newobj     instance void [System]System.Uri::.ctor(string,
                                                                 valuetype [System]System.UriKind)
    IL_0023:  stloc.0
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\MainWindow.xaml' 
//000001: ?<Window xmlns:my="clr-namespace:DiningPhilosophers"  x:Class="DiningPhilosophers.MainWindow"
    IL_0024:  ldarg.0
    IL_0025:  ldloc.0
    IL_0026:  call       void [PresentationFramework]System.Windows.Application::LoadComponent(object,
                                                                                               class [System]System.Uri)
    IL_002b:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_002c:  ret
  } // end of method MainWindow::InitializeComponent

  .method assembly hidebysig instance class [mscorlib]System.Delegate 
          _CreateDelegate(class [mscorlib]System.Type delegateType,
                          string 'handler') cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       14 (0xe)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Delegate CS$1$0000)
    IL_0000:  nop
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldarg.2
    IL_0004:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::CreateDelegate(class [mscorlib]System.Type,
                                                                                                   object,
                                                                                                   string)
    IL_0009:  stloc.0
    IL_000a:  br.s       IL_000c

    IL_000c:  ldloc.0
    IL_000d:  ret
  } // end of method MainWindow::_CreateDelegate

  .method private hidebysig newslot virtual final 
          instance void  System.Windows.Markup.IComponentConnector.Connect(int32 connectionId,
                                                                           object target) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
    .override [System.Xaml]System.Windows.Markup.IComponentConnector::Connect
    // Code size       31 (0x1f)
    .maxstack  2
    .locals init ([0] int32 CS$4$0000)
    IL_0000:  nop
    IL_0001:  ldarg.1
    IL_0002:  stloc.0
    IL_0003:  ldloc.0
    IL_0004:  ldc.i4.1
    IL_0005:  beq.s      IL_0009

    IL_0007:  br.s       IL_0017

    IL_0009:  ldarg.0
    IL_000a:  ldarg.2
    IL_000b:  castclass  DiningPhilosophers.CircularPanel
    IL_0010:  stfld      class DiningPhilosophers.CircularPanel DiningPhilosophers.MainWindow::circularPanel1
    IL_0015:  br.s       IL_001e

    IL_0017:  ldarg.0
    IL_0018:  ldc.i4.1
    IL_0019:  stfld      bool DiningPhilosophers.MainWindow::_contentLoaded
    IL_001e:  ret
  } // end of method MainWindow::System.Windows.Markup.IComponentConnector.Connect

  .method private hidebysig static class [PresentationFramework]System.Windows.Shapes.Ellipse 
          '<ConfigurePhilosophers>b__1'(int32 i) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       68 (0x44)
    .maxstack  2
    .locals init ([0] class [PresentationFramework]System.Windows.Shapes.Ellipse '<>g__initLocal0',
             [1] class [PresentationFramework]System.Windows.Shapes.Ellipse CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\MainWindow.xaml.cs' 
//000065:             _philosophers = (from i in Enumerable.Range(0, NUM_PHILOSOPHERS) select new Ellipse { Height = 75, Width = 75, Fill = Brushes.Red, Stroke = Brushes.Black }).ToArray();
    IL_0000:  newobj     instance void [PresentationFramework]System.Windows.Shapes.Ellipse::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldc.r8     75.
    IL_0010:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_Height(float64)
    IL_0015:  nop
    IL_0016:  ldloc.0
    IL_0017:  ldc.r8     75.
    IL_0020:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_Width(float64)
    IL_0025:  nop
    IL_0026:  ldloc.0
    IL_0027:  call       class [PresentationCore]System.Windows.Media.SolidColorBrush [PresentationCore]System.Windows.Media.Brushes::get_Red()
    IL_002c:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
    IL_0031:  nop
    IL_0032:  ldloc.0
    IL_0033:  call       class [PresentationCore]System.Windows.Media.SolidColorBrush [PresentationCore]System.Windows.Media.Brushes::get_Black()
    IL_0038:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Stroke(class [PresentationCore]System.Windows.Media.Brush)
    IL_003d:  nop
    IL_003e:  ldloc.0
    IL_003f:  stloc.1
    IL_0040:  br.s       IL_0042

//000066:             foreach (var philosopher in _philosophers) circularPanel1.Children.Add(philosopher);
//000067:         }
//000068: 
//000069:         /// <summary>Gets the fork IDs of the forks for a particular philosopher.</summary>
//000070:         /// <param name="philosopherIndex">The index of the philosopher whose IDs are being retrieved.</param>
//000071:         /// <param name="numForks">The number of forks that exist.</param>
//000072:         /// <param name="left">The ID of the philosopher's left fork.</param>
//000073:         /// <param name="right">The ID of the philosopher's right fork.</param>
//000074:         /// <param name="sort">Whether to sort the forks, so that the left fork is always smaller than the right.</param>
//000075:         private void GetForkIds(int philosopherIndex, int numForks, out int left, out int right, bool sort)
//000076:         {
//000077:             // The forks for a philosopher are the ones at philosopherIndex and philosopherIndex+1, though
//000078:             // the latter can wrap around.  We need to ensure they're always acquired in the right order, to
//000079:             // prevent deadlock, so order them.
//000080:             left = philosopherIndex;
//000081:             right = (philosopherIndex + 1) % numForks;
//000082:             if (sort && left > right)
//000083:             {
//000084:                 int tmp = left;
//000085:                 left = right;
//000086:                 right = tmp;
//000087:             }
//000088:         }
//000089:         #endregion
//000090: 
//000091:         #region Synchronous, Ordered
//000092:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000093:         private void RunWithSemaphoresSyncWithOrderedForks()
//000094:         {
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0042:  ldloc.1
    IL_0043:  ret
  } // end of method MainWindow::'<ConfigurePhilosophers>b__1'

  .method private hidebysig static class [mscorlib]System.Threading.SemaphoreSlim 
          '<RunWithSemaphoresSyncWithOrderedForks>b__3'(int32 i) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Threading.SemaphoreSlim CS$1$0000)
//000095:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new SemaphoreSlim(1, 1)).ToArray();
    IL_0000:  ldc.i4.1
    IL_0001:  ldc.i4.1
    IL_0002:  newobj     instance void [mscorlib]System.Threading.SemaphoreSlim::.ctor(int32,
                                                                                       int32)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000096:             for (int i = 0; i < _philosophers.Length; i++)
//000097:             {
//000098:                 int index = i;
//000099:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithOrderedForks(forks, index), TaskCreationOptions.LongRunning);
//000100:             }
//000101:         }
//000102: 
//000103:         /// <summary>Runs a philosopher synchronously.</summary>
//000104:         /// <param name="forks">The forks, represented as semaphores.</param>
//000105:         /// <param name="index">The philosopher's index number.</param>
//000106:         private void RunPhilosopherSyncWithOrderedForks(SemaphoreSlim[] forks, int index)
//000107:         {
//000108:             // Assign forks
//000109:             int fork1Id, fork2Id;
//000110:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000111:             SemaphoreSlim fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000112: 
//000113:             // Think and Eat, repeatedly
//000114:             var rand = new Random(index);
//000115:             while (true)
//000116:             {
//000117:                 // Think (Yellow)
//000118:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000119:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000120: 
//000121:                 // Wait for forks (Red)
//000122:                 fork1.Wait();
//000123:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000124:                 fork2.Wait();
//000125: 
//000126:                 // Eat (Green)
//000127:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000128:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000129: 
//000130:                 // Done with forks
//000131:                 fork1.Release();
//000132:                 fork2.Release();
//000133:             }
//000134:         }
//000135:         #endregion
//000136: 
//000137:         #region Synchronous, WaitAll
//000138:         /// <summary>Runs the philosophers utilizing one thread per philosopher.</summary>
//000139:         private void RunWithSemaphoresSyncWithWaitAll()
//000140:         {
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainWindow::'<RunWithSemaphoresSyncWithOrderedForks>b__3'

  .method private hidebysig static class [System]System.Threading.Semaphore 
          '<RunWithSemaphoresSyncWithWaitAll>b__12'(int32 i) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  3
    .locals init ([0] class [System]System.Threading.Semaphore CS$1$0000)
//000141:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new Semaphore(1, 1)).ToArray();
    IL_0000:  ldc.i4.1
    IL_0001:  ldc.i4.1
    IL_0002:  newobj     instance void [System]System.Threading.Semaphore::.ctor(int32,
                                                                                 int32)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000142:             for (int i = 0; i < _philosophers.Length; i++)
//000143:             {
//000144:                 int index = i;
//000145:                 Task.Factory.StartNew(() => RunPhilosopherSyncWithWaitAll(forks, index), TaskCreationOptions.LongRunning);
//000146:             }
//000147:         }
//000148: 
//000149:         /// <summary>Runs a philosopher synchronously.</summary>
//000150:         /// <param name="forks">The forks, represented as semaphores.</param>
//000151:         /// <param name="index">The philosopher's index number.</param>
//000152:         private void RunPhilosopherSyncWithWaitAll(Semaphore[] forks, int index)
//000153:         {
//000154:             // Assign forks
//000155:             int fork1Id, fork2Id;
//000156:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, false);
//000157:             Semaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000158: 
//000159:             // Think and Eat, repeatedly
//000160:             var rand = new Random(index);
//000161:             while (true)
//000162:             {
//000163:                 // Think (Yellow)
//000164:                 _ui.StartNew(() => _philosophers[index].Fill = _think).Wait();
//000165:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000166: 
//000167:                 // Wait for forks (Red)
//000168:                 _ui.StartNew(() => _philosophers[index].Fill = _wait).Wait();
//000169:                 WaitHandle.WaitAll(new[] { fork1, fork2 });
//000170: 
//000171:                 // Eat (Green)
//000172:                 _ui.StartNew(() => _philosophers[index].Fill = _eat).Wait();
//000173:                 Thread.Sleep(rand.Next(10) * TIMESCALE);
//000174: 
//000175:                 // Done with forks
//000176:                 fork1.Release();
//000177:                 fork2.Release();
//000178:             }
//000179:         }
//000180:         #endregion
//000181: 
//000182:         #region Asynchronous
//000183:         /// <summary>Runs the philosophers using asynchronous processing techniques to avoid one thread per philosopher.</summary>
//000184:         private void RunWithSemaphoresAsync()
//000185:         {
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainWindow::'<RunWithSemaphoresSyncWithWaitAll>b__12'

  .method private hidebysig static class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore 
          '<RunWithSemaphoresAsync>b__21'(int32 i) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  3
    .locals init ([0] class [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore CS$1$0000)
//000186:             var forks = (from i in Enumerable.Range(0, _philosophers.Length) select new AsyncSemaphore(1, 1)).ToArray();
    IL_0000:  ldc.i4.1
    IL_0001:  ldc.i4.1
    IL_0002:  newobj     instance void [ParallelExtensionsExtras]System.Threading.Async.AsyncSemaphore::.ctor(int32,
                                                                                                              int32)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000187:             for (int i = 0; i < _philosophers.Length; i++)
//000188:             {
//000189:                 Task.Factory.Iterate(RunPhilosopherAsync(forks, i));
//000190:             }
//000191:         }
//000192: 
//000193:         /// <summary>Runs a philosopher asynchronously.</summary>
//000194:         /// <param name="forks">The forks, represented as semaphores.</param>
//000195:         /// <param name="index">The philosopher's index number.</param>
//000196:         /// <returns>An enumerable of tasks representing a philosopher's execution.</returns>
//000197:         private IEnumerable<Task> RunPhilosopherAsync(AsyncSemaphore[] forks, int index)
//000198:         {
//000199:             // Assign forks
//000200:             int fork1Id, fork2Id;
//000201:             GetForkIds(index, forks.Length, out fork1Id, out fork2Id, true);
//000202:             AsyncSemaphore fork1 = forks[fork1Id], fork2 = forks[fork2Id];
//000203: 
//000204:             // Think and Eat, repeatedly
//000205:             var rand = new Random(index);
//000206:             while (true)
//000207:             {
//000208:                 // Think (Yellow)
//000209:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _think);
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainWindow::'<RunWithSemaphoresAsync>b__21'

  .method private hidebysig static void  '<RunPhilosopherAsync>b__24'() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       2 (0x2)
    .maxstack  8
//000210:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
    IL_0000:  nop
//000211: 
//000212:                 // Wait for forks (Red)
//000213:                 yield return fork1.WaitAsync();
//000214:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _wait);
//000215:                 yield return fork2.WaitAsync();
//000216: 
//000217:                 // Eat (Green)
//000218:                 yield return _ui.StartNew(() => _philosophers[index].Fill = _eat);
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0001:  ret
  } // end of method MainWindow::'<RunPhilosopherAsync>b__24'

  .method private hidebysig static void  '<RunPhilosopherAsync>b__27'() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       2 (0x2)
    .maxstack  8
//000219:                 yield return Task.Factory.StartNewDelayed(rand.Next(10) * TIMESCALE, () => { });
    IL_0000:  nop
//000220: 
//000221:                 // Done with forks
//000222:                 fork1.Release();
//000223:                 fork2.Release();
//000224:             }
//000225:         }
//000226:         #endregion
//000227:     }
//000228: }
    IL_0001:  ret
  } // end of method MainWindow::'<RunPhilosopherAsync>b__27'

} // end of class DiningPhilosophers.MainWindow

.class public auto ansi beforefieldinit DiningPhilosophers.CircularPanel
       extends [PresentationFramework]System.Windows.Controls.Panel
{
  .field private static class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> 'CS$<>9__CachedAnonymousMethodDelegate2'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> 'CS$<>9__CachedAnonymousMethodDelegate3'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method family hidebysig virtual instance valuetype [WindowsBase]System.Windows.Size 
          MeasureOverride(valuetype [WindowsBase]System.Windows.Size availableSize) cil managed
  {
    // Code size       213 (0xd5)
    .maxstack  2
    .locals init ([0] valuetype [WindowsBase]System.Windows.Size maxChildSize,
             [1] class [PresentationCore]System.Windows.UIElement child,
             [2] valuetype [WindowsBase]System.Windows.Size CS$1$0000,
             [3] class [mscorlib]System.Collections.IEnumerator CS$5$0001,
             [4] valuetype [WindowsBase]System.Windows.Size CS$0$0002,
             [5] bool CS$4$0003,
             [6] class [mscorlib]System.IDisposable CS$0$0004)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\CircularPanel.cs' 
//000019:         {
    IL_0000:  nop
//000020:             var maxChildSize = new Size();
    IL_0001:  ldloca.s   maxChildSize
    IL_0003:  initobj    [WindowsBase]System.Windows.Size
//000021:             foreach (UIElement child in InternalChildren)
    IL_0009:  nop
    IL_000a:  ldarg.0
    IL_000b:  call       instance class [PresentationFramework]System.Windows.Controls.UIElementCollection [PresentationFramework]System.Windows.Controls.Panel::get_InternalChildren()
    IL_0010:  callvirt   instance class [mscorlib]System.Collections.IEnumerator [PresentationFramework]System.Windows.Controls.UIElementCollection::GetEnumerator()
    IL_0015:  stloc.3
//000022:             {
//000023:                 child.Measure(availableSize);
//000024:                 if (maxChildSize.Width < child.DesiredSize.Width) maxChildSize.Width = child.DesiredSize.Width;
//000025:                 if (maxChildSize.Height < child.DesiredSize.Height) maxChildSize.Height = child.DesiredSize.Height;
//000026:             }
//000027:             return maxChildSize;
//000028:         }
//000029: 
//000030:         protected override Size ArrangeOverride(Size finalSize)
//000031:         {
//000032:             var children = InternalChildren.OfType<UIElement>().ToArray();
//000033:             if (children.Length > 0)
//000034:             {
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    .try
    {
      IL_0016:  br         IL_00a1

//000021:             foreach (UIElement child in InternalChildren)
      IL_001b:  ldloc.3
      IL_001c:  callvirt   instance object [mscorlib]System.Collections.IEnumerator::get_Current()
      IL_0021:  castclass  [PresentationCore]System.Windows.UIElement
      IL_0026:  stloc.1
//000022:             {
      IL_0027:  nop
//000023:                 child.Measure(availableSize);
      IL_0028:  ldloc.1
      IL_0029:  ldarg.1
      IL_002a:  callvirt   instance void [PresentationCore]System.Windows.UIElement::Measure(valuetype [WindowsBase]System.Windows.Size)
      IL_002f:  nop
//000024:                 if (maxChildSize.Width < child.DesiredSize.Width) maxChildSize.Width = child.DesiredSize.Width;
      IL_0030:  ldloca.s   maxChildSize
      IL_0032:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
      IL_0037:  ldloc.1
      IL_0038:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
      IL_003d:  stloc.s    CS$0$0002
      IL_003f:  ldloca.s   CS$0$0002
      IL_0041:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
      IL_0046:  clt
      IL_0048:  ldc.i4.0
      IL_0049:  ceq
      IL_004b:  stloc.s    CS$4$0003
//000025:                 if (maxChildSize.Height < child.DesiredSize.Height) maxChildSize.Height = child.DesiredSize.Height;
//000026:             }
//000027:             return maxChildSize;
//000028:         }
//000029: 
//000030:         protected override Size ArrangeOverride(Size finalSize)
//000031:         {
//000032:             var children = InternalChildren.OfType<UIElement>().ToArray();
//000033:             if (children.Length > 0)
//000034:             {
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
      IL_004d:  ldloc.s    CS$4$0003
      IL_004f:  brtrue.s   IL_0068

//000024:                 if (maxChildSize.Width < child.DesiredSize.Width) maxChildSize.Width = child.DesiredSize.Width;
      IL_0051:  ldloca.s   maxChildSize
      IL_0053:  ldloc.1
      IL_0054:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
      IL_0059:  stloc.s    CS$0$0002
      IL_005b:  ldloca.s   CS$0$0002
      IL_005d:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
      IL_0062:  call       instance void [WindowsBase]System.Windows.Size::set_Width(float64)
      IL_0067:  nop
//000025:                 if (maxChildSize.Height < child.DesiredSize.Height) maxChildSize.Height = child.DesiredSize.Height;
      IL_0068:  ldloca.s   maxChildSize
      IL_006a:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
      IL_006f:  ldloc.1
      IL_0070:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
      IL_0075:  stloc.s    CS$0$0002
      IL_0077:  ldloca.s   CS$0$0002
      IL_0079:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
      IL_007e:  clt
      IL_0080:  ldc.i4.0
      IL_0081:  ceq
      IL_0083:  stloc.s    CS$4$0003
//000026:             }
//000027:             return maxChildSize;
//000028:         }
//000029: 
//000030:         protected override Size ArrangeOverride(Size finalSize)
//000031:         {
//000032:             var children = InternalChildren.OfType<UIElement>().ToArray();
//000033:             if (children.Length > 0)
//000034:             {
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
      IL_0085:  ldloc.s    CS$4$0003
      IL_0087:  brtrue.s   IL_00a0

//000025:                 if (maxChildSize.Height < child.DesiredSize.Height) maxChildSize.Height = child.DesiredSize.Height;
      IL_0089:  ldloca.s   maxChildSize
      IL_008b:  ldloc.1
      IL_008c:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
      IL_0091:  stloc.s    CS$0$0002
      IL_0093:  ldloca.s   CS$0$0002
      IL_0095:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
      IL_009a:  call       instance void [WindowsBase]System.Windows.Size::set_Height(float64)
      IL_009f:  nop
//000026:             }
      IL_00a0:  nop
//000021:             foreach (UIElement child in InternalChildren)
      IL_00a1:  ldloc.3
      IL_00a2:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_00a7:  stloc.s    CS$4$0003
//000022:             {
//000023:                 child.Measure(availableSize);
//000024:                 if (maxChildSize.Width < child.DesiredSize.Width) maxChildSize.Width = child.DesiredSize.Width;
//000025:                 if (maxChildSize.Height < child.DesiredSize.Height) maxChildSize.Height = child.DesiredSize.Height;
//000026:             }
//000027:             return maxChildSize;
//000028:         }
//000029: 
//000030:         protected override Size ArrangeOverride(Size finalSize)
//000031:         {
//000032:             var children = InternalChildren.OfType<UIElement>().ToArray();
//000033:             if (children.Length > 0)
//000034:             {
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
      IL_00a9:  ldloc.s    CS$4$0003
      IL_00ab:  brtrue     IL_001b

      IL_00b0:  leave.s    IL_00ce

    }  // end .try
    finally
    {
      IL_00b2:  ldloc.3
      IL_00b3:  isinst     [mscorlib]System.IDisposable
      IL_00b8:  stloc.s    CS$0$0004
      IL_00ba:  ldloc.s    CS$0$0004
      IL_00bc:  ldnull
      IL_00bd:  ceq
      IL_00bf:  stloc.s    CS$4$0003
      IL_00c1:  ldloc.s    CS$4$0003
      IL_00c3:  brtrue.s   IL_00cd

      IL_00c5:  ldloc.s    CS$0$0004
      IL_00c7:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00cc:  nop
      IL_00cd:  endfinally
    }  // end handler
    IL_00ce:  nop
//000027:             return maxChildSize;
    IL_00cf:  ldloc.0
    IL_00d0:  stloc.2
    IL_00d1:  br.s       IL_00d3

//000028:         }
    IL_00d3:  ldloc.2
    IL_00d4:  ret
  } // end of method CircularPanel::MeasureOverride

  .method family hidebysig virtual instance valuetype [WindowsBase]System.Windows.Size 
          ArrangeOverride(valuetype [WindowsBase]System.Windows.Size finalSize) cil managed
  {
    // Code size       435 (0x1b3)
    .maxstack  6
    .locals init ([0] class [PresentationCore]System.Windows.UIElement[] children,
             [1] valuetype [WindowsBase]System.Windows.Point midPanel,
             [2] valuetype [WindowsBase]System.Windows.Size maxChild,
             [3] valuetype [WindowsBase]System.Windows.Size radius,
             [4] float64 arcRadiansPerChild,
             [5] int32 curPos,
             [6] class [PresentationCore]System.Windows.UIElement child,
             [7] float64 childAngleInRadians,
             [8] valuetype [WindowsBase]System.Windows.Point childPosition,
             [9] valuetype [WindowsBase]System.Windows.Size CS$1$0000,
             [10] bool CS$4$0001,
             [11] class [PresentationCore]System.Windows.UIElement[] CS$6$0002,
             [12] int32 CS$7$0003,
             [13] valuetype [WindowsBase]System.Windows.Size CS$0$0004)
//000029: 
//000030:         protected override Size ArrangeOverride(Size finalSize)
//000031:         {
    IL_0000:  nop
//000032:             var children = InternalChildren.OfType<UIElement>().ToArray();
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [PresentationFramework]System.Windows.Controls.UIElementCollection [PresentationFramework]System.Windows.Controls.Panel::get_InternalChildren()
    IL_0007:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [System.Core]System.Linq.Enumerable::OfType<class [PresentationCore]System.Windows.UIElement>(class [mscorlib]System.Collections.IEnumerable)
    IL_000c:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<class [PresentationCore]System.Windows.UIElement>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0011:  stloc.0
//000033:             if (children.Length > 0)
    IL_0012:  ldloc.0
    IL_0013:  ldlen
    IL_0014:  conv.i4
    IL_0015:  ldc.i4.0
    IL_0016:  cgt
    IL_0018:  ldc.i4.0
    IL_0019:  ceq
    IL_001b:  stloc.s    CS$4$0001
//000034:             {
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_001d:  ldloc.s    CS$4$0001
    IL_001f:  brtrue     IL_01ab

//000034:             {
    IL_0024:  nop
//000035:                 var midPanel = new Point(finalSize.Width / 2, finalSize.Height / 2);
    IL_0025:  ldloca.s   midPanel
    IL_0027:  ldarga.s   finalSize
    IL_0029:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_002e:  ldc.r8     2.
    IL_0037:  div
    IL_0038:  ldarga.s   finalSize
    IL_003a:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_003f:  ldc.r8     2.
    IL_0048:  div
    IL_0049:  call       instance void [WindowsBase]System.Windows.Point::.ctor(float64,
                                                                                float64)
    IL_004e:  nop
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
    IL_004f:  ldloca.s   maxChild
    IL_0051:  ldloc.0
    IL_0052:  ldsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0057:  brtrue.s   IL_006c

    IL_0059:  ldnull
    IL_005a:  ldftn      float64 DiningPhilosophers.CircularPanel::'<ArrangeOverride>b__0'(class [PresentationCore]System.Windows.UIElement)
    IL_0060:  newobj     instance void class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64>::.ctor(object,
                                                                                                                                      native int)
    IL_0065:  stsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_006a:  br.s       IL_006c

    IL_006c:  ldsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate2'
    IL_0071:  call       float64 [System.Core]System.Linq.Enumerable::Max<class [PresentationCore]System.Windows.UIElement>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                            class [mscorlib]System.Func`2<!!0,float64>)
    IL_0076:  ldloc.0
    IL_0077:  ldsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate3'
    IL_007c:  brtrue.s   IL_0091

    IL_007e:  ldnull
    IL_007f:  ldftn      float64 DiningPhilosophers.CircularPanel::'<ArrangeOverride>b__1'(class [PresentationCore]System.Windows.UIElement)
    IL_0085:  newobj     instance void class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64>::.ctor(object,
                                                                                                                                      native int)
    IL_008a:  stsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate3'
    IL_008f:  br.s       IL_0091

    IL_0091:  ldsfld     class [mscorlib]System.Func`2<class [PresentationCore]System.Windows.UIElement,float64> DiningPhilosophers.CircularPanel::'CS$<>9__CachedAnonymousMethodDelegate3'
    IL_0096:  call       float64 [System.Core]System.Linq.Enumerable::Max<class [PresentationCore]System.Windows.UIElement>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                            class [mscorlib]System.Func`2<!!0,float64>)
    IL_009b:  call       instance void [WindowsBase]System.Windows.Size::.ctor(float64,
                                                                               float64)
    IL_00a0:  nop
//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
    IL_00a1:  ldloca.s   radius
    IL_00a3:  ldarga.s   finalSize
    IL_00a5:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_00aa:  ldloca.s   maxChild
    IL_00ac:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_00b1:  sub
    IL_00b2:  ldc.r8     2.
    IL_00bb:  div
    IL_00bc:  ldarga.s   finalSize
    IL_00be:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_00c3:  ldloca.s   maxChild
    IL_00c5:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_00ca:  sub
    IL_00cb:  ldc.r8     2.
    IL_00d4:  div
    IL_00d5:  call       instance void [WindowsBase]System.Windows.Size::.ctor(float64,
                                                                               float64)
    IL_00da:  nop
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
    IL_00db:  ldc.r8     6.2831853071795862
    IL_00e4:  ldloc.0
    IL_00e5:  ldlen
    IL_00e6:  conv.i4
    IL_00e7:  conv.r8
    IL_00e8:  div
    IL_00e9:  stloc.s    arcRadiansPerChild
//000039: 
//000040:                 int curPos = 0;
    IL_00eb:  ldc.i4.0
    IL_00ec:  stloc.s    curPos
//000041:                 foreach (var child in children)
    IL_00ee:  nop
    IL_00ef:  ldloc.0
    IL_00f0:  stloc.s    CS$6$0002
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_00f2:  ldc.i4.0
    IL_00f3:  stloc.s    CS$7$0003
    IL_00f5:  br         IL_0199

//000041:                 foreach (var child in children)
    IL_00fa:  ldloc.s    CS$6$0002
    IL_00fc:  ldloc.s    CS$7$0003
    IL_00fe:  ldelem.ref
    IL_00ff:  stloc.s    child
//000042:                 {
    IL_0101:  nop
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
    IL_0102:  ldloc.s    curPos
    IL_0104:  conv.r8
    IL_0105:  ldloc.s    arcRadiansPerChild
    IL_0107:  mul
    IL_0108:  stloc.s    childAngleInRadians
//000044:                     var childPosition = new Point(
    IL_010a:  ldloca.s   childPosition
    IL_010c:  ldloc.s    childAngleInRadians
    IL_010e:  call       float64 [mscorlib]System.Math::Sin(float64)
    IL_0113:  ldloca.s   radius
    IL_0115:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_011a:  mul
    IL_011b:  ldloca.s   midPanel
    IL_011d:  call       instance float64 [WindowsBase]System.Windows.Point::get_X()
    IL_0122:  ldloc.s    child
    IL_0124:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
    IL_0129:  stloc.s    CS$0$0004
    IL_012b:  ldloca.s   CS$0$0004
    IL_012d:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_0132:  ldc.r8     2.
    IL_013b:  div
    IL_013c:  sub
    IL_013d:  add
    IL_013e:  ldloc.s    childAngleInRadians
    IL_0140:  call       float64 [mscorlib]System.Math::Cos(float64)
    IL_0145:  ldloca.s   radius
    IL_0147:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_014c:  mul
    IL_014d:  ldloca.s   midPanel
    IL_014f:  call       instance float64 [WindowsBase]System.Windows.Point::get_Y()
    IL_0154:  ldloc.s    child
    IL_0156:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
    IL_015b:  stloc.s    CS$0$0004
    IL_015d:  ldloca.s   CS$0$0004
    IL_015f:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_0164:  ldc.r8     2.
    IL_016d:  div
    IL_016e:  sub
    IL_016f:  add
    IL_0170:  call       instance void [WindowsBase]System.Windows.Point::.ctor(float64,
                                                                                float64)
    IL_0175:  nop
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
    IL_0176:  ldloc.s    child
    IL_0178:  ldloc.s    childPosition
    IL_017a:  ldloc.s    child
    IL_017c:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
    IL_0181:  newobj     instance void [WindowsBase]System.Windows.Rect::.ctor(valuetype [WindowsBase]System.Windows.Point,
                                                                               valuetype [WindowsBase]System.Windows.Size)
    IL_0186:  callvirt   instance void [PresentationCore]System.Windows.UIElement::Arrange(valuetype [WindowsBase]System.Windows.Rect)
    IL_018b:  nop
//000048:                     curPos++;
    IL_018c:  ldloc.s    curPos
    IL_018e:  ldc.i4.1
    IL_018f:  add
    IL_0190:  stloc.s    curPos
//000049:                 }
    IL_0192:  nop
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_0193:  ldloc.s    CS$7$0003
    IL_0195:  ldc.i4.1
    IL_0196:  add
    IL_0197:  stloc.s    CS$7$0003
//000041:                 foreach (var child in children)
    IL_0199:  ldloc.s    CS$7$0003
    IL_019b:  ldloc.s    CS$6$0002
    IL_019d:  ldlen
    IL_019e:  conv.i4
    IL_019f:  clt
    IL_01a1:  stloc.s    CS$4$0001
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_01a3:  ldloc.s    CS$4$0001
    IL_01a5:  brtrue     IL_00fa

//000050:             }
    IL_01aa:  nop
//000051:             return finalSize;
    IL_01ab:  ldarg.1
    IL_01ac:  stloc.s    CS$1$0000
    IL_01ae:  br.s       IL_01b0

//000052:         }
    IL_01b0:  ldloc.s    CS$1$0000
    IL_01b2:  ret
  } // end of method CircularPanel::ArrangeOverride

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [PresentationFramework]System.Windows.Controls.Panel::.ctor()
    IL_0006:  ret
  } // end of method CircularPanel::.ctor

  .method private hidebysig static float64 
          '<ArrangeOverride>b__0'(class [PresentationCore]System.Windows.UIElement u) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       19 (0x13)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000,
             [1] valuetype [WindowsBase]System.Windows.Size CS$0$0001)
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
    IL_0006:  stloc.1
    IL_0007:  ldloca.s   CS$0$0001
    IL_0009:  call       instance float64 [WindowsBase]System.Windows.Size::get_Width()
    IL_000e:  stloc.0
    IL_000f:  br.s       IL_0011

//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_0011:  ldloc.0
    IL_0012:  ret
  } // end of method CircularPanel::'<ArrangeOverride>b__0'

  .method private hidebysig static float64 
          '<ArrangeOverride>b__1'(class [PresentationCore]System.Windows.UIElement u) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       19 (0x13)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000,
             [1] valuetype [WindowsBase]System.Windows.Size CS$0$0001)
//000036:                 var maxChild = new Size(children.Max(u => u.DesiredSize.Width), children.Max(u => u.DesiredSize.Height));
    IL_0000:  ldarg.0
    IL_0001:  callvirt   instance valuetype [WindowsBase]System.Windows.Size [PresentationCore]System.Windows.UIElement::get_DesiredSize()
    IL_0006:  stloc.1
    IL_0007:  ldloca.s   CS$0$0001
    IL_0009:  call       instance float64 [WindowsBase]System.Windows.Size::get_Height()
    IL_000e:  stloc.0
    IL_000f:  br.s       IL_0011

//000037:                 var radius = new Size((finalSize.Width - maxChild.Width) / 2, (finalSize.Height - maxChild.Height) / 2);
//000038:                 double arcRadiansPerChild = Math.PI * 2 / children.Length;
//000039: 
//000040:                 int curPos = 0;
//000041:                 foreach (var child in children)
//000042:                 {
//000043:                     var childAngleInRadians = curPos * arcRadiansPerChild;
//000044:                     var childPosition = new Point(
//000045:                         (Math.Sin(childAngleInRadians) * radius.Width) + (midPanel.X - (child.DesiredSize.Width / 2)),
//000046:                         (Math.Cos(childAngleInRadians) * radius.Height) + (midPanel.Y - (child.DesiredSize.Height / 2)));
//000047:                     child.Arrange(new Rect(childPosition, child.DesiredSize));
//000048:                     curPos++;
//000049:                 }
//000050:             }
//000051:             return finalSize;
//000052:         }
//000053:     }
//000054: }
    IL_0011:  ldloc.0
    IL_0012:  ret
  } // end of method CircularPanel::'<ArrangeOverride>b__1'

} // end of class DiningPhilosophers.CircularPanel

.class public auto ansi beforefieldinit DiningPhilosophers.App
       extends [PresentationFramework]System.Windows.Application
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 16 50 72 65 73 65 6E 74 61 74 69 6F 6E 42   // ...PresentationB
                                                                                                  75 69 6C 64 54 61 73 6B 73 07 34 2E 30 2E 30 2E   // uildTasks.4.0.0.
                                                                                                  30 00 00 )                                        // 0..
  .method public hidebysig instance void 
          InitializeComponent() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       20 (0x14)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\obj\Debug\App.g.cs' 
//000047:         public void InitializeComponent() {
    IL_0000:  nop
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\App.xaml' 
//000004:              StartupUri="MainWindow.xaml">
    IL_0001:  ldarg.0
    IL_0002:  ldstr      "MainWindow.xaml"
    IL_0007:  ldc.i4.2
    IL_0008:  newobj     instance void [System]System.Uri::.ctor(string,
                                                                 valuetype [System]System.UriKind)
    IL_000d:  call       instance void [PresentationFramework]System.Windows.Application::set_StartupUri(class [System]System.Uri)
    IL_0012:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\obj\Debug\App.g.cs' 
    IL_0013:  ret
  } // end of method App::InitializeComponent

  .method public hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       22 (0x16)
    .maxstack  1
    .locals init ([0] class DiningPhilosophers.App app)
    IL_0000:  nop
    IL_0001:  newobj     instance void DiningPhilosophers.App::.ctor()
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  callvirt   instance void DiningPhilosophers.App::InitializeComponent()
    IL_000d:  nop
    IL_000e:  ldloc.0
    IL_000f:  callvirt   instance int32 [PresentationFramework]System.Windows.Application::Run()
    IL_0014:  pop
    IL_0015:  ret
  } // end of method App::Main

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [PresentationFramework]System.Windows.Application::.ctor()
    IL_0006:  ret
  } // end of method App::.ctor

} // end of class DiningPhilosophers.App

.class private auto ansi beforefieldinit DiningPhilosophers.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\DiningPhilosophers\DiningPhilosophers_CSharp\Properties\Resources.Designer.cs' 
//000032:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000033:         internal Resources()
//000034:         {
    IL_0007:  nop
//000035:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       60 (0x3c)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000036: 
//000037:         /// <summary>
//000038:         ///   Returns the cached ResourceManager instance used by this class.
//000039:         /// </summary>
//000040:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000041:         internal static global::System.Resources.ResourceManager ResourceManager
//000042:         {
//000043:             get
//000044:             {
    IL_0000:  nop
//000045:                 if ((resourceMan == null))
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager DiningPhilosophers.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  ceq
    IL_0009:  ldc.i4.0
    IL_000a:  ceq
    IL_000c:  stloc.2
//000046:                 {
//000047:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DiningPhilosophers.Properties.Resources", typeof(Resources).Assembly);
//000048:                     resourceMan = temp;
//000049:                 }
//000050:                 return resourceMan;
//000051:             }
//000052:         }
//000053: 
//000054:         /// <summary>
//000055:         ///   Overrides the current thread's CurrentUICulture property for all
//000056:         ///   resource lookups using this strongly typed resource class.
//000057:         /// </summary>
//000058:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000059:         internal static global::System.Globalization.CultureInfo Culture
//000060:         {
//000061:             get
//000062:             {
//000063:                 return resourceCulture;
//000064:             }
//000065:             set
//000066:             {
//000067:                 resourceCulture = value;
//000068:             }
//000069:         }
//000070:     }
//000071: }
    IL_000d:  ldloc.2
    IL_000e:  brtrue.s   IL_0032

//000046:                 {
    IL_0010:  nop
//000047:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DiningPhilosophers.Properties.Resources", typeof(Resources).Assembly);
    IL_0011:  ldstr      "DiningPhilosophers.Properties.Resources"
    IL_0016:  ldtoken    DiningPhilosophers.Properties.Resources
    IL_001b:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0020:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0025:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002a:  stloc.0
//000048:                     resourceMan = temp;
    IL_002b:  ldloc.0
    IL_002c:  stsfld     class [mscorlib]System.Resources.ResourceManager DiningPhilosophers.Properties.Resources::resourceMan
//000049:                 }
    IL_0031:  nop
//000050:                 return resourceMan;
    IL_0032:  ldsfld     class [mscorlib]System.Resources.ResourceManager DiningPhilosophers.Properties.Resources::resourceMan
    IL_0037:  stloc.1
    IL_0038:  br.s       IL_003a

//000051:             }
    IL_003a:  ldloc.1
    IL_003b:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000052:         }
//000053: 
//000054:         /// <summary>
//000055:         ///   Overrides the current thread's CurrentUICulture property for all
//000056:         ///   resource lookups using this strongly typed resource class.
//000057:         /// </summary>
//000058:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000059:         internal static global::System.Globalization.CultureInfo Culture
//000060:         {
//000061:             get
//000062:             {
    IL_0000:  nop
//000063:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo DiningPhilosophers.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000064:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000065:             set
//000066:             {
    IL_0000:  nop
//000067:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo DiningPhilosophers.Properties.Resources::resourceCulture
//000068:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager DiningPhilosophers.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Globalization.CultureInfo DiningPhilosophers.Properties.Resources::get_Culture()
    .set void DiningPhilosophers.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
  } // end of property Resources::Culture
} // end of class DiningPhilosophers.Properties.Resources


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
