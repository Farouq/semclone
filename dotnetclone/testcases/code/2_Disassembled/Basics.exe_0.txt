
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v2.0.50727
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 2:0:0:0
}
.assembly extern FSharp.Core
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 2:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 2:0:0:0
}
.assembly Basics
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.FSharpInterfaceDataVersionAttribute::.ctor(int32,
                                                                                                      int32,
                                                                                                      int32) = ( 01 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 ) 

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 01 01 00 00 00 00 ) 

  .hash algorithm 0x00008004
  .ver 0:0:0:0
}
.mresource public FSharpSignatureData.Basics
{
  // Offset: 0x00000000 Length: 0x00002861
}
.mresource public FSharpOptimizationData.Basics
{
  // Offset: 0x00002868 Length: 0x00000ADD
}
.module Basics.exe
// MVID: {4F77CC05-58D1-D72C-A745-038305CC774F}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0003       // WINDOWS_CUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x004A0000


// =============== CLASS MEMBERS DECLARATION ===================

.class public abstract auto ansi sealed BasicsDriver
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested assembly beforefieldinit writeInColor@11
         extends [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::.ctor()
      IL_0006:  ret
    } // end of method writeInColor@11::.ctor

    .method public strict virtual instance object 
            Specialize<a>() cil managed
    {
      // Code size       12 (0xc)
      .maxstack  3
      IL_0000:  ldarg.0
      IL_0001:  newobj     instance void class BasicsDriver/writeInColor@11T<!!a>::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc)
      IL_0006:  box        class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!a,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
      IL_000b:  ret
    } // end of method writeInColor@11::Specialize

  } // end of class writeInColor@11

  .class auto ansi serializable nested assembly beforefieldinit writeInColor@11T<a>
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<valuetype [mscorlib]System.ConsoleColor,!a,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc self0@
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc self0@) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<valuetype [mscorlib]System.ConsoleColor,!a,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc class BasicsDriver/writeInColor@11T<!a>::self0@
      IL_000d:  ret
    } // end of method writeInColor@11T::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(valuetype [mscorlib]System.ConsoleColor color,
                   !a msg) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       48 (0x30)
      .maxstack  6
      .locals init ([0] valuetype [mscorlib]System.ConsoleColor oldColor,
               [1] !a V_1,
               [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc V_2)
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc class BasicsDriver/writeInColor@11T<!a>::self0@
      IL_0006:  stloc.2
      .language '{AB4F38C9-B6E6-43BA-BE3B-58080B2CCCE3}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\Driver.fs' 
//000012:         let oldColor = Console.ForegroundColor
      IL_0007:  nop
      IL_0008:  call       valuetype [mscorlib]System.ConsoleColor [mscorlib]System.Console::get_ForegroundColor()
      IL_000d:  stloc.0
//000013:         Console.ForegroundColor <- color
      IL_000e:  ldarg.1
      IL_000f:  call       void [mscorlib]System.Console::set_ForegroundColor(valuetype [mscorlib]System.ConsoleColor)
//000014:         Console.WriteLine(msg.ToString())
      IL_0014:  ldarg.2
      IL_0015:  stloc.1
      IL_0016:  ldloca.s   V_1
      IL_0018:  constrained. !a
      IL_001e:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0023:  call       void [mscorlib]System.Console::WriteLine(string)
//000015:         Console.ForegroundColor <- oldColor
      IL_0028:  ldloc.0
      IL_0029:  call       void [mscorlib]System.Console::set_ForegroundColor(valuetype [mscorlib]System.ConsoleColor)
      IL_002e:  ldnull
      IL_002f:  ret
    } // end of method writeInColor@11T::Invoke

  } // end of class writeInColor@11T

  .class auto ansi serializable nested assembly beforefieldinit result@26
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,bool>::.ctor()
      IL_0006:  ret
    } // end of method result@26::.ctor

    .method public strict virtual instance bool 
            Invoke(object attr) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  5
      .locals init ([0] object V_0)
//000016: 
//000017:     writeInColor ConsoleColor.Green "::::::::::: Executing Pro F# Basics samples :::::::::::"
//000018: 
//000019:     let SIPNP = 
//000020:         BindingFlags.Static ||| BindingFlags.Instance ||| 
//000021:         BindingFlags.Public ||| BindingFlags.NonPublic
//000022:     Assembly.GetExecutingAssembly().GetTypes() |> Array.iter (fun typ ->
//000023:             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
//000024:                 let customAttrs = meth.GetCustomAttributes(false)
//000025:                 try
//000026:                     let result = customAttrs |> Array.find (fun attr -> attr :? ExampleAttribute)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  isinst     ProFSharp/ExampleAttribute
      IL_0009:  ldnull
      IL_000a:  cgt.un
      IL_000c:  ret
    } // end of method result@26::Invoke

  } // end of class result@26

  .class auto ansi serializable nested assembly beforefieldinit 'Main@23-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MethodInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc writeInColor
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc writeInColor) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MethodInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/'Main@23-1'::writeInColor
      IL_000d:  ret
    } // end of method 'Main@23-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.Reflection.MethodInfo meth) cil managed
    {
      // Code size       245 (0xf5)
      .maxstack  8
      .locals init ([0] object[] customAttrs,
               [1] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_1,
               [2] object result,
               [3] object V_3,
               [4] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_4,
               [5] object V_5,
               [6] object V_6,
               [7] class [mscorlib]System.Exception ex,
               [8] class [mscorlib]System.Exception V_8,
               [9] string V_9,
               [10] valuetype [mscorlib]System.ConsoleColor V_10,
               [11] string V_11,
               [12] valuetype [mscorlib]System.ConsoleColor V_12,
               [13] string V_13,
               [14] valuetype [mscorlib]System.ConsoleColor V_14)
//000024:                 let customAttrs = meth.GetCustomAttributes(false)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldc.i4.0
      IL_0003:  callvirt   instance object[] [mscorlib]System.Reflection.MemberInfo::GetCustomAttributes(bool)
      IL_0008:  stloc.0
//000025:                 try
      .try
      {
        IL_0009:  nop
//000026:                     let result = customAttrs |> Array.find (fun attr -> attr :? ExampleAttribute)
        IL_000a:  newobj     instance void BasicsDriver/result@26::.ctor()
        IL_000f:  ldloc.0
        IL_0010:  call       !!0 [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Find<object>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                     !!0[])
        IL_0015:  stloc.2
//000027:                     if result :? ExampleAttribute then
        IL_0016:  ldloc.2
        IL_0017:  stloc.3
        IL_0018:  ldloc.3
        IL_0019:  isinst     ProFSharp/ExampleAttribute
        IL_001e:  ldnull
        IL_001f:  cgt.un
        IL_0021:  brfalse.s  IL_0025

        IL_0023:  br.s       IL_002a

        IL_0025:  br         IL_00e4

//000028:                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result :?> ExampleAttribute).Value)
        IL_002a:  ldarg.0
        IL_002b:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/'Main@23-1'::writeInColor
        IL_0030:  ldc.i4.s   9
        IL_0032:  ldstr      "==========> Executing "
        IL_0037:  ldloc.2
        IL_0038:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::UnboxGeneric<class ProFSharp/ExampleAttribute>(object)
        IL_003d:  call       instance string ProFSharp/ExampleAttribute::get_Value()
        IL_0042:  call       string [mscorlib]System.String::Concat(string,
                                                                    string)
        IL_0047:  stloc.s    V_9
        IL_0049:  stloc.s    V_10
        IL_004b:  callvirt   instance object [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::Specialize<string>()
        IL_0050:  unbox.any  class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
        IL_0055:  ldloc.s    V_10
        IL_0057:  ldloc.s    V_9
        IL_0059:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,string>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                                  !0,
                                                                                                                                                                                                  !1)
        IL_005e:  pop
//000029:                         try
        .try
        {
          IL_005f:  nop
//000030:                             meth.Invoke(null, [| |]) |> ignore
          IL_0060:  ldarg.1
          IL_0061:  ldnull
          IL_0062:  ldc.i4.0
          IL_0063:  newarr     [mscorlib]System.Object
          IL_0068:  callvirt   instance object [mscorlib]System.Reflection.MethodBase::Invoke(object,
                                                                                              object[])
          IL_006d:  stloc.s    V_5
          IL_006f:  ldloc.s    V_5
          IL_0071:  stloc.s    V_6
          IL_0073:  ldnull
          IL_0074:  stloc.s    V_4
          IL_0076:  leave.s    IL_00df

//000031:                         with
        }  // end .try
        catch [mscorlib]System.Object 
        {
          IL_0078:  castclass  [mscorlib]System.Exception
          IL_007d:  stloc.s    ex
//000032:                         | ex -> 
//000033:                             writeInColor ConsoleColor.Red ("Exception: " + ex.InnerException.Message)
          IL_007f:  ldarg.0
          IL_0080:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/'Main@23-1'::writeInColor
          IL_0085:  ldc.i4.s   12
          IL_0087:  ldstr      "Exception: "
          IL_008c:  ldloc.s    ex
          IL_008e:  callvirt   instance class [mscorlib]System.Exception [mscorlib]System.Exception::get_InnerException()
          IL_0093:  callvirt   instance string [mscorlib]System.Exception::get_Message()
          IL_0098:  call       string [mscorlib]System.String::Concat(string,
                                                                      string)
          IL_009d:  stloc.s    V_11
          IL_009f:  stloc.s    V_12
          IL_00a1:  callvirt   instance object [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::Specialize<string>()
          IL_00a6:  unbox.any  class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
          IL_00ab:  ldloc.s    V_12
          IL_00ad:  ldloc.s    V_11
          IL_00af:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,string>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                                    !0,
                                                                                                                                                                                                    !1)
          IL_00b4:  pop
//000034:                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
          IL_00b5:  ldarg.0
          IL_00b6:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/'Main@23-1'::writeInColor
          IL_00bb:  ldc.i4.s   14
          IL_00bd:  ldloc.s    ex
          IL_00bf:  callvirt   instance string [mscorlib]System.Exception::get_StackTrace()
          IL_00c4:  stloc.s    V_13
          IL_00c6:  stloc.s    V_14
          IL_00c8:  callvirt   instance object [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::Specialize<string>()
          IL_00cd:  unbox.any  class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
          IL_00d2:  ldloc.s    V_14
          IL_00d4:  ldloc.s    V_13
          IL_00d6:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,string>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                                    !0,
                                                                                                                                                                                                    !1)
          IL_00db:  stloc.s    V_4
          IL_00dd:  leave.s    IL_00df

//000035:                     else
//000036:                         ()
//000037:                 with
//000038:                 |   ex -> ()
//000039:             )
//000040:         )
//000041:     0
        }  // end handler
        IL_00df:  ldloc.s    V_4
        IL_00e1:  stloc.1
        IL_00e2:  leave.s    IL_00f3

//000036:                         ()
        IL_00e4:  ldnull
        IL_00e5:  stloc.1
        IL_00e6:  leave.s    IL_00f3

//000037:                 with
      }  // end .try
      catch [mscorlib]System.Object 
      {
        IL_00e8:  castclass  [mscorlib]System.Exception
        IL_00ed:  stloc.s    V_8
//000038:                 |   ex -> ()
        IL_00ef:  ldnull
        IL_00f0:  stloc.1
        IL_00f1:  leave.s    IL_00f3

//000039:             )
//000040:         )
//000041:     0
      }  // end handler
      IL_00f3:  ldloc.1
      IL_00f4:  ret
    } // end of method 'Main@23-1'::Invoke

  } // end of class 'Main@23-1'

  .class auto ansi serializable nested assembly beforefieldinit Main@22
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc writeInColor
    .field public valuetype [mscorlib]System.Reflection.BindingFlags SIPNP
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc writeInColor,
                                 valuetype [mscorlib]System.Reflection.BindingFlags SIPNP) cil managed
    {
      // Code size       21 (0x15)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/Main@22::writeInColor
      IL_000d:  ldarg.0
      IL_000e:  ldarg.2
      IL_000f:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags BasicsDriver/Main@22::SIPNP
      IL_0014:  ret
    } // end of method Main@22::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.Type typ) cil managed
    {
      // Code size       107 (0x6b)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.MethodInfo[] V_0,
               [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MethodInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_1,
               [2] class [mscorlib]System.Reflection.MethodInfo[] V_2,
               [3] int32 V_3,
               [4] int32 V_4,
               [5] int32 V_5)
//000023:             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldarg.0
      IL_0003:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags BasicsDriver/Main@22::SIPNP
      IL_0008:  callvirt   instance class [mscorlib]System.Reflection.MethodInfo[] [mscorlib]System.Type::GetMethods(valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_000d:  stloc.0
      IL_000e:  ldarg.0
      IL_000f:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc BasicsDriver/Main@22::writeInColor
      IL_0014:  newobj     instance void BasicsDriver/'Main@23-1'::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc)
      IL_0019:  stloc.1
      IL_001a:  ldloc.0
      IL_001b:  stloc.2
      IL_001c:  ldloc.2
      IL_001d:  box        class [mscorlib]System.Reflection.MethodInfo[]
      IL_0022:  brfalse.s  IL_0026

      IL_0024:  br.s       IL_0039

//000024:                 let customAttrs = meth.GetCustomAttributes(false)
//000025:                 try
//000026:                     let result = customAttrs |> Array.find (fun attr -> attr :? ExampleAttribute)
//000027:                     if result :? ExampleAttribute then
//000028:                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result :?> ExampleAttribute).Value)
//000029:                         try
//000030:                             meth.Invoke(null, [| |]) |> ignore
//000031:                         with
//000032:                         | ex -> 
//000033:                             writeInColor ConsoleColor.Red ("Exception: " + ex.InnerException.Message)
//000034:                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
//000035:                     else
//000036:                         ()
//000037:                 with
//000038:                 |   ex -> ()
//000039:             )
//000040:         )
//000041:     0
      IL_0026:  ldstr      "array"
      IL_002b:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
      IL_0030:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
      IL_0035:  pop
      IL_0036:  nop
      IL_0037:  br.s       IL_003a

      IL_0039:  nop
      IL_003a:  ldloc.2
      IL_003b:  ldlen
      IL_003c:  conv.i4
      IL_003d:  stloc.3
      IL_003e:  ldc.i4.0
      IL_003f:  stloc.s    V_5
      IL_0041:  ldloc.3
      IL_0042:  ldc.i4.1
      IL_0043:  sub
      IL_0044:  stloc.s    V_4
      IL_0046:  ldloc.s    V_4
      IL_0048:  ldloc.s    V_5
      IL_004a:  blt.s      IL_0069

//000023:             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
      IL_004c:  ldloc.1
      IL_004d:  ldloc.2
      IL_004e:  ldloc.s    V_5
      IL_0050:  ldelem     [mscorlib]System.Reflection.MethodInfo
      IL_0055:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MethodInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
      IL_005a:  pop
      IL_005b:  ldloc.s    V_5
      IL_005d:  ldc.i4.1
      IL_005e:  add
      IL_005f:  stloc.s    V_5
      IL_0061:  ldloc.s    V_5
      IL_0063:  ldloc.s    V_4
      IL_0065:  ldc.i4.1
      IL_0066:  add
      IL_0067:  bne.un.s   IL_004c

      IL_0069:  ldnull
      IL_006a:  ret
    } // end of method Main@22::Invoke

  } // end of class Main@22

  .method public static int32  Main(string[] args) cil managed
  {
    .entrypoint
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.EntryPointAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       151 (0x97)
    .maxstack  5
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc writeInColor,
             [1] valuetype [mscorlib]System.Reflection.BindingFlags SIPNP,
             [2] class [mscorlib]System.Type[] V_2,
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_3,
             [4] class [mscorlib]System.Type[] V_4,
             [5] int32 V_5,
             [6] int32 V_6,
             [7] int32 V_7,
             [8] string V_8,
             [9] valuetype [mscorlib]System.ConsoleColor V_9)
//000011:     let writeInColor color msg =
    IL_0000:  nop
    IL_0001:  newobj     instance void BasicsDriver/writeInColor@11::.ctor()
    IL_0006:  stloc.0
//000012:         let oldColor = Console.ForegroundColor
//000013:         Console.ForegroundColor <- color
//000014:         Console.WriteLine(msg.ToString())
//000015:         Console.ForegroundColor <- oldColor
//000016: 
//000017:     writeInColor ConsoleColor.Green "::::::::::: Executing Pro F# Basics samples :::::::::::"
    IL_0007:  ldloc.0
    IL_0008:  ldc.i4.s   10
    IL_000a:  ldstr      "::::::::::: Executing Pro F# Basics samples ::::::"
    + ":::::"
    IL_000f:  stloc.s    V_8
    IL_0011:  stloc.s    V_9
    IL_0013:  callvirt   instance object [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::Specialize<string>()
    IL_0018:  unbox.any  class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>>
    IL_001d:  ldloc.s    V_9
    IL_001f:  ldloc.s    V_8
    IL_0021:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<valuetype [mscorlib]System.ConsoleColor,string>::InvokeFast<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                                              !0,
                                                                                                                                                                                              !1)
    IL_0026:  pop
//000018: 
//000019:     let SIPNP = 
    IL_0027:  ldc.i4.s   28
    IL_0029:  ldc.i4.s   32
    IL_002b:  or
    IL_002c:  stloc.1
//000020:         BindingFlags.Static ||| BindingFlags.Instance ||| 
//000021:         BindingFlags.Public ||| BindingFlags.NonPublic
//000022:     Assembly.GetExecutingAssembly().GetTypes() |> Array.iter (fun typ ->
    IL_002d:  call       class [mscorlib]System.Reflection.Assembly [mscorlib]System.Reflection.Assembly::GetExecutingAssembly()
    IL_0032:  callvirt   instance class [mscorlib]System.Type[] [mscorlib]System.Reflection.Assembly::GetTypes()
    IL_0037:  stloc.2
    IL_0038:  ldloc.0
    IL_0039:  ldloc.1
    IL_003a:  newobj     instance void BasicsDriver/Main@22::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc,
                                                                   valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_003f:  stloc.3
    IL_0040:  ldloc.2
    IL_0041:  stloc.s    V_4
    IL_0043:  ldloc.s    V_4
    IL_0045:  box        class [mscorlib]System.Type[]
    IL_004a:  brfalse.s  IL_004e

    IL_004c:  br.s       IL_0061

//000023:             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
//000024:                 let customAttrs = meth.GetCustomAttributes(false)
//000025:                 try
//000026:                     let result = customAttrs |> Array.find (fun attr -> attr :? ExampleAttribute)
//000027:                     if result :? ExampleAttribute then
//000028:                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result :?> ExampleAttribute).Value)
//000029:                         try
//000030:                             meth.Invoke(null, [| |]) |> ignore
//000031:                         with
//000032:                         | ex -> 
//000033:                             writeInColor ConsoleColor.Red ("Exception: " + ex.InnerException.Message)
//000034:                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
//000035:                     else
//000036:                         ()
//000037:                 with
//000038:                 |   ex -> ()
//000039:             )
//000040:         )
//000041:     0
    IL_004e:  ldstr      "array"
    IL_0053:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0058:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
    IL_005d:  pop
    IL_005e:  nop
    IL_005f:  br.s       IL_0062

    IL_0061:  nop
    IL_0062:  ldloc.s    V_4
    IL_0064:  ldlen
    IL_0065:  conv.i4
    IL_0066:  stloc.s    V_5
    IL_0068:  ldc.i4.0
    IL_0069:  stloc.s    V_7
    IL_006b:  ldloc.s    V_5
    IL_006d:  ldc.i4.1
    IL_006e:  sub
    IL_006f:  stloc.s    V_6
    IL_0071:  ldloc.s    V_6
    IL_0073:  ldloc.s    V_7
    IL_0075:  blt.s      IL_0095

//000022:     Assembly.GetExecutingAssembly().GetTypes() |> Array.iter (fun typ ->
    IL_0077:  ldloc.3
    IL_0078:  ldloc.s    V_4
    IL_007a:  ldloc.s    V_7
    IL_007c:  ldelem     [mscorlib]System.Type
    IL_0081:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
    IL_0086:  pop
    IL_0087:  ldloc.s    V_7
    IL_0089:  ldc.i4.1
    IL_008a:  add
    IL_008b:  stloc.s    V_7
    IL_008d:  ldloc.s    V_7
    IL_008f:  ldloc.s    V_6
    IL_0091:  ldc.i4.1
    IL_0092:  add
    IL_0093:  bne.un.s   IL_0077

//000023:             typ.GetMethods(SIPNP) |> Array.iter (fun meth ->
//000024:                 let customAttrs = meth.GetCustomAttributes(false)
//000025:                 try
//000026:                     let result = customAttrs |> Array.find (fun attr -> attr :? ExampleAttribute)
//000027:                     if result :? ExampleAttribute then
//000028:                         writeInColor ConsoleColor.Blue ("==========> Executing " + (result :?> ExampleAttribute).Value)
//000029:                         try
//000030:                             meth.Invoke(null, [| |]) |> ignore
//000031:                         with
//000032:                         | ex -> 
//000033:                             writeInColor ConsoleColor.Red ("Exception: " + ex.InnerException.Message)
//000034:                             writeInColor ConsoleColor.Yellow (ex.StackTrace)
//000035:                     else
//000036:                         ()
//000037:                 with
//000038:                 |   ex -> ()
//000039:             )
//000040:         )
//000041:     0
    IL_0095:  ldc.i4.0
    IL_0096:  ret
  } // end of method BasicsDriver::Main

} // end of class BasicsDriver

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$BasicsDriver
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Basics>'.$BasicsDriver

.class public abstract auto ansi sealed PatternMatching
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested assembly beforefieldinit pat_example@27
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]System.Tuple`3<string,string,int32>,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]System.Tuple`3<string,string,int32>,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method pat_example@27::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [FSharp.Core]System.Tuple`3<string,string,int32> p) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  7
      .locals init ([0] class [FSharp.Core]System.Tuple`3<string,string,int32> V_0,
               [1] string ln,
               [2] string fn)
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PatternMatching.fs' 
//000027:         (fun (p) -> match p with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  call       instance !1 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item2()
      IL_0009:  stloc.1
      IL_000a:  ldloc.0
      IL_000b:  call       instance !0 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item1()
      IL_0010:  stloc.2
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
      IL_0011:  ldstr      "{0} {1}"
      IL_0016:  ldloc.2
      IL_0017:  ldloc.1
      IL_0018:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object,
                                                                    object)
      IL_001d:  ldnull
      IL_001e:  ret
    } // end of method pat_example@27::Invoke

  } // end of class pat_example@27

  .class auto ansi serializable nested assembly beforefieldinit 'pat_example@48-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method 'pat_example@48-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       113 (0x71)
      .maxstack  6
      .locals init ([0] class [FSharp.Core]System.Tuple`2<string,string> V_0,
               [1] string fn,
               [2] string V_2)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
//000035:                     | ("Ken", "Sipe", _) -> p.LastName
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0007:  ldarg.1
      IL_0008:  call       instance string HelperTypes/Person::get_LastName()
      IL_000d:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,string>::.ctor(!0,
                                                                                                 !1)
      IL_0012:  stloc.0
      IL_0013:  ldloc.0
      IL_0014:  call       instance !1 class [FSharp.Core]System.Tuple`2<string,string>::get_Item2()
      IL_0019:  ldstr      "Sipe"
      IL_001e:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0023:  brfalse.s  IL_0027

      IL_0025:  br.s       IL_003d

      IL_0027:  ldloc.0
      IL_0028:  call       instance !1 class [FSharp.Core]System.Tuple`2<string,string>::get_Item2()
      IL_002d:  ldstr      "Neward"
      IL_0032:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0037:  brfalse.s  IL_003b

      IL_0039:  br.s       IL_0051

      IL_003b:  br.s       IL_0065

      IL_003d:  ldloc.0
      IL_003e:  call       instance !0 class [FSharp.Core]System.Tuple`2<string,string>::get_Item1()
      IL_0043:  stloc.1
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
      IL_0044:  ldstr      "Hello, {0}!"
      IL_0049:  ldloc.1
      IL_004a:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_004f:  ldnull
      IL_0050:  ret

//000049:             match (p.FirstName, p.LastName) with
      IL_0051:  ldloc.0
      IL_0052:  call       instance !0 class [FSharp.Core]System.Tuple`2<string,string>::get_Item1()
      IL_0057:  stloc.2
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
      IL_0058:  ldstr      "Go away, {0}!"
      IL_005d:  ldloc.2
      IL_005e:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_0063:  ldnull
      IL_0064:  ret

//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
      IL_0065:  ldstr      "Who the heck are you\?"
      IL_006a:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_006f:  ldnull
      IL_0070:  ret
    } // end of method 'pat_example@48-1'::Invoke

  } // end of class 'pat_example@48-1'

  .class auto ansi serializable nested assembly beforefieldinit sumList@132
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>,int32>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>,int32>::.ctor()
      IL_0006:  ret
    } // end of method sumList@132::.ctor

    .method public strict virtual instance int32 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> ns) cil managed
    {
      // Code size       41 (0x29)
      .maxstack  7
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_0,
               [1] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_1,
               [2] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> tail,
               [3] int32 head)
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

//000133:                             | [] -> 0
      IL_000d:  ldc.i4.0
      IL_000e:  ret

//000132:     let rec sumList ns = match ns with
      IL_000f:  ldloc.0
      IL_0010:  stloc.1
      IL_0011:  ldloc.1
      IL_0012:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
      IL_0017:  stloc.2
      IL_0018:  ldloc.1
      IL_0019:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_HeadOrDefault()
      IL_001e:  stloc.3
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
      IL_001f:  ldloc.3
      IL_0020:  ldarg.0
      IL_0021:  ldloc.2
      IL_0022:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>,int32>::Invoke(!0)
      IL_0027:  add
      IL_0028:  ret
    } // end of method sumList@132::Invoke

  } // end of class sumList@132

  .class auto ansi serializable nested assembly beforefieldinit isOldFogey@199
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method isOldFogey@199::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person person) cil managed
    {
      // Code size       118 (0x76)
      .maxstack  6
      .locals init ([0] class HelperTypes/Person V_0)
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldarg.1
      IL_0004:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0009:  ldc.i4.s   35
      IL_000b:  ble.s      IL_000f

      IL_000d:  br.s       IL_0011

      IL_000f:  br.s       IL_0015

//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
      IL_0011:  ldc.i4.1
      IL_0012:  nop
      IL_0013:  br.s       IL_0040

      IL_0015:  ldarg.1
      IL_0016:  call       instance string HelperTypes/Person::get_FirstName()
      IL_001b:  ldstr      "Ted"
      IL_0020:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0025:  brfalse.s  IL_0029

      IL_0027:  br.s       IL_002b

      IL_0029:  br.s       IL_003e

      IL_002b:  ldarg.1
      IL_002c:  call       instance string HelperTypes/Person::get_LastName()
      IL_0031:  ldstr      "Neward"
      IL_0036:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_003b:  nop
      IL_003c:  br.s       IL_0040

      IL_003e:  ldc.i4.0
      IL_003f:  nop
      IL_0040:  brfalse.s  IL_0044

      IL_0042:  br.s       IL_0046

      IL_0044:  br.s       IL_004a

      IL_0046:  ldc.i4.1
      IL_0047:  nop
      IL_0048:  br.s       IL_0075

      IL_004a:  ldarg.1
      IL_004b:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0050:  ldstr      "Aaron"
      IL_0055:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_005a:  brfalse.s  IL_005e

      IL_005c:  br.s       IL_0060

      IL_005e:  br.s       IL_0073

      IL_0060:  ldarg.1
      IL_0061:  call       instance string HelperTypes/Person::get_LastName()
      IL_0066:  ldstr      "Erickson"
      IL_006b:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0070:  nop
      IL_0071:  br.s       IL_0075

      IL_0073:  ldc.i4.0
      IL_0074:  nop
      IL_0075:  ret
    } // end of method isOldFogey@199::Invoke

  } // end of class isOldFogey@199

  .class auto ansi serializable nested assembly beforefieldinit isOld@211
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method isOld@211::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       12 (0xc)
      .maxstack  6
//000211:             p.Age > 35
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0007:  ldc.i4.s   35
      IL_0009:  cgt
      IL_000b:  ret
    } // end of method isOld@211::Invoke

  } // end of class isOld@211

  .class auto ansi serializable nested assembly beforefieldinit isTed@213
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method isTed@213::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       42 (0x2a)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0007:  ldstr      "Ted"
      IL_000c:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0011:  brfalse.s  IL_0015

      IL_0013:  br.s       IL_0017

      IL_0015:  br.s       IL_0028

      IL_0017:  ldarg.1
      IL_0018:  call       instance string HelperTypes/Person::get_LastName()
      IL_001d:  ldstr      "Neward"
      IL_0022:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0027:  ret

      IL_0028:  ldc.i4.0
      IL_0029:  ret
    } // end of method isTed@213::Invoke

  } // end of class isTed@213

  .class auto ansi serializable nested assembly beforefieldinit isAaron@215
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method isAaron@215::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       42 (0x2a)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0007:  ldstr      "Aaron"
      IL_000c:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0011:  brfalse.s  IL_0015

      IL_0013:  br.s       IL_0017

      IL_0015:  br.s       IL_0028

      IL_0017:  ldarg.1
      IL_0018:  call       instance string HelperTypes/Person::get_LastName()
      IL_001d:  ldstr      "Erickson"
      IL_0022:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0027:  ret

      IL_0028:  ldc.i4.0
      IL_0029:  ret
    } // end of method isAaron@215::Invoke

  } // end of class isAaron@215

  .class auto ansi serializable nested assembly beforefieldinit 'isOldFogey\'@210'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .field public class HelperTypes/Person p
    .method assembly specialname rtspecialname 
            instance void  .ctor(class HelperTypes/Person p) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class HelperTypes/Person PatternMatching/'isOldFogey\'@210'::p
      IL_000d:  ret
    } // end of method 'isOldFogey\'@210'::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person person) cil managed
    {
      // Code size       85 (0x55)
      .maxstack  6
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> isOld,
               [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> isTed,
               [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> isAaron,
               [3] class HelperTypes/Person V_3)
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
      IL_0000:  newobj     instance void PatternMatching/isOld@211::.ctor()
      IL_0005:  stloc.0
      IL_0006:  newobj     instance void PatternMatching/isTed@213::.ctor()
      IL_000b:  stloc.1
      IL_000c:  newobj     instance void PatternMatching/isAaron@215::.ctor()
      IL_0011:  stloc.2
      IL_0012:  nop
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class HelperTypes/Person PatternMatching/'isOldFogey\'@210'::p
      IL_0019:  stloc.3
      IL_001a:  ldloc.0
      IL_001b:  ldarg.0
      IL_001c:  ldfld      class HelperTypes/Person PatternMatching/'isOldFogey\'@210'::p
      IL_0021:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
      IL_0026:  brfalse.s  IL_002a

      IL_0028:  br.s       IL_002c

      IL_002a:  br.s       IL_0030

//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
      IL_002c:  ldc.i4.1
      IL_002d:  nop
      IL_002e:  br.s       IL_003d

      IL_0030:  ldloc.1
      IL_0031:  ldarg.0
      IL_0032:  ldfld      class HelperTypes/Person PatternMatching/'isOldFogey\'@210'::p
      IL_0037:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
      IL_003c:  nop
      IL_003d:  brfalse.s  IL_0041

      IL_003f:  br.s       IL_0043

      IL_0041:  br.s       IL_0047

      IL_0043:  ldc.i4.1
      IL_0044:  nop
      IL_0045:  br.s       IL_0054

      IL_0047:  ldloc.2
      IL_0048:  ldarg.0
      IL_0049:  ldfld      class HelperTypes/Person PatternMatching/'isOldFogey\'@210'::p
      IL_004e:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
      IL_0053:  nop
      IL_0054:  ret
    } // end of method 'isOldFogey\'@210'::Invoke

  } // end of class 'isOldFogey\'@210'

  .class auto ansi serializable nested assembly beforefieldinit 'isOldFogey\'\'@225'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method 'isOldFogey\'\'@225'::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       185 (0xb9)
      .maxstack  7
      .locals init ([0] class [FSharp.Core]System.Tuple`3<int32,string,string> V_0,
               [1] int32 a,
               [2] int32 V_2,
               [3] int32 V_3,
               [4] int32 V_4)
//000225:         match p.Age, p.FirstName, p.LastName with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0007:  ldarg.1
      IL_0008:  call       instance string HelperTypes/Person::get_FirstName()
      IL_000d:  ldarg.1
      IL_000e:  call       instance string HelperTypes/Person::get_LastName()
      IL_0013:  newobj     instance void class [FSharp.Core]System.Tuple`3<int32,string,string>::.ctor(!0,
                                                                                                       !1,
                                                                                                       !2)
      IL_0018:  stloc.0
      IL_0019:  ldloc.0
      IL_001a:  call       instance !1 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item2()
      IL_001f:  ldstr      "Ted"
      IL_0024:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0029:  brfalse.s  IL_0054

      IL_002b:  ldloc.0
      IL_002c:  call       instance !2 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item3()
      IL_0031:  ldstr      "Neward"
      IL_0036:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_003b:  brfalse.s  IL_0042

      IL_003d:  br         IL_00aa

      IL_0042:  ldloc.0
      IL_0043:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_0048:  stloc.1
      IL_0049:  ldloc.1
      IL_004a:  ldc.i4.s   35
      IL_004c:  cgt
      IL_004e:  brfalse.s  IL_0052

      IL_0050:  br.s       IL_00ae

      IL_0052:  br.s       IL_00b7

      IL_0054:  ldloc.0
      IL_0055:  call       instance !1 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item2()
      IL_005a:  ldstr      "Aaron"
      IL_005f:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0064:  brfalse.s  IL_0091

      IL_0066:  ldloc.0
      IL_0067:  call       instance !2 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item3()
      IL_006c:  ldstr      "Erickson"
      IL_0071:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0076:  brfalse.s  IL_007a

      IL_0078:  br.s       IL_00ac

      IL_007a:  ldloc.0
      IL_007b:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_0080:  stloc.3
      IL_0081:  ldloc.3
      IL_0082:  ldc.i4.s   35
      IL_0084:  cgt
      IL_0086:  brfalse.s  IL_00b7

      IL_0088:  ldloc.0
      IL_0089:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_008e:  stloc.2
      IL_008f:  br.s       IL_00b5

      IL_0091:  ldloc.0
      IL_0092:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_0097:  stloc.s    V_4
      IL_0099:  ldloc.s    V_4
      IL_009b:  ldc.i4.s   35
      IL_009d:  cgt
      IL_009f:  brfalse.s  IL_00b7

      IL_00a1:  ldloc.0
      IL_00a2:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_00a7:  stloc.2
      IL_00a8:  br.s       IL_00b5

//000226:         | _, "Ted", "Neward" -> true
      IL_00aa:  ldc.i4.1
      IL_00ab:  ret

//000227:         | _, "Aaron", "Erickson" -> true
      IL_00ac:  ldc.i4.1
      IL_00ad:  ret

//000225:         match p.Age, p.FirstName, p.LastName with
      IL_00ae:  ldloc.0
      IL_00af:  call       instance !0 class [FSharp.Core]System.Tuple`3<int32,string,string>::get_Item1()
      IL_00b4:  stloc.2
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
      IL_00b5:  ldc.i4.1
      IL_00b6:  ret

//000229:         | _ -> false
      IL_00b7:  ldc.i4.0
      IL_00b8:  ret
    } // end of method 'isOldFogey\'\'@225'::Invoke

  } // end of class 'isOldFogey\'\'@225'

  .class auto ansi serializable nested assembly beforefieldinit contains@239
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,bool>::.ctor()
      IL_0006:  ret
    } // end of method contains@239::.ctor

    .method public strict virtual instance bool 
            Invoke(string srchStr,
                   string inStr) cil managed
    {
      // Code size       9 (0x9)
      .maxstack  6
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  call       instance bool [mscorlib]System.String::Contains(string)
      IL_0008:  ret
    } // end of method contains@239::Invoke

  } // end of class contains@239

  .class auto ansi serializable nested assembly beforefieldinit goodInput@241
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>
  {
    .field public class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> contains
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> contains) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> PatternMatching/goodInput@241::contains
      IL_000d:  ret
    } // end of method goodInput@241::.ctor

    .method public strict virtual instance bool 
            Invoke(string inStr) cil managed
    {
      // Code size       100 (0x64)
      .maxstack  7
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> PatternMatching/goodInput@241::contains
      IL_0007:  ldstr      "<script>"
      IL_000c:  ldarg.1
      IL_000d:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,string>::InvokeFast<bool>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                      !0,
                                                                                                                      !1)
      IL_0012:  brfalse.s  IL_0016

      IL_0014:  br.s       IL_0018

      IL_0016:  br.s       IL_001c

      IL_0018:  ldc.i4.1
      IL_0019:  nop
      IL_001a:  br.s       IL_002e

      IL_001c:  ldarg.0
      IL_001d:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> PatternMatching/goodInput@241::contains
      IL_0022:  ldstr      "<object>"
      IL_0027:  ldarg.1
      IL_0028:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,string>::InvokeFast<bool>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                      !0,
                                                                                                                      !1)
      IL_002d:  nop
      IL_002e:  brfalse.s  IL_0032

      IL_0030:  br.s       IL_0034

      IL_0032:  br.s       IL_0038

      IL_0034:  ldc.i4.1
      IL_0035:  nop
      IL_0036:  br.s       IL_004a

      IL_0038:  ldarg.0
      IL_0039:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> PatternMatching/goodInput@241::contains
      IL_003e:  ldstr      "<embed>"
      IL_0043:  ldarg.1
      IL_0044:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,string>::InvokeFast<bool>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                      !0,
                                                                                                                      !1)
      IL_0049:  nop
      IL_004a:  brfalse.s  IL_004e

      IL_004c:  br.s       IL_0050

      IL_004e:  br.s       IL_0052

      IL_0050:  ldc.i4.1
      IL_0051:  ret

      IL_0052:  ldarg.0
      IL_0053:  ldfld      class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> PatternMatching/goodInput@241::contains
      IL_0058:  ldstr      "<applet>"
      IL_005d:  ldarg.1
      IL_005e:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,string>::InvokeFast<bool>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                      !0,
                                                                                                                      !1)
      IL_0063:  ret
    } // end of method goodInput@241::Invoke

  } // end of class goodInput@241

  .class auto ansi serializable nested assembly beforefieldinit '|Contains|@249'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,bool>::.ctor()
      IL_0006:  ret
    } // end of method '|Contains|@249'::.ctor

    .method public strict virtual instance bool 
            Invoke(string srchStr,
                   string inStr) cil managed
    {
      // Code size       9 (0x9)
      .maxstack  6
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  call       instance bool [mscorlib]System.String::Contains(string)
      IL_0008:  ret
    } // end of method '|Contains|@249'::Invoke

  } // end of class '|Contains|@249'

  .class auto ansi serializable nested assembly beforefieldinit '|Contains|_|@265-2'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [mscorlib]System.Collections.IEnumerator>
  {
    .field public class [System]System.Text.RegularExpressions.MatchCollection inputSequence
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method assembly specialname rtspecialname 
            instance void  .ctor(class [System]System.Text.RegularExpressions.MatchCollection inputSequence) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [mscorlib]System.Collections.IEnumerator>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      class [System]System.Text.RegularExpressions.MatchCollection PatternMatching/'|Contains|_|@265-2'::inputSequence
      IL_000d:  ret
    } // end of method '|Contains|_|@265-2'::.ctor

    .method public strict virtual instance class [mscorlib]System.Collections.IEnumerator 
            Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  5
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System]System.Text.RegularExpressions.MatchCollection PatternMatching/'|Contains|_|@265-2'::inputSequence
      IL_0007:  callvirt   instance class [mscorlib]System.Collections.IEnumerator [System]System.Text.RegularExpressions.MatchCollection::GetEnumerator()
      IL_000c:  ret
    } // end of method '|Contains|_|@265-2'::Invoke

  } // end of class '|Contains|_|@265-2'

  .class auto ansi serializable nested assembly beforefieldinit '|Contains|_|@265-3'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Collections.IEnumerator,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Collections.IEnumerator,bool>::.ctor()
      IL_0006:  ret
    } // end of method '|Contains|_|@265-3'::.ctor

    .method public strict virtual instance bool 
            Invoke(class [mscorlib]System.Collections.IEnumerator enumerator) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0007:  ret
    } // end of method '|Contains|_|@265-3'::Invoke

  } // end of class '|Contains|_|@265-3'

  .class auto ansi serializable nested assembly beforefieldinit '|Contains|_|@265-4'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Collections.IEnumerator,class [System]System.Text.RegularExpressions.Match>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Collections.IEnumerator,class [System]System.Text.RegularExpressions.Match>::.ctor()
      IL_0006:  ret
    } // end of method '|Contains|_|@265-4'::.ctor

    .method public strict virtual instance class [System]System.Text.RegularExpressions.Match 
            Invoke(class [mscorlib]System.Collections.IEnumerator enumerator) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance object [mscorlib]System.Collections.IEnumerator::get_Current()
      IL_0007:  unbox.any  [System]System.Text.RegularExpressions.Match
      IL_000c:  ret
    } // end of method '|Contains|_|@265-4'::Invoke

  } // end of class '|Contains|_|@265-4'

  .class auto autochar sealed nested assembly beforefieldinit specialname '|Contains|_|@265-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<string>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [System]System.Text.RegularExpressions.MatchCollection results
    .field public class [System]System.Text.RegularExpressions.Match m
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public string current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(class [System]System.Text.RegularExpressions.MatchCollection results,
                                 class [System]System.Text.RegularExpressions.Match m,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> 'enum',
                                 int32 pc,
                                 string current) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [System]System.Text.RegularExpressions.MatchCollection PatternMatching/'|Contains|_|@265-1'::results
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [System]System.Text.RegularExpressions.Match PatternMatching/'|Contains|_|@265-1'::m
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    pc
      IL_0018:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_001d:  ldarg.0
      IL_001e:  ldarg.s    current
      IL_0020:  stfld      string PatternMatching/'|Contains|_|@265-1'::current
      IL_0025:  ldarg.0
      IL_0026:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<string>::.ctor()
      IL_002b:  ret
    } // end of method '|Contains|_|@265-1'::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<string>& next) cil managed
    {
      // Code size       203 (0xcb)
      .maxstack  8
      .locals init ([0] class [System]System.Text.RegularExpressions.MatchCollection V_0)
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_0030

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0027

      IL_001f:  br.s       IL_002a

      IL_0021:  nop
      IL_0022:  br         IL_00a1

      IL_0027:  nop
      IL_0028:  br.s       IL_0097

      IL_002a:  nop
      IL_002b:  br         IL_00c2

      IL_0030:  nop
//000265:             then Some [ for m in results -> m.Value ] 
      IL_0031:  ldarg.0
      IL_0032:  ldarg.0
      IL_0033:  ldfld      class [System]System.Text.RegularExpressions.MatchCollection PatternMatching/'|Contains|_|@265-1'::results
      IL_0038:  stloc.0
      IL_0039:  ldloc.0
      IL_003a:  newobj     instance void PatternMatching/'|Contains|_|@265-2'::.ctor(class [System]System.Text.RegularExpressions.MatchCollection)
      IL_003f:  newobj     instance void PatternMatching/'|Contains|_|@265-3'::.ctor()
      IL_0044:  newobj     instance void PatternMatching/'|Contains|_|@265-4'::.ctor()
      IL_0049:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.RuntimeHelpers::EnumerateFromFunctions<class [mscorlib]System.Collections.IEnumerator,class [System]System.Text.RegularExpressions.Match>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,!!0>,
                                                                                                                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,!!1>)
      IL_004e:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class [System]System.Text.RegularExpressions.Match>::GetEnumerator()
      IL_0053:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_0058:  ldarg.0
      IL_0059:  ldc.i4.2
      IL_005a:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_005f:  ldarg.0
      IL_0060:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_0065:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_006a:  brfalse.s  IL_00a1

      IL_006c:  ldarg.0
      IL_006d:  ldarg.0
      IL_006e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_0073:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match>::get_Current()
      IL_0078:  stfld      class [System]System.Text.RegularExpressions.Match PatternMatching/'|Contains|_|@265-1'::m
      IL_007d:  ldarg.0
      IL_007e:  ldc.i4.3
      IL_007f:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_0084:  ldarg.0
      IL_0085:  ldarg.0
      IL_0086:  ldfld      class [System]System.Text.RegularExpressions.Match PatternMatching/'|Contains|_|@265-1'::m
      IL_008b:  call       instance string [System]System.Text.RegularExpressions.Capture::get_Value()
      IL_0090:  stfld      string PatternMatching/'|Contains|_|@265-1'::current
      IL_0095:  ldc.i4.1
      IL_0096:  ret

      IL_0097:  ldarg.0
      IL_0098:  ldnull
      IL_0099:  stfld      class [System]System.Text.RegularExpressions.Match PatternMatching/'|Contains|_|@265-1'::m
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
      IL_009e:  nop
      IL_009f:  br.s       IL_005f

      IL_00a1:  ldarg.0
      IL_00a2:  ldc.i4.4
      IL_00a3:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
//000265:             then Some [ for m in results -> m.Value ] 
      IL_00a8:  ldarg.0
      IL_00a9:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_00ae:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match>>(!!0)
      IL_00b3:  nop
      IL_00b4:  ldarg.0
      IL_00b5:  ldnull
      IL_00b6:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_00bb:  ldarg.0
      IL_00bc:  ldc.i4.4
      IL_00bd:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_00c2:  ldarg.0
      IL_00c3:  ldnull
      IL_00c4:  stfld      string PatternMatching/'|Contains|_|@265-1'::current
      IL_00c9:  ldc.i4.0
      IL_00ca:  ret
    } // end of method '|Contains|_|@265-1'::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match> PatternMatching/'|Contains|_|@265-1'::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_0051:  ldarg.0
      IL_0052:  ldnull
      IL_0053:  stfld      string PatternMatching/'|Contains|_|@265-1'::current
      IL_0058:  ret
    } // end of method '|Contains|_|@265-1'::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 PatternMatching/'|Contains|_|@265-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method '|Contains|_|@265-1'::get_CheckClose

    .method public strict virtual instance string 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      string PatternMatching/'|Contains|_|@265-1'::current
      IL_0007:  ret
    } // end of method '|Contains|_|@265-1'::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       17 (0x11)
      .maxstack  9
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [System]System.Text.RegularExpressions.MatchCollection PatternMatching/'|Contains|_|@265-1'::results
      IL_0007:  ldnull
      IL_0008:  ldnull
      IL_0009:  ldc.i4.0
      IL_000a:  ldnull
      IL_000b:  newobj     instance void PatternMatching/'|Contains|_|@265-1'::.ctor(class [System]System.Text.RegularExpressions.MatchCollection,
                                                                                     class [System]System.Text.RegularExpressions.Match,
                                                                                     class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match>,
                                                                                     int32,
                                                                                     string)
      IL_0010:  ret
    } // end of method '|Contains|_|@265-1'::GetFreshEnumerator

  } // end of class '|Contains|_|@265-1'

  .class auto ansi serializable nested assembly beforefieldinit '|Contains|_|@262'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>::.ctor()
      IL_0006:  ret
    } // end of method '|Contains|_|@262'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>> 
            Invoke(string pat,
                   string inStr) cil managed
    {
      // Code size       45 (0x2d)
      .maxstack  9
      .locals init ([0] class [System]System.Text.RegularExpressions.MatchCollection results)
//000262:         let results = 
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  call       class [System]System.Text.RegularExpressions.MatchCollection [System]System.Text.RegularExpressions.Regex::Matches(string,
                                                                                                                                              string)
      IL_0008:  stloc.0
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
      IL_0009:  ldloc.0
      IL_000a:  callvirt   instance int32 [System]System.Text.RegularExpressions.MatchCollection::get_Count()
      IL_000f:  ldc.i4.0
      IL_0010:  ble.s      IL_0014

      IL_0012:  br.s       IL_0016

      IL_0014:  br.s       IL_002b

//000265:             then Some [ for m in results -> m.Value ] 
      IL_0016:  ldloc.0
      IL_0017:  ldnull
      IL_0018:  ldnull
      IL_0019:  ldc.i4.0
      IL_001a:  ldnull
      IL_001b:  newobj     instance void PatternMatching/'|Contains|_|@265-1'::.ctor(class [System]System.Text.RegularExpressions.MatchCollection,
                                                                                     class [System]System.Text.RegularExpressions.Match,
                                                                                     class [mscorlib]System.Collections.Generic.IEnumerator`1<class [System]System.Text.RegularExpressions.Match>,
                                                                                     int32,
                                                                                     string)
      IL_0020:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToList<string>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
      IL_0025:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>::Some(!0)
      IL_002a:  ret

//000266:             else None
      IL_002b:  ldnull
      IL_002c:  ret
    } // end of method '|Contains|_|@262'::Invoke

  } // end of class '|Contains|_|@262'

  .class auto ansi serializable nested assembly beforefieldinit '|Field|_|@282'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.FieldInfo>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.FieldInfo>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Field|_|@282'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Field|_|@282'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.FieldInfo> 
            Invoke(string name,
                   class [mscorlib]System.Type t) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.FieldInfo fi,
               [1] class [mscorlib]System.Reflection.FieldInfo V_1,
               [2] class [mscorlib]System.Reflection.FieldInfo V_2)
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  ldarg.0
      IL_0004:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Field|_|@282'::AllBindingFlags
      IL_0009:  callvirt   instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(string,
                                                                                                                valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_000e:  stloc.0
//000283:         if fi <> null then Some(fi) else None
      IL_000f:  ldloc.0
      IL_0010:  stloc.1
      IL_0011:  ldnull
      IL_0012:  stloc.2
      IL_0013:  ldloc.1
      IL_0014:  ldloc.2
      IL_0015:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.FieldInfo>(!!0,
                                                                                                                                                                         !!0)
      IL_001a:  ldc.i4.0
      IL_001b:  ceq
      IL_001d:  brfalse.s  IL_0021

      IL_001f:  br.s       IL_0023

      IL_0021:  br.s       IL_002a

      IL_0023:  ldloc.0
      IL_0024:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.FieldInfo>::Some(!0)
      IL_0029:  ret

      IL_002a:  ldnull
      IL_002b:  ret
    } // end of method '|Field|_|@282'::Invoke

  } // end of class '|Field|_|@282'

  .class auto ansi serializable nested assembly beforefieldinit '|Method|_|@285'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Method|_|@285'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Method|_|@285'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo> 
            Invoke(string name,
                   class [mscorlib]System.Type t) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.MethodInfo fi,
               [1] class [mscorlib]System.Reflection.MethodInfo V_1,
               [2] class [mscorlib]System.Reflection.MethodInfo V_2)
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  ldarg.0
      IL_0004:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Method|_|@285'::AllBindingFlags
      IL_0009:  callvirt   instance class [mscorlib]System.Reflection.MethodInfo [mscorlib]System.Type::GetMethod(string,
                                                                                                                  valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_000e:  stloc.0
//000286:         if fi <> null then Some(fi) else None
      IL_000f:  ldloc.0
      IL_0010:  stloc.1
      IL_0011:  ldnull
      IL_0012:  stloc.2
      IL_0013:  ldloc.1
      IL_0014:  ldloc.2
      IL_0015:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.MethodInfo>(!!0,
                                                                                                                                                                          !!0)
      IL_001a:  ldc.i4.0
      IL_001b:  ceq
      IL_001d:  brfalse.s  IL_0021

      IL_001f:  br.s       IL_0023

      IL_0021:  br.s       IL_002a

      IL_0023:  ldloc.0
      IL_0024:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>::Some(!0)
      IL_0029:  ret

      IL_002a:  ldnull
      IL_002b:  ret
    } // end of method '|Method|_|@285'::Invoke

  } // end of class '|Method|_|@285'

  .class auto ansi serializable nested assembly beforefieldinit '|Property|_|@288'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Property|_|@288'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Property|_|@288'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo> 
            Invoke(string name,
                   class [mscorlib]System.Type t) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.PropertyInfo fi,
               [1] class [mscorlib]System.Reflection.PropertyInfo V_1,
               [2] class [mscorlib]System.Reflection.PropertyInfo V_2)
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  ldarg.1
      IL_0003:  ldarg.0
      IL_0004:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Property|_|@288'::AllBindingFlags
      IL_0009:  callvirt   instance class [mscorlib]System.Reflection.PropertyInfo [mscorlib]System.Type::GetProperty(string,
                                                                                                                      valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_000e:  stloc.0
//000289:         if fi <> null then Some(fi) else None
      IL_000f:  ldloc.0
      IL_0010:  stloc.1
      IL_0011:  ldnull
      IL_0012:  stloc.2
      IL_0013:  ldloc.1
      IL_0014:  ldloc.2
      IL_0015:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.PropertyInfo>(!!0,
                                                                                                                                                                            !!0)
      IL_001a:  ldc.i4.0
      IL_001b:  ceq
      IL_001d:  brfalse.s  IL_0021

      IL_001f:  br.s       IL_0023

      IL_0021:  br.s       IL_002a

      IL_0023:  ldloc.0
      IL_0024:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>::Some(!0)
      IL_0029:  ret

      IL_002a:  ldnull
      IL_002b:  ret
    } // end of method '|Property|_|@288'::Invoke

  } // end of class '|Property|_|@288'

  .class auto ansi serializable nested assembly beforefieldinit '|Field|_|@306-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Field|_|@306-1'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Field|_|@306-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> 
            Invoke(string name,
                   object inst) cil managed
    {
      // Code size       55 (0x37)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.FieldInfo fi,
               [1] class [mscorlib]System.Reflection.FieldInfo V_1,
               [2] class [mscorlib]System.Reflection.FieldInfo V_2)
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
      IL_0007:  ldarg.1
      IL_0008:  ldarg.0
      IL_0009:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Field|_|@306-1'::AllBindingFlags
      IL_000e:  callvirt   instance class [mscorlib]System.Reflection.FieldInfo [mscorlib]System.Type::GetField(string,
                                                                                                                valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_0013:  stloc.0
//000307:         if fi <> null 
      IL_0014:  ldloc.0
      IL_0015:  stloc.1
      IL_0016:  ldnull
      IL_0017:  stloc.2
      IL_0018:  ldloc.1
      IL_0019:  ldloc.2
      IL_001a:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.FieldInfo>(!!0,
                                                                                                                                                                         !!0)
      IL_001f:  ldc.i4.0
      IL_0020:  ceq
      IL_0022:  brfalse.s  IL_0026

      IL_0024:  br.s       IL_0028

      IL_0026:  br.s       IL_0035

//000308:         then Some(fi.GetValue(inst)) 
      IL_0028:  ldloc.0
      IL_0029:  ldarg.2
      IL_002a:  callvirt   instance object [mscorlib]System.Reflection.FieldInfo::GetValue(object)
      IL_002f:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::Some(!0)
      IL_0034:  ret

//000309:         else None
      IL_0035:  ldnull
      IL_0036:  ret
    } // end of method '|Field|_|@306-1'::Invoke

  } // end of class '|Field|_|@306-1'

  .class auto ansi serializable nested assembly beforefieldinit '|Method|_|@311-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Method|_|@311-1'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Method|_|@311-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo> 
            Invoke(string name,
                   object inst) cil managed
    {
      // Code size       49 (0x31)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.MethodInfo fi,
               [1] class [mscorlib]System.Reflection.MethodInfo V_1,
               [2] class [mscorlib]System.Reflection.MethodInfo V_2)
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
      IL_0007:  ldarg.1
      IL_0008:  ldarg.0
      IL_0009:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Method|_|@311-1'::AllBindingFlags
      IL_000e:  callvirt   instance class [mscorlib]System.Reflection.MethodInfo [mscorlib]System.Type::GetMethod(string,
                                                                                                                  valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_0013:  stloc.0
//000312:         if fi <> null 
      IL_0014:  ldloc.0
      IL_0015:  stloc.1
      IL_0016:  ldnull
      IL_0017:  stloc.2
      IL_0018:  ldloc.1
      IL_0019:  ldloc.2
      IL_001a:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.MethodInfo>(!!0,
                                                                                                                                                                          !!0)
      IL_001f:  ldc.i4.0
      IL_0020:  ceq
      IL_0022:  brfalse.s  IL_0026

      IL_0024:  br.s       IL_0028

      IL_0026:  br.s       IL_002f

//000313:         then Some(fi) 
      IL_0028:  ldloc.0
      IL_0029:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>::Some(!0)
      IL_002e:  ret

//000314:         else None
      IL_002f:  ldnull
      IL_0030:  ret
    } // end of method '|Method|_|@311-1'::Invoke

  } // end of class '|Method|_|@311-1'

  .class auto ansi serializable nested assembly beforefieldinit '|Property|_|@316-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>
  {
    .field public valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags
    .method assembly specialname rtspecialname 
            instance void  .ctor(valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags) cil managed
    {
      // Code size       14 (0xe)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<string,object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  ldarg.1
      IL_0008:  stfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Property|_|@316-1'::AllBindingFlags
      IL_000d:  ret
    } // end of method '|Property|_|@316-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> 
            Invoke(string name,
                   object inst) cil managed
    {
      // Code size       56 (0x38)
      .maxstack  7
      .locals init ([0] class [mscorlib]System.Reflection.PropertyInfo fi,
               [1] class [mscorlib]System.Reflection.PropertyInfo V_1,
               [2] class [mscorlib]System.Reflection.PropertyInfo V_2)
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
      IL_0007:  ldarg.1
      IL_0008:  ldarg.0
      IL_0009:  ldfld      valuetype [mscorlib]System.Reflection.BindingFlags PatternMatching/'|Property|_|@316-1'::AllBindingFlags
      IL_000e:  callvirt   instance class [mscorlib]System.Reflection.PropertyInfo [mscorlib]System.Type::GetProperty(string,
                                                                                                                      valuetype [mscorlib]System.Reflection.BindingFlags)
      IL_0013:  stloc.0
//000317:         if fi <> null 
      IL_0014:  ldloc.0
      IL_0015:  stloc.1
      IL_0016:  ldnull
      IL_0017:  stloc.2
      IL_0018:  ldloc.1
      IL_0019:  ldloc.2
      IL_001a:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [mscorlib]System.Reflection.PropertyInfo>(!!0,
                                                                                                                                                                            !!0)
      IL_001f:  ldc.i4.0
      IL_0020:  ceq
      IL_0022:  brfalse.s  IL_0026

      IL_0024:  br.s       IL_0028

      IL_0026:  br.s       IL_0036

//000318:         then Some(fi.GetValue(inst, null)) 
      IL_0028:  ldloc.0
      IL_0029:  ldarg.2
      IL_002a:  ldnull
      IL_002b:  callvirt   instance object [mscorlib]System.Reflection.PropertyInfo::GetValue(object,
                                                                                              object[])
      IL_0030:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::Some(!0)
      IL_0035:  ret

//000319:         else None
      IL_0036:  ldnull
      IL_0037:  ret
    } // end of method '|Property|_|@316-1'::Invoke

  } // end of class '|Property|_|@316-1'

  .class auto ansi serializable nested assembly beforefieldinit '|Property|Method|Field|Constructor|@347'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MemberInfo,class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MemberInfo,class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>>::.ctor()
      IL_0006:  ret
    } // end of method '|Property|Method|Field|Constructor|@347'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]> 
            Invoke(class [mscorlib]System.Reflection.MemberInfo mi) cil managed
    {
      // Code size       200 (0xc8)
      .maxstack  7
      .locals init ([0] object V_0,
               [1] object V_1,
               [2] class [mscorlib]System.Reflection.MethodInfo mthi,
               [3] object V_3,
               [4] class [mscorlib]System.Reflection.PropertyInfo pi,
               [5] object V_5,
               [6] class [mscorlib]System.Reflection.ConstructorInfo ci)
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  isinst     [mscorlib]System.Reflection.FieldInfo
      IL_0009:  ldnull
      IL_000a:  cgt.un
      IL_000c:  brfalse.s  IL_0010

      IL_000e:  br.s       IL_0012

      IL_0010:  br.s       IL_002e

//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
      IL_0012:  ldarg.1
      IL_0013:  callvirt   instance string [mscorlib]System.Reflection.MemberInfo::get_Name()
      IL_0018:  ldarg.1
      IL_0019:  unbox.any  [mscorlib]System.Reflection.FieldInfo
      IL_001e:  callvirt   instance class [mscorlib]System.Type [mscorlib]System.Reflection.FieldInfo::get_FieldType()
      IL_0023:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::.ctor(!0,
                                                                                                                      !1)
      IL_0028:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<!0,!1,!2,!3> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::NewChoice3Of4(!2)
      IL_002d:  ret

//000349:         elif (mi :? MethodInfo) then
      IL_002e:  ldarg.1
      IL_002f:  stloc.1
      IL_0030:  ldloc.1
      IL_0031:  isinst     [mscorlib]System.Reflection.MethodInfo
      IL_0036:  ldnull
      IL_0037:  cgt.un
      IL_0039:  brfalse.s  IL_003d

      IL_003b:  br.s       IL_003f

      IL_003d:  br.s       IL_0063

//000350:             let mthi = (mi :?> MethodInfo)
      IL_003f:  ldarg.1
      IL_0040:  unbox.any  [mscorlib]System.Reflection.MethodInfo
      IL_0045:  stloc.2
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
      IL_0046:  ldarg.1
      IL_0047:  callvirt   instance string [mscorlib]System.Reflection.MemberInfo::get_Name()
      IL_004c:  ldloc.2
      IL_004d:  callvirt   instance class [mscorlib]System.Type [mscorlib]System.Reflection.MethodInfo::get_ReturnType()
      IL_0052:  ldloc.2
      IL_0053:  callvirt   instance class [mscorlib]System.Reflection.ParameterInfo[] [mscorlib]System.Reflection.MethodBase::GetParameters()
      IL_0058:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>::.ctor(!0,
                                                                                                                                                                        !1,
                                                                                                                                                                        !2)
      IL_005d:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<!0,!1,!2,!3> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::NewChoice2Of4(!1)
      IL_0062:  ret

//000352:         elif (mi :? PropertyInfo) then
      IL_0063:  ldarg.1
      IL_0064:  stloc.3
      IL_0065:  ldloc.3
      IL_0066:  isinst     [mscorlib]System.Reflection.PropertyInfo
      IL_006b:  ldnull
      IL_006c:  cgt.un
      IL_006e:  brfalse.s  IL_0072

      IL_0070:  br.s       IL_0074

      IL_0072:  br.s       IL_0095

//000353:             let pi = (mi :?> PropertyInfo)
      IL_0074:  ldarg.1
      IL_0075:  unbox.any  [mscorlib]System.Reflection.PropertyInfo
      IL_007a:  stloc.s    pi
//000354:             Property(pi.Name, pi.PropertyType)
      IL_007c:  ldloc.s    pi
      IL_007e:  callvirt   instance string [mscorlib]System.Reflection.MemberInfo::get_Name()
      IL_0083:  ldloc.s    pi
      IL_0085:  callvirt   instance class [mscorlib]System.Type [mscorlib]System.Reflection.PropertyInfo::get_PropertyType()
      IL_008a:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::.ctor(!0,
                                                                                                                      !1)
      IL_008f:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<!0,!1,!2,!3> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::NewChoice1Of4(!0)
      IL_0094:  ret

//000355:         elif (mi :? ConstructorInfo) then
      IL_0095:  ldarg.1
      IL_0096:  stloc.s    V_5
      IL_0098:  ldloc.s    V_5
      IL_009a:  isinst     [mscorlib]System.Reflection.ConstructorInfo
      IL_009f:  ldnull
      IL_00a0:  cgt.un
      IL_00a2:  brfalse.s  IL_00a6

      IL_00a4:  br.s       IL_00a8

      IL_00a6:  br.s       IL_00bd

//000356:             let ci = (mi :?> ConstructorInfo)
      IL_00a8:  ldarg.1
      IL_00a9:  unbox.any  [mscorlib]System.Reflection.ConstructorInfo
      IL_00ae:  stloc.s    ci
//000357:             Constructor(ci.GetParameters())
      IL_00b0:  ldloc.s    ci
      IL_00b2:  callvirt   instance class [mscorlib]System.Reflection.ParameterInfo[] [mscorlib]System.Reflection.MethodBase::GetParameters()
      IL_00b7:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<!0,!1,!2,!3> class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::NewChoice4Of4(!3)
      IL_00bc:  ret

//000358:         else
//000359:             failwith "Unrecognized Reflection type"
      IL_00bd:  ldstr      "Unrecognized Reflection type"
      IL_00c2:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::FailWith<class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>>(string)
      IL_00c7:  ret
    } // end of method '|Property|Method|Field|Constructor|@347'::Invoke

  } // end of class '|Property|Method|Field|Constructor|@347'

  .class auto ansi serializable nested assembly beforefieldinit '|FileFullName|@379'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::.ctor()
      IL_0006:  ret
    } // end of method '|FileFullName|@379'::.ctor

    .method public strict virtual instance string 
            Invoke(class [mscorlib]System.IO.FileInfo f) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance string [mscorlib]System.IO.FileSystemInfo::get_FullName()
      IL_0007:  ret
    } // end of method '|FileFullName|@379'::Invoke

  } // end of class '|FileFullName|@379'

  .class auto ansi serializable nested assembly beforefieldinit '|FileName|@380'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::.ctor()
      IL_0006:  ret
    } // end of method '|FileName|@380'::.ctor

    .method public strict virtual instance string 
            Invoke(class [mscorlib]System.IO.FileInfo f) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000380:     let (|FileName|) (f:FileInfo) = f.Name
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance string [mscorlib]System.IO.FileSystemInfo::get_Name()
      IL_0007:  ret
    } // end of method '|FileName|@380'::Invoke

  } // end of class '|FileName|@380'

  .class auto ansi serializable nested assembly beforefieldinit '|FileExt|@381'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::.ctor()
      IL_0006:  ret
    } // end of method '|FileExt|@381'::.ctor

    .method public strict virtual instance string 
            Invoke(class [mscorlib]System.IO.FileInfo f) cil managed
    {
      // Code size       8 (0x8)
      .maxstack  5
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string [mscorlib]System.IO.FileSystemInfo::get_Extension()
      IL_0007:  ret
    } // end of method '|FileExt|@381'::Invoke

  } // end of class '|FileExt|@381'

  .class auto ansi serializable nested assembly beforefieldinit '|FileTuple|@382'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,class [FSharp.Core]System.Tuple`3<string,string,string>>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,class [FSharp.Core]System.Tuple`3<string,string,string>>::.ctor()
      IL_0006:  ret
    } // end of method '|FileTuple|@382'::.ctor

    .method public strict virtual instance class [FSharp.Core]System.Tuple`3<string,string,string> 
            Invoke(class [mscorlib]System.IO.FileInfo f) cil managed
    {
      // Code size       25 (0x19)
      .maxstack  7
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  callvirt   instance string [mscorlib]System.IO.FileSystemInfo::get_FullName()
      IL_0007:  ldarg.1
      IL_0008:  callvirt   instance string [mscorlib]System.IO.FileSystemInfo::get_Name()
      IL_000d:  ldarg.1
      IL_000e:  call       instance string [mscorlib]System.IO.FileSystemInfo::get_Extension()
      IL_0013:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,string>::.ctor(!0,
                                                                                                        !1,
                                                                                                        !2)
      IL_0018:  ret
    } // end of method '|FileTuple|@382'::Invoke

  } // end of class '|FileTuple|@382'

  .field public static literal string rachel = "Rachel"
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.LiteralAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public static void  pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 16 42 61 73 69 63 20 70 61 74 74 65 72 6E   // ...Basic pattern
                                                                        20 6D 61 74 63 68 69 6E 67 00 00 )                //  matching..
    // Code size       452 (0x1c4)
    .maxstack  11
    .locals init ([0] int32 x,
             [1] int32 y,
             [2] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>> people,
             [3] class HelperTypes/Person p,
             [4] string lastName,
             [5] class [FSharp.Core]System.Tuple`3<string,string,int32> V_5,
             [6] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person> persons)
//000010:     let x = 12
    IL_0000:  nop
    IL_0001:  ldc.i4.s   12
    IL_0003:  stloc.0
//000011:     match x with
    IL_0004:  ldloc.0
    IL_0005:  ldc.i4.s   12
    IL_0007:  sub
    IL_0008:  switch     ( 
                          IL_0013)
    IL_0011:  br.s       IL_0020

//000012:     | 12 -> System.Console.WriteLine("It's 12")
    IL_0013:  ldstr      "It's 12"
    IL_0018:  call       void [mscorlib]System.Console::WriteLine(string)
//000013:     | _ -> System.Console.WriteLine("It's not 12")
//000014:     
//000015:     let y = match x with
//000016:             | 12 -> 24
//000017:             | _ -> 36
//000018:             
//000019:     
//000020:     let people = [
//000021:         ("Ted", "Neward", 38)
//000022:         ("Mark", "Richards", 45)
//000023:         ("Naomi", "Wilson", 38)
//000024:         ("Ken", "Sipe", 43)
//000025:     ]
//000026:     List.iter
//000027:         (fun (p) -> match p with
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
//000035:                     | ("Ken", "Sipe", _) -> p.LastName
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_001d:  nop
    IL_001e:  br.s       IL_002b

//000013:     | _ -> System.Console.WriteLine("It's not 12")
    IL_0020:  ldstr      "It's not 12"
    IL_0025:  call       void [mscorlib]System.Console::WriteLine(string)
//000014:     
//000015:     let y = match x with
//000016:             | 12 -> 24
//000017:             | _ -> 36
//000018:             
//000019:     
//000020:     let people = [
//000021:         ("Ted", "Neward", 38)
//000022:         ("Mark", "Richards", 45)
//000023:         ("Naomi", "Wilson", 38)
//000024:         ("Ken", "Sipe", 43)
//000025:     ]
//000026:     List.iter
//000027:         (fun (p) -> match p with
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
//000035:                     | ("Ken", "Sipe", _) -> p.LastName
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_002a:  nop
//000015:     let y = match x with
    IL_002b:  nop
    IL_002c:  ldloc.0
    IL_002d:  ldc.i4.s   12
    IL_002f:  sub
    IL_0030:  switch     ( 
                          IL_003b)
    IL_0039:  br.s       IL_0040

//000016:             | 12 -> 24
    IL_003b:  ldc.i4.s   24
//000017:             | _ -> 36
//000018:             
//000019:     
//000020:     let people = [
//000021:         ("Ted", "Neward", 38)
//000022:         ("Mark", "Richards", 45)
//000023:         ("Naomi", "Wilson", 38)
//000024:         ("Ken", "Sipe", 43)
//000025:     ]
//000026:     List.iter
//000027:         (fun (p) -> match p with
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
//000035:                     | ("Ken", "Sipe", _) -> p.LastName
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_003d:  nop
    IL_003e:  br.s       IL_0043

//000017:             | _ -> 36
    IL_0040:  ldc.i4.s   36
//000018:             
//000019:     
//000020:     let people = [
//000021:         ("Ted", "Neward", 38)
//000022:         ("Mark", "Richards", 45)
//000023:         ("Naomi", "Wilson", 38)
//000024:         ("Ken", "Sipe", 43)
//000025:     ]
//000026:     List.iter
//000027:         (fun (p) -> match p with
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
//000035:                     | ("Ken", "Sipe", _) -> p.LastName
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0042:  nop
    IL_0043:  stloc.1
//000020:     let people = [
    IL_0044:  ldstr      "Ted"
    IL_0049:  ldstr      "Neward"
    IL_004e:  ldc.i4.s   38
    IL_0050:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0055:  ldstr      "Mark"
    IL_005a:  ldstr      "Richards"
    IL_005f:  ldc.i4.s   45
    IL_0061:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0066:  ldstr      "Naomi"
    IL_006b:  ldstr      "Wilson"
    IL_0070:  ldc.i4.s   38
    IL_0072:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0077:  ldstr      "Ken"
    IL_007c:  ldstr      "Sipe"
    IL_0081:  ldc.i4.s   43
    IL_0083:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0088:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_Empty()
    IL_008d:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0092:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0097:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_009c:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00a1:  stloc.2
//000021:         ("Ted", "Neward", 38)
//000022:         ("Mark", "Richards", 45)
//000023:         ("Naomi", "Wilson", 38)
//000024:         ("Ken", "Sipe", 43)
//000025:     ]
//000026:     List.iter
    IL_00a2:  newobj     instance void PatternMatching/pat_example@27::.ctor()
    IL_00a7:  ldloc.2
    IL_00a8:  call       void [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Iterate<class [FSharp.Core]System.Tuple`3<string,string,int32>>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_00ad:  nop
//000027:         (fun (p) -> match p with
//000028:                      | (fn, ln, _) -> System.Console.WriteLine("{0} {1}", fn, ln)
//000029:                      | _ -> failwith "Unexpected value"
//000030:         )
//000031:         people
//000032: 
//000033:     let p = new Person("Ken", "Sipe", 45)
    IL_00ae:  ldstr      "Ken"
    IL_00b3:  ldstr      "Sipe"
    IL_00b8:  ldc.i4.s   45
    IL_00ba:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_00bf:  stloc.3
//000034:     let lastName = match (p.FirstName, p.LastName, p.Age) with
    IL_00c0:  nop
    IL_00c1:  ldloc.3
    IL_00c2:  call       instance string HelperTypes/Person::get_FirstName()
    IL_00c7:  ldloc.3
    IL_00c8:  call       instance string HelperTypes/Person::get_LastName()
    IL_00cd:  ldloc.3
    IL_00ce:  call       instance int32 HelperTypes/Person::get_Age()
    IL_00d3:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_00d8:  stloc.s    V_5
    IL_00da:  ldloc.s    V_5
    IL_00dc:  call       instance !0 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item1()
    IL_00e1:  ldstr      "Ken"
    IL_00e6:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_00eb:  brfalse.s  IL_010d

    IL_00ed:  ldloc.s    V_5
    IL_00ef:  call       instance !1 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item2()
    IL_00f4:  ldstr      "Sipe"
    IL_00f9:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_00fe:  brfalse.s  IL_0102

    IL_0100:  br.s       IL_0104

    IL_0102:  br.s       IL_010d

//000035:                     | ("Ken", "Sipe", _) -> p.LastName
    IL_0104:  ldloc.3
    IL_0105:  call       instance string HelperTypes/Person::get_LastName()
//000036:                     | _ -> ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_010a:  nop
    IL_010b:  br.s       IL_0113

//000036:                     | _ -> ""
    IL_010d:  ldstr      ""
//000037: 
//000038:     let persons = [
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
//000063:     let message = match r with
//000064:                     | 0 -> "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0112:  nop
    IL_0113:  stloc.s    lastName
//000038:     let persons = [
    IL_0115:  ldstr      "Ted"
    IL_011a:  ldstr      "Neward"
    IL_011f:  ldc.i4.s   38
    IL_0121:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0126:  ldstr      "Ken"
    IL_012b:  ldstr      "Sipe"
    IL_0130:  ldc.i4.s   43
    IL_0132:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0137:  ldstr      "Michael"
    IL_013c:  ldstr      "Neward"
    IL_0141:  ldc.i4.s   16
    IL_0143:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0148:  ldstr      "Matthew"
    IL_014d:  ldstr      "Neward"
    IL_0152:  ldc.i4.s   9
    IL_0154:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0159:  ldstr      "Mark"
    IL_015e:  ldstr      "Richards"
    IL_0163:  ldc.i4.s   45
    IL_0165:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_016a:  ldstr      "Naomi"
    IL_016f:  ldstr      "Wilson"
    IL_0174:  ldc.i4.s   38
    IL_0176:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_017b:  ldstr      "Amanda"
    IL_0180:  ldstr      "Sipe"
    IL_0185:  ldc.i4.s   18
    IL_0187:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_018c:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::get_Empty()
    IL_0191:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0196:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_019b:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_01a0:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_01a5:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_01aa:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_01af:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_01b4:  stloc.s    persons
//000039:         new Person("Ted", "Neward", 38)
//000040:         new Person("Ken", "Sipe", 43)
//000041:         new Person("Michael", "Neward", 16)
//000042:         new Person("Matthew", "Neward", 9)
//000043:         new Person("Mark", "Richards", 45)
//000044:         new Person("Naomi", "Wilson", 38)
//000045:         new Person("Amanda", "Sipe", 18)
//000046:         ]
//000047:     List.iter
    IL_01b6:  newobj     instance void PatternMatching/'pat_example@48-1'::.ctor()
    IL_01bb:  ldloc.s    persons
    IL_01bd:  call       void [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Iterate<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                      class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_01c2:  nop
//000048:         (fun (p : Person) -> 
//000049:             match (p.FirstName, p.LastName) with
//000050:             | (fn, "Sipe") ->
//000051:                 System.Console.WriteLine("Hello, {0}!", fn)
//000052:             | (fn, "Neward") ->
//000053:                 System.Console.WriteLine("Go away, {0}!", fn)
//000054:             | _ ->
//000055:                 System.Console.WriteLine("Who the heck are you?")
//000056:         )
//000057:         persons
//000058:     ()
    IL_01c3:  ret
  } // end of method PatternMatching::pat_example

  .method public static void  const_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 19 43 6F 6E 73 74 61 6E 74 20 70 61 74 74   // ...Constant patt
                                                                        65 72 6E 20 6D 61 74 63 68 69 6E 67 00 00 )       // ern matching..
    // Code size       408 (0x198)
    .maxstack  5
    .locals init ([0] int32 r,
             [1] string message,
             [2] int32 x,
             [3] int32 y,
             [4] string quadrant,
             [5] class [FSharp.Core]System.Tuple`2<int32,int32> V_5)
//000059:     
//000060: [<Example("Constant pattern matching")>]
//000061: let const_pat_example() =
//000062:     let r = (new System.Random()).Next(5)
    IL_0000:  nop
    IL_0001:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_0006:  ldc.i4.5
    IL_0007:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_000c:  stloc.0
//000063:     let message = match r with
    IL_000d:  nop
    IL_000e:  ldloc.0
    IL_000f:  switch     ( 
                          IL_002e,
                          IL_0030,
                          IL_0032,
                          IL_0034,
                          IL_0036,
                          IL_0038)
    IL_002c:  br.s       IL_006a

    IL_002e:  br.s       IL_003a

    IL_0030:  br.s       IL_0042

    IL_0032:  br.s       IL_004a

    IL_0034:  br.s       IL_0052

    IL_0036:  br.s       IL_005a

    IL_0038:  br.s       IL_0062

//000064:                     | 0 -> "zero"
    IL_003a:  ldstr      "zero"
//000065:                     | 1 -> "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_003f:  nop
    IL_0040:  br.s       IL_0082

//000065:                     | 1 -> "one"
    IL_0042:  ldstr      "one"
//000066:                     | 2 -> "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0047:  nop
    IL_0048:  br.s       IL_0082

//000066:                     | 2 -> "two"
    IL_004a:  ldstr      "two"
//000067:                     | 3 -> "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_004f:  nop
    IL_0050:  br.s       IL_0082

//000067:                     | 3 -> "three"
    IL_0052:  ldstr      "three"
//000068:                     | 4 -> "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0057:  nop
    IL_0058:  br.s       IL_0082

//000068:                     | 4 -> "four"
    IL_005a:  ldstr      "four"
//000069:                     | 5 -> "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_005f:  nop
    IL_0060:  br.s       IL_0082

//000069:                     | 5 -> "five"
    IL_0062:  ldstr      "five"
//000070:                     | _ -> "Unknown: " + r.ToString()
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0067:  nop
    IL_0068:  br.s       IL_0082

//000070:                     | _ -> "Unknown: " + r.ToString()
    IL_006a:  ldstr      "Unknown: "
    IL_006f:  ldloca.s   r
    IL_0071:  constrained. [mscorlib]System.Int32
    IL_0077:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_007c:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000071:     System.Console.WriteLine("We got {0}", message)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
//000074:     let y = (new System.Random()).Next(2)
//000075:     let quadrant = match x, y with
//000076:                     | 0, 0 -> "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0081:  nop
    IL_0082:  stloc.1
//000071:     System.Console.WriteLine("We got {0}", message)
    IL_0083:  ldstr      "We got {0}"
    IL_0088:  ldloc.1
    IL_0089:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000072:     
//000073:     let x = (new System.Random()).Next(2)
    IL_008e:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_0093:  ldc.i4.2
    IL_0094:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_0099:  stloc.2
//000074:     let y = (new System.Random()).Next(2)
    IL_009a:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_009f:  ldc.i4.2
    IL_00a0:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
    IL_00a5:  stloc.3
//000075:     let quadrant = match x, y with
    IL_00a6:  nop
    IL_00a7:  ldloc.2
    IL_00a8:  ldloc.3
    IL_00a9:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,int32>::.ctor(!0,
                                                                                             !1)
    IL_00ae:  stloc.s    V_5
    IL_00b0:  ldloc.s    V_5
    IL_00b2:  call       instance !0 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item1()
    IL_00b7:  switch     ( 
                          IL_00cd,
                          IL_00f0,
                          IL_0113)
    IL_00c8:  br         IL_017b

    IL_00cd:  ldloc.s    V_5
    IL_00cf:  call       instance !1 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item2()
    IL_00d4:  switch     ( 
                          IL_00ea,
                          IL_00ec,
                          IL_00ee)
    IL_00e5:  br         IL_017b

    IL_00ea:  br.s       IL_0133

    IL_00ec:  br.s       IL_013b

    IL_00ee:  br.s       IL_0143

    IL_00f0:  ldloc.s    V_5
    IL_00f2:  call       instance !1 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item2()
    IL_00f7:  switch     ( 
                          IL_010d,
                          IL_010f,
                          IL_0111)
    IL_0108:  br         IL_017b

    IL_010d:  br.s       IL_014b

    IL_010f:  br.s       IL_0153

    IL_0111:  br.s       IL_015b

    IL_0113:  ldloc.s    V_5
    IL_0115:  call       instance !1 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item2()
    IL_011a:  switch     ( 
                          IL_012d,
                          IL_012f,
                          IL_0131)
    IL_012b:  br.s       IL_017b

    IL_012d:  br.s       IL_0163

    IL_012f:  br.s       IL_016b

    IL_0131:  br.s       IL_0173

//000076:                     | 0, 0 -> "(0,0)"
    IL_0133:  ldstr      "(0,0)"
//000077:                     | 0, 1 -> "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0138:  nop
    IL_0139:  br.s       IL_018a

//000077:                     | 0, 1 -> "(0,1)"
    IL_013b:  ldstr      "(0,1)"
//000078:                     | 0, 2 -> "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0140:  nop
    IL_0141:  br.s       IL_018a

//000078:                     | 0, 2 -> "(0,2)"
    IL_0143:  ldstr      "(0,2)"
//000079:                     | 1, 0 -> "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0148:  nop
    IL_0149:  br.s       IL_018a

//000079:                     | 1, 0 -> "(1,0)"
    IL_014b:  ldstr      "(1,0)"
//000080:                     | 1, 1 -> "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0150:  nop
    IL_0151:  br.s       IL_018a

//000080:                     | 1, 1 -> "(1,1)"
    IL_0153:  ldstr      "(1,1)"
//000081:                     | 1, 2 -> "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0158:  nop
    IL_0159:  br.s       IL_018a

//000081:                     | 1, 2 -> "(1,2)"
    IL_015b:  ldstr      "(1,2)"
//000082:                     | 2, 0 -> "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0160:  nop
    IL_0161:  br.s       IL_018a

//000082:                     | 2, 0 -> "(2,0)"
    IL_0163:  ldstr      "(2,0)"
//000083:                     | 2, 1 -> "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0168:  nop
    IL_0169:  br.s       IL_018a

//000083:                     | 2, 1 -> "(2,1)"
    IL_016b:  ldstr      "(2,1)"
//000084:                     | 2, 2 -> "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0170:  nop
    IL_0171:  br.s       IL_018a

//000084:                     | 2, 2 -> "(2,2)"
    IL_0173:  ldstr      "(2,2)"
//000085:     System.Console.WriteLine("We got {0}", message)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
//000090:     let message = match p.FirstName with
//000091:                     | fn -> "Hello, " + fn
//000092:     System.Console.WriteLine("We got {0}", message)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
//000095:     let message = match p.FirstName with
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0178:  nop
    IL_0179:  br.s       IL_018a

    IL_017b:  ldstr      "C:\\Users\\faa634\\Desktop\\book codes\\F#\\Code\\Basics"
    + "\\PatternMatching.fs"
    IL_0180:  ldc.i4.s   75
    IL_0182:  ldc.i4.s   19
    IL_0184:  newobj     instance void [FSharp.Core]Microsoft.FSharp.Core.MatchFailureException::.ctor(string,
                                                                                                       int32,
                                                                                                       int32)
    IL_0189:  throw

    IL_018a:  stloc.s    quadrant
//000085:     System.Console.WriteLine("We got {0}", message)
    IL_018c:  ldstr      "We got {0}"
    IL_0191:  ldloc.1
    IL_0192:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0197:  ret
  } // end of method PatternMatching::const_pat_example

  .method public static void  named_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 15 4E 61 6D 65 64 20 70 61 74 74 65 72 6E   // ...Named pattern
                                                                        20 65 78 61 6D 70 6C 65 00 00 )                   //  example..
    // Code size       135 (0x87)
    .maxstack  5
    .locals init ([0] class HelperTypes/Person p,
             [1] string message,
             [2] string fn,
             [3] class HelperTypes/Person V_3,
             [4] string V_4,
             [5] string V_5,
             [6] string V_6)
//000086: 
//000087: [<Example("Named pattern example")>]
//000088: let named_pat_example() =
//000089:     let p = new Person("Rachel", "Reese", 25)
    IL_0000:  nop
    IL_0001:  ldstr      "Rachel"
    IL_0006:  ldstr      "Reese"
    IL_000b:  ldc.i4.s   25
    IL_000d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0012:  stloc.0
//000090:     let message = match p.FirstName with
    IL_0013:  nop
    IL_0014:  ldloc.0
    IL_0015:  call       instance string HelperTypes/Person::get_FirstName()
    IL_001a:  stloc.2
//000091:                     | fn -> "Hello, " + fn
    IL_001b:  ldstr      "Hello, "
    IL_0020:  ldloc.2
    IL_0021:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0026:  stloc.1
//000092:     System.Console.WriteLine("We got {0}", message)
    IL_0027:  ldstr      "We got {0}"
    IL_002c:  ldloc.1
    IL_002d:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000093: 
//000094:     let p = new Person("Rachel", "Appel", 25)
    IL_0032:  ldstr      "Rachel"
    IL_0037:  ldstr      "Appel"
    IL_003c:  ldc.i4.s   25
    IL_003e:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0043:  stloc.3
//000095:     let message = match p.FirstName with
    IL_0044:  nop
    IL_0045:  ldloc.3
    IL_0046:  call       instance string HelperTypes/Person::get_FirstName()
    IL_004b:  stloc.s    V_5
    IL_004d:  ldloc.s    V_5
    IL_004f:  ldstr      "Rachel"
    IL_0054:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0059:  brfalse.s  IL_005d

    IL_005b:  br.s       IL_005f

    IL_005d:  br.s       IL_0067

//000096:                     | "Rachel" -> "It's one of the Rachii!!"
    IL_005f:  ldstr      "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0064:  nop
    IL_0065:  br.s       IL_0078

//000095:     let message = match p.FirstName with
    IL_0067:  ldloc.s    V_5
    IL_0069:  stloc.s    V_6
//000096:                     | "Rachel" -> "It's one of the Rachii!!"
//000097:                     | fn -> "Alas, you are not a Rachii, " + fn
    IL_006b:  ldstr      "Alas, you are not a Rachii, "
    IL_0070:  ldloc.s    V_6
    IL_0072:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000098:     System.Console.WriteLine("We got {0}", message)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
//000103:     let message = match p.FirstName with
//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0077:  nop
    IL_0078:  stloc.s    V_4
//000098:     System.Console.WriteLine("We got {0}", message)
    IL_007a:  ldstr      "We got {0}"
    IL_007f:  ldloc.s    V_4
    IL_0081:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0086:  ret
  } // end of method PatternMatching::named_pat_example

  .method public static void  andor_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 16 41 4E 44 2F 4F 52 20 70 61 74 74 65 72   // ...AND/OR patter
                                                                        6E 20 65 78 61 6D 70 6C 65 00 00 )                // n example..
    // Code size       97 (0x61)
    .maxstack  5
    .locals init ([0] class HelperTypes/Person p,
             [1] string message,
             [2] string V_2)
//000099: 
//000100: [<Example("AND/OR pattern example")>]
//000101: let andor_pat_example() =
//000102:     let p = new Person("Rachel", "Reese", 25)
    IL_0000:  nop
    IL_0001:  ldstr      "Rachel"
    IL_0006:  ldstr      "Reese"
    IL_000b:  ldc.i4.s   25
    IL_000d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0012:  stloc.0
//000103:     let message = match p.FirstName with
    IL_0013:  nop
    IL_0014:  ldloc.0
    IL_0015:  call       instance string HelperTypes/Person::get_FirstName()
    IL_001a:  stloc.2
    IL_001b:  ldloc.2
    IL_001c:  ldstr      "Rachel"
    IL_0021:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0026:  brfalse.s  IL_002a

    IL_0028:  br.s       IL_003b

    IL_002a:  ldloc.2
    IL_002b:  ldstr      "Scott"
    IL_0030:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0035:  brfalse.s  IL_0039

    IL_0037:  br.s       IL_003b

    IL_0039:  br.s       IL_004e

//000104:                     | ("Rachel" | "Scott") -> "Hello, " + p.FirstName
    IL_003b:  ldstr      "Hello, "
    IL_0040:  ldloc.0
    IL_0041:  call       instance string HelperTypes/Person::get_FirstName()
    IL_0046:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000105:                     | _ -> "Who are you, again?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_004b:  nop
    IL_004c:  br.s       IL_0054

//000105:                     | _ -> "Who are you, again?"
    IL_004e:  ldstr      "Who are you, again\?"
//000106:     System.Console.WriteLine("We got {0}", message)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
//000115:     let message = match p.FirstName with
//000116:                     | rachel -> "Howdy, Rachel!"
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
//000123:     let message = match p with
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
//000132:     let rec sumList ns = match ns with
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
//000137:     
//000138:     let message = match numbers with
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0053:  nop
    IL_0054:  stloc.1
//000106:     System.Console.WriteLine("We got {0}", message)
    IL_0055:  ldstr      "We got {0}"
    IL_005a:  ldloc.1
    IL_005b:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0060:  ret
  } // end of method PatternMatching::andor_pat_example

  .method public static void  literal_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 18 4C 69 74 65 72 61 6C 73 20 70 61 74 74   // ...Literals patt
                                                                        65 72 6E 20 65 78 61 6D 70 6C 65 00 00 )          // ern example..
    // Code size       47 (0x2f)
    .maxstack  5
    .locals init ([0] class HelperTypes/Person p,
             [1] string message,
             [2] string V_2,
             [3] string rachel)
//000107: 
//000108: 
//000109: [<Literal>]
//000110: let rachel = "Rachel"
//000111: 
//000112: [<Example("Literals pattern example")>]
//000113: let literal_pat_example() =
//000114:     let p = new Person("Rachel", "Reese", 25)
    IL_0000:  nop
    IL_0001:  ldstr      "Rachel"
    IL_0006:  ldstr      "Reese"
    IL_000b:  ldc.i4.s   25
    IL_000d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0012:  stloc.0
//000115:     let message = match p.FirstName with
    IL_0013:  nop
    IL_0014:  ldloc.0
    IL_0015:  call       instance string HelperTypes/Person::get_FirstName()
    IL_001a:  stloc.2
    IL_001b:  ldloc.2
    IL_001c:  stloc.3
//000116:                     | rachel -> "Howdy, Rachel!"
    IL_001d:  ldstr      "Howdy, Rachel!"
    IL_0022:  stloc.1
//000117:                     | _ -> "Howdy, whoever you are!"
//000118:     System.Console.WriteLine("We got {0}", message)
    IL_0023:  ldstr      "We got {0}"
    IL_0028:  ldloc.1
    IL_0029:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_002e:  ret
  } // end of method PatternMatching::literal_pat_example

  .method public static void  tuple_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1D 54 75 70 6C 65 20 70 61 74 74 65 72 6E   // ...Tuple pattern
                                                                        20 6D 61 63 68 69 6E 67 20 65 78 61 6D 70 6C 65   //  maching example
                                                                        00 00 ) 
    // Code size       124 (0x7c)
    .maxstack  5
    .locals init ([0] class [FSharp.Core]System.Tuple`3<string,string,int32> p,
             [1] string message,
             [2] class [FSharp.Core]System.Tuple`3<string,string,int32> V_2,
             [3] string last,
             [4] string first,
             [5] int32 age)
//000119: 
//000120: [<Example("Tuple pattern maching example")>]
//000121: let tuple_pat_example() =
//000122:     let p = ("Aaron", "Erickson", 35)
    IL_0000:  nop
    IL_0001:  ldstr      "Aaron"
    IL_0006:  ldstr      "Erickson"
    IL_000b:  ldc.i4.s   35
    IL_000d:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0012:  stloc.0
//000123:     let message = match p with
    IL_0013:  nop
    IL_0014:  ldloc.0
    IL_0015:  stloc.2
    IL_0016:  ldloc.2
    IL_0017:  call       instance !1 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item2()
    IL_001c:  stloc.3
    IL_001d:  ldloc.2
    IL_001e:  call       instance !0 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item1()
    IL_0023:  stloc.s    first
    IL_0025:  ldloc.2
    IL_0026:  call       instance !2 class [FSharp.Core]System.Tuple`3<string,string,int32>::get_Item3()
    IL_002b:  stloc.s    age
//000124:                     | (first, last, age) -> 
//000125:                         "Howdy " + first + " " + last +
    IL_002d:  ldstr      "Howdy "
    IL_0032:  ldloc.s    first
    IL_0034:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0039:  ldstr      " "
    IL_003e:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0043:  ldloc.3
    IL_0044:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0049:  ldstr      ", I'm glad to hear you're "
    IL_004e:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0053:  ldloca.s   age
    IL_0055:  constrained. [mscorlib]System.Int32
    IL_005b:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0060:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0065:  ldstr      "!"
    IL_006a:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_006f:  stloc.1
//000126:                         ", I'm glad to hear you're " + age.ToString() + "!"
//000127:     System.Console.WriteLine("We got {0}", message)
    IL_0070:  ldstr      "We got {0}"
    IL_0075:  ldloc.1
    IL_0076:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_007b:  ret
  } // end of method PatternMatching::tuple_pat_example

  .method public static void  list_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1D 4C 69 73 74 20 70 61 74 74 65 72 6E 20   // ...List pattern 
                                                                        6D 61 74 63 68 69 6E 67 20 65 78 61 6D 70 6C 65   // matching example
                                                                        00 00 ) 
    // Code size       264 (0x108)
    .maxstack  8
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> numbers,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>,int32> sumList,
             [2] int32 sum,
             [3] string message,
             [4] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_4,
             [5] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_5,
             [6] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> V_6,
             [7] int32 two,
             [8] int32 V_8,
             [9] int32 one)
//000128: 
//000129: [<Example("List pattern matching example")>]
//000130: let list_pat_example() =
//000131:     let numbers = [1; 2; 3; 4; 5]
    IL_0000:  nop
    IL_0001:  ldc.i4.1
    IL_0002:  ldc.i4.2
    IL_0003:  ldc.i4.3
    IL_0004:  ldc.i4.4
    IL_0005:  ldc.i4.5
    IL_0006:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_Empty()
    IL_000b:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0010:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0015:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_001a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_001f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0024:  stloc.0
//000132:     let rec sumList ns = match ns with
    IL_0025:  newobj     instance void PatternMatching/sumList@132::.ctor()
    IL_002a:  stloc.1
//000133:                             | [] -> 0
//000134:                             | head :: tail -> head + sumList tail
//000135:     let sum = sumList numbers
    IL_002b:  ldloc.1
    IL_002c:  ldloc.0
    IL_002d:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>,int32>::Invoke(!0)
    IL_0032:  stloc.2
//000136:     System.Console.WriteLine("Sum of numbers = {0}", sum)
    IL_0033:  ldstr      "Sum of numbers = {0}"
    IL_0038:  ldloc.2
    IL_0039:  box        [mscorlib]System.Int32
    IL_003e:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000137:     
//000138:     let message = match numbers with
    IL_0043:  nop
    IL_0044:  ldloc.0
    IL_0045:  stloc.s    V_4
    IL_0047:  ldloc.s    V_4
    IL_0049:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_004e:  brfalse.s  IL_0082

    IL_0050:  ldloc.s    V_4
    IL_0052:  stloc.s    V_5
    IL_0054:  ldloc.s    V_5
    IL_0056:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_005b:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_0060:  brfalse.s  IL_0080

    IL_0062:  ldloc.s    V_5
    IL_0064:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_0069:  stloc.s    V_6
    IL_006b:  ldloc.s    V_6
    IL_006d:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_0072:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_TailOrNull()
    IL_0077:  brtrue.s   IL_007b

    IL_0079:  br.s       IL_00ad

    IL_007b:  br         IL_00f5

    IL_0080:  br.s       IL_008a

//000139:                     | [] -> "List is empty!"
    IL_0082:  ldstr      "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0087:  nop
    IL_0088:  br.s       IL_00fb

//000138:     let message = match numbers with
    IL_008a:  ldloc.s    V_5
    IL_008c:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_HeadOrDefault()
    IL_0091:  stloc.s    one
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
    IL_0093:  ldstr      "List has one item: "
    IL_0098:  ldloca.s   one
    IL_009a:  constrained. [mscorlib]System.Int32
    IL_00a0:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00a5:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00aa:  nop
    IL_00ab:  br.s       IL_00fb

//000138:     let message = match numbers with
    IL_00ad:  ldloc.s    V_6
    IL_00af:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_HeadOrDefault()
    IL_00b4:  stloc.s    two
    IL_00b6:  ldloc.s    V_5
    IL_00b8:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_HeadOrDefault()
    IL_00bd:  stloc.s    V_8
//000139:                     | [] -> "List is empty!"
//000140:                     | [one] -> 
//000141:                         "List has one item: " + one.ToString()
//000142:                     | [one; two] ->
//000143:                         "List has two items: " + 
    IL_00bf:  ldstr      "List has two items: "
    IL_00c4:  ldloca.s   V_8
    IL_00c6:  constrained. [mscorlib]System.Int32
    IL_00cc:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00d1:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_00d6:  ldstr      " "
    IL_00db:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_00e0:  ldloca.s   two
    IL_00e2:  constrained. [mscorlib]System.Int32
    IL_00e8:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00ed:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000144:                         one.ToString() + " " + two.ToString()
//000145:                     | _ -> "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00f2:  nop
    IL_00f3:  br.s       IL_00fb

//000145:                     | _ -> "List has more than two items"
    IL_00f5:  ldstr      "List has more than two items"
//000146:     System.Console.WriteLine("We got {0}", message)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
//000151:     let message = match numbers with
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00fa:  nop
    IL_00fb:  stloc.3
//000146:     System.Console.WriteLine("We got {0}", message)
    IL_00fc:  ldstr      "We got {0}"
    IL_0101:  ldloc.3
    IL_0102:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0107:  ret
  } // end of method PatternMatching::list_pat_example

  .method public static void  array_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1E 41 72 72 61 79 20 70 61 74 74 65 72 6E   // ...Array pattern
                                                                        20 6D 61 74 63 68 69 6E 67 20 65 78 61 6D 70 6C   //  matching exampl
                                                                        65 00 00 )                                        // e..
    // Code size       274 (0x112)
    .maxstack  6
    .locals init ([0] int32[] numbers,
             [1] string message,
             [2] int32[] V_2,
             [3] int32[] V_3,
             [4] int32[] V_4,
             [5] int32[] V_5,
             [6] int32 one,
             [7] int32 two,
             [8] int32 V_8)
//000147:     
//000148: [<Example("Array pattern matching example")>]
//000149: let array_pat_example() =
//000150:     let numbers = [|1; 2; 3; 4; 5|]
    IL_0000:  nop
    IL_0001:  ldc.i4.5
    IL_0002:  newarr     [mscorlib]System.Int32
    IL_0007:  dup
    IL_0008:  ldc.i4.0
    IL_0009:  ldc.i4.1
    IL_000a:  stelem     [mscorlib]System.Int32
    IL_000f:  dup
    IL_0010:  ldc.i4.1
    IL_0011:  ldc.i4.2
    IL_0012:  stelem     [mscorlib]System.Int32
    IL_0017:  dup
    IL_0018:  ldc.i4.2
    IL_0019:  ldc.i4.3
    IL_001a:  stelem     [mscorlib]System.Int32
    IL_001f:  dup
    IL_0020:  ldc.i4.3
    IL_0021:  ldc.i4.4
    IL_0022:  stelem     [mscorlib]System.Int32
    IL_0027:  dup
    IL_0028:  ldc.i4.4
    IL_0029:  ldc.i4.5
    IL_002a:  stelem     [mscorlib]System.Int32
    IL_002f:  stloc.0
//000151:     let message = match numbers with
    IL_0030:  nop
    IL_0031:  ldloc.0
    IL_0032:  stloc.2
    IL_0033:  ldloc.2
    IL_0034:  stloc.3
    IL_0035:  ldloc.3
    IL_0036:  ldnull
    IL_0037:  cgt.un
    IL_0039:  brfalse.s  IL_003d

    IL_003b:  br.s       IL_003f

    IL_003d:  br.s       IL_0048

//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_003f:  ldloc.3
    IL_0040:  ldlen
    IL_0041:  conv.i4
    IL_0042:  ldc.i4.0
    IL_0043:  ceq
    IL_0045:  nop
    IL_0046:  br.s       IL_004a

    IL_0048:  ldc.i4.0
    IL_0049:  nop
    IL_004a:  brfalse.s  IL_004e

    IL_004c:  br.s       IL_008c

    IL_004e:  ldloc.2
    IL_004f:  stloc.s    V_4
    IL_0051:  ldloc.s    V_4
    IL_0053:  ldnull
    IL_0054:  cgt.un
    IL_0056:  brfalse.s  IL_005a

    IL_0058:  br.s       IL_005c

    IL_005a:  br.s       IL_0066

    IL_005c:  ldloc.s    V_4
    IL_005e:  ldlen
    IL_005f:  conv.i4
    IL_0060:  ldc.i4.1
    IL_0061:  ceq
    IL_0063:  nop
    IL_0064:  br.s       IL_0068

    IL_0066:  ldc.i4.0
    IL_0067:  nop
    IL_0068:  brfalse.s  IL_006c

    IL_006a:  br.s       IL_0094

    IL_006c:  ldloc.2
    IL_006d:  stloc.s    V_5
    IL_006f:  ldloc.s    V_5
    IL_0071:  ldnull
    IL_0072:  cgt.un
    IL_0074:  brfalse.s  IL_0078

    IL_0076:  br.s       IL_007a

    IL_0078:  br.s       IL_0084

    IL_007a:  ldloc.s    V_5
    IL_007c:  ldlen
    IL_007d:  conv.i4
    IL_007e:  ldc.i4.2
    IL_007f:  ceq
    IL_0081:  nop
    IL_0082:  br.s       IL_0086

    IL_0084:  ldc.i4.0
    IL_0085:  nop
    IL_0086:  brfalse.s  IL_008a

    IL_0088:  br.s       IL_00b7

    IL_008a:  br.s       IL_00ff

//000152:                     | [| |] -> "Array is empty!"
    IL_008c:  ldstr      "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0091:  nop
    IL_0092:  br.s       IL_0105

//000151:     let message = match numbers with
    IL_0094:  ldloc.2
    IL_0095:  ldc.i4.0
    IL_0096:  ldelem     [mscorlib]System.Int32
    IL_009b:  stloc.s    one
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
    IL_009d:  ldstr      "Array has one item: "
    IL_00a2:  ldloca.s   one
    IL_00a4:  constrained. [mscorlib]System.Int32
    IL_00aa:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00af:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00b4:  nop
    IL_00b5:  br.s       IL_0105

//000151:     let message = match numbers with
    IL_00b7:  ldloc.2
    IL_00b8:  ldc.i4.1
    IL_00b9:  ldelem     [mscorlib]System.Int32
    IL_00be:  stloc.s    two
    IL_00c0:  ldloc.2
    IL_00c1:  ldc.i4.0
    IL_00c2:  ldelem     [mscorlib]System.Int32
    IL_00c7:  stloc.s    V_8
//000152:                     | [| |] -> "Array is empty!"
//000153:                     | [| one |] ->
//000154:                         "Array has one item: " + one.ToString()
//000155:                     | [| one; two |] ->
//000156:                         "Array has two items: " +
    IL_00c9:  ldstr      "Array has two items: "
    IL_00ce:  ldloca.s   V_8
    IL_00d0:  constrained. [mscorlib]System.Int32
    IL_00d6:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00db:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_00e0:  ldstr      " "
    IL_00e5:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_00ea:  ldloca.s   two
    IL_00ec:  constrained. [mscorlib]System.Int32
    IL_00f2:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_00f7:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000157:                         one.ToString() + " " + two.ToString()
//000158:                     | _ -> "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00fc:  nop
    IL_00fd:  br.s       IL_0105

//000158:                     | _ -> "Array has more than two items"
    IL_00ff:  ldstr      "Array has more than two items"
//000159:     System.Console.WriteLine("We got {0}", message)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
//000164:     let message = match t1 with
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
//000187:     let message = match (p.FirstName) with
//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0104:  nop
    IL_0105:  stloc.1
//000159:     System.Console.WriteLine("We got {0}", message)
    IL_0106:  ldstr      "We got {0}"
    IL_010b:  ldloc.1
    IL_010c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0111:  ret
  } // end of method PatternMatching::array_pat_example

  .method public static void  as_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 22 41 73 2D 70 61 74 74 65 72 6E 20 70 61   // .."As-pattern pa
                                                                        74 74 65 72 6E 20 6D 61 63 68 69 6E 67 20 65 78   // ttern maching ex
                                                                        61 6D 70 6C 65 00 00 )                            // ample..
    // Code size       102 (0x66)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]System.Tuple`2<int32,int32> t1,
             [1] string message,
             [2] class [FSharp.Core]System.Tuple`2<int32,int32> t2,
             [3] int32 y,
             [4] int32 x)
//000160: 
//000161: [<Example("As-pattern pattern maching example")>]    
//000162: let as_pat_example() =
//000163:     let t1 = (1, 2)
    IL_0000:  nop
    IL_0001:  ldc.i4.1
    IL_0002:  ldc.i4.2
    IL_0003:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,int32>::.ctor(!0,
                                                                                             !1)
    IL_0008:  stloc.0
//000164:     let message = match t1 with
    IL_0009:  nop
    IL_000a:  ldloc.0
    IL_000b:  stloc.2
    IL_000c:  ldloc.2
    IL_000d:  call       instance !1 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item2()
    IL_0012:  stloc.3
    IL_0013:  ldloc.2
    IL_0014:  call       instance !0 class [FSharp.Core]System.Tuple`2<int32,int32>::get_Item1()
    IL_0019:  stloc.s    x
//000165:                     | (x,y) as t2 ->
//000166:                         x.ToString() + " " +
    IL_001b:  ldloca.s   x
    IL_001d:  constrained. [mscorlib]System.Int32
    IL_0023:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0028:  ldstr      " "
    IL_002d:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0032:  ldloca.s   y
    IL_0034:  constrained. [mscorlib]System.Int32
    IL_003a:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_003f:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0044:  ldstr      " "
    IL_0049:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_004e:  ldloc.2
    IL_004f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0054:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0059:  stloc.1
//000167:                         y.ToString() + " " +
//000168:                         t2.ToString()
//000169:     System.Console.WriteLine("We got {0}", message)
    IL_005a:  ldstr      "We got {0}"
    IL_005f:  ldloc.1
    IL_0060:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0065:  ret
  } // end of method PatternMatching::as_pat_example

  .method public static void  when_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1D 57 68 65 6E 20 70 61 74 74 65 72 6E 20   // ...When pattern 
                                                                        6D 61 74 63 68 69 6E 67 20 65 78 61 6D 70 6C 65   // matching example
                                                                        00 00 ) 
    // Code size       239 (0xef)
    .maxstack  6
    .locals init ([0] class HelperTypes/Person p,
             [1] string message,
             [2] string V_2,
             [3] string V_3,
             [4] string V_4,
             [5] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> isOldFogey,
             [6] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> 'isOldFogey\'',[7] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool> 'isOldFogey\'\'')
//000170: 
//000171: (*    
//000172: let pat_example90() =
//000173:     let rec buildMessage (l : obj list) =
//000174:         match l with
//000175:             | [(n : string) :: t] -> 
//000176:                 System.String.Format("Greetings {0}", n) + buildMessage t
//000177:             | [(a : int) :: t] -> 
//000178:                 System.String.Format("You're {0}", a) + buildMessage t
//000179:             | _ -> "."
//000180:     let message = buildMessage ["Fred"; 38]
//000181:     System.Console.WriteLine(message)
//000182: *)    
//000183: 
//000184: [<Example("When pattern matching example")>]
//000185: let when_pat_example() =
//000186:     let p = new Person("Rick", "Minerich", 35)
    IL_0000:  nop
    IL_0001:  ldstr      "Rick"
    IL_0006:  ldstr      "Minerich"
    IL_000b:  ldc.i4.s   35
    IL_000d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0012:  stloc.0
//000187:     let message = match (p.FirstName) with
    IL_0013:  nop
    IL_0014:  ldloc.0
    IL_0015:  call       instance string HelperTypes/Person::get_FirstName()
    IL_001a:  stloc.2
    IL_001b:  ldloc.0
    IL_001c:  call       instance int32 HelperTypes/Person::get_Age()
    IL_0021:  ldc.i4.s   30
    IL_0023:  ble.s      IL_0027

    IL_0025:  br.s       IL_0029

    IL_0027:  br.s       IL_0031

//000188:                     | _ when p.Age > 30 ->
//000189:                         "Never found"
    IL_0029:  ldstr      "Never found"
//000190:                     | "Minerich" when p.FirstName <> "Rick" ->
//000191:                         "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_002e:  nop
    IL_002f:  br.s       IL_0084

    IL_0031:  ldloc.2
    IL_0032:  ldstr      "Minerich"
    IL_0037:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_003c:  brfalse.s  IL_0065

    IL_003e:  ldloc.0
    IL_003f:  call       instance string HelperTypes/Person::get_FirstName()
    IL_0044:  stloc.3
    IL_0045:  ldstr      "Rick"
    IL_004a:  stloc.s    V_4
    IL_004c:  ldloc.3
    IL_004d:  ldloc.s    V_4
    IL_004f:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0054:  ldc.i4.0
    IL_0055:  ceq
    IL_0057:  brfalse.s  IL_005b

    IL_0059:  br.s       IL_005d

    IL_005b:  br.s       IL_0065

//000191:                         "Also never found"
    IL_005d:  ldstr      "Also never found"
//000192:                     | "Minerich" ->
//000193:                         "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0062:  nop
    IL_0063:  br.s       IL_0084

    IL_0065:  ldloc.2
    IL_0066:  ldstr      "Minerich"
    IL_006b:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0070:  brfalse.s  IL_0074

    IL_0072:  br.s       IL_0076

    IL_0074:  br.s       IL_007e

//000193:                         "Hiya, Rick!"
    IL_0076:  ldstr      "Hiya, Rick!"
//000194:                     | _ ->
//000195:                         "Who are you?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_007b:  nop
    IL_007c:  br.s       IL_0084

//000195:                         "Who are you?"
    IL_007e:  ldstr      "Who are you\?"
//000196:     System.Console.WriteLine("We got {0}", message)
//000197:     
//000198:     let isOldFogey (person : Person) =
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
//000208:             
//000209:     let isOldFogey' (person : Person) =
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
//000251:     | Contains "<script>" true -> false
//000252:     | Contains "<object>" true -> false
//000253:     | Contains "<embed>" true -> false
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
//000260: 
//000261:     let (|Contains|_|) pat inStr =
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
//000269:     | Contains "http://S+" _ -> "Contains urls"
//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0083:  nop
    IL_0084:  stloc.1
//000196:     System.Console.WriteLine("We got {0}", message)
    IL_0085:  ldstr      "We got {0}"
    IL_008a:  ldloc.1
    IL_008b:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000197:     
//000198:     let isOldFogey (person : Person) =
    IL_0090:  newobj     instance void PatternMatching/isOldFogey@199::.ctor()
    IL_0095:  stloc.s    isOldFogey
//000199:         match person with
//000200:         | _ when person.Age > 35 || 
//000201:             (person.FirstName = "Ted" && 
//000202:                 person.LastName = "Neward") ||
//000203:             (person.FirstName = "Aaron" && 
//000204:                 person.LastName = "Erickson") ->
//000205:             true
//000206:         | _ -> false
//000207:     System.Console.WriteLine("{0} is an old fogey: {1}", p, isOldFogey p)
    IL_0097:  ldstr      "{0} is an old fogey: {1}"
    IL_009c:  ldloc.0
    IL_009d:  ldloc.s    isOldFogey
    IL_009f:  ldloc.0
    IL_00a0:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
    IL_00a5:  box        [mscorlib]System.Boolean
    IL_00aa:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
//000208:             
//000209:     let isOldFogey' (person : Person) =
    IL_00af:  ldloc.0
    IL_00b0:  newobj     instance void PatternMatching/'isOldFogey\'@210'::.ctor(class HelperTypes/Person)
    IL_00b5:  stloc.s    'isOldFogey\''
//000210:         let isOld (p : Person) = 
//000211:             p.Age > 35
//000212:         let isTed (p : Person) = 
//000213:             p.FirstName = "Ted" && p.LastName = "Neward"
//000214:         let isAaron (p : Person) = 
//000215:             p.FirstName = "Aaron" && p.LastName = "Erickson"
//000216:         match p with
//000217:             | _ when isOld p || isTed p || isAaron p -> 
//000218:                 true
//000219:             | _ -> 
//000220:                 false
//000221:     System.Console.WriteLine("{0} is an old fogey: {1}",
    IL_00b7:  ldstr      "{0} is an old fogey: {1}"
    IL_00bc:  ldloc.0
    IL_00bd:  ldloc.s    'isOldFogey\''
    IL_00bf:  ldloc.0
    IL_00c0:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
    IL_00c5:  box        [mscorlib]System.Boolean
    IL_00ca:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
//000222:         p, isOldFogey' p)
//000223:         
//000224:     let isOldFogey'' (p : Person) =
    IL_00cf:  newobj     instance void PatternMatching/'isOldFogey\'\'@225'::.ctor()
    IL_00d4:  stloc.s    'isOldFogey\'\''
//000225:         match p.Age, p.FirstName, p.LastName with
//000226:         | _, "Ted", "Neward" -> true
//000227:         | _, "Aaron", "Erickson" -> true
//000228:         | a, _, _ when a > 35 -> true
//000229:         | _ -> false
//000230:     System.Console.WriteLine("{0} is an old fogey: {1}",
    IL_00d6:  ldstr      "{0} is an old fogey: {1}"
    IL_00db:  ldloc.0
    IL_00dc:  ldloc.s    'isOldFogey\'\''
    IL_00de:  ldloc.0
    IL_00df:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::Invoke(!0)
    IL_00e4:  box        [mscorlib]System.Boolean
    IL_00e9:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
    IL_00ee:  ret
  } // end of method PatternMatching::when_pat_example

  .method public static bool  active_simple_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1F 41 63 74 69 76 65 20 70 61 74 74 65 72   // ...Active patter
                                                                        6E 20 6D 61 74 63 68 69 6E 67 20 65 78 61 6D 70   // n matching examp
                                                                        6C 65 00 00 )                                     // le..
    // Code size       180 (0xb4)
    .maxstack  5
    .locals init ([0] string inputData,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> contains,
             [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool> goodInput,
             [3] bool V_3,
             [4] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>> '|Contains|',
             [5] string V_5,
             [6] bool V_6,
             [7] bool V_7,
             [8] bool V_8,
             [9] bool V_9)
//000231:         p, isOldFogey'' p)
//000232:     
//000233: open System.IO
//000234: 
//000235: [<Example("Active pattern matching example")>]
//000236: let active_simple_pat_example() =
//000237:     let inputData = "This is some <script>alert()</script> data"
    IL_0000:  nop
    IL_0001:  ldstr      "This is some <script>alert()</script> data"
    IL_0006:  stloc.0
    IL_0007:  newobj     instance void PatternMatching/contains@239::.ctor()
    IL_000c:  stloc.1
    IL_000d:  ldloc.1
    IL_000e:  newobj     instance void PatternMatching/goodInput@241::.ctor(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>>)
    IL_0013:  stloc.2
//000238:     let contains (srchStr : string) (inStr : string) =
//000239:         inStr.Contains srchStr
//000240:     let goodInput inStr =
//000241:         contains "<script>" inStr ||
//000242:         contains "<object>" inStr ||
//000243:         contains "<embed>" inStr ||
//000244:         contains "<applet>" inStr
//000245:     System.Console.WriteLine("Does the text contain bad data? " +
    IL_0014:  ldstr      "Does the text contain bad data\? "
    IL_0019:  ldloc.2
    IL_001a:  ldloc.0
    IL_001b:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::Invoke(!0)
    IL_0020:  stloc.3
    IL_0021:  ldloca.s   V_3
    IL_0023:  constrained. [mscorlib]System.Boolean
    IL_0029:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_002e:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0033:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0038:  newobj     instance void PatternMatching/'|Contains|@249'::.ctor()
    IL_003d:  stloc.s    '|Contains|'
//000246:         (goodInput inputData).ToString())
//000247:         
//000248:     let (|Contains|) srchStr (inStr : string) =
//000249:         inStr.Contains srchStr
//000250:     match inputData with
    IL_003f:  ldloc.0
    IL_0040:  stloc.s    V_5
    IL_0042:  ldloc.s    '|Contains|'
    IL_0044:  ldstr      "<script>"
    IL_0049:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>>::Invoke(!0)
    IL_004e:  ldloc.s    V_5
    IL_0050:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::Invoke(!0)
    IL_0055:  stloc.s    V_6
    IL_0057:  ldloc.s    V_6
    IL_0059:  brfalse.s  IL_005d

    IL_005b:  br.s       IL_00ae

    IL_005d:  ldloc.s    '|Contains|'
    IL_005f:  ldstr      "<object>"
    IL_0064:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>>::Invoke(!0)
    IL_0069:  ldloc.s    V_5
    IL_006b:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::Invoke(!0)
    IL_0070:  stloc.s    V_7
    IL_0072:  ldloc.s    V_7
    IL_0074:  brfalse.s  IL_0078

    IL_0076:  br.s       IL_00b0

    IL_0078:  ldloc.s    '|Contains|'
    IL_007a:  ldstr      "<embed>"
    IL_007f:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>>::Invoke(!0)
    IL_0084:  ldloc.s    V_5
    IL_0086:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::Invoke(!0)
    IL_008b:  stloc.s    V_8
    IL_008d:  ldloc.s    V_8
    IL_008f:  brfalse.s  IL_0093

    IL_0091:  br.s       IL_00b2

    IL_0093:  ldloc.s    '|Contains|'
    IL_0095:  ldstr      "<applet>"
    IL_009a:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>>::Invoke(!0)
    IL_009f:  ldloc.s    V_5
    IL_00a1:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,bool>::Invoke(!0)
    IL_00a6:  stloc.s    V_9
    IL_00a8:  ldloc.s    V_9
    IL_00aa:  ldc.i4.0
    IL_00ab:  ceq
    IL_00ad:  ret

//000251:     | Contains "<script>" true -> false
    IL_00ae:  ldc.i4.0
    IL_00af:  ret

//000252:     | Contains "<object>" true -> false
    IL_00b0:  ldc.i4.0
    IL_00b1:  ret

//000253:     | Contains "<embed>" true -> false
    IL_00b2:  ldc.i4.0
    IL_00b3:  ret
  } // end of method PatternMatching::active_simple_pat_example

  .method public static string  active_partial_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 23 50 61 72 74 69 61 6C 2D 63 61 73 65 20   // ..#Partial-case 
                                                                        61 63 74 69 76 65 20 70 61 74 74 65 72 6E 20 65   // active pattern e
                                                                        78 61 6D 70 6C 65 00 00 )                         // xample..
    // Code size       151 (0x97)
    .maxstack  4
    .locals init ([0] string inputData,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>> '|Contains|_|',
             [2] string V_2,
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>> V_3,
             [4] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>> V_4,
             [5] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>> V_5,
             [6] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>> V_6)
//000254:     | Contains "<applet>" true -> false
//000255:     | _ -> true
//000256: 
//000257: [<Example("Partial-case active pattern example")>]
//000258: let active_partial_pat_example() =
//000259:     let inputData = "This is some <script>alert()</script> data"
    IL_0000:  nop
    IL_0001:  ldstr      "This is some <script>alert()</script> data"
    IL_0006:  stloc.0
//000260: 
//000261:     let (|Contains|_|) pat inStr =
    IL_0007:  newobj     instance void PatternMatching/'|Contains|_|@262'::.ctor()
    IL_000c:  stloc.1
//000262:         let results = 
//000263:             (System.Text.RegularExpressions.Regex.Matches(inStr, pat))
//000264:         if results.Count > 0 
//000265:             then Some [ for m in results -> m.Value ] 
//000266:             else None
//000267: 
//000268:     match inputData with
    IL_000d:  ldloc.0
    IL_000e:  stloc.2
    IL_000f:  ldloc.1
    IL_0010:  ldstr      "http://S+"
    IL_0015:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>>::Invoke(!0)
    IL_001a:  ldloc.2
    IL_001b:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>::Invoke(!0)
    IL_0020:  stloc.3
    IL_0021:  ldloc.3
    IL_0022:  brfalse.s  IL_0026

    IL_0024:  br.s       IL_0028

    IL_0026:  br.s       IL_002e

//000269:     | Contains "http://S+" _ -> "Contains urls"
    IL_0028:  ldstr      "Contains urls"
    IL_002d:  ret

//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_002e:  ldloc.1
    IL_002f:  ldstr      "[^@]@[^.]+\\.\\W+"
    IL_0034:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>>::Invoke(!0)
    IL_0039:  ldloc.2
    IL_003a:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>::Invoke(!0)
    IL_003f:  stloc.s    V_4
    IL_0041:  ldloc.s    V_4
    IL_0043:  brfalse.s  IL_0047

    IL_0045:  br.s       IL_0049

    IL_0047:  br.s       IL_004f

//000270:     | Contains "[^@]@[^.]+\.\W+" _ -> "Contains emails"
    IL_0049:  ldstr      "Contains emails"
    IL_004e:  ret

//000271:     | Contains "\<script\>" _ -> "Found <script>"
//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_004f:  ldloc.1
    IL_0050:  ldstr      "\\<script\\>"
    IL_0055:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>>::Invoke(!0)
    IL_005a:  ldloc.2
    IL_005b:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>::Invoke(!0)
    IL_0060:  stloc.s    V_5
    IL_0062:  ldloc.s    V_5
    IL_0064:  brfalse.s  IL_0068

    IL_0066:  br.s       IL_006a

    IL_0068:  br.s       IL_0070

//000271:     | Contains "\<script\>" _ -> "Found <script>"
    IL_006a:  ldstr      "Found <script>"
    IL_006f:  ret

//000272:     | Contains "\<object\>" _ -> "Found <object>"
//000273:     | _ -> "Didn't find what we were looking for"
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
//000291:     let message = 
//000292:         match pt with
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0070:  ldloc.1
    IL_0071:  ldstr      "\\<object\\>"
    IL_0076:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>>::Invoke(!0)
    IL_007b:  ldloc.2
    IL_007c:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>>>::Invoke(!0)
    IL_0081:  stloc.s    V_6
    IL_0083:  ldloc.s    V_6
    IL_0085:  brfalse.s  IL_0089

    IL_0087:  br.s       IL_008b

    IL_0089:  br.s       IL_0091

//000272:     | Contains "\<object\>" _ -> "Found <object>"
    IL_008b:  ldstr      "Found <object>"
    IL_0090:  ret

//000273:     | _ -> "Didn't find what we were looking for"
    IL_0091:  ldstr      "Didn't find what we were looking for"
    IL_0096:  ret
  } // end of method PatternMatching::active_partial_pat_example

  .method public static void  active_reflect_pat_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 2E 50 61 72 74 69 61 6C 2D 63 61 73 65 20   // ...Partial-case 
                                                                        52 65 66 6C 65 63 74 69 6F 6E 20 61 63 74 69 76   // Reflection activ
                                                                        65 20 70 61 74 74 65 72 6E 20 65 78 61 6D 70 6C   // e pattern exampl
                                                                        65 00 00 )                                        // e..
    // Code size       174 (0xae)
    .maxstack  4
    .locals init ([0] valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.FieldInfo>>> '|Field|_|',
             [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>> '|Method|_|',
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>> '|Property|_|',
             [4] class [mscorlib]System.Type pt,
             [5] string message,
             [6] class [mscorlib]System.Type V_6,
             [7] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo> V_7,
             [8] class [mscorlib]System.Reflection.PropertyInfo pi,
             [9] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo> V_9,
             [10] class [mscorlib]System.Reflection.PropertyInfo V_10)
//000274: 
//000275: open System.Reflection
//000276: [<Example("Partial-case Reflection active pattern example")>]
//000277: let active_reflect_pat_example() =
//000278:     let AllBindingFlags = 
    IL_0000:  nop
    IL_0001:  ldc.i4.s   52
    IL_0003:  ldc.i4.8
    IL_0004:  or
    IL_0005:  stloc.0
//000279:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000280:         BindingFlags.Instance ||| BindingFlags.Static
//000281:     let (|Field|_|) name (t : System.Type) =
    IL_0006:  ldloc.0
    IL_0007:  newobj     instance void PatternMatching/'|Field|_|@282'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_000c:  stloc.1
//000282:         let fi = t.GetField(name, AllBindingFlags) 
//000283:         if fi <> null then Some(fi) else None
//000284:     let (|Method|_|) name (t : System.Type) =
    IL_000d:  ldloc.0
    IL_000e:  newobj     instance void PatternMatching/'|Method|_|@285'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_0013:  stloc.2
//000285:         let fi = t.GetMethod(name, AllBindingFlags) 
//000286:         if fi <> null then Some(fi) else None
//000287:     let (|Property|_|) name (t : System.Type) =
    IL_0014:  ldloc.0
    IL_0015:  newobj     instance void PatternMatching/'|Property|_|@288'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_001a:  stloc.3
//000288:         let fi = t.GetProperty(name, AllBindingFlags) 
//000289:         if fi <> null then Some(fi) else None
//000290:     let pt = typeof<Person>
    IL_001b:  ldtoken    HelperTypes/Person
    IL_0020:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0025:  stloc.s    pt
//000291:     let message = 
    IL_0027:  nop
//000292:         match pt with
    IL_0028:  ldloc.s    pt
    IL_002a:  stloc.s    V_6
    IL_002c:  ldloc.3
    IL_002d:  ldstr      "FirstName"
    IL_0032:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>>::Invoke(!0)
    IL_0037:  ldloc.s    V_6
    IL_0039:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>::Invoke(!0)
    IL_003e:  stloc.s    V_7
    IL_0040:  ldloc.s    V_7
    IL_0042:  brfalse.s  IL_0046

    IL_0044:  br.s       IL_0048

    IL_0046:  br.s       IL_0065

    IL_0048:  ldloc.s    V_7
    IL_004a:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>::get_Value()
    IL_004f:  stloc.s    pi
//000293:         | Property "FirstName" pi -> 
//000294:             "Found property " + pi.ToString()
    IL_0051:  ldstr      "Found property "
    IL_0056:  ldloc.s    pi
    IL_0058:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_005d:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000295:         | Property "LastName" pi -> 
//000296:             "Found property " + pi.ToString()
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0062:  nop
    IL_0063:  br.s       IL_00a4

    IL_0065:  ldloc.3
    IL_0066:  ldstr      "LastName"
    IL_006b:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>>::Invoke(!0)
    IL_0070:  ldloc.s    V_6
    IL_0072:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Type,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>>::Invoke(!0)
    IL_0077:  stloc.s    V_9
    IL_0079:  ldloc.s    V_9
    IL_007b:  brfalse.s  IL_007f

    IL_007d:  br.s       IL_0081

    IL_007f:  br.s       IL_009e

    IL_0081:  ldloc.s    V_9
    IL_0083:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.PropertyInfo>::get_Value()
    IL_0088:  stloc.s    V_10
//000296:             "Found property " + pi.ToString()
    IL_008a:  ldstr      "Found property "
    IL_008f:  ldloc.s    V_10
    IL_0091:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0096:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000297:         | _ -> "There's other stuff, but who cares?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_009b:  nop
    IL_009c:  br.s       IL_00a4

//000297:         | _ -> "There's other stuff, but who cares?"
    IL_009e:  ldstr      "There's other stuff, but who cares\?"
//000298:     System.Console.WriteLine(message)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00a3:  nop
    IL_00a4:  stloc.s    message
//000298:     System.Console.WriteLine(message)
    IL_00a6:  ldloc.s    message
    IL_00a8:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_00ad:  ret
  } // end of method PatternMatching::active_reflect_pat_example

  .method public static void  activepat_ducktyping_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 32 50 61 72 74 69 61 6C 2D 63 61 73 65 20   // ..2Partial-case 
                                                                        52 65 66 6C 65 63 74 69 6F 6E 20 64 75 63 6B 20   // Reflection duck 
                                                                        74 79 70 69 6E 67 20 61 63 74 69 76 65 20 70 61   // typing active pa
                                                                        74 74 65 72 6E 00 00 )                            // ttern..
    // Code size       472 (0x1d8)
    .maxstack  5
    .locals init ([0] valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> '|Field|_|',
             [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class [mscorlib]System.Reflection.MethodInfo>>> '|Method|_|',
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> '|Property|_|',
             [4] class HelperTypes/Person rm,
             [5] string message,
             [6] class HelperTypes/Person V_6,
             [7] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> V_7,
             [8] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> V_8,
             [9] string V_9,
             [10] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>> V_10,
             [11] class HelperTypes/Person V_11,
             [12] object 'value',
             [13] class HelperTypes/Person V_13,
             [14] string V_14,
             [15] class HelperTypes/Person V_15,
             [16] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> V_16,
             [17] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> V_17,
             [18] string V_18,
             [19] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>> V_19,
             [20] class HelperTypes/Person V_20,
             [21] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> V_21,
             [22] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> V_22,
             [23] string V_23,
             [24] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>> V_24,
             [25] class HelperTypes/Person V_25,
             [26] object lnval,
             [27] object fnval,
             [28] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> V_28,
             [29] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> V_29,
             [30] string V_30,
             [31] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>> V_31,
             [32] class HelperTypes/Person V_32,
             [33] object V_33,
             [34] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object> V_34,
             [35] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>> V_35,
             [36] string V_36,
             [37] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>> V_37,
             [38] class HelperTypes/Person V_38,
             [39] object V_39)
//000299: 
//000300: [<Example("Partial-case Reflection duck typing active pattern")>]
//000301: let activepat_ducktyping_example() =
//000302:     let AllBindingFlags = 
    IL_0000:  nop
    IL_0001:  ldc.i4.s   52
    IL_0003:  ldc.i4.8
    IL_0004:  or
    IL_0005:  stloc.0
//000303:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000304:         BindingFlags.Instance ||| BindingFlags.Static
//000305:     let (|Field|_|) name (inst : obj) =
    IL_0006:  ldloc.0
    IL_0007:  newobj     instance void PatternMatching/'|Field|_|@306-1'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_000c:  stloc.1
//000306:         let fi = inst.GetType().GetField(name, AllBindingFlags)
//000307:         if fi <> null 
//000308:         then Some(fi.GetValue(inst)) 
//000309:         else None
//000310:     let (|Method|_|) name (inst : obj) =
    IL_000d:  ldloc.0
    IL_000e:  newobj     instance void PatternMatching/'|Method|_|@311-1'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_0013:  stloc.2
//000311:         let fi = inst.GetType().GetMethod(name, AllBindingFlags)
//000312:         if fi <> null 
//000313:         then Some(fi) 
//000314:         else None
//000315:     let (|Property|_|) name (inst : obj) =
    IL_0014:  ldloc.0
    IL_0015:  newobj     instance void PatternMatching/'|Property|_|@316-1'::.ctor(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_001a:  stloc.3
//000316:         let fi = inst.GetType().GetProperty(name, AllBindingFlags)
//000317:         if fi <> null 
//000318:         then Some(fi.GetValue(inst, null)) 
//000319:         else None
//000320: 
//000321:     let rm = new Person("Rick", "Minerich", 29)
    IL_001b:  ldstr      "Rick"
    IL_0020:  ldstr      "Minerich"
    IL_0025:  ldc.i4.s   29
    IL_0027:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_002c:  stloc.s    rm
//000322:     // Does it have a first name? Get the value if it does
//000323:     let message = match rm with
    IL_002e:  nop
    IL_002f:  ldloc.s    rm
    IL_0031:  stloc.s    V_6
    IL_0033:  ldloc.3
    IL_0034:  stloc.s    V_8
    IL_0036:  ldstr      "FirstName"
    IL_003b:  stloc.s    V_9
    IL_003d:  ldloc.s    V_8
    IL_003f:  ldloc.s    V_9
    IL_0041:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>>::Invoke(!0)
    IL_0046:  stloc.s    V_10
    IL_0048:  ldloc.s    V_6
    IL_004a:  stloc.s    V_11
    IL_004c:  ldloc.s    V_10
    IL_004e:  ldloc.s    V_11
    IL_0050:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::Invoke(!0)
    IL_0055:  stloc.s    V_7
    IL_0057:  ldloc.s    V_7
    IL_0059:  brfalse.s  IL_005d

    IL_005b:  br.s       IL_005f

    IL_005d:  br.s       IL_007c

    IL_005f:  ldloc.s    V_7
    IL_0061:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::get_Value()
    IL_0066:  stloc.s    'value'
//000324:                     | Property "FirstName" value ->
//000325:                         "FirstName = " + value.ToString()
    IL_0068:  ldstr      "FirstName = "
    IL_006d:  ldloc.s    'value'
    IL_006f:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0074:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000326:                     | _ -> "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0079:  nop
    IL_007a:  br.s       IL_0082

//000326:                     | _ -> "No FirstName to be found"
    IL_007c:  ldstr      "No FirstName to be found"
//000327:     System.Console.WriteLine(message)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0081:  nop
    IL_0082:  stloc.s    message
//000327:     System.Console.WriteLine(message)
    IL_0084:  ldloc.s    message
    IL_0086:  call       void [mscorlib]System.Console::WriteLine(string)
//000328: 
//000329:     let rm = new Person("Rick", "Minerich", 29)
    IL_008b:  ldstr      "Rick"
    IL_0090:  ldstr      "Minerich"
    IL_0095:  ldc.i4.s   29
    IL_0097:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_009c:  stloc.s    V_13
//000330:     // Does it have a first name AND a last name?
//000331:     let message = match rm with
    IL_009e:  nop
    IL_009f:  ldloc.s    V_13
    IL_00a1:  stloc.s    V_15
    IL_00a3:  ldloc.3
    IL_00a4:  stloc.s    V_17
    IL_00a6:  ldstr      "FirstName"
    IL_00ab:  stloc.s    V_18
    IL_00ad:  ldloc.s    V_17
    IL_00af:  ldloc.s    V_18
    IL_00b1:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>>::Invoke(!0)
    IL_00b6:  stloc.s    V_19
    IL_00b8:  ldloc.s    V_15
    IL_00ba:  stloc.s    V_20
    IL_00bc:  ldloc.s    V_19
    IL_00be:  ldloc.s    V_20
    IL_00c0:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::Invoke(!0)
    IL_00c5:  stloc.s    V_16
    IL_00c7:  ldloc.s    V_16
    IL_00c9:  brfalse.s  IL_0136

    IL_00cb:  ldloc.3
    IL_00cc:  stloc.s    V_22
    IL_00ce:  ldstr      "LastName"
    IL_00d3:  stloc.s    V_23
    IL_00d5:  ldloc.s    V_22
    IL_00d7:  ldloc.s    V_23
    IL_00d9:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>>::Invoke(!0)
    IL_00de:  stloc.s    V_24
    IL_00e0:  ldloc.s    V_15
    IL_00e2:  stloc.s    V_25
    IL_00e4:  ldloc.s    V_24
    IL_00e6:  ldloc.s    V_25
    IL_00e8:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::Invoke(!0)
    IL_00ed:  stloc.s    V_21
    IL_00ef:  ldloc.s    V_21
    IL_00f1:  brfalse.s  IL_00f5

    IL_00f3:  br.s       IL_00f7

    IL_00f5:  br.s       IL_0136

    IL_00f7:  ldloc.s    V_21
    IL_00f9:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::get_Value()
    IL_00fe:  stloc.s    lnval
    IL_0100:  ldloc.s    V_16
    IL_0102:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::get_Value()
    IL_0107:  stloc.s    fnval
//000332:                     | Property "FirstName" fnval &
//000333:                       Property "LastName" lnval ->
//000334:                         "Full name = " + fnval.ToString() +
    IL_0109:  ldstr      "Full name = "
    IL_010e:  ldloc.s    fnval
    IL_0110:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0115:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_011a:  ldstr      " "
    IL_011f:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0124:  ldloc.s    lnval
    IL_0126:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_012b:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000335:                         " " + lnval.ToString()
//000336:                     | Property "FirstName" value ->
//000337:                         "Name = " + value.ToString()
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0130:  nop
    IL_0131:  br         IL_01ce

    IL_0136:  ldloc.3
    IL_0137:  stloc.s    V_29
    IL_0139:  ldstr      "FirstName"
    IL_013e:  stloc.s    V_30
    IL_0140:  ldloc.s    V_29
    IL_0142:  ldloc.s    V_30
    IL_0144:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>>::Invoke(!0)
    IL_0149:  stloc.s    V_31
    IL_014b:  ldloc.s    V_15
    IL_014d:  stloc.s    V_32
    IL_014f:  ldloc.s    V_31
    IL_0151:  ldloc.s    V_32
    IL_0153:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::Invoke(!0)
    IL_0158:  stloc.s    V_28
    IL_015a:  ldloc.s    V_28
    IL_015c:  brfalse.s  IL_0160

    IL_015e:  br.s       IL_0162

    IL_0160:  br.s       IL_017f

    IL_0162:  ldloc.s    V_28
    IL_0164:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::get_Value()
    IL_0169:  stloc.s    V_33
//000337:                         "Name = " + value.ToString()
    IL_016b:  ldstr      "Name = "
    IL_0170:  ldloc.s    V_33
    IL_0172:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0177:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000338:                     | Property "LastName" value ->
//000339:                         "Name = " + value.ToString()
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_017c:  nop
    IL_017d:  br.s       IL_01ce

    IL_017f:  ldloc.3
    IL_0180:  stloc.s    V_35
    IL_0182:  ldstr      "LastName"
    IL_0187:  stloc.s    V_36
    IL_0189:  ldloc.s    V_35
    IL_018b:  ldloc.s    V_36
    IL_018d:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>>::Invoke(!0)
    IL_0192:  stloc.s    V_37
    IL_0194:  ldloc.s    V_15
    IL_0196:  stloc.s    V_38
    IL_0198:  ldloc.s    V_37
    IL_019a:  ldloc.s    V_38
    IL_019c:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<object,class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>>::Invoke(!0)
    IL_01a1:  stloc.s    V_34
    IL_01a3:  ldloc.s    V_34
    IL_01a5:  brfalse.s  IL_01a9

    IL_01a7:  br.s       IL_01ab

    IL_01a9:  br.s       IL_01c8

    IL_01ab:  ldloc.s    V_34
    IL_01ad:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<object>::get_Value()
    IL_01b2:  stloc.s    V_39
//000339:                         "Name = " + value.ToString()
    IL_01b4:  ldstr      "Name = "
    IL_01b9:  ldloc.s    V_39
    IL_01bb:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_01c0:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
//000340:                     | _ -> 
//000341:                         "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_01c5:  nop
    IL_01c6:  br.s       IL_01ce

//000341:                         "No name to be found"
    IL_01c8:  ldstr      "No name to be found"
//000342:     System.Console.WriteLine(message)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
//000361:     let AllBindingFlags = 
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_01cd:  nop
    IL_01ce:  stloc.s    V_14
//000342:     System.Console.WriteLine(message)
    IL_01d0:  ldloc.s    V_14
    IL_01d2:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_01d7:  ret
  } // end of method PatternMatching::activepat_ducktyping_example

  .method public static void  active_pat_multicase_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 21 4D 75 6C 74 69 2D 63 61 73 65 20 61 63   // ..!Multi-case ac
                                                                        74 69 76 65 20 70 61 74 74 65 72 6E 20 65 78 61   // tive pattern exa
                                                                        6D 70 6C 65 00 00 )                               // mple..
    // Code size       331 (0x14b)
    .maxstack  5
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MemberInfo,class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>> '|Property|Method|Field|Constructor|',
             [1] class [mscorlib]System.Type pt,
             [2] valuetype [mscorlib]System.Reflection.BindingFlags AllBindingFlags,
             [3] class [mscorlib]System.Reflection.MemberInfo[] V_3,
             [4] int32 V_4,
             [5] class [mscorlib]System.Reflection.MemberInfo p,
             [6] class [mscorlib]System.Reflection.MemberInfo V_6,
             [7] class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]> V_7,
             [8] class [mscorlib]System.Type ty,
             [9] string nm,
             [10] class [mscorlib]System.Type V_10,
             [11] string V_11,
             [12] class [mscorlib]System.Type rt,
             [13] class [mscorlib]System.Reflection.ParameterInfo[] parms,
             [14] string V_14,
             [15] class [mscorlib]System.Reflection.ParameterInfo[] V_15)
//000343: 
//000344: [<Example("Multi-case active pattern example")>]
//000345: let active_pat_multicase_example() =
//000346:     let (|Property|Method|Field|Constructor|) (mi : MemberInfo) =
    IL_0000:  nop
    IL_0001:  newobj     instance void PatternMatching/'|Property|Method|Field|Constructor|@347'::.ctor()
    IL_0006:  stloc.0
//000347:         if (mi :? FieldInfo) then 
//000348:             Field(mi.Name, (mi :?> FieldInfo).FieldType)
//000349:         elif (mi :? MethodInfo) then
//000350:             let mthi = (mi :?> MethodInfo)
//000351:             Method(mi.Name, mthi.ReturnType, mthi.GetParameters())
//000352:         elif (mi :? PropertyInfo) then
//000353:             let pi = (mi :?> PropertyInfo)
//000354:             Property(pi.Name, pi.PropertyType)
//000355:         elif (mi :? ConstructorInfo) then
//000356:             let ci = (mi :?> ConstructorInfo)
//000357:             Constructor(ci.GetParameters())
//000358:         else
//000359:             failwith "Unrecognized Reflection type"
//000360:     let pt = typeof<Person>
    IL_0007:  ldtoken    HelperTypes/Person
    IL_000c:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0011:  stloc.1
//000361:     let AllBindingFlags = 
    IL_0012:  ldc.i4.s   52
    IL_0014:  ldc.i4.8
    IL_0015:  or
    IL_0016:  stloc.2
//000362:         BindingFlags.NonPublic ||| BindingFlags.Public |||
//000363:         BindingFlags.Instance ||| BindingFlags.Static
//000364:     for p in pt.GetMembers(AllBindingFlags) do
    IL_0017:  ldloc.1
    IL_0018:  ldloc.2
    IL_0019:  callvirt   instance class [mscorlib]System.Reflection.MemberInfo[] [mscorlib]System.Type::GetMembers(valuetype [mscorlib]System.Reflection.BindingFlags)
    IL_001e:  stloc.3
    IL_001f:  ldc.i4.0
    IL_0020:  stloc.s    V_4
    IL_0022:  br         IL_0140

    IL_0027:  ldloc.3
    IL_0028:  ldloc.s    V_4
    IL_002a:  ldelem     [mscorlib]System.Reflection.MemberInfo
    IL_002f:  stloc.s    p
//000365:         match p with
    IL_0031:  ldloc.s    p
    IL_0033:  stloc.s    V_6
    IL_0035:  ldloc.0
    IL_0036:  ldloc.s    V_6
    IL_0038:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.Reflection.MemberInfo,class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>>::Invoke(!0)
    IL_003d:  stloc.s    V_7
    IL_003f:  ldloc.s    V_7
    IL_0041:  call       instance int32 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Tag()
    IL_0046:  switch     ( 
                          IL_005b,
                          IL_005f,
                          IL_005d,
                          IL_0061)
    IL_005b:  br.s       IL_0066

    IL_005d:  br.s       IL_00a0

    IL_005f:  br.s       IL_00d7

    IL_0061:  br         IL_0121

    IL_0066:  ldloc.s    V_7
    IL_0068:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice1Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_006d:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice1Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_0072:  call       instance !1 class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::get_Item2()
    IL_0077:  stloc.s    ty
    IL_0079:  ldloc.s    V_7
    IL_007b:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice1Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_0080:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice1Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_0085:  call       instance !0 class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::get_Item1()
    IL_008a:  stloc.s    nm
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
    IL_008c:  ldstr      "Found prop {1} {0}"
    IL_0091:  ldloc.s    nm
    IL_0093:  ldloc.s    ty
    IL_0095:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_009a:  nop
    IL_009b:  br         IL_013a

//000365:         match p with
    IL_00a0:  ldloc.s    V_7
    IL_00a2:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice3Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_00a7:  call       instance !2 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice3Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_00ac:  call       instance !1 class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::get_Item2()
    IL_00b1:  stloc.s    V_10
    IL_00b3:  ldloc.s    V_7
    IL_00b5:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice3Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_00ba:  call       instance !2 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice3Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_00bf:  call       instance !0 class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>::get_Item1()
    IL_00c4:  stloc.s    V_11
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
    IL_00c6:  ldstr      "Found fld {1} {0}"
    IL_00cb:  ldloc.s    V_11
    IL_00cd:  ldloc.s    V_10
    IL_00cf:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_00d4:  nop
    IL_00d5:  br.s       IL_013a

//000365:         match p with
    IL_00d7:  ldloc.s    V_7
    IL_00d9:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_00de:  call       instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_00e3:  call       instance !1 class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item2()
    IL_00e8:  stloc.s    rt
    IL_00ea:  ldloc.s    V_7
    IL_00ec:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_00f1:  call       instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_00f6:  call       instance !2 class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item3()
    IL_00fb:  stloc.s    parms
    IL_00fd:  ldloc.s    V_7
    IL_00ff:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_0104:  call       instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice2Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_0109:  call       instance !0 class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item1()
    IL_010e:  stloc.s    V_14
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
    IL_0110:  ldstr      "Found mth {1} {0}(...)"
    IL_0115:  ldloc.s    V_14
    IL_0117:  ldloc.s    rt
    IL_0119:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_011e:  nop
    IL_011f:  br.s       IL_013a

//000365:         match p with
    IL_0121:  ldloc.s    V_7
    IL_0123:  castclass  class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice4Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>
    IL_0128:  call       instance !3 class [FSharp.Core]Microsoft.FSharp.Core.FSharpChoice`4/Choice4Of4<class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [FSharp.Core]System.Tuple`3<string,class [mscorlib]System.Type,class [mscorlib]System.Reflection.ParameterInfo[]>,class [FSharp.Core]System.Tuple`2<string,class [mscorlib]System.Type>,class [mscorlib]System.Reflection.ParameterInfo[]>::get_Item()
    IL_012d:  stloc.s    V_15
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
    IL_012f:  ldstr      "Found ctor"
    IL_0134:  call       void [mscorlib]System.Console::WriteLine(string)
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
//000384:     match cmd with
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
//000388:     | _ -> "No idea"
    IL_0139:  nop
    IL_013a:  ldloc.s    V_4
    IL_013c:  ldc.i4.1
    IL_013d:  add
    IL_013e:  stloc.s    V_4
//000364:     for p in pt.GetMembers(AllBindingFlags) do
    IL_0140:  ldloc.s    V_4
    IL_0142:  ldloc.3
    IL_0143:  ldlen
    IL_0144:  conv.i4
    IL_0145:  blt        IL_0027

    IL_014a:  ret
  } // end of method PatternMatching::active_pat_multicase_example

  .method public static string  active_pat_example() cil managed
  {
    // Code size       131 (0x83)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string> '|FileFullName|',
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string> '|FileName|',
             [2] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string> '|FileExt|',
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,class [FSharp.Core]System.Tuple`3<string,string,string>> '|FileTuple|',
             [4] class [mscorlib]System.IO.FileInfo cmd,
             [5] class [mscorlib]System.IO.FileInfo V_5,
             [6] string V_6,
             [7] string V_7,
             [8] string V_8,
             [9] string fn)
//000365:         match p with
//000366:         | Property(nm, ty) -> 
//000367:             System.Console.WriteLine(
//000368:                 "Found prop {1} {0}", nm, ty)
//000369:         | Field(nm, ty) ->
//000370:             System.Console.WriteLine(
//000371:                 "Found fld {1} {0}", nm, ty)
//000372:         | Method(nm, rt, parms) ->
//000373:             System.Console.WriteLine(
//000374:                 "Found mth {1} {0}(...)", nm, rt)
//000375:         | Constructor(parms) ->
//000376:             System.Console.WriteLine("Found ctor")
//000377: 
//000378: let active_pat_example() =
//000379:     let (|FileFullName|) (f:FileInfo) = f.FullName
//000380:     let (|FileName|) (f:FileInfo) = f.Name
//000381:     let (|FileExt|) (f:FileInfo) = f.Extension
//000382:     let (|FileTuple|) (f:FileInfo) = (f.FullName, f.Name, f.Extension)
//000383:     let cmd = new FileInfo(@"C:\Windows\System32\cmd.exe")
    IL_0000:  newobj     instance void PatternMatching/'|FileFullName|@379'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  newobj     instance void PatternMatching/'|FileName|@380'::.ctor()
    IL_000b:  stloc.1
    IL_000c:  newobj     instance void PatternMatching/'|FileExt|@381'::.ctor()
    IL_0011:  stloc.2
    IL_0012:  newobj     instance void PatternMatching/'|FileTuple|@382'::.ctor()
    IL_0017:  stloc.3
    IL_0018:  nop
    IL_0019:  ldstr      "C:\\Windows\\System32\\cmd.exe"
    IL_001e:  newobj     instance void [mscorlib]System.IO.FileInfo::.ctor(string)
    IL_0023:  stloc.s    cmd
//000384:     match cmd with
    IL_0025:  ldloc.s    cmd
    IL_0027:  stloc.s    V_5
    IL_0029:  ldloc.0
    IL_002a:  ldloc.s    V_5
    IL_002c:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::Invoke(!0)
    IL_0031:  stloc.s    V_6
    IL_0033:  ldloc.1
    IL_0034:  ldloc.s    V_5
    IL_0036:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::Invoke(!0)
    IL_003b:  stloc.s    V_7
    IL_003d:  ldloc.s    V_7
    IL_003f:  ldstr      "cmd"
    IL_0044:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0049:  brfalse.s  IL_007d

    IL_004b:  ldloc.2
    IL_004c:  ldloc.s    V_5
    IL_004e:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileInfo,string>::Invoke(!0)
    IL_0053:  stloc.s    V_8
    IL_0055:  ldloc.s    V_8
    IL_0057:  ldstr      ".exe"
    IL_005c:  call       bool [mscorlib]System.String::Equals(string,
                                                              string)
    IL_0061:  brfalse.s  IL_0065

    IL_0063:  br.s       IL_0067

    IL_0065:  br.s       IL_007d

    IL_0067:  ldloc.s    V_6
    IL_0069:  stloc.s    fn
//000385: //    | FileTuple(fn, n, ".exe") -> "Found " + fn.ToString()
//000386:     | FileFullName(fn) & FileName("cmd") & FileExt(".exe") ->
//000387:         "Found " + fn.ToString()
    IL_006b:  ldstr      "Found "
    IL_0070:  ldloc.s    fn
    IL_0072:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_0077:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_007c:  ret

//000388:     | _ -> "No idea"
    IL_007d:  ldstr      "No idea"
    IL_0082:  ret
  } // end of method PatternMatching::active_pat_example

  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       13 (0xd)
    .maxstack  3
    IL_0000:  ldc.i4.0
    IL_0001:  stsfld     int32 '<StartupCode$Basics>'.$PatternMatching::init@
    IL_0006:  ldsfld     int32 '<StartupCode$Basics>'.$PatternMatching::init@
    IL_000b:  pop
    IL_000c:  ret
  } // end of method PatternMatching::.cctor

} // end of class PatternMatching

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$PatternMatching
       extends [mscorlib]System.Object
{
  .field static assembly int32 init@
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       2 (0x2)
    .maxstack  2
    .locals init ([0] string rachel)
//000110: let rachel = "Rachel"
    IL_0000:  nop
    IL_0001:  ret
  } // end of method $PatternMatching::.cctor

} // end of class '<StartupCode$Basics>'.$PatternMatching

.class public abstract auto ansi sealed SimpleCompositeTypes
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested assembly beforefieldinit option_examples_5@51
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method option_examples_5@51::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(string o) cil managed
    {
      // Code size       23 (0x17)
      .maxstack  5
      .locals init ([0] string V_0)
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\CompositeTypes.fs' 
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloca.s   V_0
      IL_0005:  constrained. [mscorlib]System.String
      IL_000b:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0010:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_0015:  ldnull
      IL_0016:  ret
    } // end of method option_examples_5@51::Invoke

  } // end of class option_examples_5@51

  .class auto ansi serializable nested assembly beforefieldinit emptyArray@108
         extends [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::.ctor()
      IL_0006:  ret
    } // end of method emptyArray@108::.ctor

    .method public strict virtual instance object 
            Specialize<a>() cil managed
    {
      // Code size       13 (0xd)
      .maxstack  5
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  newarr     !!a
      IL_0007:  box        !!a[]
      IL_000c:  ret
    } // end of method emptyArray@108::Specialize

  } // end of class emptyArray@108

  .class auto autochar sealed nested assembly beforefieldinit specialname forBuiltArray@121
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 i
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 i,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum',
                                 int32 pc,
                                 int32 current) cil managed
    {
      // Code size       36 (0x24)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::i
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    current
      IL_0018:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::current
      IL_001d:  ldarg.0
      IL_001e:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>::.ctor()
      IL_0023:  ret
    } // end of method forBuiltArray@121::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>& next) cil managed
    {
      // Code size       183 (0xb7)
      .maxstack  8
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_002d

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0024

      IL_001f:  br.s       IL_0027

      IL_0021:  nop
      IL_0022:  br.s       IL_008d

      IL_0024:  nop
      IL_0025:  br.s       IL_0083

      IL_0027:  nop
      IL_0028:  br         IL_00ae

      IL_002d:  nop
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
      IL_002e:  ldarg.0
      IL_002f:  ldc.i4.1
      IL_0030:  ldc.i4.1
      IL_0031:  ldc.i4.s   10
      IL_0033:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                       int32,
                                                                                                                                                                       int32)
      IL_0038:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
      IL_003d:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_0042:  ldarg.0
      IL_0043:  ldc.i4.2
      IL_0044:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_004f:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0054:  brfalse.s  IL_008d

      IL_0056:  ldarg.0
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_005d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
      IL_0062:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::i
      IL_0067:  ldarg.0
      IL_0068:  ldc.i4.3
      IL_0069:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_006e:  ldarg.0
      IL_006f:  ldarg.0
      IL_0070:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::i
      IL_0075:  ldarg.0
      IL_0076:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::i
      IL_007b:  mul
      IL_007c:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::current
      IL_0081:  ldc.i4.1
      IL_0082:  ret

      IL_0083:  ldarg.0
      IL_0084:  ldc.i4.0
      IL_0085:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::i
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_008a:  nop
      IL_008b:  br.s       IL_0049

      IL_008d:  ldarg.0
      IL_008e:  ldc.i4.4
      IL_008f:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
      IL_0094:  ldarg.0
      IL_0095:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_009a:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_009f:  nop
      IL_00a0:  ldarg.0
      IL_00a1:  ldnull
      IL_00a2:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_00a7:  ldarg.0
      IL_00a8:  ldc.i4.4
      IL_00a9:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_00ae:  ldarg.0
      IL_00af:  ldc.i4.0
      IL_00b0:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::current
      IL_00b5:  ldc.i4.0
      IL_00b6:  ret
    } // end of method forBuiltArray@121::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltArray@121::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0051:  ldarg.0
      IL_0052:  ldc.i4.0
      IL_0053:  stfld      int32 SimpleCompositeTypes/forBuiltArray@121::current
      IL_0058:  ret
    } // end of method forBuiltArray@121::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method forBuiltArray@121::get_CheckClose

    .method public strict virtual instance int32 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltArray@121::current
      IL_0007:  ret
    } // end of method forBuiltArray@121::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       11 (0xb)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldnull
      IL_0003:  ldc.i4.0
      IL_0004:  ldc.i4.0
      IL_0005:  newobj     instance void SimpleCompositeTypes/forBuiltArray@121::.ctor(int32,
                                                                                       class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                                       int32,
                                                                                       int32)
      IL_000a:  ret
    } // end of method forBuiltArray@121::GetFreshEnumerator

  } // end of class forBuiltArray@121

  .class auto ansi serializable nested assembly beforefieldinit array_examples_3@150
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method array_examples_3@150::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(string it) cil managed
    {
      // Code size       23 (0x17)
      .maxstack  5
      .locals init ([0] string V_0)
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloca.s   V_0
      IL_0005:  constrained. [mscorlib]System.String
      IL_000b:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0010:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_0015:  ldnull
      IL_0016:  ret
    } // end of method array_examples_3@150::Invoke

  } // end of class array_examples_3@150

  .class auto ansi serializable nested assembly beforefieldinit newardsFound@164
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method newardsFound@164::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       18 (0x12)
      .maxstack  6
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string HelperTypes/Person::get_LastName()
      IL_0007:  ldstr      "Neward"
      IL_000c:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0011:  ret
    } // end of method newardsFound@164::Invoke

  } // end of class newardsFound@164

  .class auto ansi serializable nested assembly beforefieldinit drinkers@167
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method drinkers@167::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       12 (0xc)
      .maxstack  6
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0007:  ldc.i4.s   21
      IL_0009:  cgt
      IL_000b:  ret
    } // end of method drinkers@167::Invoke

  } // end of class drinkers@167

  .class auto ansi serializable nested assembly beforefieldinit array_examples_4@168
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method array_examples_4@168::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
      IL_0000:  nop
      IL_0001:  ldstr      "Have a beer, {0}!"
      IL_0006:  ldarg.1
      IL_0007:  call       instance string HelperTypes/Person::get_FirstName()
      IL_000c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_0011:  ldnull
      IL_0012:  ret
    } // end of method array_examples_4@168::Invoke

  } // end of class array_examples_4@168

  .class auto ansi serializable nested assembly beforefieldinit 'array_examples_4@172-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method 'array_examples_4@172-1'::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       12 (0xc)
      .maxstack  6
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0007:  ldc.i4.s   21
      IL_0009:  cgt
      IL_000b:  ret
    } // end of method 'array_examples_4@172-1'::Invoke

  } // end of class 'array_examples_4@172-1'

  .class auto ansi serializable nested assembly beforefieldinit 'array_examples_4@173-2'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method 'array_examples_4@173-2'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
      IL_0000:  nop
      IL_0001:  ldstr      "Have a beer, {0}!"
      IL_0006:  ldarg.1
      IL_0007:  call       instance string HelperTypes/Person::get_FirstName()
      IL_000c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_0011:  ldnull
      IL_0012:  ret
    } // end of method 'array_examples_4@173-2'::Invoke

  } // end of class 'array_examples_4@173-2'

  .class auto ansi serializable nested assembly beforefieldinit 'isADrinker@176-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method 'isADrinker@176-1'::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       12 (0xc)
      .maxstack  6
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance int32 HelperTypes/Person::get_Age()
      IL_0007:  ldc.i4.s   21
      IL_0009:  cgt
      IL_000b:  ret
    } // end of method 'isADrinker@176-1'::Invoke

  } // end of class 'isADrinker@176-1'

  .class auto ansi serializable nested assembly beforefieldinit isADrinker@176
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class HelperTypes/Person[]>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class HelperTypes/Person[]>::.ctor()
      IL_0006:  ret
    } // end of method isADrinker@176::.ctor

    .method public strict virtual instance class HelperTypes/Person[] 
            Invoke(class HelperTypes/Person[] ar) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  newobj     instance void SimpleCompositeTypes/'isADrinker@176-1'::.ctor()
      IL_0006:  ldarg.1
      IL_0007:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Filter<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                         !!0[])
      IL_000c:  ret
    } // end of method isADrinker@176::Invoke

  } // end of class isADrinker@176

  .class auto ansi serializable nested assembly beforefieldinit 'haveABeer@178-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method 'haveABeer@178-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person p) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
      IL_0000:  nop
      IL_0001:  ldstr      "Have a beer, {0}!"
      IL_0006:  ldarg.1
      IL_0007:  call       instance string HelperTypes/Person::get_FirstName()
      IL_000c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_0011:  ldnull
      IL_0012:  ret
    } // end of method 'haveABeer@178-1'::Invoke

  } // end of class 'haveABeer@178-1'

  .class auto ansi serializable nested assembly beforefieldinit haveABeer@178
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method haveABeer@178::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person[] ar) cil managed
    {
      // Code size       85 (0x55)
      .maxstack  7
      .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_0,
               [1] class HelperTypes/Person[] V_1,
               [2] int32 V_2,
               [3] int32 V_3,
               [4] int32 V_4)
      IL_0000:  nop
      IL_0001:  newobj     instance void SimpleCompositeTypes/'haveABeer@178-1'::.ctor()
      IL_0006:  stloc.0
      IL_0007:  ldarg.1
      IL_0008:  stloc.1
      IL_0009:  ldloc.1
      IL_000a:  box        class HelperTypes/Person[]
      IL_000f:  brfalse.s  IL_0013

      IL_0011:  br.s       IL_0026

//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0013:  ldstr      "array"
      IL_0018:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
      IL_001d:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
      IL_0022:  pop
      IL_0023:  nop
      IL_0024:  br.s       IL_0027

      IL_0026:  nop
      IL_0027:  ldloc.1
      IL_0028:  ldlen
      IL_0029:  conv.i4
      IL_002a:  stloc.2
      IL_002b:  ldc.i4.0
      IL_002c:  stloc.s    V_4
      IL_002e:  ldloc.2
      IL_002f:  ldc.i4.1
      IL_0030:  sub
      IL_0031:  stloc.3
      IL_0032:  ldloc.3
      IL_0033:  ldloc.s    V_4
      IL_0035:  blt.s      IL_0053

//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
      IL_0037:  ldloc.0
      IL_0038:  ldloc.1
      IL_0039:  ldloc.s    V_4
      IL_003b:  ldelem     HelperTypes/Person
      IL_0040:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
      IL_0045:  pop
      IL_0046:  ldloc.s    V_4
      IL_0048:  ldc.i4.1
      IL_0049:  add
      IL_004a:  stloc.s    V_4
      IL_004c:  ldloc.s    V_4
      IL_004e:  ldloc.3
      IL_004f:  ldc.i4.1
      IL_0050:  add
      IL_0051:  bne.un.s   IL_0037

      IL_0053:  ldnull
      IL_0054:  ret
    } // end of method haveABeer@178::Invoke

  } // end of class haveABeer@178

  .class auto ansi serializable nested assembly beforefieldinit emptyList@184
         extends [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc::.ctor()
      IL_0006:  ret
    } // end of method emptyList@184::.ctor

    .method public strict virtual instance object 
            Specialize<a>() cil managed
    {
      // Code size       12 (0xc)
      .maxstack  5
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
      IL_0000:  nop
      IL_0001:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!a>::get_Empty()
      IL_0006:  box        class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!a>
      IL_000b:  ret
    } // end of method emptyList@184::Specialize

  } // end of class emptyList@184

  .class auto autochar sealed nested assembly beforefieldinit specialname forBuiltList@208
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 i
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 i,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum',
                                 int32 pc,
                                 int32 current) cil managed
    {
      // Code size       36 (0x24)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::i
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    current
      IL_0018:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::current
      IL_001d:  ldarg.0
      IL_001e:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>::.ctor()
      IL_0023:  ret
    } // end of method forBuiltList@208::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>& next) cil managed
    {
      // Code size       183 (0xb7)
      .maxstack  8
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_002d

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0024

      IL_001f:  br.s       IL_0027

      IL_0021:  nop
      IL_0022:  br.s       IL_008d

      IL_0024:  nop
      IL_0025:  br.s       IL_0083

      IL_0027:  nop
      IL_0028:  br         IL_00ae

      IL_002d:  nop
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
      IL_002e:  ldarg.0
      IL_002f:  ldc.i4.1
      IL_0030:  ldc.i4.1
      IL_0031:  ldc.i4.s   10
      IL_0033:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                       int32,
                                                                                                                                                                       int32)
      IL_0038:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
      IL_003d:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_0042:  ldarg.0
      IL_0043:  ldc.i4.2
      IL_0044:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_004f:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0054:  brfalse.s  IL_008d

      IL_0056:  ldarg.0
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_005d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
      IL_0062:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::i
      IL_0067:  ldarg.0
      IL_0068:  ldc.i4.3
      IL_0069:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_006e:  ldarg.0
      IL_006f:  ldarg.0
      IL_0070:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::i
      IL_0075:  ldarg.0
      IL_0076:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::i
      IL_007b:  mul
      IL_007c:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::current
      IL_0081:  ldc.i4.1
      IL_0082:  ret

      IL_0083:  ldarg.0
      IL_0084:  ldc.i4.0
      IL_0085:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::i
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_008a:  nop
      IL_008b:  br.s       IL_0049

      IL_008d:  ldarg.0
      IL_008e:  ldc.i4.4
      IL_008f:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
      IL_0094:  ldarg.0
      IL_0095:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_009a:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_009f:  nop
      IL_00a0:  ldarg.0
      IL_00a1:  ldnull
      IL_00a2:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_00a7:  ldarg.0
      IL_00a8:  ldc.i4.4
      IL_00a9:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_00ae:  ldarg.0
      IL_00af:  ldc.i4.0
      IL_00b0:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::current
      IL_00b5:  ldc.i4.0
      IL_00b6:  ret
    } // end of method forBuiltList@208::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/forBuiltList@208::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0051:  ldarg.0
      IL_0052:  ldc.i4.0
      IL_0053:  stfld      int32 SimpleCompositeTypes/forBuiltList@208::current
      IL_0058:  ret
    } // end of method forBuiltList@208::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method forBuiltList@208::get_CheckClose

    .method public strict virtual instance int32 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/forBuiltList@208::current
      IL_0007:  ret
    } // end of method forBuiltList@208::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       11 (0xb)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldnull
      IL_0003:  ldc.i4.0
      IL_0004:  ldc.i4.0
      IL_0005:  newobj     instance void SimpleCompositeTypes/forBuiltList@208::.ctor(int32,
                                                                                      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                                      int32,
                                                                                      int32)
      IL_000a:  ret
    } // end of method forBuiltList@208::GetFreshEnumerator

  } // end of class forBuiltList@208

  .class auto ansi serializable nested assembly beforefieldinit newards@255
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,bool>::.ctor()
      IL_0006:  ret
    } // end of method newards@255::.ctor

    .method public strict virtual instance bool 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       18 (0x12)
      .maxstack  6
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  call       instance string HelperTypes/Person::get_LastName()
      IL_0007:  ldstr      "Neward"
      IL_000c:  call       bool [mscorlib]System.String::Equals(string,
                                                                string)
      IL_0011:  ret
    } // end of method newards@255::Invoke

  } // end of class newards@255

  .class auto ansi serializable nested assembly beforefieldinit seq_examples_1@256
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method seq_examples_1@256::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class HelperTypes/Person it) cil managed
    {
      // Code size       24 (0x18)
      .maxstack  6
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
      IL_0000:  nop
      IL_0001:  ldstr      "Found "
      IL_0006:  ldarg.1
      IL_0007:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_000c:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_0011:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_0016:  ldnull
      IL_0017:  ret
    } // end of method seq_examples_1@256::Invoke

  } // end of class seq_examples_1@256

  .class auto autochar sealed nested assembly beforefieldinit specialname x@257
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 i
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 i,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum',
                                 int32 pc,
                                 int32 current) cil managed
    {
      // Code size       36 (0x24)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/x@257::i
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    current
      IL_0018:  stfld      int32 SimpleCompositeTypes/x@257::current
      IL_001d:  ldarg.0
      IL_001e:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>::.ctor()
      IL_0023:  ret
    } // end of method x@257::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>& next) cil managed
    {
      // Code size       176 (0xb0)
      .maxstack  8
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_002d

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0024

      IL_001f:  br.s       IL_0027

      IL_0021:  nop
      IL_0022:  br.s       IL_0086

      IL_0024:  nop
      IL_0025:  br.s       IL_007c

      IL_0027:  nop
      IL_0028:  br         IL_00a7

      IL_002d:  nop
//000257:     let x = seq { for i = 1 to 10 do yield i }
      IL_002e:  ldarg.0
      IL_002f:  ldc.i4.1
      IL_0030:  ldc.i4.1
      IL_0031:  ldc.i4.s   10
      IL_0033:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                       int32,
                                                                                                                                                                       int32)
      IL_0038:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
      IL_003d:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_0042:  ldarg.0
      IL_0043:  ldc.i4.2
      IL_0044:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_004f:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0054:  brfalse.s  IL_0086

      IL_0056:  ldarg.0
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_005d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
      IL_0062:  stfld      int32 SimpleCompositeTypes/x@257::i
      IL_0067:  ldarg.0
      IL_0068:  ldc.i4.3
      IL_0069:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_006e:  ldarg.0
      IL_006f:  ldarg.0
      IL_0070:  ldfld      int32 SimpleCompositeTypes/x@257::i
      IL_0075:  stfld      int32 SimpleCompositeTypes/x@257::current
      IL_007a:  ldc.i4.1
      IL_007b:  ret

      IL_007c:  ldarg.0
      IL_007d:  ldc.i4.0
      IL_007e:  stfld      int32 SimpleCompositeTypes/x@257::i
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0083:  nop
      IL_0084:  br.s       IL_0049

      IL_0086:  ldarg.0
      IL_0087:  ldc.i4.4
      IL_0088:  stfld      int32 SimpleCompositeTypes/x@257::pc
//000257:     let x = seq { for i = 1 to 10 do yield i }
      IL_008d:  ldarg.0
      IL_008e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_0093:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0098:  nop
      IL_0099:  ldarg.0
      IL_009a:  ldnull
      IL_009b:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_00a0:  ldarg.0
      IL_00a1:  ldc.i4.4
      IL_00a2:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_00a7:  ldarg.0
      IL_00a8:  ldc.i4.0
      IL_00a9:  stfld      int32 SimpleCompositeTypes/x@257::current
      IL_00ae:  ldc.i4.0
      IL_00af:  ret
    } // end of method x@257::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/x@257::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0051:  ldarg.0
      IL_0052:  ldc.i4.0
      IL_0053:  stfld      int32 SimpleCompositeTypes/x@257::current
      IL_0058:  ret
    } // end of method x@257::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/x@257::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method x@257::get_CheckClose

    .method public strict virtual instance int32 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/x@257::current
      IL_0007:  ret
    } // end of method x@257::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       11 (0xb)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldnull
      IL_0003:  ldc.i4.0
      IL_0004:  ldc.i4.0
      IL_0005:  newobj     instance void SimpleCompositeTypes/x@257::.ctor(int32,
                                                                           class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                           int32,
                                                                           int32)
      IL_000a:  ret
    } // end of method x@257::GetFreshEnumerator

  } // end of class x@257

  .class auto autochar sealed nested assembly beforefieldinit specialname y@259
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 i
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 i,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum',
                                 int32 pc,
                                 int32 current) cil managed
    {
      // Code size       36 (0x24)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/y@259::i
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32 SimpleCompositeTypes/y@259::pc
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    current
      IL_0018:  stfld      int32 SimpleCompositeTypes/y@259::current
      IL_001d:  ldarg.0
      IL_001e:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>::.ctor()
      IL_0023:  ret
    } // end of method y@259::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>& next) cil managed
    {
      // Code size       200 (0xc8)
      .maxstack  8
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/y@259::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_0030

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0027

      IL_001f:  br.s       IL_002a

      IL_0021:  nop
      IL_0022:  br         IL_009e

      IL_0027:  nop
      IL_0028:  br.s       IL_0094

      IL_002a:  nop
      IL_002b:  br         IL_00bf

      IL_0030:  nop
//000259:     let y = seq { for i = 1 to 10 do
      IL_0031:  ldarg.0
      IL_0032:  ldc.i4.1
      IL_0033:  ldc.i4.1
      IL_0034:  ldc.i4.s   10
      IL_0036:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                       int32,
                                                                                                                                                                       int32)
      IL_003b:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
      IL_0040:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_0045:  ldarg.0
      IL_0046:  ldc.i4.2
      IL_0047:  stfld      int32 SimpleCompositeTypes/y@259::pc
      IL_004c:  ldarg.0
      IL_004d:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_0052:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0057:  brfalse.s  IL_009e

      IL_0059:  ldarg.0
      IL_005a:  ldarg.0
      IL_005b:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_0060:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
      IL_0065:  stfld      int32 SimpleCompositeTypes/y@259::i
//000260:                     System.Console.WriteLine("Generating {0}", i)
      IL_006a:  ldstr      "Generating {0}"
      IL_006f:  ldarg.0
      IL_0070:  ldfld      int32 SimpleCompositeTypes/y@259::i
      IL_0075:  box        [mscorlib]System.Int32
      IL_007a:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_007f:  ldarg.0
      IL_0080:  ldc.i4.3
      IL_0081:  stfld      int32 SimpleCompositeTypes/y@259::pc
//000261:                     yield i }
      IL_0086:  ldarg.0
      IL_0087:  ldarg.0
      IL_0088:  ldfld      int32 SimpleCompositeTypes/y@259::i
      IL_008d:  stfld      int32 SimpleCompositeTypes/y@259::current
      IL_0092:  ldc.i4.1
      IL_0093:  ret

//000259:     let y = seq { for i = 1 to 10 do
      IL_0094:  ldarg.0
      IL_0095:  ldc.i4.0
      IL_0096:  stfld      int32 SimpleCompositeTypes/y@259::i
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_009b:  nop
      IL_009c:  br.s       IL_004c

      IL_009e:  ldarg.0
      IL_009f:  ldc.i4.4
      IL_00a0:  stfld      int32 SimpleCompositeTypes/y@259::pc
//000259:     let y = seq { for i = 1 to 10 do
      IL_00a5:  ldarg.0
      IL_00a6:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_00ab:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_00b0:  nop
      IL_00b1:  ldarg.0
      IL_00b2:  ldnull
      IL_00b3:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_00b8:  ldarg.0
      IL_00b9:  ldc.i4.4
      IL_00ba:  stfld      int32 SimpleCompositeTypes/y@259::pc
      IL_00bf:  ldarg.0
      IL_00c0:  ldc.i4.0
      IL_00c1:  stfld      int32 SimpleCompositeTypes/y@259::current
      IL_00c6:  ldc.i4.0
      IL_00c7:  ret
    } // end of method y@259::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/y@259::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/y@259::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/y@259::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/y@259::pc
      IL_0051:  ldarg.0
      IL_0052:  ldc.i4.0
      IL_0053:  stfld      int32 SimpleCompositeTypes/y@259::current
      IL_0058:  ret
    } // end of method y@259::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/y@259::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method y@259::get_CheckClose

    .method public strict virtual instance int32 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/y@259::current
      IL_0007:  ret
    } // end of method y@259::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       11 (0xb)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldnull
      IL_0003:  ldc.i4.0
      IL_0004:  ldc.i4.0
      IL_0005:  newobj     instance void SimpleCompositeTypes/y@259::.ctor(int32,
                                                                           class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                           int32,
                                                                           int32)
      IL_000a:  ret
    } // end of method y@259::GetFreshEnumerator

  } // end of class y@259

  .class auto autochar serializable sealed nested assembly beforefieldinit specialname 'randomNumberGenerator@267-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 minVal
    .field public int32 maxVal
    .field public class [mscorlib]System.Random randomer
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 minVal,
                                 int32 maxVal,
                                 class [mscorlib]System.Random randomer,
                                 int32 pc,
                                 int32 current) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::minVal
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::maxVal
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      class [mscorlib]System.Random SimpleCompositeTypes/'randomNumberGenerator@267-1'::randomer
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    pc
      IL_0018:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_001d:  ldarg.0
      IL_001e:  ldarg.s    current
      IL_0020:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::current
      IL_0025:  ldarg.0
      IL_0026:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<int32>::.ctor()
      IL_002b:  ret
    } // end of method 'randomNumberGenerator@267-1'::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>& next) cil managed
    {
      // Code size       102 (0x66)
      .maxstack  8
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_0017,
                            IL_0019)
      IL_0015:  br.s       IL_0021

      IL_0017:  br.s       IL_001b

      IL_0019:  br.s       IL_001e

      IL_001b:  nop
      IL_001c:  br.s       IL_0053

      IL_001e:  nop
      IL_001f:  br.s       IL_005d

      IL_0021:  nop
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
      IL_0022:  ldc.i4.1
      IL_0023:  brfalse.s  IL_0056

      IL_0025:  ldarg.0
      IL_0026:  ldc.i4.2
      IL_0027:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_002c:  ldarg.0
      IL_002d:  ldarg.0
      IL_002e:  ldfld      class [mscorlib]System.Random SimpleCompositeTypes/'randomNumberGenerator@267-1'::randomer
      IL_0033:  ldarg.0
      IL_0034:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::maxVal
      IL_0039:  ldarg.0
      IL_003a:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::minVal
      IL_003f:  sub
      IL_0040:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0045:  ldarg.0
      IL_0046:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::minVal
      IL_004b:  add
      IL_004c:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::current
      IL_0051:  ldc.i4.1
      IL_0052:  ret

//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0053:  nop
      IL_0054:  br.s       IL_0022

      IL_0056:  ldarg.0
      IL_0057:  ldc.i4.3
      IL_0058:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_005d:  ldarg.0
      IL_005e:  ldc.i4.0
      IL_005f:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::current
      IL_0064:  ldc.i4.0
      IL_0065:  ret
    } // end of method 'randomNumberGenerator@267-1'::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       60 (0x3c)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_001c,
                            IL_001e,
                            IL_0020)
      IL_001a:  br.s       IL_002b

      IL_001c:  br.s       IL_0022

      IL_001e:  br.s       IL_0025

      IL_0020:  br.s       IL_0028

      IL_0022:  nop
      IL_0023:  br.s       IL_002d

      IL_0025:  nop
      IL_0026:  br.s       IL_002c

      IL_0028:  nop
      IL_0029:  br.s       IL_002d

      IL_002b:  nop
      IL_002c:  nop
      IL_002d:  ldarg.0
      IL_002e:  ldc.i4.3
      IL_002f:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_0034:  ldarg.0
      IL_0035:  ldc.i4.0
      IL_0036:  stfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::current
      IL_003b:  ret
    } // end of method 'randomNumberGenerator@267-1'::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       48 (0x30)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_001c,
                            IL_001e,
                            IL_0020)
      IL_001a:  br.s       IL_002b

      IL_001c:  br.s       IL_0022

      IL_001e:  br.s       IL_0025

      IL_0020:  br.s       IL_0028

      IL_0022:  nop
      IL_0023:  br.s       IL_002e

      IL_0025:  nop
      IL_0026:  br.s       IL_002c

      IL_0028:  nop
      IL_0029:  br.s       IL_002e

      IL_002b:  nop
      IL_002c:  ldc.i4.0
      IL_002d:  ret

      IL_002e:  ldc.i4.0
      IL_002f:  ret
    } // end of method 'randomNumberGenerator@267-1'::get_CheckClose

    .method public strict virtual instance int32 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::current
      IL_0007:  ret
    } // end of method 'randomNumberGenerator@267-1'::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       27 (0x1b)
      .maxstack  9
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::minVal
      IL_0007:  ldarg.0
      IL_0008:  ldfld      int32 SimpleCompositeTypes/'randomNumberGenerator@267-1'::maxVal
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class [mscorlib]System.Random SimpleCompositeTypes/'randomNumberGenerator@267-1'::randomer
      IL_0013:  ldc.i4.0
      IL_0014:  ldc.i4.0
      IL_0015:  newobj     instance void SimpleCompositeTypes/'randomNumberGenerator@267-1'::.ctor(int32,
                                                                                                   int32,
                                                                                                   class [mscorlib]System.Random,
                                                                                                   int32,
                                                                                                   int32)
      IL_001a:  ret
    } // end of method 'randomNumberGenerator@267-1'::GetFreshEnumerator

  } // end of class 'randomNumberGenerator@267-1'

  .class auto ansi serializable nested assembly beforefieldinit randomNumberGenerator@266
         extends class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<int32,int32,class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.OptimizedClosures/FSharpFunc`3<int32,int32,class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>>::.ctor()
      IL_0006:  ret
    } // end of method randomNumberGenerator@266::.ctor

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> 
            Invoke(int32 minVal,
                   int32 maxVal) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  9
      .locals init ([0] class [mscorlib]System.Random randomer,
               [1] valuetype [mscorlib]System.DateTime V_1)
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
      IL_0000:  nop
      IL_0001:  call       valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::get_Now()
      IL_0006:  stloc.1
      IL_0007:  ldloca.s   V_1
      IL_0009:  call       instance int32 [mscorlib]System.DateTime::get_Millisecond()
      IL_000e:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
      IL_0013:  stloc.0
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
      IL_0014:  ldarg.1
      IL_0015:  ldarg.2
      IL_0016:  ldloc.0
      IL_0017:  ldc.i4.0
      IL_0018:  ldc.i4.0
      IL_0019:  newobj     instance void SimpleCompositeTypes/'randomNumberGenerator@267-1'::.ctor(int32,
                                                                                                   int32,
                                                                                                   class [mscorlib]System.Random,
                                                                                                   int32,
                                                                                                   int32)
      IL_001e:  ret
    } // end of method randomNumberGenerator@266::Invoke

  } // end of class randomNumberGenerator@266

  .class auto ansi serializable nested assembly beforefieldinit 'seq_examples_1@269-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method 'seq_examples_1@269-1'::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(int32 roll) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  6
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
      IL_0000:  nop
      IL_0001:  ldstr      "You rolled a "
      IL_0006:  ldarga.s   roll
      IL_0008:  constrained. [mscorlib]System.Int32
      IL_000e:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0013:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_0018:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_001d:  ldnull
      IL_001e:  ret
    } // end of method 'seq_examples_1@269-1'::Invoke

  } // end of class 'seq_examples_1@269-1'

  .class auto autochar sealed nested assembly beforefieldinit specialname squares@271
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<class [FSharp.Core]System.Tuple`2<int32,int32>>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public int32 i
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [FSharp.Core]System.Tuple`2<int32,int32> current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(int32 i,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> 'enum',
                                 int32 pc,
                                 class [FSharp.Core]System.Tuple`2<int32,int32> current) cil managed
    {
      // Code size       36 (0x24)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      int32 SimpleCompositeTypes/squares@271::i
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    current
      IL_0018:  stfld      class [FSharp.Core]System.Tuple`2<int32,int32> SimpleCompositeTypes/squares@271::current
      IL_001d:  ldarg.0
      IL_001e:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<class [FSharp.Core]System.Tuple`2<int32,int32>>::.ctor()
      IL_0023:  ret
    } // end of method squares@271::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<int32,int32>>& next) cil managed
    {
      // Code size       194 (0xc2)
      .maxstack  8
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_002d

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0024

      IL_001f:  br.s       IL_0027

      IL_0021:  nop
      IL_0022:  br.s       IL_0098

      IL_0024:  nop
      IL_0025:  br.s       IL_008e

      IL_0027:  nop
      IL_0028:  br         IL_00b9

      IL_002d:  nop
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
      IL_002e:  ldarg.0
      IL_002f:  ldc.i4.0
      IL_0030:  ldc.i4.1
      IL_0031:  ldc.i4.s   10
      IL_0033:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                       int32,
                                                                                                                                                                       int32)
      IL_0038:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
      IL_003d:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_0042:  ldarg.0
      IL_0043:  ldc.i4.2
      IL_0044:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0049:  ldarg.0
      IL_004a:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_004f:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0054:  brfalse.s  IL_0098

      IL_0056:  ldarg.0
      IL_0057:  ldarg.0
      IL_0058:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_005d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
      IL_0062:  stfld      int32 SimpleCompositeTypes/squares@271::i
      IL_0067:  ldarg.0
      IL_0068:  ldc.i4.3
      IL_0069:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_006e:  ldarg.0
      IL_006f:  ldarg.0
      IL_0070:  ldfld      int32 SimpleCompositeTypes/squares@271::i
      IL_0075:  ldarg.0
      IL_0076:  ldfld      int32 SimpleCompositeTypes/squares@271::i
      IL_007b:  ldarg.0
      IL_007c:  ldfld      int32 SimpleCompositeTypes/squares@271::i
      IL_0081:  mul
      IL_0082:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,int32>::.ctor(!0,
                                                                                               !1)
      IL_0087:  stfld      class [FSharp.Core]System.Tuple`2<int32,int32> SimpleCompositeTypes/squares@271::current
      IL_008c:  ldc.i4.1
      IL_008d:  ret

      IL_008e:  ldarg.0
      IL_008f:  ldc.i4.0
      IL_0090:  stfld      int32 SimpleCompositeTypes/squares@271::i
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0095:  nop
      IL_0096:  br.s       IL_0049

      IL_0098:  ldarg.0
      IL_0099:  ldc.i4.4
      IL_009a:  stfld      int32 SimpleCompositeTypes/squares@271::pc
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
      IL_009f:  ldarg.0
      IL_00a0:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_00a5:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_00aa:  nop
      IL_00ab:  ldarg.0
      IL_00ac:  ldnull
      IL_00ad:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_00b2:  ldarg.0
      IL_00b3:  ldc.i4.4
      IL_00b4:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_00b9:  ldarg.0
      IL_00ba:  ldnull
      IL_00bb:  stfld      class [FSharp.Core]System.Tuple`2<int32,int32> SimpleCompositeTypes/squares@271::current
      IL_00c0:  ldc.i4.0
      IL_00c1:  ret
    } // end of method squares@271::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> SimpleCompositeTypes/squares@271::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0051:  ldarg.0
      IL_0052:  ldnull
      IL_0053:  stfld      class [FSharp.Core]System.Tuple`2<int32,int32> SimpleCompositeTypes/squares@271::current
      IL_0058:  ret
    } // end of method squares@271::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/squares@271::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method squares@271::get_CheckClose

    .method public strict virtual instance class [FSharp.Core]System.Tuple`2<int32,int32> 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [FSharp.Core]System.Tuple`2<int32,int32> SimpleCompositeTypes/squares@271::current
      IL_0007:  ret
    } // end of method squares@271::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class [FSharp.Core]System.Tuple`2<int32,int32>> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       11 (0xb)
      .maxstack  8
      IL_0000:  nop
      IL_0001:  ldc.i4.0
      IL_0002:  ldnull
      IL_0003:  ldc.i4.0
      IL_0004:  ldnull
      IL_0005:  newobj     instance void SimpleCompositeTypes/squares@271::.ctor(int32,
                                                                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                                 int32,
                                                                                 class [FSharp.Core]System.Tuple`2<int32,int32>)
      IL_000a:  ret
    } // end of method squares@271::GetFreshEnumerator

  } // end of class squares@271

  .class auto autochar sealed nested assembly beforefieldinit specialname 'dir@278-1'
         extends class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<class [mscorlib]System.IO.FileSystemInfo>
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 06 00 00 00 00 00 ) 
    .field public class [mscorlib]System.IO.DirectoryInfo di
    .field public class [mscorlib]System.IO.FileSystemInfo fi
    .field public class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> 'enum'
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 pc
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [mscorlib]System.IO.FileSystemInfo current
    .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor(class [mscorlib]System.IO.DirectoryInfo di,
                                 class [mscorlib]System.IO.FileSystemInfo fi,
                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> 'enum',
                                 int32 pc,
                                 class [mscorlib]System.IO.FileSystemInfo current) cil managed
    {
      // Code size       44 (0x2c)
      .maxstack  6
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  stfld      class [mscorlib]System.IO.DirectoryInfo SimpleCompositeTypes/'dir@278-1'::di
      IL_0007:  ldarg.0
      IL_0008:  ldarg.2
      IL_0009:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::fi
      IL_000e:  ldarg.0
      IL_000f:  ldarg.3
      IL_0010:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_0015:  ldarg.0
      IL_0016:  ldarg.s    pc
      IL_0018:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_001d:  ldarg.0
      IL_001e:  ldarg.s    current
      IL_0020:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::current
      IL_0025:  ldarg.0
      IL_0026:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1<class [mscorlib]System.IO.FileSystemInfo>::.ctor()
      IL_002b:  ret
    } // end of method 'dir@278-1'::.ctor

    .method public strict virtual instance int32 
            GenerateNext(class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>& next) cil managed
    {
      // Code size       183 (0xb7)
      .maxstack  6
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0000:  ldarg.0
      IL_0001:  ldfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0006:  ldc.i4.2
      IL_0007:  sub
      IL_0008:  switch     ( 
                            IL_001b,
                            IL_001d,
                            IL_001f)
      IL_0019:  br.s       IL_002d

      IL_001b:  br.s       IL_0021

      IL_001d:  br.s       IL_0024

      IL_001f:  br.s       IL_0027

      IL_0021:  nop
      IL_0022:  br.s       IL_008d

      IL_0024:  nop
      IL_0025:  br.s       IL_0083

      IL_0027:  nop
      IL_0028:  br         IL_00ae

      IL_002d:  nop
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
      IL_002e:  ldarg.0
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class [mscorlib]System.IO.DirectoryInfo SimpleCompositeTypes/'dir@278-1'::di
      IL_0035:  call       instance class [mscorlib]System.IO.FileSystemInfo[] [mscorlib]System.IO.DirectoryInfo::GetFileSystemInfos()
      IL_003a:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>
      IL_003f:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>::GetEnumerator()
      IL_0044:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_0049:  ldarg.0
      IL_004a:  ldc.i4.2
      IL_004b:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0050:  ldarg.0
      IL_0051:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_0056:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_005b:  brfalse.s  IL_008d

      IL_005d:  ldarg.0
      IL_005e:  ldarg.0
      IL_005f:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_0064:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>::get_Current()
      IL_0069:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::fi
      IL_006e:  ldarg.0
      IL_006f:  ldc.i4.3
      IL_0070:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0075:  ldarg.0
      IL_0076:  ldarg.0
      IL_0077:  ldfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::fi
      IL_007c:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::current
      IL_0081:  ldc.i4.1
      IL_0082:  ret

      IL_0083:  ldarg.0
      IL_0084:  ldnull
      IL_0085:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::fi
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_008a:  nop
      IL_008b:  br.s       IL_0050

      IL_008d:  ldarg.0
      IL_008e:  ldc.i4.4
      IL_008f:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
      IL_0094:  ldarg.0
      IL_0095:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_009a:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>>(!!0)
      IL_009f:  nop
      IL_00a0:  ldarg.0
      IL_00a1:  ldnull
      IL_00a2:  stfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_00a7:  ldarg.0
      IL_00a8:  ldc.i4.4
      IL_00a9:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_00ae:  ldarg.0
      IL_00af:  ldnull
      IL_00b0:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::current
      IL_00b5:  ldc.i4.0
      IL_00b6:  ret
    } // end of method 'dir@278-1'::GenerateNext

    .method public strict virtual instance void 
            Close() cil managed
    {
      // Code size       89 (0x59)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_004a

      IL_002b:  nop
      IL_002c:  br.s       IL_0036

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_004a

      IL_0034:  nop
      IL_0035:  nop
      IL_0036:  ldarg.0
      IL_0037:  ldc.i4.4
      IL_0038:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_003d:  ldarg.0
      IL_003e:  ldfld      class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> SimpleCompositeTypes/'dir@278-1'::'enum'
      IL_0043:  call       void [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::Dispose<class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>>(!!0)
      IL_0048:  nop
      IL_0049:  nop
      IL_004a:  ldarg.0
      IL_004b:  ldc.i4.4
      IL_004c:  stfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0051:  ldarg.0
      IL_0052:  ldnull
      IL_0053:  stfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::current
      IL_0058:  ret
    } // end of method 'dir@278-1'::Close

    .method public strict virtual instance bool 
            get_CheckClose() cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  6
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 SimpleCompositeTypes/'dir@278-1'::pc
      IL_0007:  ldc.i4.1
      IL_0008:  sub
      IL_0009:  switch     ( 
                            IL_0020,
                            IL_0022,
                            IL_0024,
                            IL_0026)
      IL_001e:  br.s       IL_0034

      IL_0020:  br.s       IL_0028

      IL_0022:  br.s       IL_002b

      IL_0024:  br.s       IL_002e

      IL_0026:  br.s       IL_0031

      IL_0028:  nop
      IL_0029:  br.s       IL_0039

      IL_002b:  nop
      IL_002c:  br.s       IL_0037

      IL_002e:  nop
      IL_002f:  br.s       IL_0035

      IL_0031:  nop
      IL_0032:  br.s       IL_0039

      IL_0034:  nop
      IL_0035:  ldc.i4.1
      IL_0036:  ret

      IL_0037:  ldc.i4.1
      IL_0038:  ret

      IL_0039:  ldc.i4.0
      IL_003a:  ret
    } // end of method 'dir@278-1'::get_CheckClose

    .method public strict virtual instance class [mscorlib]System.IO.FileSystemInfo 
            get_LastGenerated() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       8 (0x8)
      .maxstack  5
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [mscorlib]System.IO.FileSystemInfo SimpleCompositeTypes/'dir@278-1'::current
      IL_0007:  ret
    } // end of method 'dir@278-1'::get_LastGenerated

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> 
            GetFreshEnumerator() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       17 (0x11)
      .maxstack  9
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class [mscorlib]System.IO.DirectoryInfo SimpleCompositeTypes/'dir@278-1'::di
      IL_0007:  ldnull
      IL_0008:  ldnull
      IL_0009:  ldc.i4.0
      IL_000a:  ldnull
      IL_000b:  newobj     instance void SimpleCompositeTypes/'dir@278-1'::.ctor(class [mscorlib]System.IO.DirectoryInfo,
                                                                                 class [mscorlib]System.IO.FileSystemInfo,
                                                                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>,
                                                                                 int32,
                                                                                 class [mscorlib]System.IO.FileSystemInfo)
      IL_0010:  ret
    } // end of method 'dir@278-1'::GetFreshEnumerator

  } // end of class 'dir@278-1'

  .class auto ansi serializable nested assembly beforefieldinit dir@277
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>>::.ctor()
      IL_0006:  ret
    } // end of method dir@277::.ctor

    .method public strict virtual instance class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo> 
            Invoke(string d) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  9
      .locals init ([0] class [mscorlib]System.IO.DirectoryInfo di)
//000277:         let di = new System.IO.DirectoryInfo(d)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  newobj     instance void [mscorlib]System.IO.DirectoryInfo::.ctor(string)
      IL_0007:  stloc.0
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
      IL_0008:  ldloc.0
      IL_0009:  ldnull
      IL_000a:  ldnull
      IL_000b:  ldc.i4.0
      IL_000c:  ldnull
      IL_000d:  newobj     instance void SimpleCompositeTypes/'dir@278-1'::.ctor(class [mscorlib]System.IO.DirectoryInfo,
                                                                                 class [mscorlib]System.IO.FileSystemInfo,
                                                                                 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>,
                                                                                 int32,
                                                                                 class [mscorlib]System.IO.FileSystemInfo)
      IL_0012:  ret
    } // end of method dir@277::Invoke

  } // end of class dir@277

  .class auto ansi serializable nested assembly beforefieldinit printFileInfo@280
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileSystemInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileSystemInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::.ctor()
      IL_0006:  ret
    } // end of method printFileInfo@280::.ctor

    .method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Core.Unit 
            Invoke(class [mscorlib]System.IO.FileSystemInfo fi) cil managed
    {
      // Code size       19 (0x13)
      .maxstack  6
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
      IL_0000:  nop
      IL_0001:  ldstr      "{0}"
      IL_0006:  ldarg.1
      IL_0007:  callvirt   instance string [mscorlib]System.IO.FileSystemInfo::get_FullName()
      IL_000c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                    object)
      IL_0011:  ldnull
      IL_0012:  ret
    } // end of method printFileInfo@280::Invoke

  } // end of class printFileInfo@280

  .method public static void  option_examples_1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 09 4F 70 74 69 6F 6E 73 20 31 00 00 )       // ...Options 1..
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> nothing,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> something)
//000011:     let nothing : string option = None
    IL_0000:  nop
    IL_0001:  ldnull
    IL_0002:  stloc.0
//000012:     let something : string option = Some("Ted Neward")
    IL_0003:  ldstr      "Ted Neward"
    IL_0008:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::Some(!0)
    IL_000d:  stloc.1
//000013:     System.Console.WriteLine("nothing = {0}", nothing)
    IL_000e:  ldstr      "nothing = {0}"
    IL_0013:  ldloc.0
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000014:     System.Console.WriteLine("something = {0}", something.Value)
    IL_0019:  ldstr      "something = {0}"
    IL_001e:  ldloc.1
    IL_001f:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::get_Value()
    IL_0024:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0029:  ret
  } // end of method SimpleCompositeTypes::option_examples_1

  .method public static void  option_examples_2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 09 4F 70 74 69 6F 6E 73 20 32 00 00 )       // ...Options 2..
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> nothing,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> something)
//000015:     
//000016: [<Example("Options 2")>]
//000017: let option_examples_2() =
//000018:     let nothing : Option<string> = None
    IL_0000:  nop
    IL_0001:  ldnull
    IL_0002:  stloc.0
//000019:     let something : Option<string> = Some("Ted Neward")
    IL_0003:  ldstr      "Ted Neward"
    IL_0008:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::Some(!0)
    IL_000d:  stloc.1
//000020:     System.Console.WriteLine("nothing = {0}", nothing)
    IL_000e:  ldstr      "nothing = {0}"
    IL_0013:  ldloc.0
    IL_0014:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000021:     System.Console.WriteLine("something = {0}", something.Value)
    IL_0019:  ldstr      "something = {0}"
    IL_001e:  ldloc.1
    IL_001f:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::get_Value()
    IL_0024:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0029:  ret
  } // end of method SimpleCompositeTypes::option_examples_2

  .method public static void  option_examples_3() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 09 4F 70 74 69 6F 6E 73 20 33 00 00 )       // ...Options 3..
    // Code size       74 (0x4a)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> possibleValue,
             [1] valuetype [mscorlib]System.DateTime V_1)
//000022: 
//000023: [<Example("Options 3")>]
//000024: let option_examples_3() =
//000025:     let possibleValue =
    IL_0000:  nop
    IL_0001:  nop
//000026:         if (System.DateTime.Now.Millisecond % 2) = 0 then
    IL_0002:  call       valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::get_Now()
    IL_0007:  stloc.1
    IL_0008:  ldloca.s   V_1
    IL_000a:  call       instance int32 [mscorlib]System.DateTime::get_Millisecond()
    IL_000f:  ldc.i4.2
    IL_0010:  rem
    IL_0011:  brtrue.s   IL_0015

    IL_0013:  br.s       IL_0017

    IL_0015:  br.s       IL_001b

//000027:             None
    IL_0017:  ldnull
//000028:         else
//000029:             Some("Have a happy day!")
//000030:     if possibleValue.IsSome then
//000031:         System.Console.WriteLine("Ah, we got a good value. Good!")
//000032:         System.Console.WriteLine(possibleValue.Value)
//000033: 
//000034: [<Example("Options 4")>]
//000035: let option_examples_4() =
//000036:     // This will deliberately throw an exception
//000037:     //
//000038:     let nothing : string option = None
//000039:     if nothing.Equals(None) then
//000040:         System.Console.WriteLine("None.Equals(None)")
//000041:     System.Console.WriteLine(nothing.GetHashCode())
//000042:     System.Console.WriteLine(nothing.ToString())
//000043: 
//000044: [<Example("Options 5")>]
//000045: let option_examples_5() =
//000046:     let possibleValue =
//000047:         if (System.DateTime.Now.Millisecond % 2) = 0 then
//000048:             None
//000049:         else
//000050:             Some("Have a happy day!")
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0018:  nop
    IL_0019:  br.s       IL_0026

//000029:             Some("Have a happy day!")
    IL_001b:  ldstr      "Have a happy day!"
    IL_0020:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::Some(!0)
//000030:     if possibleValue.IsSome then
//000031:         System.Console.WriteLine("Ah, we got a good value. Good!")
//000032:         System.Console.WriteLine(possibleValue.Value)
//000033: 
//000034: [<Example("Options 4")>]
//000035: let option_examples_4() =
//000036:     // This will deliberately throw an exception
//000037:     //
//000038:     let nothing : string option = None
//000039:     if nothing.Equals(None) then
//000040:         System.Console.WriteLine("None.Equals(None)")
//000041:     System.Console.WriteLine(nothing.GetHashCode())
//000042:     System.Console.WriteLine(nothing.ToString())
//000043: 
//000044: [<Example("Options 5")>]
//000045: let option_examples_5() =
//000046:     let possibleValue =
//000047:         if (System.DateTime.Now.Millisecond % 2) = 0 then
//000048:             None
//000049:         else
//000050:             Some("Have a happy day!")
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0025:  nop
    IL_0026:  stloc.0
//000030:     if possibleValue.IsSome then
    IL_0027:  ldloc.0
    IL_0028:  call       bool class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::get_IsSome(class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0>)
    IL_002d:  brfalse.s  IL_0031

    IL_002f:  br.s       IL_0033

    IL_0031:  br.s       IL_0049

//000031:         System.Console.WriteLine("Ah, we got a good value. Good!")
    IL_0033:  ldstr      "Ah, we got a good value. Good!"
    IL_0038:  call       void [mscorlib]System.Console::WriteLine(string)
//000032:         System.Console.WriteLine(possibleValue.Value)
    IL_003d:  ldloc.0
    IL_003e:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::get_Value()
    IL_0043:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0048:  ret

//000033: 
//000034: [<Example("Options 4")>]
//000035: let option_examples_4() =
//000036:     // This will deliberately throw an exception
//000037:     //
//000038:     let nothing : string option = None
//000039:     if nothing.Equals(None) then
//000040:         System.Console.WriteLine("None.Equals(None)")
//000041:     System.Console.WriteLine(nothing.GetHashCode())
//000042:     System.Console.WriteLine(nothing.ToString())
//000043: 
//000044: [<Example("Options 5")>]
//000045: let option_examples_5() =
//000046:     let possibleValue =
//000047:         if (System.DateTime.Now.Millisecond % 2) = 0 then
//000048:             None
//000049:         else
//000050:             Some("Have a happy day!")
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0049:  ret
  } // end of method SimpleCompositeTypes::option_examples_3

  .method public static void  option_examples_4() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 09 4F 70 74 69 6F 6E 73 20 34 00 00 )       // ...Options 4..
    // Code size       53 (0x35)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> nothing)
//000038:     let nothing : string option = None
    IL_0000:  nop
    IL_0001:  ldnull
    IL_0002:  stloc.0
//000039:     if nothing.Equals(None) then
    IL_0003:  ldloc.0
    IL_0004:  ldnull
    IL_0005:  callvirt   instance bool [mscorlib]System.Object::Equals(object)
    IL_000a:  brfalse.s  IL_000e

    IL_000c:  br.s       IL_0010

    IL_000e:  br.s       IL_001d

//000040:         System.Console.WriteLine("None.Equals(None)")
    IL_0010:  ldstr      "None.Equals(None)"
    IL_0015:  call       void [mscorlib]System.Console::WriteLine(string)
//000041:     System.Console.WriteLine(nothing.GetHashCode())
//000042:     System.Console.WriteLine(nothing.ToString())
//000043: 
//000044: [<Example("Options 5")>]
//000045: let option_examples_5() =
//000046:     let possibleValue =
//000047:         if (System.DateTime.Now.Millisecond % 2) = 0 then
//000048:             None
//000049:         else
//000050:             Some("Have a happy day!")
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_001a:  nop
    IL_001b:  br.s       IL_001e

    IL_001d:  nop
//000041:     System.Console.WriteLine(nothing.GetHashCode())
    IL_001e:  ldloc.0
    IL_001f:  callvirt   instance int32 [mscorlib]System.Object::GetHashCode()
    IL_0024:  call       void [mscorlib]System.Console::WriteLine(int32)
//000042:     System.Console.WriteLine(nothing.ToString())
    IL_0029:  ldloc.0
    IL_002a:  callvirt   instance string [mscorlib]System.Object::ToString()
    IL_002f:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0034:  ret
  } // end of method SimpleCompositeTypes::option_examples_4

  .method public static void  option_examples_5() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 09 4F 70 74 69 6F 6E 73 20 35 00 00 )       // ...Options 5..
    // Code size       51 (0x33)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string> possibleValue,
             [1] valuetype [mscorlib]System.DateTime V_1)
//000043: 
//000044: [<Example("Options 5")>]
//000045: let option_examples_5() =
//000046:     let possibleValue =
    IL_0000:  nop
    IL_0001:  nop
//000047:         if (System.DateTime.Now.Millisecond % 2) = 0 then
    IL_0002:  call       valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::get_Now()
    IL_0007:  stloc.1
    IL_0008:  ldloca.s   V_1
    IL_000a:  call       instance int32 [mscorlib]System.DateTime::get_Millisecond()
    IL_000f:  ldc.i4.2
    IL_0010:  rem
    IL_0011:  brtrue.s   IL_0015

    IL_0013:  br.s       IL_0017

    IL_0015:  br.s       IL_001b

//000048:             None
    IL_0017:  ldnull
//000049:         else
//000050:             Some("Have a happy day!")
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0018:  nop
    IL_0019:  br.s       IL_0026

//000050:             Some("Have a happy day!")
    IL_001b:  ldstr      "Have a happy day!"
    IL_0020:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!0> class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<string>::Some(!0)
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
//000060:     System.Console.WriteLine("Hello, {0}", myName)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
//000066:     let cityState = ("Phoenix", "AZ")
//000067:     System.Console.WriteLine("myName = herName? {0}", 
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
//000075:     let firstName = fst me
//000076:     let lastName = snd me
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000082:     let (firstName, lastName, age, city, state) = me
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
//000088:     let (firstName, _, _, city, _) = me
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
//000110:     let arrayOfStrings = [|
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
//000117:     let arrayOfTeds = Array.create 10 "Ted"
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
//000122:     let mutableArray = Array.create 10 0
//000123:     for i = 0 to 9 do
//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
//000126:     ()
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
//000141:     ()
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
//000146:     for i = 0 to array.Length - 1 do
//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0025:  nop
    IL_0026:  stloc.0
//000051:     Option.iter (fun o -> System.Console.WriteLine(o.ToString()))
    IL_0027:  newobj     instance void SimpleCompositeTypes/option_examples_5@51::.ctor()
    IL_002c:  ldloc.0
    IL_002d:  call       void [FSharp.Core]Microsoft.FSharp.Core.OptionModule::Iterate<string>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                               class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!!0>)
    IL_0032:  ret
  } // end of method SimpleCompositeTypes::option_examples_5

  .method public static void  tuple_examples_1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 08 54 75 70 6C 65 73 20 31 00 00 )          // ...Tuples 1..
    // Code size       52 (0x34)
    .maxstack  6
    .locals init ([0] class [FSharp.Core]System.Tuple`2<string,string> myName,
             [1] class [FSharp.Core]System.Tuple`4<string,string,int32,int32> myDescription)
//000052:                 possibleValue
//000053:                 
//000054: 
//000055: // ======= Tuples ==========
//000056: [<Example("Tuples 1")>]
//000057: let tuple_examples_1() =
//000058:     let myName : (string * string) = ("Ted", "Neward")
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,string>::.ctor(!0,
                                                                                               !1)
    IL_0010:  stloc.0
//000059:     let myDescription : (string * string * int * int) = ("Ted", "Neward", 38, 98053)
    IL_0011:  ldstr      "Ted"
    IL_0016:  ldstr      "Neward"
    IL_001b:  ldc.i4.s   38
    IL_001d:  ldc.i4     0x17f05
    IL_0022:  newobj     instance void class [FSharp.Core]System.Tuple`4<string,string,int32,int32>::.ctor(!0,
                                                                                                           !1,
                                                                                                           !2,
                                                                                                           !3)
    IL_0027:  stloc.1
//000060:     System.Console.WriteLine("Hello, {0}", myName)
    IL_0028:  ldstr      "Hello, {0}"
    IL_002d:  ldloc.0
    IL_002e:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0033:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_1

  .method public static void  tuple_examples_2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 08 54 75 70 6C 65 73 20 32 00 00 )          // ...Tuples 2..
    // Code size       119 (0x77)
    .maxstack  5
    .locals init ([0] class [FSharp.Core]System.Tuple`2<string,string> myName,
             [1] class [FSharp.Core]System.Tuple`3<string,string,string> herName,
             [2] class [FSharp.Core]System.Tuple`2<string,string> cityState)
//000061: 
//000062: [<Example("Tuples 2")>]
//000063: let tuple_examples_2() =
//000064:     let myName = ("Ted", "Neward")
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,string>::.ctor(!0,
                                                                                               !1)
    IL_0010:  stloc.0
//000065:     let herName = ("Sarah", "Michelle", "Gellar")
    IL_0011:  ldstr      "Sarah"
    IL_0016:  ldstr      "Michelle"
    IL_001b:  ldstr      "Gellar"
    IL_0020:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,string>::.ctor(!0,
                                                                                                      !1,
                                                                                                      !2)
    IL_0025:  stloc.1
//000066:     let cityState = ("Phoenix", "AZ")
    IL_0026:  ldstr      "Phoenix"
    IL_002b:  ldstr      "AZ"
    IL_0030:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,string>::.ctor(!0,
                                                                                               !1)
    IL_0035:  stloc.2
//000067:     System.Console.WriteLine("myName = herName? {0}", 
    IL_0036:  ldstr      "myName = herName\? {0}"
    IL_003b:  ldloc.0
    IL_003c:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0041:  ldloc.1
    IL_0042:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0047:  callvirt   instance bool [mscorlib]System.Type::Equals(class [mscorlib]System.Type)
    IL_004c:  box        [mscorlib]System.Boolean
    IL_0051:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000068:         myName.GetType().Equals(herName.GetType()))
//000069:     System.Console.WriteLine("myName = cityState? {0}", 
    IL_0056:  ldstr      "myName = cityState\? {0}"
    IL_005b:  ldloc.0
    IL_005c:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0061:  ldloc.2
    IL_0062:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0067:  callvirt   instance bool [mscorlib]System.Type::Equals(class [mscorlib]System.Type)
    IL_006c:  box        [mscorlib]System.Boolean
    IL_0071:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0076:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_2

  .method public static void  tuple_examples_3() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 08 54 75 70 6C 65 73 20 33 00 00 )          // ...Tuples 3..
    // Code size       44 (0x2c)
    .maxstack  5
    .locals init ([0] class [FSharp.Core]System.Tuple`2<string,string> me,
             [1] string firstName,
             [2] string lastName)
//000070:         myName.GetType().Equals(cityState.GetType()))
//000071:         
//000072: [<Example("Tuples 3")>]
//000073: let tuple_examples_3() =
//000074:     let me = ("Ted", "Neward")
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,string>::.ctor(!0,
                                                                                               !1)
    IL_0010:  stloc.0
//000075:     let firstName = fst me
    IL_0011:  ldloc.0
    IL_0012:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Fst<string,string>(class [FSharp.Core]System.Tuple`2<!!0,!!1>)
    IL_0017:  stloc.1
//000076:     let lastName = snd me
    IL_0018:  ldloc.0
    IL_0019:  call       !!1 [FSharp.Core]Microsoft.FSharp.Core.Operators::Snd<string,string>(class [FSharp.Core]System.Tuple`2<!!0,!!1>)
    IL_001e:  stloc.2
//000077:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
    IL_001f:  ldstr      "Hello, {0} {1}"
    IL_0024:  ldloc.1
    IL_0025:  ldloc.2
    IL_0026:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
    IL_002b:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_3

  .method public static void  tuple_examples_4() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 08 54 75 70 6C 65 73 20 34 00 00 )          // ...Tuples 4..
    // Code size       83 (0x53)
    .maxstack  7
    .locals init ([0] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> me,
             [1] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> V_1,
             [2] string state,
             [3] string lastName,
             [4] string firstName,
             [5] string city,
             [6] int32 age)
//000078: 
//000079: [<Example("Tuples 4")>]
//000080: let tuple_examples_4() =    
//000081:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  ldc.i4.s   38
    IL_000d:  ldstr      "Redmond"
    IL_0012:  ldstr      "WA"
    IL_0017:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_001c:  stloc.0
//000082:     let (firstName, lastName, age, city, state) = me
    IL_001d:  ldloc.0
    IL_001e:  stloc.1
    IL_001f:  ldloc.1
    IL_0020:  call       instance !4 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item5()
    IL_0025:  stloc.2
    IL_0026:  ldloc.1
    IL_0027:  call       instance !1 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item2()
    IL_002c:  stloc.3
    IL_002d:  ldloc.1
    IL_002e:  call       instance !0 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item1()
    IL_0033:  stloc.s    firstName
    IL_0035:  ldloc.1
    IL_0036:  call       instance !3 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item4()
    IL_003b:  stloc.s    city
    IL_003d:  ldloc.1
    IL_003e:  call       instance !2 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item3()
    IL_0043:  stloc.s    age
//000083:     System.Console.WriteLine("Hello, {0} {1}", firstName, lastName)
    IL_0045:  ldstr      "Hello, {0} {1}"
    IL_004a:  ldloc.s    firstName
    IL_004c:  ldloc.3
    IL_004d:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
    IL_0052:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_4

  .method public static void  tuple_examples_5() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 08 54 75 70 6C 65 73 20 35 00 00 )          // ...Tuples 5..
    // Code size       58 (0x3a)
    .maxstack  7
    .locals init ([0] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> me,
             [1] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> V_1,
             [2] string firstName,
             [3] string city)
//000084:     
//000085: [<Example("Tuples 5")>]
//000086: let tuple_examples_5() =    
//000087:     let me = ("Ted", "Neward", 38, "Redmond", "WA")
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  ldc.i4.s   38
    IL_000d:  ldstr      "Redmond"
    IL_0012:  ldstr      "WA"
    IL_0017:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_001c:  stloc.0
//000088:     let (firstName, _, _, city, _) = me
    IL_001d:  ldloc.0
    IL_001e:  stloc.1
    IL_001f:  ldloc.1
    IL_0020:  call       instance !0 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item1()
    IL_0025:  stloc.2
    IL_0026:  ldloc.1
    IL_0027:  call       instance !3 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item4()
    IL_002c:  stloc.3
//000089:     System.Console.WriteLine("Hello, {0}, how's {1}", firstName, city)
    IL_002d:  ldstr      "Hello, {0}, how's {1}"
    IL_0032:  ldloc.2
    IL_0033:  ldloc.3
    IL_0034:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
    IL_0039:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_5

  .method public static void  tuple_examples_6() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 15 54 75 70 6C 65 73 20 27 66 6F 72 27 20   // ...Tuples 'for' 
                                                                        65 78 61 6D 70 6C 65 73 00 00 )                   // examples..
    // Code size       272 (0x110)
    .maxstack  10
    .locals init ([0] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>[] people,
             [1] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>[] V_1,
             [2] int32 V_2,
             [3] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> V_3,
             [4] string firstName,
             [5] int32 age)
//000090: 
//000091: [<Example("Tuples 'for' examples")>]
//000092: let tuple_examples_6() =
//000093:     let people = [|
    IL_0000:  nop
    IL_0001:  ldc.i4.6
    IL_0002:  newarr     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_0007:  dup
    IL_0008:  ldc.i4.0
    IL_0009:  ldstr      "Ted"
    IL_000e:  ldstr      "Neward"
    IL_0013:  ldc.i4.s   38
    IL_0015:  ldstr      "Redmond"
    IL_001a:  ldstr      "WA"
    IL_001f:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0024:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_0029:  dup
    IL_002a:  ldc.i4.1
    IL_002b:  ldstr      "Katie"
    IL_0030:  ldstr      "Ellison"
    IL_0035:  ldc.i4.s   30
    IL_0037:  ldstr      "Seattle"
    IL_003c:  ldstr      "WA"
    IL_0041:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0046:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_004b:  dup
    IL_004c:  ldc.i4.2
    IL_004d:  ldstr      "Mark"
    IL_0052:  ldstr      "Richards"
    IL_0057:  ldc.i4.s   45
    IL_0059:  ldstr      "Boston"
    IL_005e:  ldstr      "MA"
    IL_0063:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0068:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_006d:  dup
    IL_006e:  ldc.i4.3
    IL_006f:  ldstr      "Rachel"
    IL_0074:  ldstr      "Reese"
    IL_0079:  ldc.i4.s   27
    IL_007b:  ldstr      "Phoenix"
    IL_0080:  ldstr      "AZ"
    IL_0085:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_008a:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_008f:  dup
    IL_0090:  ldc.i4.4
    IL_0091:  ldstr      "Ken"
    IL_0096:  ldstr      "Sipe"
    IL_009b:  ldc.i4.s   43
    IL_009d:  ldstr      "St Louis"
    IL_00a2:  ldstr      "MO"
    IL_00a7:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00ac:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00b1:  dup
    IL_00b2:  ldc.i4.5
    IL_00b3:  ldstr      "Naomi"
    IL_00b8:  ldstr      "Wilson"
    IL_00bd:  ldc.i4.s   35
    IL_00bf:  ldstr      "Seattle"
    IL_00c4:  ldstr      "WA"
    IL_00c9:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00ce:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00d3:  stloc.0
//000094:         ("Ted", "Neward", 38, "Redmond", "WA")
//000095:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000096:         ("Mark", "Richards", 45, "Boston", "MA")
//000097:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000098:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000099:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000100:     |]
//000101:     for (firstName, _, age, _, _) in people do
    IL_00d4:  ldloc.0
    IL_00d5:  stloc.1
    IL_00d6:  ldc.i4.0
    IL_00d7:  stloc.2
    IL_00d8:  br.s       IL_0109

    IL_00da:  ldloc.1
    IL_00db:  ldloc.2
    IL_00dc:  ldelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00e1:  stloc.3
    IL_00e2:  ldloc.3
    IL_00e3:  call       instance !0 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item1()
    IL_00e8:  stloc.s    firstName
    IL_00ea:  ldloc.3
    IL_00eb:  call       instance !2 class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::get_Item3()
    IL_00f0:  stloc.s    age
    IL_00f2:  ldstr      "{0} is {1}"
    IL_00f7:  ldloc.s    firstName
    IL_00f9:  ldloc.s    age
    IL_00fb:  box        [mscorlib]System.Int32
    IL_0100:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object,
                                                                  object)
    IL_0105:  ldloc.2
    IL_0106:  ldc.i4.1
    IL_0107:  add
    IL_0108:  stloc.2
    IL_0109:  ldloc.2
    IL_010a:  ldloc.1
    IL_010b:  ldlen
    IL_010c:  conv.i4
    IL_010d:  blt.s      IL_00da

    IL_010f:  ret
  } // end of method SimpleCompositeTypes::tuple_examples_6

  .method public static void  array_examples_1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1D 41 72 72 61 79 20 69 6E 69 74 69 61 6C   // ...Array initial
                                                                        69 7A 61 74 69 6F 6E 20 65 78 61 6D 70 6C 65 73   // ization examples
                                                                        00 00 ) 
    // Code size       324 (0x144)
    .maxstack  6
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc emptyArray,
             [1] int32[] arrayOfIntegers,
             [2] string[] arrayOfStrings,
             [3] int32[] arrayOfZeroes,
             [4] string[] arrayOfTeds,
             [5] int32[] rangeOfIntegers,
             [6] int32[] V_6,
             [7] float64[] rangeOfFloats,
             [8] int32[] forBuiltArray,
             [9] int32[] mutableArray,
             [10] int32 i,
             [11] object[] arrayOfObjects)
//000102:         System.Console.WriteLine("{0} is {1}", firstName, age)
//000103:     
//000104: 
//000105: // ========= Arrays ==========
//000106: [<Example("Array initialization examples")>]
//000107: let array_examples_1() =
//000108:     let emptyArray = [| |]
//000109:     let arrayOfIntegers = [| 1; 2; 3; 4; |]
    IL_0000:  newobj     instance void SimpleCompositeTypes/emptyArray@108::.ctor()
    IL_0005:  stloc.0
    IL_0006:  nop
    IL_0007:  ldc.i4.4
    IL_0008:  newarr     [mscorlib]System.Int32
    IL_000d:  dup
    IL_000e:  ldc.i4.0
    IL_000f:  ldc.i4.1
    IL_0010:  stelem     [mscorlib]System.Int32
    IL_0015:  dup
    IL_0016:  ldc.i4.1
    IL_0017:  ldc.i4.2
    IL_0018:  stelem     [mscorlib]System.Int32
    IL_001d:  dup
    IL_001e:  ldc.i4.2
    IL_001f:  ldc.i4.3
    IL_0020:  stelem     [mscorlib]System.Int32
    IL_0025:  dup
    IL_0026:  ldc.i4.3
    IL_0027:  ldc.i4.4
    IL_0028:  stelem     [mscorlib]System.Int32
    IL_002d:  stloc.1
//000110:     let arrayOfStrings = [|
    IL_002e:  ldc.i4.4
    IL_002f:  newarr     [mscorlib]System.String
    IL_0034:  dup
    IL_0035:  ldc.i4.0
    IL_0036:  ldstr      "Fred"
    IL_003b:  stelem     [mscorlib]System.String
    IL_0040:  dup
    IL_0041:  ldc.i4.1
    IL_0042:  ldstr      "Wilma"
    IL_0047:  stelem     [mscorlib]System.String
    IL_004c:  dup
    IL_004d:  ldc.i4.2
    IL_004e:  ldstr      "Barney"
    IL_0053:  stelem     [mscorlib]System.String
    IL_0058:  dup
    IL_0059:  ldc.i4.3
    IL_005a:  ldstr      "Betty"
    IL_005f:  stelem     [mscorlib]System.String
    IL_0064:  stloc.2
//000111:         "Fred"
//000112:         "Wilma"
//000113:         "Barney"
//000114:         "Betty"
//000115:     |]
//000116:     let arrayOfZeroes = Array.create 10 0
    IL_0065:  ldc.i4.s   10
    IL_0067:  ldc.i4.0
    IL_0068:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Create<int32>(int32,
                                                                                                    !!0)
    IL_006d:  stloc.3
//000117:     let arrayOfTeds = Array.create 10 "Ted"
    IL_006e:  ldc.i4.s   10
    IL_0070:  ldstr      "Ted"
    IL_0075:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Create<string>(int32,
                                                                                                     !!0)
    IL_007a:  stloc.s    arrayOfTeds
//000118:     let rangeOfIntegers = [| 1 .. 10 |]
    IL_007c:  ldc.i4.1
    IL_007d:  ldc.i4.1
    IL_007e:  ldc.i4.s   10
    IL_0080:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_0085:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_008a:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToArray<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_008f:  stloc.s    rangeOfIntegers
//000119:     let rangeOfIntegers = [| 1 .. 2 .. 10 |]
    IL_0091:  ldc.i4.1
    IL_0092:  ldc.i4.2
    IL_0093:  ldc.i4.s   10
    IL_0095:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_009a:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_009f:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToArray<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00a4:  stloc.s    V_6
//000120:     let rangeOfFloats = [| 0.0 .. 0.5 .. 10.0 |]
    IL_00a6:  ldc.r8     0.0
    IL_00af:  ldc.r8     0.5
    IL_00b8:  ldc.r8     10.
    IL_00c1:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<float64> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeDouble(float64,
                                                                                                                                                                        float64,
                                                                                                                                                                        float64)
    IL_00c6:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00cb:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToArray<float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00d0:  stloc.s    rangeOfFloats
//000121:     let forBuiltArray = [| for i in 1 .. 10 -> i*i |]
    IL_00d2:  ldc.i4.0
    IL_00d3:  ldnull
    IL_00d4:  ldc.i4.0
    IL_00d5:  ldc.i4.0
    IL_00d6:  newobj     instance void SimpleCompositeTypes/forBuiltArray@121::.ctor(int32,
                                                                                     class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                                     int32,
                                                                                     int32)
    IL_00db:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToArray<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00e0:  stloc.s    forBuiltArray
//000122:     let mutableArray = Array.create 10 0
    IL_00e2:  ldc.i4.s   10
    IL_00e4:  ldc.i4.0
    IL_00e5:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Create<int32>(int32,
                                                                                                    !!0)
    IL_00ea:  stloc.s    mutableArray
//000123:     for i = 0 to 9 do
    IL_00ec:  ldc.i4.0
    IL_00ed:  stloc.s    i
    IL_00ef:  br.s       IL_0105

//000124:         mutableArray.[i] <- i*i
    IL_00f1:  ldloc.s    mutableArray
    IL_00f3:  ldloc.s    i
    IL_00f5:  ldloc.s    i
    IL_00f7:  ldloc.s    i
    IL_00f9:  mul
    IL_00fa:  stelem     [mscorlib]System.Int32
    IL_00ff:  ldloc.s    i
    IL_0101:  ldc.i4.1
    IL_0102:  add
    IL_0103:  stloc.s    i
//000123:     for i = 0 to 9 do
    IL_0105:  ldloc.s    i
    IL_0107:  ldc.i4.1
    IL_0108:  ldc.i4.s   9
    IL_010a:  add
    IL_010b:  blt.s      IL_00f1

//000124:         mutableArray.[i] <- i*i
//000125:     let (arrayOfObjects : obj array) = [| (1 :> obj); ("two" :> obj); (3.0 :> obj) |]
    IL_010d:  ldc.i4.3
    IL_010e:  newarr     [mscorlib]System.Object
    IL_0113:  dup
    IL_0114:  ldc.i4.0
    IL_0115:  ldc.i4.1
    IL_0116:  box        [mscorlib]System.Int32
    IL_011b:  stelem     [mscorlib]System.Object
    IL_0120:  dup
    IL_0121:  ldc.i4.1
    IL_0122:  ldstr      "two"
    IL_0127:  stelem     [mscorlib]System.Object
    IL_012c:  dup
    IL_012d:  ldc.i4.2
    IL_012e:  ldc.r8     3.
    IL_0137:  box        [mscorlib]System.Double
    IL_013c:  stelem     [mscorlib]System.Object
    IL_0141:  stloc.s    arrayOfObjects
//000126:     ()
    IL_0143:  ret
  } // end of method SimpleCompositeTypes::array_examples_1

  .method public static void  array_examples_2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 15 41 72 72 61 79 20 61 63 63 65 73 73 20   // ...Array access 
                                                                        65 78 61 6D 70 6C 65 73 00 00 )                   // examples..
    // Code size       255 (0xff)
    .maxstack  10
    .locals init ([0] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>[] people,
             [1] class [FSharp.Core]System.Tuple`5<string,string,int32,string,string> thirdPerson)
//000127:     
//000128: [<Example("Array access examples")>]
//000129: let array_examples_2() =
//000130:     let people = [|
    IL_0000:  nop
    IL_0001:  ldc.i4.6
    IL_0002:  newarr     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_0007:  dup
    IL_0008:  ldc.i4.0
    IL_0009:  ldstr      "Ted"
    IL_000e:  ldstr      "Neward"
    IL_0013:  ldc.i4.s   38
    IL_0015:  ldstr      "Redmond"
    IL_001a:  ldstr      "WA"
    IL_001f:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0024:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_0029:  dup
    IL_002a:  ldc.i4.1
    IL_002b:  ldstr      "Katie"
    IL_0030:  ldstr      "Ellison"
    IL_0035:  ldc.i4.s   30
    IL_0037:  ldstr      "Seattle"
    IL_003c:  ldstr      "WA"
    IL_0041:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0046:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_004b:  dup
    IL_004c:  ldc.i4.2
    IL_004d:  ldstr      "Mark"
    IL_0052:  ldstr      "Richards"
    IL_0057:  ldc.i4.s   45
    IL_0059:  ldstr      "Boston"
    IL_005e:  ldstr      "MA"
    IL_0063:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0068:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_006d:  dup
    IL_006e:  ldc.i4.3
    IL_006f:  ldstr      "Rachel"
    IL_0074:  ldstr      "Reese"
    IL_0079:  ldc.i4.s   27
    IL_007b:  ldstr      "Phoenix"
    IL_0080:  ldstr      "AZ"
    IL_0085:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_008a:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_008f:  dup
    IL_0090:  ldc.i4.4
    IL_0091:  ldstr      "Ken"
    IL_0096:  ldstr      "Sipe"
    IL_009b:  ldc.i4.s   43
    IL_009d:  ldstr      "St Louis"
    IL_00a2:  ldstr      "MO"
    IL_00a7:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00ac:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00b1:  dup
    IL_00b2:  ldc.i4.5
    IL_00b3:  ldstr      "Naomi"
    IL_00b8:  ldstr      "Wilson"
    IL_00bd:  ldc.i4.s   35
    IL_00bf:  ldstr      "Seattle"
    IL_00c4:  ldstr      "WA"
    IL_00c9:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00ce:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00d3:  stloc.0
//000131:         ("Ted", "Neward", 38, "Redmond", "WA")
//000132:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000133:         ("Mark", "Richards", 45, "Boston", "MA")
//000134:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000135:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000136:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000137:     |]
//000138:     let thirdPerson = people.[2]
    IL_00d4:  ldloc.0
    IL_00d5:  ldc.i4.2
    IL_00d6:  ldelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
    IL_00db:  stloc.1
//000139:     // Happy Birthday, Mark!
//000140:     people.[2] <- ("Mark", "Richards", 46, "Boston", "MA")
    IL_00dc:  ldloc.0
    IL_00dd:  ldc.i4.2
    IL_00de:  ldstr      "Mark"
    IL_00e3:  ldstr      "Richards"
    IL_00e8:  ldc.i4.s   46
    IL_00ea:  ldstr      "Boston"
    IL_00ef:  ldstr      "MA"
    IL_00f4:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00f9:  stelem     class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>
//000141:     ()
    IL_00fe:  ret
  } // end of method SimpleCompositeTypes::array_examples_2

  .method public static void  array_examples_3() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 18 41 72 72 61 79 20 69 74 65 72 61 74 69   // ...Array iterati
                                                                        6F 6E 20 65 78 61 6D 70 6C 65 73 00 00 )          // on examples..
    // Code size       232 (0xe8)
    .maxstack  6
    .locals init ([0] string[] 'array',
             [1] int32 i,
             [2] string[] V_2,
             [3] int32 V_3,
             [4] string p,
             [5] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_5,
             [6] string[] V_6,
             [7] int32 V_7,
             [8] int32 V_8,
             [9] int32 V_9)
//000142:     
//000143: [<Example("Array iteration examples")>]
//000144: let array_examples_3() =
//000145:     let array = [| "Ted"; "Katie"; "Mark"; "Rachel"; "Ken"; "Naomi" |]
    IL_0000:  nop
    IL_0001:  ldc.i4.6
    IL_0002:  newarr     [mscorlib]System.String
    IL_0007:  dup
    IL_0008:  ldc.i4.0
    IL_0009:  ldstr      "Ted"
    IL_000e:  stelem     [mscorlib]System.String
    IL_0013:  dup
    IL_0014:  ldc.i4.1
    IL_0015:  ldstr      "Katie"
    IL_001a:  stelem     [mscorlib]System.String
    IL_001f:  dup
    IL_0020:  ldc.i4.2
    IL_0021:  ldstr      "Mark"
    IL_0026:  stelem     [mscorlib]System.String
    IL_002b:  dup
    IL_002c:  ldc.i4.3
    IL_002d:  ldstr      "Rachel"
    IL_0032:  stelem     [mscorlib]System.String
    IL_0037:  dup
    IL_0038:  ldc.i4.4
    IL_0039:  ldstr      "Ken"
    IL_003e:  stelem     [mscorlib]System.String
    IL_0043:  dup
    IL_0044:  ldc.i4.5
    IL_0045:  ldstr      "Naomi"
    IL_004a:  stelem     [mscorlib]System.String
    IL_004f:  stloc.0
//000146:     for i = 0 to array.Length - 1 do
    IL_0050:  ldc.i4.0
    IL_0051:  stloc.1
    IL_0052:  br.s       IL_0064

//000147:         System.Console.WriteLine(array.[i])
    IL_0054:  ldloc.0
    IL_0055:  ldloc.1
    IL_0056:  ldelem     [mscorlib]System.String
    IL_005b:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0060:  ldloc.1
    IL_0061:  ldc.i4.1
    IL_0062:  add
    IL_0063:  stloc.1
//000146:     for i = 0 to array.Length - 1 do
    IL_0064:  ldloc.1
    IL_0065:  ldloc.0
    IL_0066:  ldlen
    IL_0067:  conv.i4
    IL_0068:  blt.s      IL_0054

//000147:         System.Console.WriteLine(array.[i])
//000148:     for p in array do
    IL_006a:  ldloc.0
    IL_006b:  stloc.2
    IL_006c:  ldc.i4.0
    IL_006d:  stloc.3
    IL_006e:  br.s       IL_0084

    IL_0070:  ldloc.2
    IL_0071:  ldloc.3
    IL_0072:  ldelem     [mscorlib]System.String
    IL_0077:  stloc.s    p
    IL_0079:  ldloc.s    p
    IL_007b:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0080:  ldloc.3
    IL_0081:  ldc.i4.1
    IL_0082:  add
    IL_0083:  stloc.3
    IL_0084:  ldloc.3
    IL_0085:  ldloc.2
    IL_0086:  ldlen
    IL_0087:  conv.i4
    IL_0088:  blt.s      IL_0070

//000149:         System.Console.WriteLine(p)
//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
    IL_008a:  newobj     instance void SimpleCompositeTypes/array_examples_3@150::.ctor()
    IL_008f:  stloc.s    V_5
    IL_0091:  ldloc.0
    IL_0092:  stloc.s    V_6
    IL_0094:  ldloc.s    V_6
    IL_0096:  box        string[]
    IL_009b:  brfalse.s  IL_009f

    IL_009d:  br.s       IL_00b2

//000151:     ()
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
//000166:     let drinkers =
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_009f:  ldstr      "array"
    IL_00a4:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_00a9:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
    IL_00ae:  pop
    IL_00af:  nop
    IL_00b0:  br.s       IL_00b3

    IL_00b2:  nop
    IL_00b3:  ldloc.s    V_6
    IL_00b5:  ldlen
    IL_00b6:  conv.i4
    IL_00b7:  stloc.s    V_7
    IL_00b9:  ldc.i4.0
    IL_00ba:  stloc.s    V_9
    IL_00bc:  ldloc.s    V_7
    IL_00be:  ldc.i4.1
    IL_00bf:  sub
    IL_00c0:  stloc.s    V_8
    IL_00c2:  ldloc.s    V_8
    IL_00c4:  ldloc.s    V_9
    IL_00c6:  blt.s      IL_00e7

//000150:     Array.iter (fun it -> System.Console.WriteLine(it.ToString())) array
    IL_00c8:  ldloc.s    V_5
    IL_00ca:  ldloc.s    V_6
    IL_00cc:  ldloc.s    V_9
    IL_00ce:  ldelem     [mscorlib]System.String
    IL_00d3:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
    IL_00d8:  pop
    IL_00d9:  ldloc.s    V_9
    IL_00db:  ldc.i4.1
    IL_00dc:  add
    IL_00dd:  stloc.s    V_9
    IL_00df:  ldloc.s    V_9
    IL_00e1:  ldloc.s    V_8
    IL_00e3:  ldc.i4.1
    IL_00e4:  add
    IL_00e5:  bne.un.s   IL_00c8

//000151:     ()
    IL_00e7:  ret
  } // end of method SimpleCompositeTypes::array_examples_3

  .method public static void  array_examples_4() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 18 41 72 72 61 79 20 6F 70 65 72 61 74 69   // ...Array operati
                                                                        6F 6E 20 65 78 61 6D 70 6C 65 73 00 00 )          // on examples..
    // Code size       411 (0x19b)
    .maxstack  8
    .locals init ([0] class HelperTypes/Person[] people,
             [1] class HelperTypes/Person newardsFound,
             [2] class HelperTypes/Person[] drinkers,
             [3] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_3,
             [4] class HelperTypes/Person[] V_4,
             [5] int32 V_5,
             [6] int32 V_6,
             [7] int32 V_7,
             [8] class HelperTypes/Person[] V_8,
             [9] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit> V_9,
             [10] class HelperTypes/Person[] V_10,
             [11] int32 V_11,
             [12] int32 V_12,
             [13] int32 V_13,
             [14] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class HelperTypes/Person[]> isADrinker,
             [15] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class [FSharp.Core]Microsoft.FSharp.Core.Unit> haveABeer)
//000152: 
//000153: [<Example("Array operation examples")>]
//000154: let array_examples_4() =
//000155:     let people = [|
    IL_0000:  nop
    IL_0001:  ldc.i4.6
    IL_0002:  newarr     HelperTypes/Person
    IL_0007:  dup
    IL_0008:  ldc.i4.0
    IL_0009:  ldstr      "Ted"
    IL_000e:  ldstr      "Neward"
    IL_0013:  ldc.i4.s   38
    IL_0015:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_001a:  stelem     HelperTypes/Person
    IL_001f:  dup
    IL_0020:  ldc.i4.1
    IL_0021:  ldstr      "Mark"
    IL_0026:  ldstr      "Richards"
    IL_002b:  ldc.i4.s   45
    IL_002d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0032:  stelem     HelperTypes/Person
    IL_0037:  dup
    IL_0038:  ldc.i4.2
    IL_0039:  ldstr      "Ken"
    IL_003e:  ldstr      "Siple"
    IL_0043:  ldc.i4.s   43
    IL_0045:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_004a:  stelem     HelperTypes/Person
    IL_004f:  dup
    IL_0050:  ldc.i4.3
    IL_0051:  ldstr      "Naomi"
    IL_0056:  ldstr      "Wilson"
    IL_005b:  ldc.i4.s   38
    IL_005d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0062:  stelem     HelperTypes/Person
    IL_0067:  dup
    IL_0068:  ldc.i4.4
    IL_0069:  ldstr      "Michael"
    IL_006e:  ldstr      "Neward"
    IL_0073:  ldc.i4.s   16
    IL_0075:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_007a:  stelem     HelperTypes/Person
    IL_007f:  dup
    IL_0080:  ldc.i4.5
    IL_0081:  ldstr      "Matthew"
    IL_0086:  ldstr      "Neward"
    IL_008b:  ldc.i4.s   9
    IL_008d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0092:  stelem     HelperTypes/Person
    IL_0097:  stloc.0
//000156:         new Person("Ted", "Neward", 38)
//000157:         new Person("Mark", "Richards", 45)
//000158:         new Person("Ken", "Siple", 43)
//000159:         new Person("Naomi", "Wilson", 38)
//000160:         new Person("Michael", "Neward", 16)
//000161:         new Person("Matthew", "Neward", 9)
//000162:     |]
//000163:     let newardsFound = 
    IL_0098:  newobj     instance void SimpleCompositeTypes/newardsFound@164::.ctor()
    IL_009d:  ldloc.0
    IL_009e:  call       !!0 [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Find<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                   !!0[])
    IL_00a3:  stloc.1
//000164:         Array.find (fun (it : Person) -> it.LastName = "Neward") people
//000165:     System.Console.WriteLine(newardsFound)
    IL_00a4:  ldloc.1
    IL_00a5:  call       void [mscorlib]System.Console::WriteLine(object)
//000166:     let drinkers =
    IL_00aa:  newobj     instance void SimpleCompositeTypes/drinkers@167::.ctor()
    IL_00af:  ldloc.0
    IL_00b0:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Filter<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                       !!0[])
    IL_00b5:  stloc.2
//000167:         Array.filter (fun (it : Person) -> it.Age > 21) people
//000168:     Array.iter (fun (it : Person) -> 
    IL_00b6:  newobj     instance void SimpleCompositeTypes/array_examples_4@168::.ctor()
    IL_00bb:  stloc.3
    IL_00bc:  ldloc.2
    IL_00bd:  stloc.s    V_4
    IL_00bf:  ldloc.s    V_4
    IL_00c1:  box        class HelperTypes/Person[]
    IL_00c6:  brfalse.s  IL_00ca

    IL_00c8:  br.s       IL_00dd

//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_00ca:  ldstr      "array"
    IL_00cf:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_00d4:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
    IL_00d9:  pop
    IL_00da:  nop
    IL_00db:  br.s       IL_00de

    IL_00dd:  nop
    IL_00de:  ldloc.s    V_4
    IL_00e0:  ldlen
    IL_00e1:  conv.i4
    IL_00e2:  stloc.s    V_5
    IL_00e4:  ldc.i4.0
    IL_00e5:  stloc.s    V_7
    IL_00e7:  ldloc.s    V_5
    IL_00e9:  ldc.i4.1
    IL_00ea:  sub
    IL_00eb:  stloc.s    V_6
    IL_00ed:  ldloc.s    V_6
    IL_00ef:  ldloc.s    V_7
    IL_00f1:  blt.s      IL_0111

//000168:     Array.iter (fun (it : Person) -> 
    IL_00f3:  ldloc.3
    IL_00f4:  ldloc.s    V_4
    IL_00f6:  ldloc.s    V_7
    IL_00f8:  ldelem     HelperTypes/Person
    IL_00fd:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
    IL_0102:  pop
    IL_0103:  ldloc.s    V_7
    IL_0105:  ldc.i4.1
    IL_0106:  add
    IL_0107:  stloc.s    V_7
    IL_0109:  ldloc.s    V_7
    IL_010b:  ldloc.s    V_6
    IL_010d:  ldc.i4.1
    IL_010e:  add
    IL_010f:  bne.un.s   IL_00f3

//000169:         System.Console.WriteLine("Have a beer, {0}!", it.FirstName) )
//000170:         drinkers
//000171:     people
    IL_0111:  newobj     instance void SimpleCompositeTypes/'array_examples_4@172-1'::.ctor()
    IL_0116:  ldloc.0
    IL_0117:  call       !!0[] [FSharp.Core]Microsoft.FSharp.Collections.ArrayModule::Filter<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                       !!0[])
    IL_011c:  stloc.s    V_8
    IL_011e:  newobj     instance void SimpleCompositeTypes/'array_examples_4@173-2'::.ctor()
    IL_0123:  stloc.s    V_9
    IL_0125:  ldloc.s    V_8
    IL_0127:  stloc.s    V_10
    IL_0129:  ldloc.s    V_10
    IL_012b:  box        class HelperTypes/Person[]
    IL_0130:  brfalse.s  IL_0134

    IL_0132:  br.s       IL_0147

//000172:         |> Array.filter (fun (it : Person) -> it.Age > 21)
//000173:         |> Array.iter (fun (it : Person) -> 
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
//000186:     let listOfStrings = [
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
//000209:     let concattedList = listOfIntegers @ consedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
//000232:     System.Console.WriteLine(peopleHead)
//000233:     let firstPerson = List.head people
//000234:     System.Console.WriteLine(firstPerson)
//000235:     let (personOne :: rest) = people
//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0134:  ldstr      "array"
    IL_0139:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_013e:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
    IL_0143:  pop
    IL_0144:  nop
    IL_0145:  br.s       IL_0148

    IL_0147:  nop
    IL_0148:  ldloc.s    V_10
    IL_014a:  ldlen
    IL_014b:  conv.i4
    IL_014c:  stloc.s    V_11
    IL_014e:  ldc.i4.0
    IL_014f:  stloc.s    V_13
    IL_0151:  ldloc.s    V_11
    IL_0153:  ldc.i4.1
    IL_0154:  sub
    IL_0155:  stloc.s    V_12
    IL_0157:  ldloc.s    V_12
    IL_0159:  ldloc.s    V_13
    IL_015b:  blt.s      IL_017c

//000173:         |> Array.iter (fun (it : Person) -> 
    IL_015d:  ldloc.s    V_9
    IL_015f:  ldloc.s    V_10
    IL_0161:  ldloc.s    V_13
    IL_0163:  ldelem     HelperTypes/Person
    IL_0168:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
    IL_016d:  pop
    IL_016e:  ldloc.s    V_13
    IL_0170:  ldc.i4.1
    IL_0171:  add
    IL_0172:  stloc.s    V_13
    IL_0174:  ldloc.s    V_13
    IL_0176:  ldloc.s    V_12
    IL_0178:  ldc.i4.1
    IL_0179:  add
    IL_017a:  bne.un.s   IL_015d

    IL_017c:  newobj     instance void SimpleCompositeTypes/isADrinker@176::.ctor()
    IL_0181:  stloc.s    isADrinker
    IL_0183:  newobj     instance void SimpleCompositeTypes/haveABeer@178::.ctor()
    IL_0188:  stloc.s    haveABeer
//000174:             System.Console.WriteLine("Have a beer, {0}!", it.FirstName))
//000175:     let isADrinker (ar : Person array) = 
//000176:         Array.filter (fun (p : Person) -> p.Age > 21) ar
//000177:     let haveABeer (ar : Person array) = 
//000178:         Array.iter (fun (p : Person) -> System.Console.WriteLine("Have a beer, {0}!", p.FirstName) ) ar
//000179:     people |> isADrinker |> haveABeer
    IL_018a:  ldloc.s    haveABeer
    IL_018c:  ldloc.s    isADrinker
    IL_018e:  ldloc.0
    IL_018f:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class HelperTypes/Person[]>::Invoke(!0)
    IL_0194:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class HelperTypes/Person[],class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
    IL_0199:  pop
    IL_019a:  ret
  } // end of method SimpleCompositeTypes::array_examples_4

  .method public static class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string> 
          list_examples_1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 0F 4C 69 73 74 20 65 78 61 6D 70 6C 65 73   // ...List examples
                                                                        20 31 00 00 )                                     //  1..
    // Code size       426 (0x1aa)
    .maxstack  12
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpTypeFunc emptyList,
             [1] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> listOfIntegers,
             [2] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string> listOfStrings,
             [3] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>> listOfPeopleTuples,
             [4] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> listOfIntegersToTen,
             [5] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> listOfEvenIntsToTen,
             [6] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<float64> listOfFloatsToTen,
             [7] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> consedList,
             [8] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> forBuiltList,
             [9] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32> concattedList)
//000180: 
//000181: // ========= Lists ==========
//000182: [<Example("List examples 1")>]
//000183: let list_examples_1() =
//000184:     let emptyList = []
//000185:     let listOfIntegers = [ 1; 2; 3; 4; ]
    IL_0000:  newobj     instance void SimpleCompositeTypes/emptyList@184::.ctor()
    IL_0005:  stloc.0
    IL_0006:  nop
    IL_0007:  ldc.i4.1
    IL_0008:  ldc.i4.2
    IL_0009:  ldc.i4.3
    IL_000a:  ldc.i4.4
    IL_000b:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_Empty()
    IL_0010:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0015:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_001a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_001f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0024:  stloc.1
//000186:     let listOfStrings = [
    IL_0025:  ldstr      "Fred"
    IL_002a:  ldstr      "Wilma"
    IL_002f:  ldstr      "Barney"
    IL_0034:  ldstr      "Betty"
    IL_0039:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::get_Empty()
    IL_003e:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0043:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0048:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_004d:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0052:  stloc.2
//000187:         "Fred"      // Flintstone
//000188:         "Wilma"     // Flintstone
//000189:         "Barney"    // Rubble
//000190:         "Betty"     // Rubble
//000191:         ]
//000192:     let listOfPeopleTuples = [
    IL_0053:  ldstr      "Ted"
    IL_0058:  ldstr      "Neward"
    IL_005d:  ldc.i4.s   38
    IL_005f:  ldstr      "Redmond"
    IL_0064:  ldstr      "WA"
    IL_0069:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_006e:  ldstr      "Katie"
    IL_0073:  ldstr      "Ellison"
    IL_0078:  ldc.i4.s   30
    IL_007a:  ldstr      "Seattle"
    IL_007f:  ldstr      "WA"
    IL_0084:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_0089:  ldstr      "Mark"
    IL_008e:  ldstr      "Richards"
    IL_0093:  ldc.i4.s   45
    IL_0095:  ldstr      "Boston"
    IL_009a:  ldstr      "MA"
    IL_009f:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00a4:  ldstr      "Rachel"
    IL_00a9:  ldstr      "Reese"
    IL_00ae:  ldc.i4.s   27
    IL_00b0:  ldstr      "Phoenix"
    IL_00b5:  ldstr      "AZ"
    IL_00ba:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00bf:  ldstr      "Ken"
    IL_00c4:  ldstr      "Sipe"
    IL_00c9:  ldc.i4.s   43
    IL_00cb:  ldstr      "St Louis"
    IL_00d0:  ldstr      "MO"
    IL_00d5:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00da:  ldstr      "Naomi"
    IL_00df:  ldstr      "Wilson"
    IL_00e4:  ldc.i4.s   35
    IL_00e6:  ldstr      "Seattle"
    IL_00eb:  ldstr      "WA"
    IL_00f0:  newobj     instance void class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>::.ctor(!0,
                                                                                                                   !1,
                                                                                                                   !2,
                                                                                                                   !3,
                                                                                                                   !4)
    IL_00f5:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::get_Empty()
    IL_00fa:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00ff:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0104:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0109:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_010e:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0113:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`5<string,string,int32,string,string>>::Cons(!0,
                                                                                                                                                                                                                                   class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0118:  stloc.3
//000193:         ("Ted", "Neward", 38, "Redmond", "WA")
//000194:         ("Katie", "Ellison", 30, "Seattle", "WA")
//000195:         ("Mark", "Richards", 45, "Boston", "MA")
//000196:         ("Rachel", "Reese", 27, "Phoenix", "AZ")
//000197:         ("Ken", "Sipe", 43, "St Louis", "MO")
//000198:         ("Naomi", "Wilson", 35, "Seattle", "WA")
//000199:         ]
//000200:     let listOfIntegersToTen = [ 1 .. 10 ]  // [ 1; 2; 3; ... 10; ]
    IL_0119:  ldc.i4.1
    IL_011a:  ldc.i4.1
    IL_011b:  ldc.i4.s   10
    IL_011d:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_0122:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0127:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToList<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_012c:  stloc.s    listOfIntegersToTen
//000201:     let listOfEvenIntsToTen = [ 0 .. 2 .. 10 ] 
    IL_012e:  ldc.i4.0
    IL_012f:  ldc.i4.2
    IL_0130:  ldc.i4.s   10
    IL_0132:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_0137:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_013c:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToList<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0141:  stloc.s    listOfEvenIntsToTen
//000202:         // [ 0; 2; 4; ... 10; ]
//000203:     let listOfFloatsToTen = [ 0.0 .. 0.5 .. 10.0 ]
    IL_0143:  ldc.r8     0.0
    IL_014c:  ldc.r8     0.5
    IL_0155:  ldc.r8     10.
    IL_015e:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<float64> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeDouble(float64,
                                                                                                                                                                        float64,
                                                                                                                                                                        float64)
    IL_0163:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0168:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToList<float64>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_016d:  stloc.s    listOfFloatsToTen
//000204:     let consedList = 1 :: 2 :: 3 :: 4 :: []
    IL_016f:  ldc.i4.1
    IL_0170:  ldc.i4.2
    IL_0171:  ldc.i4.3
    IL_0172:  ldc.i4.4
    IL_0173:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::get_Empty()
    IL_0178:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_017d:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0182:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0187:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<int32>::Cons(!0,
                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_018c:  stloc.s    consedList
//000205: //    let mutable forBuiltList = []
//000206: //    for i = 1 to 10 do
//000207: //        forBuiltList <- (i * i) :: forBuiltList
//000208:     let forBuiltList = [ for i in 1 .. 10 -> i * i]
    IL_018e:  ldc.i4.0
    IL_018f:  ldnull
    IL_0190:  ldc.i4.0
    IL_0191:  ldc.i4.0
    IL_0192:  newobj     instance void SimpleCompositeTypes/forBuiltList@208::.ctor(int32,
                                                                                    class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                                    int32,
                                                                                    int32)
    IL_0197:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::ToList<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_019c:  stloc.s    forBuiltList
//000209:     let concattedList = listOfIntegers @ consedList
    IL_019e:  ldloc.1
    IL_019f:  ldloc.s    consedList
    IL_01a1:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::op_Append<int32>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>,
                                                                                                                                                          class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_01a6:  stloc.s    concattedList
//000210:         // [ 1; 2; 3; 4; 1; 2; 3; 4; ]
//000211:     listOfStrings
    IL_01a8:  ldloc.2
    IL_01a9:  ret
  } // end of method SimpleCompositeTypes::list_examples_1

  .method public static class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object> 
          list_examples_2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 0F 4C 69 73 74 20 65 78 61 6D 70 6C 65 73   // ...List examples
                                                                        20 32 00 00 )                                     //  2..
    // Code size       49 (0x31)
    .maxstack  6
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object> objectList)
//000212: 
//000213: [<Example("List examples 2")>]
//000214: let list_examples_2() =
//000215:     //let notWorkingList = [ 1; "2"; 3.0; ]
//000216:     let (objectList : obj list) = [
    IL_0000:  nop
    IL_0001:  ldc.i4.1
    IL_0002:  box        [mscorlib]System.Int32
    IL_0007:  ldstr      "2"
    IL_000c:  ldc.r8     3.
    IL_0015:  box        [mscorlib]System.Double
    IL_001a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object>::get_Empty()
    IL_001f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0024:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0029:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<object>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_002e:  stloc.0
//000217:         (1 :> obj)
//000218:         ("2" :> obj)
//000219:         (3.0 :> obj)
//000220:     ]
//000221:     objectList
    IL_002f:  ldloc.0
    IL_0030:  ret
  } // end of method SimpleCompositeTypes::list_examples_2

  .method public static void  list_examples_3() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 14 4C 69 73 74 20 61 63 63 65 73 73 20 65   // ...List access e
                                                                        78 61 6D 70 6C 65 73 00 00 )                      // xamples..
    // Code size       225 (0xe1)
    .maxstack  8
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>> people,
             [1] class [FSharp.Core]System.Tuple`3<string,string,int32> peopleHead,
             [2] class [FSharp.Core]System.Tuple`3<string,string,int32> firstPerson,
             [3] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>> V_3,
             [4] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>> V_4,
             [5] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>> rest,
             [6] class [FSharp.Core]System.Tuple`3<string,string,int32> personOne,
             [7] class [FSharp.Core]System.Tuple`3<string,string,int32> secondPerson,
             [8] class [FSharp.Core]System.Tuple`3<string,string,int32> otherSecondPerson,
             [9] class [FSharp.Core]System.Tuple`3<string,string,int32> noSuchPerson)
//000222: 
//000223: [<Example("List access examples")>]
//000224: let list_examples_3() =
//000225:     let people = [
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  ldc.i4.s   38
    IL_000d:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0012:  ldstr      "Mark"
    IL_0017:  ldstr      "Richards"
    IL_001c:  ldc.i4.s   45
    IL_001e:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0023:  ldstr      "Naomi"
    IL_0028:  ldstr      "Wilson"
    IL_002d:  ldc.i4.s   38
    IL_002f:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0034:  ldstr      "Ken"
    IL_0039:  ldstr      "Sipe"
    IL_003e:  ldc.i4.s   43
    IL_0040:  newobj     instance void class [FSharp.Core]System.Tuple`3<string,string,int32>::.ctor(!0,
                                                                                                     !1,
                                                                                                     !2)
    IL_0045:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_Empty()
    IL_004a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_004f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0054:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0059:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::Cons(!0,
                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_005e:  stloc.0
//000226:         ("Ted", "Neward", 38)
//000227:         ("Mark", "Richards", 45)
//000228:         ("Naomi", "Wilson", 38)
//000229:         ("Ken", "Sipe", 43)
//000230:     ]
//000231:     let peopleHead = people.Head
    IL_005f:  ldloc.0
    IL_0060:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_Head()
    IL_0065:  stloc.1
//000232:     System.Console.WriteLine(peopleHead)
    IL_0066:  ldloc.1
    IL_0067:  call       void [mscorlib]System.Console::WriteLine(object)
//000233:     let firstPerson = List.head people
    IL_006c:  ldloc.0
    IL_006d:  call       !!0 [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Head<class [FSharp.Core]System.Tuple`3<string,string,int32>>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_0072:  stloc.2
//000234:     System.Console.WriteLine(firstPerson)
    IL_0073:  ldloc.2
    IL_0074:  call       void [mscorlib]System.Console::WriteLine(object)
//000235:     let (personOne :: rest) = people
    IL_0079:  ldloc.0
    IL_007a:  stloc.3
    IL_007b:  ldloc.3
    IL_007c:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_TailOrNull()
    IL_0081:  brfalse.s  IL_0085

    IL_0083:  br.s       IL_0087

    IL_0085:  br.s       IL_00d0

//000236:     System.Console.WriteLine(personOne)
//000237:     let secondPerson = people.[1]
//000238:     System.Console.WriteLine(secondPerson)
//000239:     let otherSecondPerson = List.nth people 1
//000240:     let noSuchPerson = List.nth people 5
//000241:     System.Console.WriteLine("Expecting an exception above")
//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0087:  ldloc.3
    IL_0088:  stloc.s    V_4
    IL_008a:  ldloc.s    V_4
    IL_008c:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_TailOrNull()
    IL_0091:  stloc.s    rest
    IL_0093:  ldloc.s    V_4
    IL_0095:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_HeadOrDefault()
    IL_009a:  stloc.s    personOne
//000236:     System.Console.WriteLine(personOne)
    IL_009c:  ldloc.s    personOne
    IL_009e:  call       void [mscorlib]System.Console::WriteLine(object)
//000237:     let secondPerson = people.[1]
    IL_00a3:  ldloc.0
    IL_00a4:  ldc.i4.1
    IL_00a5:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`3<string,string,int32>>::get_Item(int32)
    IL_00aa:  stloc.s    secondPerson
//000238:     System.Console.WriteLine(secondPerson)
    IL_00ac:  ldloc.s    secondPerson
    IL_00ae:  call       void [mscorlib]System.Console::WriteLine(object)
//000239:     let otherSecondPerson = List.nth people 1
    IL_00b3:  ldloc.0
    IL_00b4:  ldc.i4.1
    IL_00b5:  call       !!0 [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Get<class [FSharp.Core]System.Tuple`3<string,string,int32>>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>,
                                                                                                                                               int32)
    IL_00ba:  stloc.s    otherSecondPerson
//000240:     let noSuchPerson = List.nth people 5
    IL_00bc:  ldloc.0
    IL_00bd:  ldc.i4.5
    IL_00be:  call       !!0 [FSharp.Core]Microsoft.FSharp.Collections.ListModule::Get<class [FSharp.Core]System.Tuple`3<string,string,int32>>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>,
                                                                                                                                               int32)
    IL_00c3:  stloc.s    noSuchPerson
//000241:     System.Console.WriteLine("Expecting an exception above")
    IL_00c5:  ldstr      "Expecting an exception above"
    IL_00ca:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_00cf:  ret

//000242: 
//000243: // ============== Sequences
//000244: [<Example("Sequence initializers")>]
//000245: let seq_examples_1() =
//000246:     let threeNums = seq {0 .. 2}
//000247:     let lotsOfNums = seq {0 .. 100000000}
//000248:     let people = [
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
//000257:     let x = seq { for i = 1 to 10 do yield i }
//000258:     System.Console.WriteLine(x)
//000259:     let y = seq { for i = 1 to 10 do
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
//000263:     if yEnum.MoveNext() then
//000264:         System.Console.WriteLine(yEnum.Current)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_00d0:  ldstr      "C:\\Users\\faa634\\Desktop\\book codes\\F#\\Code\\Basics"
    + "\\CompositeTypes.fs"
    IL_00d5:  ldc.i4     0xeb
    IL_00da:  ldc.i4.8
    IL_00db:  newobj     instance void [FSharp.Core]Microsoft.FSharp.Core.MatchFailureException::.ctor(string,
                                                                                                       int32,
                                                                                                       int32)
    IL_00e0:  throw
  } // end of method SimpleCompositeTypes::list_examples_3

  .method public static void  seq_examples_1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 15 53 65 71 75 65 6E 63 65 20 69 6E 69 74   // ...Sequence init
                                                                        69 61 6C 69 7A 65 72 73 00 00 )                   // ializers..
    // Code size       284 (0x11c)
    .maxstack  8
    .locals init ([0] class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> threeNums,
             [1] class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> lotsOfNums,
             [2] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person> people,
             [3] class [mscorlib]System.Collections.Generic.IEnumerable`1<class HelperTypes/Person> seqPeople,
             [4] class [mscorlib]System.Collections.Generic.IEnumerable`1<class HelperTypes/Person> newards,
             [5] class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> x,
             [6] class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> y,
             [7] class [mscorlib]System.Collections.Generic.IEnumerator`1<int32> yEnum,
             [8] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>>> randomNumberGenerator,
             [9] class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> diceRolls,
             [10] class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<int32,int32>> squares)
//000246:     let threeNums = seq {0 .. 2}
    IL_0000:  nop
    IL_0001:  ldc.i4.0
    IL_0002:  ldc.i4.1
    IL_0003:  ldc.i4.2
    IL_0004:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_0009:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_000e:  stloc.0
//000247:     let lotsOfNums = seq {0 .. 100000000}
    IL_000f:  ldc.i4.0
    IL_0010:  ldc.i4.1
    IL_0011:  ldc.i4     0x5f5e100
    IL_0016:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [FSharp.Core]Microsoft.FSharp.Core.Operators/OperatorIntrinsics::RangeInt32(int32,
                                                                                                                                                                     int32,
                                                                                                                                                                     int32)
    IL_001b:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.Operators::CreateSequence<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0020:  stloc.1
//000248:     let people = [
    IL_0021:  ldstr      "Ted"
    IL_0026:  ldstr      "Neward"
    IL_002b:  ldc.i4.s   38
    IL_002d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0032:  ldstr      "Mark"
    IL_0037:  ldstr      "Richards"
    IL_003c:  ldc.i4.s   45
    IL_003e:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0043:  ldstr      "Naomi"
    IL_0048:  ldstr      "Wilson"
    IL_004d:  ldc.i4.s   38
    IL_004f:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0054:  ldstr      "Ken"
    IL_0059:  ldstr      "Sipe"
    IL_005e:  ldc.i4.s   43
    IL_0060:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0065:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::get_Empty()
    IL_006a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_006f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0074:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0079:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_007e:  stloc.2
//000249:         new Person("Ted", "Neward", 38)
//000250:         new Person("Mark", "Richards", 45)
//000251:         new Person("Naomi", "Wilson", 38)
//000252:         new Person("Ken", "Sipe", 43)
//000253:     ]
//000254:     let seqPeople = Seq.ofList people
    IL_007f:  ldloc.2
    IL_0080:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::OfList<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_0085:  stloc.3
//000255:     let newards = Seq.filter (fun (it : Person) -> it.LastName = "Neward") seqPeople
    IL_0086:  newobj     instance void SimpleCompositeTypes/newards@255::.ctor()
    IL_008b:  ldloc.3
    IL_008c:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::Filter<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,bool>,
                                                                                                                                                                             class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0091:  stloc.s    newards
//000256:     Seq.iter (fun (it : Person) -> System.Console.WriteLine("Found " + it.ToString())) newards
    IL_0093:  newobj     instance void SimpleCompositeTypes/seq_examples_1@256::.ctor()
    IL_0098:  ldloc.s    newards
    IL_009a:  call       void [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::Iterate<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                                     class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_009f:  nop
//000257:     let x = seq { for i = 1 to 10 do yield i }
    IL_00a0:  ldc.i4.0
    IL_00a1:  ldnull
    IL_00a2:  ldc.i4.0
    IL_00a3:  ldc.i4.0
    IL_00a4:  newobj     instance void SimpleCompositeTypes/x@257::.ctor(int32,
                                                                         class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                         int32,
                                                                         int32)
    IL_00a9:  stloc.s    x
//000258:     System.Console.WriteLine(x)
    IL_00ab:  ldloc.s    x
    IL_00ad:  call       void [mscorlib]System.Console::WriteLine(object)
//000259:     let y = seq { for i = 1 to 10 do
    IL_00b2:  ldc.i4.0
    IL_00b3:  ldnull
    IL_00b4:  ldc.i4.0
    IL_00b5:  ldc.i4.0
    IL_00b6:  newobj     instance void SimpleCompositeTypes/y@259::.ctor(int32,
                                                                         class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                         int32,
                                                                         int32)
    IL_00bb:  stloc.s    y
//000260:                     System.Console.WriteLine("Generating {0}", i)
//000261:                     yield i }
//000262:     let yEnum = y.GetEnumerator()
    IL_00bd:  ldloc.s    y
    IL_00bf:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>::GetEnumerator()
    IL_00c4:  stloc.s    yEnum
//000263:     if yEnum.MoveNext() then
    IL_00c6:  ldloc.s    yEnum
    IL_00c8:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
    IL_00cd:  brfalse.s  IL_00d1

    IL_00cf:  br.s       IL_00d3

    IL_00d1:  br.s       IL_00e2

//000264:         System.Console.WriteLine(yEnum.Current)
    IL_00d3:  ldloc.s    yEnum
    IL_00d5:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>::get_Current()
    IL_00da:  call       void [mscorlib]System.Console::WriteLine(int32)
//000265:     let randomNumberGenerator minVal maxVal =
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
//000272:     System.Console.WriteLine(squares)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
//000282:     for fi in rootFiles do printFileInfo fi
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_00df:  nop
    IL_00e0:  br.s       IL_00e3

    IL_00e2:  nop
//000265:     let randomNumberGenerator minVal maxVal =
    IL_00e3:  newobj     instance void SimpleCompositeTypes/randomNumberGenerator@266::.ctor()
    IL_00e8:  stloc.s    randomNumberGenerator
//000266:         let randomer = new System.Random(System.DateTime.Now.Millisecond)
//000267:         seq { while (true) do yield (randomer.Next(maxVal - minVal) + minVal) }
//000268:     let diceRolls = (randomNumberGenerator 3 18) |> Seq.take 6
    IL_00ea:  ldc.i4.6
    IL_00eb:  ldloc.s    randomNumberGenerator
    IL_00ed:  ldc.i4.3
    IL_00ee:  ldc.i4.s   18
    IL_00f0:  call       !!0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,int32>::InvokeFast<class [mscorlib]System.Collections.Generic.IEnumerable`1<int32>>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!0,class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!1,!!0>>,
                                                                                                                                                                             !0,
                                                                                                                                                                             !1)
    IL_00f5:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::Take<int32>(int32,
                                                                                                                                                        class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00fa:  stloc.s    diceRolls
//000269:     Seq.iter (fun (roll : int) -> System.Console.WriteLine("You rolled a " + roll.ToString())) diceRolls
    IL_00fc:  newobj     instance void SimpleCompositeTypes/'seq_examples_1@269-1'::.ctor()
    IL_0101:  ldloc.s    diceRolls
    IL_0103:  call       void [FSharp.Core]Microsoft.FSharp.Collections.SeqModule::Iterate<int32>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Core.Unit>,
                                                                                                  class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0108:  nop
//000270: 
//000271:     let squares = seq { for i in 0 .. 10 -> (i, i*i) }
    IL_0109:  ldc.i4.0
    IL_010a:  ldnull
    IL_010b:  ldc.i4.0
    IL_010c:  ldnull
    IL_010d:  newobj     instance void SimpleCompositeTypes/squares@271::.ctor(int32,
                                                                               class [mscorlib]System.Collections.Generic.IEnumerator`1<int32>,
                                                                               int32,
                                                                               class [FSharp.Core]System.Tuple`2<int32,int32>)
    IL_0112:  stloc.s    squares
//000272:     System.Console.WriteLine(squares)
    IL_0114:  ldloc.s    squares
    IL_0116:  call       void [mscorlib]System.Console::WriteLine(object)
    IL_011b:  ret
  } // end of method SimpleCompositeTypes::seq_examples_1

  .method public static void  seq_examples2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1D 53 65 71 75 65 6E 63 65 20 64 69 72 65   // ...Sequence dire
                                                                        63 74 6F 72 79 20 6F 70 65 72 61 74 69 6F 6E 73   // ctory operations
                                                                        00 00 ) 
    // Code size       104 (0x68)
    .maxstack  4
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>> dir,
             [1] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileSystemInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit> printFileInfo,
             [2] class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo> rootFiles,
             [3] class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo> V_3,
             [4] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo> V_4,
             [5] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_5,
             [6] class [mscorlib]System.IO.FileSystemInfo fi,
             [7] class [mscorlib]System.IDisposable V_7)
//000273: 
//000274: [<Example("Sequence directory operations")>]
//000275: let seq_examples2() =
//000276:     let dir d = 
    IL_0000:  nop
    IL_0001:  newobj     instance void SimpleCompositeTypes/dir@277::.ctor()
    IL_0006:  stloc.0
    IL_0007:  newobj     instance void SimpleCompositeTypes/printFileInfo@280::.ctor()
    IL_000c:  stloc.1
//000277:         let di = new System.IO.DirectoryInfo(d)
//000278:         seq { for fi in di.GetFileSystemInfos() -> fi }
//000279:     let printFileInfo (fi : System.IO.FileSystemInfo) =
//000280:         System.Console.WriteLine("{0}", fi.FullName)
//000281:     let rootFiles = dir "C:\\"
    IL_000d:  ldloc.0
    IL_000e:  ldstr      "C:\\"
    IL_0013:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<string,class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>>::Invoke(!0)
    IL_0018:  stloc.2
//000282:     for fi in rootFiles do printFileInfo fi
    IL_0019:  ldloc.2
    IL_001a:  stloc.3
    IL_001b:  ldloc.3
    IL_001c:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.IO.FileSystemInfo>::GetEnumerator()
    IL_0021:  stloc.s    V_4
    .try
    {
      IL_0023:  ldloc.s    V_4
      IL_0025:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_002a:  brfalse.s  IL_0041

      IL_002c:  ldloc.s    V_4
      IL_002e:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.IO.FileSystemInfo>::get_Current()
      IL_0033:  stloc.s    fi
      IL_0035:  ldloc.1
      IL_0036:  ldloc.s    fi
      IL_0038:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [mscorlib]System.IO.FileSystemInfo,class [FSharp.Core]Microsoft.FSharp.Core.Unit>::Invoke(!0)
      IL_003d:  pop
//000283:     
//000284:     (* Uncomment this if you really want to iterate the
//000285:        entire contents of your hard drive :-) *)
//000286:     (*
//000287:     let rec recursiveDir d =
//000288:         let di = new System.IO.DirectoryInfo(d)
//000289:         seq {
//000290:             for f in di.GetFiles() do yield f
//000291:             for sd in di.GetDirectories() do yield! recursiveDir sd.FullName 
//000292:         }
//000293:     let allFiles = recursiveDir @"C:\"
//000294:     for fi in allFiles do printFileInfo fi
//000295:     *)
//000296:     ()
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
//000309:     let nicknames = 
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
//000326:     System.Console.WriteLine(ted)
//000327:     let ted = Map.find "Ted" nicknames
//000328:     System.Console.WriteLine(ted)
//000329: 
//000330:     try
//000331:         let noone = nicknames.["Katie"]
//000332:         System.Console.WriteLine(noone)
//000333:     with 
//000334:     | ex -> System.Console.WriteLine("Katie not found")
//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_003e:  nop
      IL_003f:  br.s       IL_0023

      IL_0041:  ldnull
      IL_0042:  stloc.s    V_5
      IL_0044:  leave.s    IL_0064

    }  // end .try
    finally
    {
      IL_0046:  ldloc.s    V_4
      IL_0048:  isinst     [mscorlib]System.IDisposable
      IL_004d:  stloc.s    V_7
      IL_004f:  ldloc.s    V_7
      IL_0051:  brfalse.s  IL_0055

      IL_0053:  br.s       IL_0057

      IL_0055:  br.s       IL_0061

      IL_0057:  ldloc.s    V_7
      IL_0059:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_005e:  ldnull
      IL_005f:  pop
      IL_0060:  endfinally
      IL_0061:  ldnull
      IL_0062:  pop
      IL_0063:  endfinally
    }  // end handler
    IL_0064:  ldloc.s    V_5
    IL_0066:  pop
//000296:     ()
    IL_0067:  ret
  } // end of method SimpleCompositeTypes::seq_examples2

  .method public static void  map_creation_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 14 4D 61 70 20 63 72 65 61 74 69 6F 6E 20   // ...Map creation 
                                                                        65 78 61 6D 70 6C 65 00 00 )                      // example..
    // Code size       314 (0x13a)
    .maxstack  8
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person> nicknames,
             [1] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person> moreNicknames,
             [2] class [mscorlib]System.Collections.Generic.IDictionary`2<int32,string> numberMappings,
             [3] class [mscorlib]System.Collections.Generic.IDictionary`2<string,class HelperTypes/Person> V_3)
//000297: 
//000298: // ============== Maps
//000299: [<Example("Map creation example")>]
//000300: let map_creation_example() =
//000301:     let nicknames = Map.ofList [ 
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Ted"
    IL_000b:  ldstr      "Neward"
    IL_0010:  ldc.i4.s   38
    IL_0012:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0017:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_001c:  ldstr      "Katie"
    IL_0021:  ldstr      "Katie"
    IL_0026:  ldstr      "Ellison"
    IL_002b:  ldc.i4.s   30
    IL_002d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0032:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_0037:  ldstr      "Michael"
    IL_003c:  ldstr      "Michael"
    IL_0041:  ldstr      "Neward"
    IL_0046:  ldc.i4.s   16
    IL_0048:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_004d:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_0052:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::get_Empty()
    IL_0057:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_005c:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0061:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0066:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Collections.MapModule::OfList<string,class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<!!0,!!1>>)
    IL_006b:  stloc.0
//000302:                         "Ted", new Person("Ted", "Neward", 38);
//000303:                         "Katie", new Person("Katie", "Ellison", 30);
//000304:                         "Michael", new Person("Michael", "Neward", 16) 
//000305:                     ]
//000306:     let moreNicknames = 
    IL_006c:  ldloc.0
    IL_006d:  ldstr      "Mark"
    IL_0072:  ldstr      "William"
    IL_0077:  ldstr      "Richards"
    IL_007c:  ldc.i4.s   45
    IL_007e:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0083:  call       instance class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!0,!1> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person>::Add(!0,
                                                                                                                                                                                                       !1)
    IL_0088:  stloc.1
//000307:         nicknames.Add("Mark", new Person("William", "Richards", 45))
//000308:     let numberMappings = dict [ (1, "One"); (2, "Two"); (3, "Three") ]
    IL_0089:  ldc.i4.1
    IL_008a:  ldstr      "One"
    IL_008f:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,string>::.ctor(!0,
                                                                                              !1)
    IL_0094:  ldc.i4.2
    IL_0095:  ldstr      "Two"
    IL_009a:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,string>::.ctor(!0,
                                                                                              !1)
    IL_009f:  ldc.i4.3
    IL_00a0:  ldstr      "Three"
    IL_00a5:  newobj     instance void class [FSharp.Core]System.Tuple`2<int32,string>::.ctor(!0,
                                                                                              !1)
    IL_00aa:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<int32,string>>::get_Empty()
    IL_00af:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<int32,string>>::Cons(!0,
                                                                                                                                                                                                              class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00b4:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<int32,string>>::Cons(!0,
                                                                                                                                                                                                              class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00b9:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<int32,string>>::Cons(!0,
                                                                                                                                                                                                              class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00be:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<int32,string>>
    IL_00c3:  call       class [mscorlib]System.Collections.Generic.IDictionary`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::CreateDictionary<int32,string>(class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<!!0,!!1>>)
    IL_00c8:  stloc.2
//000309:     let nicknames = 
    IL_00c9:  ldstr      "Ted"
    IL_00ce:  ldstr      "Theodore"
    IL_00d3:  ldstr      "Neward"
    IL_00d8:  ldc.i4.s   38
    IL_00da:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_00df:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_00e4:  ldstr      "Naomi"
    IL_00e9:  ldstr      "Naomi"
    IL_00ee:  ldstr      "Wilson"
    IL_00f3:  ldc.i4.s   38
    IL_00f5:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_00fa:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_00ff:  ldstr      "Ken"
    IL_0104:  ldstr      "Kenneth"
    IL_0109:  ldstr      "Sipe"
    IL_010e:  ldc.i4.s   45
    IL_0110:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0115:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_011a:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::get_Empty()
    IL_011f:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0124:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0129:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_012e:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>
    IL_0133:  call       class [mscorlib]System.Collections.Generic.IDictionary`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::CreateDictionary<string,class HelperTypes/Person>(class [mscorlib]System.Collections.Generic.IEnumerable`1<class [FSharp.Core]System.Tuple`2<!!0,!!1>>)
    IL_0138:  stloc.3
//000310:         dict [ 
//000311:             ("Ted", new Person("Theodore", "Neward", 38))
//000312:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000313:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000314:         ]
//000315:     ()
    IL_0139:  ret
  } // end of method SimpleCompositeTypes::map_creation_example

  .method public static void  map_access_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 12 4D 61 70 20 61 63 63 65 73 73 20 65 78   // ...Map access ex
                                                                        61 6D 70 6C 65 00 00 )                            // ample..
    // Code size       352 (0x160)
    .maxstack  8
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person> nicknames,
             [1] class HelperTypes/Person ted,
             [2] class HelperTypes/Person V_2,
             [3] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_3,
             [4] class HelperTypes/Person noone,
             [5] class [mscorlib]System.Exception ex,
             [6] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_6,
             [7] class HelperTypes/Person V_7,
             [8] class [mscorlib]System.Exception V_8,
             [9] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person> notfound,
             [10] class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person> V_10)
//000316: 
//000317: [<Example("Map access example")>]
//000318: let map_access_example() =
//000319:     let nicknames = 
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Theodore"
    IL_000b:  ldstr      "Neward"
    IL_0010:  ldc.i4.s   38
    IL_0012:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0017:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_001c:  ldstr      "Naomi"
    IL_0021:  ldstr      "Naomi"
    IL_0026:  ldstr      "Wilson"
    IL_002b:  ldc.i4.s   38
    IL_002d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0032:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_0037:  ldstr      "Ken"
    IL_003c:  ldstr      "Kenneth"
    IL_0041:  ldstr      "Sipe"
    IL_0046:  ldc.i4.s   45
    IL_0048:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_004d:  newobj     instance void class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>::.ctor(!0,
                                                                                                                 !1)
    IL_0052:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::get_Empty()
    IL_0057:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_005c:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0061:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<string,class HelperTypes/Person>>::Cons(!0,
                                                                                                                                                                                                                                 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0066:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!!0,!!1> [FSharp.Core]Microsoft.FSharp.Collections.MapModule::OfList<string,class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class [FSharp.Core]System.Tuple`2<!!0,!!1>>)
    IL_006b:  stloc.0
//000320:         Map.ofList [
//000321:             ("Ted", new Person("Theodore", "Neward", 38))
//000322:             ("Naomi", new Person("Naomi", "Wilson", 38))
//000323:             ("Ken", new Person("Kenneth", "Sipe", 45)) 
//000324:         ]
//000325:     let ted = nicknames.["Ted"]
    IL_006c:  ldloc.0
    IL_006d:  ldstr      "Ted"
    IL_0072:  call       instance !1 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person>::get_Item(!0)
    IL_0077:  stloc.1
//000326:     System.Console.WriteLine(ted)
    IL_0078:  ldloc.1
    IL_0079:  call       void [mscorlib]System.Console::WriteLine(object)
//000327:     let ted = Map.find "Ted" nicknames
    IL_007e:  ldstr      "Ted"
    IL_0083:  ldloc.0
    IL_0084:  call       !!1 [FSharp.Core]Microsoft.FSharp.Collections.MapModule::Find<string,class HelperTypes/Person>(!!0,
                                                                                                                        class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!!0,!!1>)
    IL_0089:  stloc.2
//000328:     System.Console.WriteLine(ted)
    IL_008a:  ldloc.2
    IL_008b:  call       void [mscorlib]System.Console::WriteLine(object)
//000329: 
//000330:     try
    .try
    {
      IL_0090:  nop
//000331:         let noone = nicknames.["Katie"]
      IL_0091:  ldloc.0
      IL_0092:  ldstr      "Katie"
      IL_0097:  call       instance !1 class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person>::get_Item(!0)
      IL_009c:  stloc.s    noone
//000332:         System.Console.WriteLine(noone)
      IL_009e:  ldloc.s    noone
      IL_00a0:  call       void [mscorlib]System.Console::WriteLine(object)
      IL_00a5:  ldnull
      IL_00a6:  stloc.3
      IL_00a7:  leave.s    IL_00be

//000333:     with 
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_00a9:  castclass  [mscorlib]System.Exception
      IL_00ae:  stloc.s    ex
//000334:     | ex -> System.Console.WriteLine("Katie not found")
      IL_00b0:  ldstr      "Katie not found"
      IL_00b5:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_00ba:  ldnull
      IL_00bb:  stloc.3
      IL_00bc:  leave.s    IL_00be

//000335:     
//000336:     try
//000337:         let noone = Map.find "Katie" nicknames
//000338:         System.Console.WriteLine(noone)
//000339:     with
//000340:     | ex -> System.Console.WriteLine("Katie not found")
//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    }  // end handler
    IL_00be:  ldloc.3
    IL_00bf:  pop
//000336:     try
    .try
    {
      IL_00c0:  nop
//000337:         let noone = Map.find "Katie" nicknames
      IL_00c1:  ldstr      "Katie"
      IL_00c6:  ldloc.0
      IL_00c7:  call       !!1 [FSharp.Core]Microsoft.FSharp.Collections.MapModule::Find<string,class HelperTypes/Person>(!!0,
                                                                                                                          class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!!0,!!1>)
      IL_00cc:  stloc.s    V_7
//000338:         System.Console.WriteLine(noone)
      IL_00ce:  ldloc.s    V_7
      IL_00d0:  call       void [mscorlib]System.Console::WriteLine(object)
      IL_00d5:  ldnull
      IL_00d6:  stloc.s    V_6
      IL_00d8:  leave.s    IL_00f0

//000339:     with
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_00da:  castclass  [mscorlib]System.Exception
      IL_00df:  stloc.s    V_8
//000340:     | ex -> System.Console.WriteLine("Katie not found")
      IL_00e1:  ldstr      "Katie not found"
      IL_00e6:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_00eb:  ldnull
      IL_00ec:  stloc.s    V_6
      IL_00ee:  leave.s    IL_00f0

//000341:     
//000342:     let notfound = nicknames.TryFind("Katie")
//000343:     System.Console.WriteLine(
//000344:         if notfound = None then "Not found" 
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    }  // end handler
    IL_00f0:  ldloc.s    V_6
    IL_00f2:  pop
//000342:     let notfound = nicknames.TryFind("Katie")
    IL_00f3:  ldloc.0
    IL_00f4:  ldstr      "Katie"
    IL_00f9:  call       instance class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!1> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<string,class HelperTypes/Person>::TryFind(!0)
    IL_00fe:  stloc.s    notfound
//000343:     System.Console.WriteLine(
    IL_0100:  nop
//000344:         if notfound = None then "Not found" 
    IL_0101:  ldloc.s    notfound
    IL_0103:  ldnull
    IL_0104:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person>>(!!0,
                                                                                                                                                                                                             !!0)
    IL_0109:  brfalse.s  IL_010d

    IL_010b:  br.s       IL_010f

    IL_010d:  br.s       IL_0117

    IL_010f:  ldstr      "Not found"
//000345:         else notfound.Value.ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0114:  nop
    IL_0115:  br.s       IL_0124

//000345:         else notfound.Value.ToString()
    IL_0117:  ldloc.s    notfound
    IL_0119:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person>::get_Value()
    IL_011e:  callvirt   instance string [mscorlib]System.Object::ToString()
//000346:     )
//000347:     let notfound = Map.tryFind "Katie" nicknames
//000348:     System.Console.WriteLine(
//000349:         if notfound = None then "Not found" 
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0123:  nop
    IL_0124:  call       void [mscorlib]System.Console::WriteLine(string)
//000347:     let notfound = Map.tryFind "Katie" nicknames
    IL_0129:  ldstr      "Katie"
    IL_012e:  ldloc.0
    IL_012f:  call       class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<!!1> [FSharp.Core]Microsoft.FSharp.Collections.MapModule::TryFind<string,class HelperTypes/Person>(!!0,
                                                                                                                                                                                    class [FSharp.Core]Microsoft.FSharp.Collections.FSharpMap`2<!!0,!!1>)
    IL_0134:  stloc.s    V_10
//000348:     System.Console.WriteLine(
    IL_0136:  nop
//000349:         if notfound = None then "Not found" 
    IL_0137:  ldloc.s    V_10
    IL_0139:  ldnull
    IL_013a:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/HashCompare::GenericEqualityIntrinsic<class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person>>(!!0,
                                                                                                                                                                                                             !!0)
    IL_013f:  brfalse.s  IL_0143

    IL_0141:  br.s       IL_0145

    IL_0143:  br.s       IL_014d

    IL_0145:  ldstr      "Not found"
//000350:         else notfound.Value.ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_014a:  nop
    IL_014b:  br.s       IL_015a

//000350:         else notfound.Value.ToString()
    IL_014d:  ldloc.s    V_10
    IL_014f:  call       instance !0 class [FSharp.Core]Microsoft.FSharp.Core.FSharpOption`1<class HelperTypes/Person>::get_Value()
    IL_0154:  callvirt   instance string [mscorlib]System.Object::ToString()
//000351:     )
//000352: 
//000353: // ============== Sets
//000354: [<Example("Set examples")>]
//000355: let set_examples1() =
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
//000360:         System.Console.WriteLine(p)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
    IL_0159:  nop
    IL_015a:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_015f:  ret
  } // end of method SimpleCompositeTypes::map_access_example

  .method public static void  set_examples1() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 0C 53 65 74 20 65 78 61 6D 70 6C 65 73 00   // ...Set examples.
                                                                        00 ) 
    // Code size       315 (0x13b)
    .maxstack  9
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<class HelperTypes/Person> setOfPeople,
             [1] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<class HelperTypes/Person> V_1,
             [2] class [mscorlib]System.Collections.Generic.IEnumerator`1<class HelperTypes/Person> V_2,
             [3] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_3,
             [4] class HelperTypes/Person p,
             [5] class [mscorlib]System.IDisposable V_5,
             [6] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<string> setOfNicknames,
             [7] class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<string> V_7,
             [8] class [mscorlib]System.Collections.Generic.IEnumerator`1<string> V_8,
             [9] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_9,
             [10] string V_10,
             [11] class [mscorlib]System.IDisposable V_11)
//000356:     let setOfPeople = Set.ofList [ new Person("Ted", "Neward", 38);
    IL_0000:  nop
    IL_0001:  ldstr      "Ted"
    IL_0006:  ldstr      "Neward"
    IL_000b:  ldc.i4.s   38
    IL_000d:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0012:  ldstr      "Ted"
    IL_0017:  ldstr      "Neward"
    IL_001c:  ldc.i4.s   38
    IL_001e:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0023:  ldstr      "Ted"
    IL_0028:  ldstr      "Neward"
    IL_002d:  ldc.i4.s   38
    IL_002f:  newobj     instance void HelperTypes/Person::.ctor(string,
                                                                 string,
                                                                 int32)
    IL_0034:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::get_Empty()
    IL_0039:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_003e:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0043:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<class HelperTypes/Person>::Cons(!0,
                                                                                                                                                                                       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_0048:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<!!0> [FSharp.Core]Microsoft.FSharp.Collections.SetModule::OfList<class HelperTypes/Person>(class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!!0>)
    IL_004d:  stloc.0
//000357:                                    new Person("Ted", "Neward", 38);
//000358:                                    new Person("Ted", "Neward", 38); ]
//000359:     for p in setOfPeople do
    IL_004e:  ldloc.0
    IL_004f:  stloc.1
    IL_0050:  ldloc.1
    IL_0051:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<class HelperTypes/Person>
    IL_0056:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<class HelperTypes/Person>::GetEnumerator()
    IL_005b:  stloc.2
    .try
    {
      IL_005c:  ldloc.2
      IL_005d:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0062:  brfalse.s  IL_0076

//000360:         System.Console.WriteLine(p)
      IL_0064:  ldloc.2
      IL_0065:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class HelperTypes/Person>::get_Current()
      IL_006a:  stloc.s    p
      IL_006c:  ldloc.s    p
      IL_006e:  call       void [mscorlib]System.Console::WriteLine(object)
//000361: 
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
//000363:     for p in setOfNicknames do
//000364:         System.Console.WriteLine(p)
//000365:         
//000366:     ()
//000367: 
      IL_0073:  nop
      IL_0074:  br.s       IL_005c

      IL_0076:  ldnull
      IL_0077:  stloc.3
      IL_0078:  leave.s    IL_0097

    }  // end .try
    finally
    {
      IL_007a:  ldloc.2
      IL_007b:  isinst     [mscorlib]System.IDisposable
      IL_0080:  stloc.s    V_5
      IL_0082:  ldloc.s    V_5
      IL_0084:  brfalse.s  IL_0088

      IL_0086:  br.s       IL_008a

      IL_0088:  br.s       IL_0094

      IL_008a:  ldloc.s    V_5
      IL_008c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0091:  ldnull
      IL_0092:  pop
      IL_0093:  endfinally
      IL_0094:  ldnull
      IL_0095:  pop
      IL_0096:  endfinally
    }  // end handler
    IL_0097:  ldloc.3
    IL_0098:  pop
//000362:     let setOfNicknames = set [ "Ted"; "Theo"; "Tio"; "Ted"; "Ted"; "Teddy" ]
    IL_0099:  ldstr      "Ted"
    IL_009e:  ldstr      "Theo"
    IL_00a3:  ldstr      "Tio"
    IL_00a8:  ldstr      "Ted"
    IL_00ad:  ldstr      "Ted"
    IL_00b2:  ldstr      "Teddy"
    IL_00b7:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::get_Empty()
    IL_00bc:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00c1:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00c6:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00cb:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00d0:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00d5:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0> class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<string>::Cons(!0,
                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<!0>)
    IL_00da:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<string>
    IL_00df:  call       class [FSharp.Core]Microsoft.FSharp.Collections.FSharpSet`1<!!0> [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::CreateSet<string>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00e4:  stloc.s    setOfNicknames
//000363:     for p in setOfNicknames do
    IL_00e6:  ldloc.s    setOfNicknames
    IL_00e8:  stloc.s    V_7
    IL_00ea:  ldloc.s    V_7
    IL_00ec:  unbox.any  class [mscorlib]System.Collections.Generic.IEnumerable`1<string>
    IL_00f1:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<string>::GetEnumerator()
    IL_00f6:  stloc.s    V_8
    .try
    {
      IL_00f8:  ldloc.s    V_8
      IL_00fa:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_00ff:  brfalse.s  IL_0114

//000364:         System.Console.WriteLine(p)
      IL_0101:  ldloc.s    V_8
      IL_0103:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<string>::get_Current()
      IL_0108:  stloc.s    V_10
      IL_010a:  ldloc.s    V_10
      IL_010c:  call       void [mscorlib]System.Console::WriteLine(string)
//000365:         
//000366:     ()
//000367: 
      IL_0111:  nop
      IL_0112:  br.s       IL_00f8

      IL_0114:  ldnull
      IL_0115:  stloc.s    V_9
      IL_0117:  leave.s    IL_0137

    }  // end .try
    finally
    {
      IL_0119:  ldloc.s    V_8
      IL_011b:  isinst     [mscorlib]System.IDisposable
      IL_0120:  stloc.s    V_11
      IL_0122:  ldloc.s    V_11
      IL_0124:  brfalse.s  IL_0128

      IL_0126:  br.s       IL_012a

      IL_0128:  br.s       IL_0134

      IL_012a:  ldloc.s    V_11
      IL_012c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0131:  ldnull
      IL_0132:  pop
      IL_0133:  endfinally
      IL_0134:  ldnull
      IL_0135:  pop
      IL_0136:  endfinally
    }  // end handler
    IL_0137:  ldloc.s    V_9
    IL_0139:  pop
    IL_013a:  ret
  } // end of method SimpleCompositeTypes::set_examples1

} // end of class SimpleCompositeTypes

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$SimpleCompositeTypes
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Basics>'.$SimpleCompositeTypes

.class public abstract auto ansi sealed FlowControl
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public beforefieldinit MyException
         extends [mscorlib]System.Exception
         implements [FSharp.Core]System.Collections.IStructuralEquatable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 05 00 00 00 00 00 ) 
    .method public specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  4
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Exception::.ctor()
      IL_0006:  ret
    } // end of method MyException::.ctor

    .method family specialname rtspecialname 
            instance void  .ctor(class [mscorlib]System.Runtime.Serialization.SerializationInfo info,
                                 valuetype [mscorlib]System.Runtime.Serialization.StreamingContext context) cil managed
    {
      // Code size       9 (0x9)
      .maxstack  10
      IL_0000:  ldarg.0
      IL_0001:  ldarg.1
      IL_0002:  ldarg.2
      IL_0003:  call       instance void [mscorlib]System.Exception::.ctor(class [mscorlib]System.Runtime.Serialization.SerializationInfo,
                                                                           valuetype [mscorlib]System.Runtime.Serialization.StreamingContext)
      IL_0008:  ret
    } // end of method MyException::.ctor

    .method public hidebysig virtual instance int32 
            GetHashCode(class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       15 (0xf)
      .maxstack  3
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_000d

      IL_000b:  ldc.i4.0
      IL_000c:  ret

      IL_000d:  ldc.i4.0
      IL_000e:  ret
    } // end of method MyException::GetHashCode

    .method public hidebysig virtual instance int32 
            GetHashCode() cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       13 (0xd)
      .maxstack  4
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\FlowControl.fs' 
//000108: exception MyException
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       class [mscorlib]System.Collections.IEqualityComparer [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives::get_GenericEqualityComparer()
      IL_0007:  callvirt   instance int32 FlowControl/MyException::GetHashCode(class [mscorlib]System.Collections.IEqualityComparer)
      IL_000c:  ret
    } // end of method MyException::GetHashCode

    .method public hidebysig virtual instance bool 
            Equals(object obj,
                   class [mscorlib]System.Collections.IEqualityComparer comp) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       49 (0x31)
      .maxstack  4
      .locals init (class [mscorlib]System.Exception V_0)
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0029

      IL_000b:  ldarg.1
      IL_000c:  isinst     [mscorlib]System.Exception
      IL_0011:  stloc.0
      IL_0012:  ldloc.0
      IL_0013:  brfalse.s  IL_0017

      IL_0015:  br.s       IL_0019

      IL_0017:  br.s       IL_0027

      IL_0019:  ldloc.0
      IL_001a:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::TypeTestGeneric<class FlowControl/MyException>(object)
      IL_001f:  brtrue.s   IL_0023

      IL_0021:  br.s       IL_0025

      IL_0023:  ldc.i4.1
      IL_0024:  ret

      IL_0025:  ldc.i4.0
      IL_0026:  ret

      IL_0027:  ldc.i4.0
      IL_0028:  ret

      IL_0029:  ldarg.1
      IL_002a:  ldnull
      IL_002b:  cgt.un
      IL_002d:  ldc.i4.0
      IL_002e:  ceq
      IL_0030:  ret
    } // end of method MyException::Equals

    .method public instance bool  Equals(class [mscorlib]System.Exception obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       45 (0x2d)
      .maxstack  4
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldnull
      IL_0003:  cgt.un
      IL_0005:  brfalse.s  IL_0009

      IL_0007:  br.s       IL_000b

      IL_0009:  br.s       IL_0025

      IL_000b:  ldarg.1
      IL_000c:  ldnull
      IL_000d:  cgt.un
      IL_000f:  brfalse.s  IL_0013

      IL_0011:  br.s       IL_0015

      IL_0013:  br.s       IL_0023

      IL_0015:  ldarg.1
      IL_0016:  call       bool [FSharp.Core]Microsoft.FSharp.Core.LanguagePrimitives/IntrinsicFunctions::TypeTestGeneric<class FlowControl/MyException>(object)
      IL_001b:  brtrue.s   IL_001f

      IL_001d:  br.s       IL_0021

      IL_001f:  ldc.i4.1
      IL_0020:  ret

      IL_0021:  ldc.i4.0
      IL_0022:  ret

      IL_0023:  ldc.i4.0
      IL_0024:  ret

      IL_0025:  ldarg.1
      IL_0026:  ldnull
      IL_0027:  cgt.un
      IL_0029:  ldc.i4.0
      IL_002a:  ceq
      IL_002c:  ret
    } // end of method MyException::Equals

    .method public hidebysig virtual instance bool 
            Equals(object obj) cil managed
    {
      .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
      // Code size       25 (0x19)
      .maxstack  4
      .locals init (class [mscorlib]System.Exception V_0)
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  isinst     [mscorlib]System.Exception
      IL_0007:  stloc.0
      IL_0008:  ldloc.0
      IL_0009:  brfalse.s  IL_000d

      IL_000b:  br.s       IL_000f

      IL_000d:  br.s       IL_0017

      IL_000f:  ldarg.0
      IL_0010:  ldloc.0
      IL_0011:  call       instance bool FlowControl/MyException::Equals(class [mscorlib]System.Exception)
      IL_0016:  ret

      IL_0017:  ldc.i4.0
      IL_0018:  ret
    } // end of method MyException::Equals

  } // end of class MyException

  .method public static void  if_examples() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 0B 49 66 20 65 78 61 6D 70 6C 65 73 00 00 ) // ...If examples..
    // Code size       25 (0x19)
    .maxstack  4
    .locals init ([0] int32 x)
//000009:     let x = 12
    IL_0000:  nop
    IL_0001:  ldc.i4.s   12
    IL_0003:  stloc.0
//000010:     if x = 12 then
    IL_0004:  ldloc.0
    IL_0005:  ldc.i4.s   12
    IL_0007:  bne.un.s   IL_000b

    IL_0009:  br.s       IL_000d

    IL_000b:  br.s       IL_0018

//000011:         System.Console.WriteLine("Yes, x is 12")
    IL_000d:  ldstr      "Yes, x is 12"
    IL_0012:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0017:  ret

//000012:         
//000013: [<Example("If-else examples")>]
//000014: let if_else_examples() =
//000015:     let x = 12
//000016:     if x = 12 then
//000017:         System.Console.WriteLine("Yes, x is 12")
//000018:     else
//000019:         System.Console.WriteLine("Nope, it's not 12")
//000020: 
//000021: [<Example("If-else-expression examples")>]
//000022: let if_else_expression() =
//000023:     let x = 12
//000024:     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
//000025:     System.Console.WriteLine(msg)
//000026:     
//000027: [<Example("If-elif examples")>]
//000028: let if_elif_expression() =
//000029:     let x = 12
//000030:     if x = 12 then
//000031:         System.Console.WriteLine("Yes, x is 12")
//000032:     elif x = 24 then
//000033:         System.Console.WriteLine("Well, now x is 24")
//000034:     else
//000035:         System.Console.WriteLine("I have no clue what x is")
//000036: 
//000037: //let if_else_badexpression =
//000038: //    let x = 12
//000039: //    let msg = if x = 12 then "Yes" else false
//000040: //    System.Console.WriteLine(msg)
//000041: 
//000042: //let if_int_example =
//000043: //    let x = 12
//000044: //    if x then
//000045: //        System.Console.WriteLine("Yep, x")
//000046:         
//000047: [<Example("While and for examples")>]
//000048: let while_and_for_example() =
//000049:     // Uncomment the while loop if it's close to the top of the hour,
//000050:     // or else be prepared to wait for a while. ;-)
//000051:     (*
//000052:     while (System.DateTime.Now.Minute <> 0) do
//000053:         System.Console.WriteLine("Not yet the top of the hour...")
//000054:     *)
//000055: 
//000056:     for i = 1 to System.DateTime.Now.Hour do
//000057:         System.Console.Write("Cuckoo! ")
//000058: 
//000059:     System.Console.WriteLine()
//000060:     
//000061: [<Example("For downto examples")>]
//000062: let for_downto_example() =
//000063:     for i = 10 downto 1 do
//000064:         System.Console.WriteLine("i = {0}", i)
//000065: 
//000066: [<Example("Exception-handling examples")>]
//000067: let exception_handling_example() =
//000068:     let results = 
//000069:         try
//000070:             let req = System.Net.WebRequest.Create(
//000071:                         "Not a legitimate URL")
//000072:             let resp = req.GetResponse()
//000073:             let stream = resp.GetResponseStream()
//000074:             let reader = new System.IO.StreamReader(stream)
//000075:             let html = reader.ReadToEnd()
//000076:             html
//000077:         with
//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
//000080:             | :? System.Net.WebException as webEx -> 
//000081:                 "Some other exception: " + webEx.Message
//000082:             | ex -> "We got an exception: " + ex.Message
//000083:     System.Console.WriteLine(results)
//000084: 
//000085: [<Example("Exception-finally examples")>]
//000086: let exception_handling_example2() =
//000087:     // This will throw an exception, since finally doesn't handle the
//000088:     // exception itself--thus the yellow stack trace in the console
//000089:     // is expected
//000090:     let results =
//000091:         try
//000092:             (12 / 0) 
//000093:         finally
//000094:             System.Console.WriteLine("In finally block")
//000095:     ()
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
//000103:         raise (new System.Exception("I don't wanna!"))
//000104:     finally
//000105:         System.Console.WriteLine("In finally block")
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    IL_0018:  ret
  } // end of method FlowControl::if_examples

  .method public static void  if_else_examples() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 10 49 66 2D 65 6C 73 65 20 65 78 61 6D 70   // ...If-else examp
                                                                        6C 65 73 00 00 )                                  // les..
    // Code size       35 (0x23)
    .maxstack  4
    .locals init ([0] int32 x)
//000015:     let x = 12
    IL_0000:  nop
    IL_0001:  ldc.i4.s   12
    IL_0003:  stloc.0
//000016:     if x = 12 then
    IL_0004:  ldloc.0
    IL_0005:  ldc.i4.s   12
    IL_0007:  bne.un.s   IL_000b

    IL_0009:  br.s       IL_000d

    IL_000b:  br.s       IL_0018

//000017:         System.Console.WriteLine("Yes, x is 12")
    IL_000d:  ldstr      "Yes, x is 12"
    IL_0012:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0017:  ret

//000018:     else
//000019:         System.Console.WriteLine("Nope, it's not 12")
    IL_0018:  ldstr      "Nope, it's not 12"
    IL_001d:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0022:  ret
  } // end of method FlowControl::if_else_examples

  .method public static void  if_else_expression() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1B 49 66 2D 65 6C 73 65 2D 65 78 70 72 65   // ...If-else-expre
                                                                        73 73 69 6F 6E 20 65 78 61 6D 70 6C 65 73 00 00 ) // ssion examples..
    // Code size       36 (0x24)
    .maxstack  4
    .locals init ([0] int32 x,
             [1] string msg)
//000020: 
//000021: [<Example("If-else-expression examples")>]
//000022: let if_else_expression() =
//000023:     let x = 12
    IL_0000:  nop
    IL_0001:  ldc.i4.s   12
    IL_0003:  stloc.0
//000024:     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
    IL_0004:  nop
    IL_0005:  ldloc.0
    IL_0006:  ldc.i4.s   12
    IL_0008:  bne.un.s   IL_000c

    IL_000a:  br.s       IL_000e

    IL_000c:  br.s       IL_0016

    IL_000e:  ldstr      "Yes, x is 12"
//000025:     System.Console.WriteLine(msg)
//000026:     
//000027: [<Example("If-elif examples")>]
//000028: let if_elif_expression() =
//000029:     let x = 12
//000030:     if x = 12 then
//000031:         System.Console.WriteLine("Yes, x is 12")
//000032:     elif x = 24 then
//000033:         System.Console.WriteLine("Well, now x is 24")
//000034:     else
//000035:         System.Console.WriteLine("I have no clue what x is")
//000036: 
//000037: //let if_else_badexpression =
//000038: //    let x = 12
//000039: //    let msg = if x = 12 then "Yes" else false
//000040: //    System.Console.WriteLine(msg)
//000041: 
//000042: //let if_int_example =
//000043: //    let x = 12
//000044: //    if x then
//000045: //        System.Console.WriteLine("Yep, x")
//000046:         
//000047: [<Example("While and for examples")>]
//000048: let while_and_for_example() =
//000049:     // Uncomment the while loop if it's close to the top of the hour,
//000050:     // or else be prepared to wait for a while. ;-)
//000051:     (*
//000052:     while (System.DateTime.Now.Minute <> 0) do
//000053:         System.Console.WriteLine("Not yet the top of the hour...")
//000054:     *)
//000055: 
//000056:     for i = 1 to System.DateTime.Now.Hour do
//000057:         System.Console.Write("Cuckoo! ")
//000058: 
//000059:     System.Console.WriteLine()
//000060:     
//000061: [<Example("For downto examples")>]
//000062: let for_downto_example() =
//000063:     for i = 10 downto 1 do
//000064:         System.Console.WriteLine("i = {0}", i)
//000065: 
//000066: [<Example("Exception-handling examples")>]
//000067: let exception_handling_example() =
//000068:     let results = 
//000069:         try
//000070:             let req = System.Net.WebRequest.Create(
//000071:                         "Not a legitimate URL")
//000072:             let resp = req.GetResponse()
//000073:             let stream = resp.GetResponseStream()
//000074:             let reader = new System.IO.StreamReader(stream)
//000075:             let html = reader.ReadToEnd()
//000076:             html
//000077:         with
//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
//000080:             | :? System.Net.WebException as webEx -> 
//000081:                 "Some other exception: " + webEx.Message
//000082:             | ex -> "We got an exception: " + ex.Message
//000083:     System.Console.WriteLine(results)
//000084: 
//000085: [<Example("Exception-finally examples")>]
//000086: let exception_handling_example2() =
//000087:     // This will throw an exception, since finally doesn't handle the
//000088:     // exception itself--thus the yellow stack trace in the console
//000089:     // is expected
//000090:     let results =
//000091:         try
//000092:             (12 / 0) 
//000093:         finally
//000094:             System.Console.WriteLine("In finally block")
//000095:     ()
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
//000103:         raise (new System.Exception("I don't wanna!"))
//000104:     finally
//000105:         System.Console.WriteLine("In finally block")
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    IL_0013:  nop
    IL_0014:  br.s       IL_001c

//000024:     let msg = if x = 12 then "Yes, x is 12" else "Nope, it's not 12"
    IL_0016:  ldstr      "Nope, it's not 12"
//000025:     System.Console.WriteLine(msg)
//000026:     
//000027: [<Example("If-elif examples")>]
//000028: let if_elif_expression() =
//000029:     let x = 12
//000030:     if x = 12 then
//000031:         System.Console.WriteLine("Yes, x is 12")
//000032:     elif x = 24 then
//000033:         System.Console.WriteLine("Well, now x is 24")
//000034:     else
//000035:         System.Console.WriteLine("I have no clue what x is")
//000036: 
//000037: //let if_else_badexpression =
//000038: //    let x = 12
//000039: //    let msg = if x = 12 then "Yes" else false
//000040: //    System.Console.WriteLine(msg)
//000041: 
//000042: //let if_int_example =
//000043: //    let x = 12
//000044: //    if x then
//000045: //        System.Console.WriteLine("Yep, x")
//000046:         
//000047: [<Example("While and for examples")>]
//000048: let while_and_for_example() =
//000049:     // Uncomment the while loop if it's close to the top of the hour,
//000050:     // or else be prepared to wait for a while. ;-)
//000051:     (*
//000052:     while (System.DateTime.Now.Minute <> 0) do
//000053:         System.Console.WriteLine("Not yet the top of the hour...")
//000054:     *)
//000055: 
//000056:     for i = 1 to System.DateTime.Now.Hour do
//000057:         System.Console.Write("Cuckoo! ")
//000058: 
//000059:     System.Console.WriteLine()
//000060:     
//000061: [<Example("For downto examples")>]
//000062: let for_downto_example() =
//000063:     for i = 10 downto 1 do
//000064:         System.Console.WriteLine("i = {0}", i)
//000065: 
//000066: [<Example("Exception-handling examples")>]
//000067: let exception_handling_example() =
//000068:     let results = 
//000069:         try
//000070:             let req = System.Net.WebRequest.Create(
//000071:                         "Not a legitimate URL")
//000072:             let resp = req.GetResponse()
//000073:             let stream = resp.GetResponseStream()
//000074:             let reader = new System.IO.StreamReader(stream)
//000075:             let html = reader.ReadToEnd()
//000076:             html
//000077:         with
//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
//000080:             | :? System.Net.WebException as webEx -> 
//000081:                 "Some other exception: " + webEx.Message
//000082:             | ex -> "We got an exception: " + ex.Message
//000083:     System.Console.WriteLine(results)
//000084: 
//000085: [<Example("Exception-finally examples")>]
//000086: let exception_handling_example2() =
//000087:     // This will throw an exception, since finally doesn't handle the
//000088:     // exception itself--thus the yellow stack trace in the console
//000089:     // is expected
//000090:     let results =
//000091:         try
//000092:             (12 / 0) 
//000093:         finally
//000094:             System.Console.WriteLine("In finally block")
//000095:     ()
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
//000103:         raise (new System.Exception("I don't wanna!"))
//000104:     finally
//000105:         System.Console.WriteLine("In finally block")
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    IL_001b:  nop
    IL_001c:  stloc.1
//000025:     System.Console.WriteLine(msg)
    IL_001d:  ldloc.1
    IL_001e:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0023:  ret
  } // end of method FlowControl::if_else_expression

  .method public static void  if_elif_expression() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 10 49 66 2D 65 6C 69 66 20 65 78 61 6D 70   // ...If-elif examp
                                                                        6C 65 73 00 00 )                                  // les..
    // Code size       55 (0x37)
    .maxstack  4
    .locals init ([0] int32 x)
//000026:     
//000027: [<Example("If-elif examples")>]
//000028: let if_elif_expression() =
//000029:     let x = 12
    IL_0000:  nop
    IL_0001:  ldc.i4.s   12
    IL_0003:  stloc.0
//000030:     if x = 12 then
    IL_0004:  ldloc.0
    IL_0005:  ldc.i4.s   12
    IL_0007:  bne.un.s   IL_000b

    IL_0009:  br.s       IL_000d

    IL_000b:  br.s       IL_0018

//000031:         System.Console.WriteLine("Yes, x is 12")
    IL_000d:  ldstr      "Yes, x is 12"
    IL_0012:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0017:  ret

//000032:     elif x = 24 then
    IL_0018:  ldloc.0
    IL_0019:  ldc.i4.s   24
    IL_001b:  bne.un.s   IL_001f

    IL_001d:  br.s       IL_0021

    IL_001f:  br.s       IL_002c

//000033:         System.Console.WriteLine("Well, now x is 24")
    IL_0021:  ldstr      "Well, now x is 24"
    IL_0026:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_002b:  ret

//000034:     else
//000035:         System.Console.WriteLine("I have no clue what x is")
    IL_002c:  ldstr      "I have no clue what x is"
    IL_0031:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0036:  ret
  } // end of method FlowControl::if_elif_expression

  .method public static void  while_and_for_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 16 57 68 69 6C 65 20 61 6E 64 20 66 6F 72   // ...While and for
                                                                        20 65 78 61 6D 70 6C 65 73 00 00 )                //  examples..
    // Code size       47 (0x2f)
    .maxstack  5
    .locals init ([0] int32 V_0,
             [1] int32 i,
             [2] valuetype [mscorlib]System.DateTime V_2)
//000036: 
//000037: //let if_else_badexpression =
//000038: //    let x = 12
//000039: //    let msg = if x = 12 then "Yes" else false
//000040: //    System.Console.WriteLine(msg)
//000041: 
//000042: //let if_int_example =
//000043: //    let x = 12
//000044: //    if x then
//000045: //        System.Console.WriteLine("Yep, x")
//000046:         
//000047: [<Example("While and for examples")>]
//000048: let while_and_for_example() =
//000049:     // Uncomment the while loop if it's close to the top of the hour,
//000050:     // or else be prepared to wait for a while. ;-)
//000051:     (*
//000052:     while (System.DateTime.Now.Minute <> 0) do
//000053:         System.Console.WriteLine("Not yet the top of the hour...")
//000054:     *)
//000055: 
//000056:     for i = 1 to System.DateTime.Now.Hour do
    IL_0000:  nop
    IL_0001:  ldc.i4.1
    IL_0002:  stloc.1
    IL_0003:  call       valuetype [mscorlib]System.DateTime [mscorlib]System.DateTime::get_Now()
    IL_0008:  stloc.2
    IL_0009:  ldloca.s   V_2
    IL_000b:  call       instance int32 [mscorlib]System.DateTime::get_Hour()
    IL_0010:  stloc.0
    IL_0011:  ldloc.0
    IL_0012:  ldloc.1
    IL_0013:  blt.s      IL_0029

//000057:         System.Console.Write("Cuckoo! ")
    IL_0015:  ldstr      "Cuckoo! "
    IL_001a:  call       void [mscorlib]System.Console::Write(string)
    IL_001f:  ldloc.1
    IL_0020:  ldc.i4.1
    IL_0021:  add
    IL_0022:  stloc.1
//000056:     for i = 1 to System.DateTime.Now.Hour do
    IL_0023:  ldloc.1
    IL_0024:  ldloc.0
    IL_0025:  ldc.i4.1
    IL_0026:  add
    IL_0027:  bne.un.s   IL_0015

//000057:         System.Console.Write("Cuckoo! ")
//000058: 
//000059:     System.Console.WriteLine()
    IL_0029:  call       void [mscorlib]System.Console::WriteLine()
    IL_002e:  ret
  } // end of method FlowControl::while_and_for_example

  .method public static void  for_downto_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 13 46 6F 72 20 64 6F 77 6E 74 6F 20 65 78   // ...For downto ex
                                                                        61 6D 70 6C 65 73 00 00 )                         // amples..
    // Code size       37 (0x25)
    .maxstack  5
    .locals init ([0] int32 V_0,
             [1] int32 i)
//000060:     
//000061: [<Example("For downto examples")>]
//000062: let for_downto_example() =
//000063:     for i = 10 downto 1 do
    IL_0000:  nop
    IL_0001:  ldc.i4.s   10
    IL_0003:  stloc.1
    IL_0004:  ldc.i4.1
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldloc.1
    IL_0008:  bgt.s      IL_0024

//000064:         System.Console.WriteLine("i = {0}", i)
    IL_000a:  ldstr      "i = {0}"
    IL_000f:  ldloc.1
    IL_0010:  box        [mscorlib]System.Int32
    IL_0015:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_001a:  ldloc.1
    IL_001b:  ldc.i4.1
    IL_001c:  sub
    IL_001d:  stloc.1
//000063:     for i = 10 downto 1 do
    IL_001e:  ldloc.1
    IL_001f:  ldloc.0
    IL_0020:  ldc.i4.1
    IL_0021:  sub
    IL_0022:  bne.un.s   IL_000a

    IL_0024:  ret
  } // end of method FlowControl::for_downto_example

  .method public static void  exception_handling_example() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1B 45 78 63 65 70 74 69 6F 6E 2D 68 61 6E   // ...Exception-han
                                                                        64 6C 69 6E 67 20 65 78 61 6D 70 6C 65 73 00 00 ) // dling examples..
    // Code size       156 (0x9c)
    .maxstack  4
    .locals init ([0] string results,
             [1] string V_1,
             [2] class [System]System.Net.WebRequest req,
             [3] class [System]System.Net.WebResponse resp,
             [4] class [mscorlib]System.IO.Stream 'stream',
             [5] class [mscorlib]System.IO.StreamReader reader,
             [6] string html,
             [7] class [mscorlib]System.Exception V_7,
             [8] class [System]System.UriFormatException V_8,
             [9] class [System]System.Net.WebException V_9,
             [10] class [System]System.Net.WebException webEx,
             [11] class [mscorlib]System.Exception ex)
//000064:         System.Console.WriteLine("i = {0}", i)
//000065: 
//000066: [<Example("Exception-handling examples")>]
//000067: let exception_handling_example() =
//000068:     let results = 
    IL_0000:  nop
    IL_0001:  nop
//000069:         try
    .try
    {
      IL_0002:  nop
//000070:             let req = System.Net.WebRequest.Create(
      IL_0003:  ldstr      "Not a legitimate URL"
      IL_0008:  call       class [System]System.Net.WebRequest [System]System.Net.WebRequest::Create(string)
      IL_000d:  stloc.2
//000071:                         "Not a legitimate URL")
//000072:             let resp = req.GetResponse()
      IL_000e:  ldloc.2
      IL_000f:  callvirt   instance class [System]System.Net.WebResponse [System]System.Net.WebRequest::GetResponse()
      IL_0014:  stloc.3
//000073:             let stream = resp.GetResponseStream()
      IL_0015:  ldloc.3
      IL_0016:  callvirt   instance class [mscorlib]System.IO.Stream [System]System.Net.WebResponse::GetResponseStream()
      IL_001b:  stloc.s    'stream'
//000074:             let reader = new System.IO.StreamReader(stream)
      IL_001d:  ldloc.s    'stream'
      IL_001f:  newobj     instance void [mscorlib]System.IO.StreamReader::.ctor(class [mscorlib]System.IO.Stream)
      IL_0024:  stloc.s    reader
//000075:             let html = reader.ReadToEnd()
      IL_0026:  ldloc.s    reader
      IL_0028:  callvirt   instance string [mscorlib]System.IO.TextReader::ReadToEnd()
      IL_002d:  stloc.s    html
//000076:             html
      IL_002f:  ldloc.s    html
      IL_0031:  stloc.1
      IL_0032:  leave.s    IL_0093

//000077:         with
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_0034:  castclass  [mscorlib]System.Exception
      IL_0039:  stloc.s    V_7
      IL_003b:  ldloc.s    V_7
      IL_003d:  isinst     [System]System.UriFormatException
      IL_0042:  stloc.s    V_8
      IL_0044:  ldloc.s    V_8
      IL_0046:  brfalse.s  IL_004a

      IL_0048:  br.s       IL_005b

      IL_004a:  ldloc.s    V_7
      IL_004c:  isinst     [System]System.Net.WebException
      IL_0051:  stloc.s    V_9
      IL_0053:  ldloc.s    V_9
      IL_0055:  brfalse.s  IL_0059

      IL_0057:  br.s       IL_0063

      IL_0059:  br.s       IL_007b

//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
      IL_005b:  ldstr      "You gave a bad URL"
      IL_0060:  stloc.1
      IL_0061:  leave.s    IL_0093

//000077:         with
      IL_0063:  ldloc.s    V_9
      IL_0065:  stloc.s    webEx
//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
//000080:             | :? System.Net.WebException as webEx -> 
//000081:                 "Some other exception: " + webEx.Message
      IL_0067:  ldstr      "Some other exception: "
      IL_006c:  ldloc.s    webEx
      IL_006e:  callvirt   instance string [mscorlib]System.Exception::get_Message()
      IL_0073:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_0078:  stloc.1
      IL_0079:  leave.s    IL_0093

//000077:         with
      IL_007b:  ldloc.s    V_7
      IL_007d:  stloc.s    ex
//000078:             | :? System.UriFormatException -> 
//000079:                 "You gave a bad URL"
//000080:             | :? System.Net.WebException as webEx -> 
//000081:                 "Some other exception: " + webEx.Message
//000082:             | ex -> "We got an exception: " + ex.Message
      IL_007f:  ldstr      "We got an exception: "
      IL_0084:  ldloc.s    ex
      IL_0086:  callvirt   instance string [mscorlib]System.Exception::get_Message()
      IL_008b:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_0090:  stloc.1
      IL_0091:  leave.s    IL_0093

//000083:     System.Console.WriteLine(results)
//000084: 
//000085: [<Example("Exception-finally examples")>]
//000086: let exception_handling_example2() =
//000087:     // This will throw an exception, since finally doesn't handle the
//000088:     // exception itself--thus the yellow stack trace in the console
//000089:     // is expected
//000090:     let results =
//000091:         try
//000092:             (12 / 0) 
//000093:         finally
//000094:             System.Console.WriteLine("In finally block")
//000095:     ()
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
//000103:         raise (new System.Exception("I don't wanna!"))
//000104:     finally
//000105:         System.Console.WriteLine("In finally block")
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    }  // end handler
    IL_0093:  ldloc.1
    IL_0094:  stloc.0
//000083:     System.Console.WriteLine(results)
    IL_0095:  ldloc.0
    IL_0096:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_009b:  ret
  } // end of method FlowControl::exception_handling_example

  .method public static void  exception_handling_example2() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1A 45 78 63 65 70 74 69 6F 6E 2D 66 69 6E   // ...Exception-fin
                                                                        61 6C 6C 79 20 65 78 61 6D 70 6C 65 73 00 00 )    // ally examples..
    // Code size       27 (0x1b)
    .maxstack  4
    .locals init ([0] int32 results,
             [1] int32 V_1)
//000084: 
//000085: [<Example("Exception-finally examples")>]
//000086: let exception_handling_example2() =
//000087:     // This will throw an exception, since finally doesn't handle the
//000088:     // exception itself--thus the yellow stack trace in the console
//000089:     // is expected
//000090:     let results =
    IL_0000:  nop
    IL_0001:  nop
//000091:         try
    .try
    {
      IL_0002:  nop
//000092:             (12 / 0) 
      IL_0003:  ldc.i4.s   12
      IL_0005:  ldc.i4.0
      IL_0006:  div
      IL_0007:  stloc.1
      IL_0008:  leave.s    IL_0018

//000093:         finally
    }  // end .try
    finally
    {
      IL_000a:  nop
//000094:             System.Console.WriteLine("In finally block")
      IL_000b:  ldstr      "In finally block"
      IL_0010:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_0015:  ldnull
      IL_0016:  pop
      IL_0017:  endfinally
//000095:     ()
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
//000103:         raise (new System.Exception("I don't wanna!"))
//000104:     finally
//000105:         System.Console.WriteLine("In finally block")
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    }  // end handler
    IL_0018:  ldloc.1
    IL_0019:  stloc.0
//000095:     ()
    IL_001a:  ret
  } // end of method FlowControl::exception_handling_example2

  .method public static void  exception_handling_example3() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1A 45 78 63 65 70 74 69 6F 6E 2D 72 61 69   // ...Exception-rai
                                                                        73 69 6E 67 20 65 78 61 6D 70 6C 65 73 00 00 )    // sing examples..
    // Code size       37 (0x25)
    .maxstack  3
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_0)
//000096: 
//000097: [<Example("Exception-raising examples")>]
//000098: let exception_handling_example3() =
//000099:     // This will throw an exception, since finally doesn't handle the
//000100:     // exception itself--thus the yellow stack trace in the console
//000101:     // is expected
//000102:     try
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
//000103:         raise (new System.Exception("I don't wanna!"))
      IL_0002:  ldstr      "I don't wanna!"
      IL_0007:  newobj     instance void [mscorlib]System.Exception::.ctor(string)
      IL_000c:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
      IL_0011:  stloc.0
      IL_0012:  leave.s    IL_0022

//000104:     finally
    }  // end .try
    finally
    {
      IL_0014:  nop
//000105:         System.Console.WriteLine("In finally block")
      IL_0015:  ldstr      "In finally block"
      IL_001a:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_001f:  ldnull
      IL_0020:  pop
      IL_0021:  endfinally
//000106:     ()
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
//000113:         raise MyException
//000114:     with
//000115:         | _ -> System.Console.WriteLine("In finally block")
//000116:     ()
//000117: 
    }  // end handler
    IL_0022:  ldloc.0
    IL_0023:  pop
//000106:     ()
    IL_0024:  ret
  } // end of method FlowControl::exception_handling_example3

  .method public static void  exception_handling_example4() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 1B 4E 65 77 20 65 78 63 65 70 74 69 6F 6E   // ...New exception
                                                                        20 74 79 70 65 20 65 78 61 6D 70 6C 65 73 00 00 ) //  type examples..
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Core.Unit V_0,
             [1] class [mscorlib]System.Exception V_1)
//000107: 
//000108: exception MyException
//000109: 
//000110: [<Example("New exception type examples")>]
//000111: let exception_handling_example4() =
//000112:     try
    IL_0000:  nop
    .try
    {
      IL_0001:  nop
//000113:         raise MyException
      IL_0002:  newobj     instance void FlowControl/MyException::.ctor()
      IL_0007:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [mscorlib]System.Exception)
      IL_000c:  stloc.0
      IL_000d:  leave.s    IL_0023

//000114:     with
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_000f:  castclass  [mscorlib]System.Exception
      IL_0014:  stloc.1
//000115:         | _ -> System.Console.WriteLine("In finally block")
      IL_0015:  ldstr      "In finally block"
      IL_001a:  call       void [mscorlib]System.Console::WriteLine(string)
      IL_001f:  ldnull
      IL_0020:  stloc.0
      IL_0021:  leave.s    IL_0023

//000116:     ()
//000117: 
    }  // end handler
    IL_0023:  ldloc.0
    IL_0024:  pop
    IL_0025:  ret
  } // end of method FlowControl::exception_handling_example4

} // end of class FlowControl

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$FlowControl
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Basics>'.$FlowControl

.class public abstract auto ansi sealed PrimitiveTypes
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public usd
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.MeasureAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
  } // end of class usd

  .class auto ansi serializable nested public euro
         extends [mscorlib]System.Object
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.MeasureAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
  } // end of class euro

  .class auto ansi serializable nested assembly beforefieldinit usdToEuro@38
         extends class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>
  {
    .method assembly specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::.ctor()
      IL_0006:  ret
    } // end of method usdToEuro@38::.ctor

    .method public strict virtual instance float64 
            Invoke(float64 dollars) cil managed
    {
      // Code size       13 (0xd)
      .maxstack  6
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\PrimitiveTypes.fs' 
//000038:         dollars * 1.5<euro/usd>
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  ldc.r8     1.5
      IL_000b:  mul
      IL_000c:  ret
    } // end of method usdToEuro@38::Invoke

  } // end of class usdToEuro@38

  .field public static literal string s2 = "Hello world again!"
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.LiteralAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .method public static void  string_examples() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 07 53 74 72 69 6E 67 73 00 00 )             // ...Strings..
    // Code size       15 (0xf)
    .maxstack  3
    .locals init ([0] string s,
             [1] int32 sLength)
//000009:     let s = "Howdy, world!"
    IL_0000:  nop
    IL_0001:  ldstr      "Howdy, world!"
    IL_0006:  stloc.0
//000010:     let sLength = s.Length
    IL_0007:  ldloc.0
    IL_0008:  call       instance int32 [mscorlib]System.String::get_Length()
    IL_000d:  stloc.1
//000011:     ()
    IL_000e:  ret
  } // end of method PrimitiveTypes::string_examples

  .method public static void  bitwise_operations() cil managed
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 12 42 69 74 77 69 73 65 20 6F 70 65 72 61   // ...Bitwise opera
                                                                        74 69 6F 6E 73 00 00 )                            // tions..
    // Code size       158 (0x9e)
    .maxstack  5
    .locals init ([0] int32 bitwiseAND,
             [1] int32 bitwiseOR,
             [2] int32 bitwiseXOR,
             [3] int32 bitwiseNEG,
             [4] int32 bitwiseSHL,
             [5] int32 V_5,
             [6] int32 V_6,
             [7] int32 bitwiseSHR,
             [8] int32 V_8,
             [9] int32 V_9)
//000012: 
//000013: /// Bitwise operations
//000014: [<Example("Bitwise operations")>]
//000015: let bitwise_operations() =
//000016:     let bitwiseAND = 0b1111 &&& 0b1100
    IL_0000:  nop
    IL_0001:  ldc.i4.s   15
    IL_0003:  ldc.i4.s   12
    IL_0005:  and
    IL_0006:  stloc.0
//000017:     let bitwiseOR = 0b1111 ||| 0b1100
    IL_0007:  ldc.i4.s   15
    IL_0009:  ldc.i4.s   12
    IL_000b:  or
    IL_000c:  stloc.1
//000018:     let bitwiseXOR = 0b1111 ^^^ 0b1100
    IL_000d:  ldc.i4.s   15
    IL_000f:  ldc.i4.s   12
    IL_0011:  xor
    IL_0012:  stloc.2
//000019:     let bitwiseNEG = ~~~ 0b1111
    IL_0013:  ldc.i4.s   15
    IL_0015:  not
    IL_0016:  stloc.3
//000020:     let bitwiseSHL = 0b1111 <<< 1
    IL_0017:  ldc.i4.s   15
    IL_0019:  stloc.s    V_5
    IL_001b:  ldc.i4.1
    IL_001c:  stloc.s    V_6
    IL_001e:  ldloc.s    V_5
    IL_0020:  ldloc.s    V_6
    IL_0022:  ldc.i4.s   31
    IL_0024:  and
    IL_0025:  shl
    IL_0026:  stloc.s    bitwiseSHL
//000021:     let bitwiseSHR = 0b1111 >>> 1
    IL_0028:  ldc.i4.s   15
    IL_002a:  stloc.s    V_8
    IL_002c:  ldc.i4.1
    IL_002d:  stloc.s    V_9
    IL_002f:  ldloc.s    V_8
    IL_0031:  ldloc.s    V_9
    IL_0033:  ldc.i4.s   31
    IL_0035:  and
    IL_0036:  shr
    IL_0037:  stloc.s    bitwiseSHR
//000022:     
//000023:     System.Console.WriteLine("bitwiseAND = {0}", (bitwiseAND = 0b1100))
    IL_0039:  ldstr      "bitwiseAND = {0}"
    IL_003e:  ldloc.0
    IL_003f:  ldc.i4.s   12
    IL_0041:  ceq
    IL_0043:  box        [mscorlib]System.Boolean
    IL_0048:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000024:     System.Console.WriteLine("bitwiseOR = {0}", (bitwiseOR = 0b1111))
    IL_004d:  ldstr      "bitwiseOR = {0}"
    IL_0052:  ldloc.1
    IL_0053:  ldc.i4.s   15
    IL_0055:  ceq
    IL_0057:  box        [mscorlib]System.Boolean
    IL_005c:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000025:     System.Console.WriteLine("bitwiseXOR = {0}", (bitwiseXOR = 0b0011))
    IL_0061:  ldstr      "bitwiseXOR = {0}"
    IL_0066:  ldloc.2
    IL_0067:  ldc.i4.3
    IL_0068:  ceq
    IL_006a:  box        [mscorlib]System.Boolean
    IL_006f:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000026:     //System.Console.WriteLine("bitwiseNEG = {0:B}", (bitwiseNEG))
//000027:     System.Console.WriteLine("bitwiseSHL = {0}", (bitwiseSHL = 0b11110))
    IL_0074:  ldstr      "bitwiseSHL = {0}"
    IL_0079:  ldloc.s    bitwiseSHL
    IL_007b:  ldc.i4.s   30
    IL_007d:  ceq
    IL_007f:  box        [mscorlib]System.Boolean
    IL_0084:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
//000028:     System.Console.WriteLine("bitwiseSHR = {0}", (bitwiseSHR = 0b0111))
    IL_0089:  ldstr      "bitwiseSHR = {0}"
    IL_008e:  ldloc.s    bitwiseSHR
    IL_0090:  ldc.i4.7
    IL_0091:  ceq
    IL_0093:  box        [mscorlib]System.Boolean
    IL_0098:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_009d:  ret
  } // end of method PrimitiveTypes::bitwise_operations

  .method public specialname static class [FSharp.Core]Microsoft.FSharp.Core.Unit 
          get_uom_calculations() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     class [FSharp.Core]Microsoft.FSharp.Core.Unit '<StartupCode$Basics>'.$PrimitiveTypes::uom_calculations@35
    IL_0005:  ret
  } // end of method PrimitiveTypes::get_uom_calculations

  .method public specialname static string 
          get_s() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       7 (0x7)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldstr      "Hello world!"
    IL_0006:  ret
  } // end of method PrimitiveTypes::get_s

  .method public specialname static string 
          get_literals() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     string '<StartupCode$Basics>'.$PrimitiveTypes::literals@46
    IL_0005:  ret
  } // end of method PrimitiveTypes::get_literals

  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       13 (0xd)
    .maxstack  3
//000029: 
//000030: 
//000031: [<Measure>] type usd
//000032: [<Measure>] type euro
//000033: 
//000034: [<Example("Bitwise operations")>]
//000035: let uom_calculations =
//000036:     let usdRoyaltyCheck = 15000.00<usd>
//000037:     let usdToEuro (dollars : float<usd>) =
//000038:         dollars * 1.5<euro/usd>
//000039:     System.Console.WriteLine("Royalties in Euro: {0}", usdToEuro usdRoyaltyCheck)
//000040: 
//000041: let s = "Hello world!"
//000042: 
//000043: [<Literal>]
//000044: let s2 = "Hello world again!"
//000045: 
//000046: let literals =
//000047:     System.Console.WriteLine(s2)
//000048:     s2
    IL_0000:  ldc.i4.0
    IL_0001:  stsfld     int32 '<StartupCode$Basics>'.$PrimitiveTypes::init@
    IL_0006:  ldsfld     int32 '<StartupCode$Basics>'.$PrimitiveTypes::init@
    IL_000b:  pop
    IL_000c:  ret
  } // end of method PrimitiveTypes::.cctor

  .property class [FSharp.Core]Microsoft.FSharp.Core.Unit
          uom_calculations()
  {
    .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 12 42 69 74 77 69 73 65 20 6F 70 65 72 61   // ...Bitwise opera
                                                                        74 69 6F 6E 73 00 00 )                            // tions..
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .get class [FSharp.Core]Microsoft.FSharp.Core.Unit PrimitiveTypes::get_uom_calculations()
  } // end of property PrimitiveTypes::uom_calculations
  .property string s()
  {
    .get string PrimitiveTypes::get_s()
  } // end of property PrimitiveTypes::s
  .property string literals()
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .get string PrimitiveTypes::get_literals()
  } // end of property PrimitiveTypes::literals
} // end of class PrimitiveTypes

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$PrimitiveTypes
       extends [mscorlib]System.Object
{
  .field static assembly initonly class [FSharp.Core]Microsoft.FSharp.Core.Unit uom_calculations@35
  .custom instance void ProFSharp/ExampleAttribute::.ctor(string) = ( 01 00 12 42 69 74 77 69 73 65 20 6F 70 65 72 61   // ...Bitwise opera
                                                                      74 69 6F 6E 73 00 00 )                            // tions..
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly initonly string literals@46
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly int32 init@
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       79 (0x4f)
    .maxstack  5
    .locals init ([0] string s,
             [1] string s2,
             [2] string literals,
             [3] float64 usdRoyaltyCheck,
             [4] class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64> usdToEuro)
//000036:     let usdRoyaltyCheck = 15000.00<usd>
    IL_0000:  nop
    IL_0001:  ldc.r8     15000.
    IL_000a:  stloc.3
    IL_000b:  newobj     instance void PrimitiveTypes/usdToEuro@38::.ctor()
    IL_0010:  stloc.s    usdToEuro
//000037:     let usdToEuro (dollars : float<usd>) =
//000038:         dollars * 1.5<euro/usd>
//000039:     System.Console.WriteLine("Royalties in Euro: {0}", usdToEuro usdRoyaltyCheck)
    IL_0012:  ldstr      "Royalties in Euro: {0}"
    IL_0017:  ldloc.s    usdToEuro
    IL_0019:  ldloc.3
    IL_001a:  callvirt   instance !1 class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<float64,float64>::Invoke(!0)
    IL_001f:  box        [mscorlib]System.Double
    IL_0024:  call       void [mscorlib]System.Console::WriteLine(string,
                                                                  object)
    IL_0029:  ldnull
    IL_002a:  dup
    IL_002b:  stsfld     class [FSharp.Core]Microsoft.FSharp.Core.Unit '<StartupCode$Basics>'.$PrimitiveTypes::uom_calculations@35
    IL_0030:  pop
//000040: 
//000041: let s = "Hello world!"
    IL_0031:  call       string PrimitiveTypes::get_s()
    IL_0036:  stloc.0
//000042: 
//000043: [<Literal>]
//000044: let s2 = "Hello world again!"
    IL_0037:  nop
//000045: 
//000046: let literals =
//000047:     System.Console.WriteLine(s2)
    IL_0038:  ldstr      "Hello world again!"
    IL_003d:  call       void [mscorlib]System.Console::WriteLine(string)
//000048:     s2
    IL_0042:  ldstr      "Hello world again!"
    IL_0047:  dup
    IL_0048:  stsfld     string '<StartupCode$Basics>'.$PrimitiveTypes::literals@46
    IL_004d:  stloc.2
    IL_004e:  ret
  } // end of method $PrimitiveTypes::.cctor

} // end of class '<StartupCode$Basics>'.$PrimitiveTypes

.class public abstract auto ansi sealed LexicalStructure
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .method public specialname static int32 
          get_x() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.5
    IL_0002:  ret
  } // end of method LexicalStructure::get_x

  .method public specialname static int32 
          get_y() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.1
    IL_0002:  ret
  } // end of method LexicalStructure::get_y

  .method public specialname static int32 
          get_aReallyLongIdentifierName() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.2
    IL_0002:  ret
  } // end of method LexicalStructure::get_aReallyLongIdentifierName

  .method public specialname static int32 
          get__underscores_are_OK_too() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.3
    IL_0002:  ret
  } // end of method LexicalStructure::get__underscores_are_OK_too

  .method public specialname static int32 
          get_soAreNumbers123AfterALetter() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.4
    IL_0002:  ret
  } // end of method LexicalStructure::get_soAreNumbers123AfterALetter

  .method assembly specialname static int32 
          get_patternInput@35() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       3 (0x3)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  ldc.i4.5
    IL_0002:  ret
  } // end of method LexicalStructure::get_patternInput@35

  .method public specialname static int32 
          get_foo() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       7 (0x7)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  call       int32 LexicalStructure::get_patternInput@35()
    IL_0006:  ret
  } // end of method LexicalStructure::get_foo

  .method public specialname static int32 
          get_abc() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       7 (0x7)
    .maxstack  3
    IL_0000:  nop
    IL_0001:  call       int32 LexicalStructure::get_patternInput@35()
    IL_0006:  ret
  } // end of method LexicalStructure::get_abc

  .method public specialname static class [FSharp.Core]Microsoft.FSharp.Core.Unit 
          get_outer() cil managed
  {
    // Code size       6 (0x6)
    .maxstack  4
    IL_0000:  ldsfld     class [FSharp.Core]Microsoft.FSharp.Core.Unit '<StartupCode$Basics>'.$LexicalStructure::outer@45
    IL_0005:  ret
  } // end of method LexicalStructure::get_outer

  .property int32 x()
  {
    .get int32 LexicalStructure::get_x()
  } // end of property LexicalStructure::x
  .property int32 y()
  {
    .get int32 LexicalStructure::get_y()
  } // end of property LexicalStructure::y
  .property int32 aReallyLongIdentifierName()
  {
    .get int32 LexicalStructure::get_aReallyLongIdentifierName()
  } // end of property LexicalStructure::aReallyLongIdentifierName
  .property int32 _underscores_are_OK_too()
  {
    .get int32 LexicalStructure::get__underscores_are_OK_too()
  } // end of property LexicalStructure::_underscores_are_OK_too
  .property int32 soAreNumbers123AfterALetter()
  {
    .get int32 LexicalStructure::get_soAreNumbers123AfterALetter()
  } // end of property LexicalStructure::soAreNumbers123AfterALetter
  .property int32 patternInput@35()
  {
    .get int32 LexicalStructure::get_patternInput@35()
  } // end of property LexicalStructure::patternInput@35
  .property int32 foo()
  {
    .get int32 LexicalStructure::get_foo()
  } // end of property LexicalStructure::foo
  .property int32 abc()
  {
    .get int32 LexicalStructure::get_abc()
  } // end of property LexicalStructure::abc
  .property class [FSharp.Core]Microsoft.FSharp.Core.Unit
          outer()
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 09 00 00 00 00 00 ) 
    .get class [FSharp.Core]Microsoft.FSharp.Core.Unit LexicalStructure::get_outer()
  } // end of property LexicalStructure::outer
} // end of class LexicalStructure

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$LexicalStructure
       extends [mscorlib]System.Object
{
  .field static assembly initonly class [FSharp.Core]Microsoft.FSharp.Core.Unit outer@45
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .field static assembly int32 init@
  .custom instance void [mscorlib]System.Diagnostics.DebuggerBrowsableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggerBrowsableState) = ( 01 00 00 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .method private specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       115 (0x73)
    .maxstack  4
    .locals init ([0] int32 x,
             [1] int32 y,
             [2] int32 aReallyLongIdentifierName,
             [3] int32 _underscores_are_OK_too,
             [4] int32 soAreNumbers123AfterALetter,
             [5] int32 foo,
             [6] int32 abc,
             [7] int32 V_7)
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\LexicalStructure.fs' 
//000016: let x = 5
    IL_0000:  nop
    IL_0001:  call       int32 LexicalStructure::get_x()
    IL_0006:  stloc.0
//000017: 
//000018: // This is a single-line comment
//000019: 
//000020: /// This is a documentation comment. Note that if you are
//000021: /// looking at this file inside of Visual Studio, this
//000022: /// documentation comment will be bound against the first
//000023: /// identifier in the code snippets that follow, which is
//000024: /// the identifier "y".
//000025: 
//000026: // These are legitimate identifiers
//000027: //
//000028: let y = 1
    IL_0007:  call       int32 LexicalStructure::get_y()
    IL_000c:  stloc.1
//000029: let aReallyLongIdentifierName = 2
    IL_000d:  call       int32 LexicalStructure::get_aReallyLongIdentifierName()
    IL_0012:  stloc.2
//000030: let _underscores_are_OK_too = 3
    IL_0013:  call       int32 LexicalStructure::get__underscores_are_OK_too()
    IL_0018:  stloc.3
//000031: let soAreNumbers123AfterALetter = 4
    IL_0019:  call       int32 LexicalStructure::get_soAreNumbers123AfterALetter()
    IL_001e:  stloc.s    soAreNumbers123AfterALetter
//000032: /// This is not what you think--it will compile, but it
//000033: /// actually defines two different identifiers (abc and
//000034: /// foo) with the same value (5).
//000035: let abc&foo = 5
    IL_0020:  call       int32 LexicalStructure::get_foo()
    IL_0025:  stloc.s    foo
    IL_0027:  call       int32 LexicalStructure::get_abc()
    IL_002c:  stloc.s    abc
//000036: //let can'tincludeotherpunctuation,moron = 6
//000037: 
//000038: // These are not (uncomment to see for sure)
//000039: //
//000040: // let 123abcNumbersCantComeFirst = 100
//000041: // let abc@foo = 100
//000042: 
//000043: // Demonstration of significant whitespace
//000044: //
//000045: let outer =
//000046:     let x = 2
    IL_002e:  ldc.i4.2
    IL_002f:  stloc.s    V_7
//000047:     if x = 1 then
    IL_0031:  ldloc.s    V_7
    IL_0033:  ldc.i4.1
    IL_0034:  bne.un.s   IL_0038

    IL_0036:  br.s       IL_003a

    IL_0038:  br.s       IL_005f

//000048:         System.Console.WriteLine("Hello, F#")
    IL_003a:  ldstr      "Hello, F#"
    IL_003f:  call       void [mscorlib]System.Console::WriteLine(string)
//000049:         if x = 1 then
    IL_0044:  ldloc.s    V_7
    IL_0046:  ldc.i4.1
    IL_0047:  bne.un.s   IL_004b

    IL_0049:  br.s       IL_004d

    IL_004b:  br.s       IL_005b

//000050:             System.Console.WriteLine("Again!")
    IL_004d:  ldstr      "Again!"
    IL_0052:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0057:  ldnull
//000051:       else
//000052:         System.Console.WriteLine("Uh... how did this happen?")
    IL_0058:  nop
    IL_0059:  br.s       IL_006b

    IL_005b:  ldnull
    IL_005c:  nop
    IL_005d:  br.s       IL_006b

    IL_005f:  ldstr      "Uh... how did this happen\?"
    IL_0064:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_0069:  ldnull
    IL_006a:  nop
    IL_006b:  dup
    IL_006c:  stsfld     class [FSharp.Core]Microsoft.FSharp.Core.Unit '<StartupCode$Basics>'.$LexicalStructure::outer@45
    IL_0071:  pop
    IL_0072:  ret
  } // end of method $LexicalStructure::.cctor

} // end of class '<StartupCode$Basics>'.$LexicalStructure

.class public abstract auto ansi sealed HelperTypes
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public Person
         extends [mscorlib]System.Object
         implements [mscorlib]System.IComparable
  {
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly string lastName
    .field assembly string firstName
    .field assembly int32 age
    .method public specialname rtspecialname 
            instance void  .ctor(string firstName,
                                 string lastName,
                                 int32 age) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  4
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\HelperTypes.fs' 
//000007: type public Person(firstName : string, lastName : string, age : int) =
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ldarg.0
      IL_0007:  pop
      IL_0008:  nop
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      string HelperTypes/Person::firstName
      IL_0010:  ldarg.0
      IL_0011:  ldarg.2
      IL_0012:  stfld      string HelperTypes/Person::lastName
      IL_0017:  ldarg.0
      IL_0018:  ldarg.3
      IL_0019:  stfld      int32 HelperTypes/Person::age
      IL_001e:  ret
    } // end of method Person::.ctor

    .method public specialname instance string 
            get_FirstName() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000008:     interface IComparable with
//000009:         member p.CompareTo(other : obj) : int =
//000010:             match other with
//000011:             | :? Person as otherP ->
//000012:                 let result = lastName.CompareTo(otherP.LastName)
//000013:                 if result = 0 then
//000014:                     firstName.CompareTo(otherP.FirstName)
//000015:                 else
//000016:                     result
//000017:             | _ ->
//000018:                 raise (new System.ArgumentException("Not a Person"))
//000019:     member p.FirstName = firstName
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      string HelperTypes/Person::firstName
      IL_0007:  ret
    } // end of method Person::get_FirstName

    .method public specialname instance string 
            get_LastName() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000020:     member p.LastName = lastName
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      string HelperTypes/Person::lastName
      IL_0007:  ret
    } // end of method Person::get_LastName

    .method public specialname instance int32 
            get_Age() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000021:     member p.Age = age
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      int32 HelperTypes/Person::age
      IL_0007:  ret
    } // end of method Person::get_Age

    .method public hidebysig virtual instance bool 
            Equals(object obj) cil managed
    {
      // Code size       17 (0x11)
      .maxstack  4
//000022:     
//000023:     override p.Equals(obj : obj) =
//000024:         (p :> IComparable).CompareTo(obj) = 0
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  unbox.any  [mscorlib]System.IComparable
      IL_0007:  ldarg.1
      IL_0008:  callvirt   instance int32 [mscorlib]System.IComparable::CompareTo(object)
      IL_000d:  ldc.i4.0
      IL_000e:  ceq
      IL_0010:  ret
    } // end of method Person::Equals

    .method public hidebysig virtual instance string 
            ToString() cil managed
    {
      // Code size       35 (0x23)
      .maxstack  6
//000025:     override p.ToString() = 
//000026:         System.String.Format("[Person: FirstName={0}, LastName={1}, Age={2}]",
      IL_0000:  nop
      IL_0001:  ldstr      "[Person: FirstName={0}, LastName={1}, Age={2}]"
      IL_0006:  ldarg.0
      IL_0007:  ldfld      string HelperTypes/Person::firstName
      IL_000c:  ldarg.0
      IL_000d:  ldfld      string HelperTypes/Person::lastName
      IL_0012:  ldarg.0
      IL_0013:  ldfld      int32 HelperTypes/Person::age
      IL_0018:  box        [mscorlib]System.Int32
      IL_001d:  call       string [mscorlib]System.String::Format(string,
                                                                  object,
                                                                  object,
                                                                  object)
      IL_0022:  ret
    } // end of method Person::ToString

    .method public hidebysig virtual instance int32 
            GetHashCode() cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  4
//000027:             firstName, lastName, age)
//000028:     override p.GetHashCode() =
//000029:         (p.FirstName.GetHashCode() * 10) + p.LastName.GetHashCode()
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0007:  callvirt   instance int32 [mscorlib]System.Object::GetHashCode()
      IL_000c:  ldc.i4.s   10
      IL_000e:  mul
      IL_000f:  ldarg.0
      IL_0010:  call       instance string HelperTypes/Person::get_LastName()
      IL_0015:  callvirt   instance int32 [mscorlib]System.Object::GetHashCode()
      IL_001a:  add
      IL_001b:  ret
    } // end of method Person::GetHashCode

    .method private hidebysig newslot virtual 
            instance int32  'System-IComparable-CompareTo'(object other) cil managed
    {
      .override [mscorlib]System.IComparable::CompareTo
      // Code size       80 (0x50)
      .maxstack  4
      .locals init ([0] object V_0,
               [1] class HelperTypes/Person V_1,
               [2] class HelperTypes/Person otherP,
               [3] int32 result)
//000010:             match other with
      IL_0000:  nop
      IL_0001:  ldarg.1
      IL_0002:  stloc.0
      IL_0003:  ldloc.0
      IL_0004:  isinst     HelperTypes/Person
      IL_0009:  stloc.1
      IL_000a:  ldloc.1
      IL_000b:  brfalse.s  IL_000f

      IL_000d:  br.s       IL_0011

      IL_000f:  br.s       IL_0040

      IL_0011:  ldloc.1
      IL_0012:  stloc.2
//000011:             | :? Person as otherP ->
//000012:                 let result = lastName.CompareTo(otherP.LastName)
      IL_0013:  ldarg.0
      IL_0014:  ldfld      string HelperTypes/Person::lastName
      IL_0019:  ldloc.2
      IL_001a:  call       instance string HelperTypes/Person::get_LastName()
      IL_001f:  callvirt   instance int32 [mscorlib]System.String::CompareTo(string)
      IL_0024:  stloc.3
//000013:                 if result = 0 then
      IL_0025:  ldloc.3
      IL_0026:  brtrue.s   IL_002a

      IL_0028:  br.s       IL_002c

      IL_002a:  br.s       IL_003e

//000014:                     firstName.CompareTo(otherP.FirstName)
      IL_002c:  ldarg.0
      IL_002d:  ldfld      string HelperTypes/Person::firstName
      IL_0032:  ldloc.2
      IL_0033:  call       instance string HelperTypes/Person::get_FirstName()
      IL_0038:  callvirt   instance int32 [mscorlib]System.String::CompareTo(string)
      IL_003d:  ret

//000015:                 else
//000016:                     result
      IL_003e:  ldloc.3
      IL_003f:  ret

//000017:             | _ ->
//000018:                 raise (new System.ArgumentException("Not a Person"))
      IL_0040:  ldstr      "Not a Person"
      IL_0045:  newobj     instance void [mscorlib]System.ArgumentException::.ctor(string)
      IL_004a:  call       !!0 [FSharp.Core]Microsoft.FSharp.Core.Operators::Raise<int32>(class [mscorlib]System.Exception)
      IL_004f:  ret
    } // end of method Person::'System-IComparable-CompareTo'

    .property instance string FirstName()
    {
      .get instance string HelperTypes/Person::get_FirstName()
    } // end of property Person::FirstName
    .property instance string LastName()
    {
      .get instance string HelperTypes/Person::get_LastName()
    } // end of property Person::LastName
    .property instance int32 Age()
    {
      .get instance int32 HelperTypes/Person::get_Age()
    } // end of property Person::Age
  } // end of class Person

} // end of class HelperTypes

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$HelperTypes
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Basics>'.$HelperTypes

.class public abstract auto ansi sealed ProFSharp
       extends [mscorlib]System.Object
{
  .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 07 00 00 00 00 00 ) 
  .class auto ansi serializable nested public ExampleAttribute
         extends [mscorlib]System.Attribute
  {
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = ( 01 00 40 00 00 00 01 00 54 02 0D 41 6C 6C 6F 77   // ..@.....T..Allow
                                                                                                                           4D 75 6C 74 69 70 6C 65 00 )                      // Multiple.
    .custom instance void [FSharp.Core]Microsoft.FSharp.Core.CompilationMappingAttribute::.ctor(valuetype [FSharp.Core]Microsoft.FSharp.Core.SourceConstructFlags) = ( 01 00 03 00 00 00 00 00 ) 
    .field assembly string name
    .method public specialname rtspecialname 
            instance void  .ctor(string name) cil managed
    {
      // Code size       17 (0x11)
      .maxstack  4
// Source File 'C:\Users\faa634\Desktop\book codes\F#\Code\Basics\DriverBits.fs' 
//000009:     inherit Attribute()
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  call       instance void [mscorlib]System.Attribute::.ctor()
      IL_0007:  ldarg.0
      IL_0008:  pop
//000008: type public ExampleAttribute(name:string) =
      IL_0009:  ldarg.0
      IL_000a:  ldarg.1
      IL_000b:  stfld      string ProFSharp/ExampleAttribute::name
      IL_0010:  ret
    } // end of method ExampleAttribute::.ctor

    .method public specialname instance string 
            get_Value() cil managed
    {
      // Code size       8 (0x8)
      .maxstack  3
//000009:     inherit Attribute()
//000010:     member x.Value = name
      IL_0000:  nop
      IL_0001:  ldarg.0
      IL_0002:  ldfld      string ProFSharp/ExampleAttribute::name
      IL_0007:  ret
    } // end of method ExampleAttribute::get_Value

    .property instance string Value()
    {
      .get instance string ProFSharp/ExampleAttribute::get_Value()
    } // end of property ExampleAttribute::Value
  } // end of class ExampleAttribute

} // end of class ProFSharp

.class private abstract auto ansi sealed '<StartupCode$Basics>'.$ProFSharp
       extends [mscorlib]System.Object
{
} // end of class '<StartupCode$Basics>'.$ProFSharp


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
