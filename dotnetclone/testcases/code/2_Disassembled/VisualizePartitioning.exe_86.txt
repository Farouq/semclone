
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Core
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern ParallelExtensionsExtras
{
  .ver 1:2:0:0
}
.assembly VisualizePartitioning
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 15 56 69 73 75 61 6C 69 7A 65 50 61 72 74   // ...VisualizePart
                                                                                              69 74 69 6F 6E 69 6E 67 00 00 )                   // itioning..
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 15 56 69 73 75 61 6C 69 7A 65 50 61 72 74   // ...VisualizePart
                                                                                                69 74 69 6F 6E 69 6E 67 00 00 )                   // itioning..
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 34 35 33 36 61 61 64 63 2D 33 62 61 34   // ..$4536aadc-3ba4
                                                                                                  2D 34 65 62 30 2D 38 32 37 38 2D 39 62 30 64 33   // -4eb0-8278-9b0d3
                                                                                                  32 62 65 39 32 35 64 00 00 )                      // 2be925d..
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public VisualizePartitioning.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public VisualizePartitioning.MainForm.resources
{
  // Offset: 0x000000B8 Length: 0x000000B4
}
.module VisualizePartitioning.exe
// MVID: {CF694152-64C7-4781-B234-B9962695DEF5}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x006E0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private abstract auto ansi sealed beforefieldinit VisualizePartitioning.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Program.cs' 
//000019:         {
    IL_0000:  nop
//000020:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000021:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000022:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void VisualizePartitioning.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000023:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class VisualizePartitioning.Program

.class public auto ansi beforefieldinit VisualizePartitioning.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [mscorlib]System.Random random
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1'::.ctor

    .method public hidebysig instance valuetype [System.Drawing]System.Drawing.Color 
            '<InitializeColorPalette>b__0'(int32 i) cil managed
    {
      // Code size       67 (0x43)
      .maxstack  4
      .locals init ([0] valuetype [System.Drawing]System.Drawing.Color CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs' 
//000061:                        select Color.FromArgb(random.Next(128) + 127, random.Next(128) + 127, random.Next(128) + 127)).ToArray();
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class [mscorlib]System.Random VisualizePartitioning.MainForm/'<>c__DisplayClass1'::random
      IL_0006:  ldc.i4     0x80
      IL_000b:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0010:  ldc.i4.s   127
      IL_0012:  add
      IL_0013:  ldarg.0
      IL_0014:  ldfld      class [mscorlib]System.Random VisualizePartitioning.MainForm/'<>c__DisplayClass1'::random
      IL_0019:  ldc.i4     0x80
      IL_001e:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0023:  ldc.i4.s   127
      IL_0025:  add
      IL_0026:  ldarg.0
      IL_0027:  ldfld      class [mscorlib]System.Random VisualizePartitioning.MainForm/'<>c__DisplayClass1'::random
      IL_002c:  ldc.i4     0x80
      IL_0031:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0036:  ldc.i4.s   127
      IL_0038:  add
      IL_0039:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                         int32,
                                                                                                                         int32)
      IL_003e:  stloc.0
      IL_003f:  br.s       IL_0041

//000062:         }
//000063: 
//000064:         /// <summary>Initializes the workloads list view.</summary>
//000065:         private void InitializeWorkloads()
//000066:         {
//000067:             lvWorkloads.Items.Clear();
//000068:             var workloads = new List<Tuple<string, Func<int, int, int>>>();
//000069: 
//000070:             // NOTE: To add a new workload, simply add a new entry below with a name and corresponding function
//000071:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
//000072:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0041:  ldloc.0
      IL_0042:  ret
    } // end of method '<>c__DisplayClass1'::'<InitializeColorPalette>b__0'

  } // end of class '<>c__DisplayClass1'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass1e'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32[] e
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass1e'::.ctor

    .method public hidebysig instance int32 
            '<InitializePartitioningMethods>b__e'(int32 prev) cil managed
    {
      // Code size       59 (0x3b)
      .maxstack  3
      .locals init ([0] int32 next,
               [1] int32 CS$1$0000,
               [2] bool CS$4$0001)
//000104:                 {
      IL_0000:  nop
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
      IL_0001:  ldarg.1
      IL_0002:  ldc.i4.0
      IL_0003:  cgt
      IL_0005:  stloc.2
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0006:  ldloc.2
      IL_0007:  brtrue.s   IL_002a

//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
      IL_0009:  ldarg.0
      IL_000a:  ldfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::e
      IL_000f:  ldlen
      IL_0010:  conv.i4
      IL_0011:  ldc.i4.1
      IL_0012:  ble.s      IL_0026

      IL_0014:  ldarg.0
      IL_0015:  ldfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::e
      IL_001a:  ldlen
      IL_001b:  conv.i4
      IL_001c:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
      IL_0021:  ldc.i4.3
      IL_0022:  mul
      IL_0023:  div
      IL_0024:  br.s       IL_0027

      IL_0026:  ldc.i4.1
      IL_0027:  stloc.1
      IL_0028:  br.s       IL_0039

//000106:                     var next = prev / 2;
      IL_002a:  ldarg.1
      IL_002b:  ldc.i4.2
      IL_002c:  div
      IL_002d:  stloc.0
//000107:                     return next <= 0 ? prev : next;
      IL_002e:  ldloc.0
      IL_002f:  ldc.i4.0
      IL_0030:  ble.s      IL_0035

      IL_0032:  ldloc.0
      IL_0033:  br.s       IL_0036

      IL_0035:  ldarg.1
      IL_0036:  stloc.1
      IL_0037:  br.s       IL_0039

//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0039:  ldloc.1
      IL_003a:  ret
    } // end of method '<>c__DisplayClass1e'::'<InitializePartitioningMethods>b__e'

  } // end of class '<>c__DisplayClass1e'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass21'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32[] e
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass21'::.ctor

    .method public hidebysig instance int32 
            '<InitializePartitioningMethods>b__12'(int32 prev) cil managed
    {
      // Code size       28 (0x1c)
      .maxstack  2
      .locals init ([0] int32 CS$1$0000)
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
      IL_0000:  ldsfld     class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::_localRandom
      IL_0005:  callvirt   instance !0 class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random>::get_Value()
      IL_000a:  ldarg.0
      IL_000b:  ldfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass21'::e
      IL_0010:  ldlen
      IL_0011:  conv.i4
      IL_0012:  callvirt   instance int32 [mscorlib]System.Random::Next(int32)
      IL_0017:  stloc.0
      IL_0018:  br.s       IL_001a

//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_001a:  ldloc.0
      IL_001b:  ret
    } // end of method '<>c__DisplayClass21'::'<InitializePartitioningMethods>b__12'

  } // end of class '<>c__DisplayClass21'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass2f'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass35'
           extends [mscorlib]System.Object
    {
      .field public class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' 'CS$<>8__locals30'
      .field public int32 nextId
      .field public class [mscorlib]System.Threading.ThreadLocal`1<int32> threadId
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass35'::.ctor

      .method public hidebysig instance int32 
              '<btnVisualize_Click>b__27'() cil managed
      {
        // Code size       16 (0x10)
        .maxstack  1
        .locals init ([0] int32 CS$1$0000)
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
        IL_0000:  ldarg.0
        IL_0001:  ldflda     int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::nextId
        IL_0006:  call       int32 [mscorlib]System.Threading.Interlocked::Increment(int32&)
        IL_000b:  stloc.0
        IL_000c:  br.s       IL_000e

//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_000e:  ldloc.0
        IL_000f:  ret
      } // end of method '<>c__DisplayClass35'::'<btnVisualize_Click>b__27'

    } // end of class '<>c__DisplayClass35'

    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass3a'
           extends [mscorlib]System.Object
    {
      .field public class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' 'CS$<>8__locals36'
      .field public class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' 'CS$<>8__locals30'
      .field public class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap fastBmp
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClass3a'::.ctor

      .method public hidebysig instance void 
              '<btnVisualize_Click>b__28'(int32 i) cil managed
      {
        // Code size       144 (0x90)
        .maxstack  6
        .locals init ([0] int32 id,
                 [1] int32 j,
                 [2] bool CS$4$0000)
//000166:                         {
        IL_0000:  nop
//000167:                             int id = threadId.Value;
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals36'
        IL_0007:  ldfld      class [mscorlib]System.Threading.ThreadLocal`1<int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::threadId
        IL_000c:  callvirt   instance !0 class [mscorlib]System.Threading.ThreadLocal`1<int32>::get_Value()
        IL_0011:  stloc.0
//000168:                             DoWork(selectedWorkload.Item2(height, i));
        IL_0012:  ldarg.0
        IL_0013:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0018:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedWorkload
        IL_001d:  callvirt   instance !1 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>::get_Item2()
        IL_0022:  ldarg.0
        IL_0023:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0028:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_002d:  ldarg.1
        IL_002e:  callvirt   instance !2 class [mscorlib]System.Func`3<int32,int32,int32>::Invoke(!0,
                                                                                                  !1)
        IL_0033:  call       int32 VisualizePartitioning.MainForm::DoWork(int32)
        IL_0038:  pop
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_0039:  ldc.i4.0
        IL_003a:  stloc.1
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_003b:  br.s       IL_007d

//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_003d:  ldarg.0
        IL_003e:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
        IL_0043:  ldloc.1
        IL_0044:  ldarg.1
        IL_0045:  ldarg.0
        IL_0046:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_004b:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0050:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0055:  ldloc.0
        IL_0056:  ldarg.0
        IL_0057:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_005c:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0061:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0066:  ldlen
        IL_0067:  conv.i4
        IL_0068:  rem
        IL_0069:  ldelema    [System.Drawing]System.Drawing.Color
        IL_006e:  ldobj      [System.Drawing]System.Drawing.Color
        IL_0073:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                            int32,
                                                                                                            valuetype [System.Drawing]System.Drawing.Color)
        IL_0078:  nop
        IL_0079:  ldloc.1
        IL_007a:  ldc.i4.1
        IL_007b:  add
        IL_007c:  stloc.1
        IL_007d:  ldloc.1
        IL_007e:  ldarg.0
        IL_007f:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0084:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::width
        IL_0089:  clt
        IL_008b:  stloc.2
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_008c:  ldloc.2
        IL_008d:  brtrue.s   IL_003d

        IL_008f:  ret
      } // end of method '<>c__DisplayClass3a'::'<btnVisualize_Click>b__28'

      .method public hidebysig instance void 
              '<btnVisualize_Click>b__29'(int32 i) cil managed
      {
        // Code size       144 (0x90)
        .maxstack  6
        .locals init ([0] int32 id,
                 [1] int32 j,
                 [2] bool CS$4$0000)
//000181:                             {
        IL_0000:  nop
//000182:                                 int id = threadId.Value;
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals36'
        IL_0007:  ldfld      class [mscorlib]System.Threading.ThreadLocal`1<int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::threadId
        IL_000c:  callvirt   instance !0 class [mscorlib]System.Threading.ThreadLocal`1<int32>::get_Value()
        IL_0011:  stloc.0
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
        IL_0012:  ldarg.0
        IL_0013:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0018:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedWorkload
        IL_001d:  callvirt   instance !1 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>::get_Item2()
        IL_0022:  ldarg.0
        IL_0023:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0028:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_002d:  ldarg.1
        IL_002e:  callvirt   instance !2 class [mscorlib]System.Func`3<int32,int32,int32>::Invoke(!0,
                                                                                                  !1)
        IL_0033:  call       int32 VisualizePartitioning.MainForm::DoWork(int32)
        IL_0038:  pop
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_0039:  ldc.i4.0
        IL_003a:  stloc.1
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_003b:  br.s       IL_007d

//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_003d:  ldarg.0
        IL_003e:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
        IL_0043:  ldloc.1
        IL_0044:  ldarg.1
        IL_0045:  ldarg.0
        IL_0046:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_004b:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0050:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0055:  ldloc.0
        IL_0056:  ldarg.0
        IL_0057:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_005c:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0061:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0066:  ldlen
        IL_0067:  conv.i4
        IL_0068:  rem
        IL_0069:  ldelema    [System.Drawing]System.Drawing.Color
        IL_006e:  ldobj      [System.Drawing]System.Drawing.Color
        IL_0073:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                            int32,
                                                                                                            valuetype [System.Drawing]System.Drawing.Color)
        IL_0078:  nop
        IL_0079:  ldloc.1
        IL_007a:  ldc.i4.1
        IL_007b:  add
        IL_007c:  stloc.1
        IL_007d:  ldloc.1
        IL_007e:  ldarg.0
        IL_007f:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0084:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::width
        IL_0089:  clt
        IL_008b:  stloc.2
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_008c:  ldloc.2
        IL_008d:  brtrue.s   IL_003d

        IL_008f:  ret
      } // end of method '<>c__DisplayClass3a'::'<btnVisualize_Click>b__29'

      .method public hidebysig instance void 
              '<btnVisualize_Click>b__2e'(int32 i) cil managed
      {
        // Code size       144 (0x90)
        .maxstack  6
        .locals init ([0] int32 id,
                 [1] int32 j,
                 [2] bool CS$4$0000)
//000195:                             {
        IL_0000:  nop
//000196:                                 int id = threadId.Value;
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals36'
        IL_0007:  ldfld      class [mscorlib]System.Threading.ThreadLocal`1<int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::threadId
        IL_000c:  callvirt   instance !0 class [mscorlib]System.Threading.ThreadLocal`1<int32>::get_Value()
        IL_0011:  stloc.0
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
        IL_0012:  ldarg.0
        IL_0013:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0018:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedWorkload
        IL_001d:  callvirt   instance !1 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>::get_Item2()
        IL_0022:  ldarg.0
        IL_0023:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0028:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_002d:  ldarg.1
        IL_002e:  callvirt   instance !2 class [mscorlib]System.Func`3<int32,int32,int32>::Invoke(!0,
                                                                                                  !1)
        IL_0033:  call       int32 VisualizePartitioning.MainForm::DoWork(int32)
        IL_0038:  pop
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_0039:  ldc.i4.0
        IL_003a:  stloc.1
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_003b:  br.s       IL_007d

//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
        IL_003d:  ldarg.0
        IL_003e:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
        IL_0043:  ldloc.1
        IL_0044:  ldarg.1
        IL_0045:  ldarg.0
        IL_0046:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_004b:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0050:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0055:  ldloc.0
        IL_0056:  ldarg.0
        IL_0057:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_005c:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
        IL_0061:  ldfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
        IL_0066:  ldlen
        IL_0067:  conv.i4
        IL_0068:  rem
        IL_0069:  ldelema    [System.Drawing]System.Drawing.Color
        IL_006e:  ldobj      [System.Drawing]System.Drawing.Color
        IL_0073:  callvirt   instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::SetColor(int32,
                                                                                                            int32,
                                                                                                            valuetype [System.Drawing]System.Drawing.Color)
        IL_0078:  nop
        IL_0079:  ldloc.1
        IL_007a:  ldc.i4.1
        IL_007b:  add
        IL_007c:  stloc.1
        IL_007d:  ldloc.1
        IL_007e:  ldarg.0
        IL_007f:  ldfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
        IL_0084:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::width
        IL_0089:  clt
        IL_008b:  stloc.2
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_008c:  ldloc.2
        IL_008d:  brtrue.s   IL_003d

        IL_008f:  ret
      } // end of method '<>c__DisplayClass3a'::'<btnVisualize_Click>b__2e'

    } // end of class '<>c__DisplayClass3a'

    .field public int32 numProcs
    .field public int32 width
    .field public int32 height
    .field public bool useParallelFor
    .field public bool useParallelForEach
    .field public class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> selectedMethod
    .field public class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> selectedWorkload
    .field public class [System.Drawing]System.Drawing.Bitmap bmp
    .field public class VisualizePartitioning.MainForm '<>4__this'
    .field private static class [mscorlib]System.Func`2<int32,bool> 'CS$<>9__CachedAnonymousMethodDelegate31'
    .field private static class [mscorlib]System.Func`2<int32,int32> 'CS$<>9__CachedAnonymousMethodDelegate32'
    .field private static class [mscorlib]System.Func`2<int32,int32> 'CS$<>9__CachedAnonymousMethodDelegate33'
    .field private static class [mscorlib]System.Func`3<int32,int32,int32> 'CS$<>9__CachedAnonymousMethodDelegate34'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass2f'::.ctor

    .method public hidebysig instance void 
            '<btnVisualize_Click>b__25'(class [mscorlib]System.Threading.Tasks.Task`1<valuetype [mscorlib]System.TimeSpan> t) cil managed
    {
      // Code size       122 (0x7a)
      .maxstack  3
      .locals init ([0] class [System.Drawing]System.Drawing.Image old,
               [1] bool CS$4$0000,
               [2] valuetype [mscorlib]System.TimeSpan CS$0$0001)
//000209:             {
      IL_0000:  nop
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
      IL_0007:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
      IL_000c:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
      IL_0011:  stloc.0
//000212:                 pbPartitionedImage.Image = bmp;
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
      IL_0018:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
      IL_001d:  ldarg.0
      IL_001e:  ldfld      class [System.Drawing]System.Drawing.Bitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::bmp
      IL_0023:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_0028:  nop
//000213:                 if (old != null) old.Dispose();
      IL_0029:  ldloc.0
      IL_002a:  ldnull
      IL_002b:  ceq
      IL_002d:  stloc.1
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_002e:  ldloc.1
      IL_002f:  brtrue.s   IL_0038

//000213:                 if (old != null) old.Dispose();
      IL_0031:  ldloc.0
      IL_0032:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
      IL_0037:  nop
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
      IL_0038:  ldarg.0
      IL_0039:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
      IL_003e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
      IL_0043:  ldc.i4.1
      IL_0044:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_0049:  nop
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
      IL_004a:  ldarg.0
      IL_004b:  ldfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
      IL_0050:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
      IL_0055:  ldstr      "Time: "
      IL_005a:  ldarg.1
      IL_005b:  callvirt   instance !0 class [mscorlib]System.Threading.Tasks.Task`1<valuetype [mscorlib]System.TimeSpan>::get_Result()
      IL_0060:  stloc.2
      IL_0061:  ldloca.s   CS$0$0001
      IL_0063:  constrained. [mscorlib]System.TimeSpan
      IL_0069:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_006e:  call       string [mscorlib]System.String::Concat(string,
                                                                  string)
      IL_0073:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_0078:  nop
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0079:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__25'

    .method public hidebysig instance valuetype [mscorlib]System.TimeSpan 
            '<btnVisualize_Click>b__26'() cil managed
    {
      // Code size       613 (0x265)
      .maxstack  7
      .locals init ([0] class [System]System.Diagnostics.Stopwatch sw,
               [1] class [mscorlib]System.Threading.Tasks.ParallelOptions '<>g__initLocal23',
               [2] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> partitioner,
               [3] class [mscorlib]System.Threading.Tasks.ParallelOptions '<>g__initLocal24',
               [4] class [System.Core]System.Linq.ParallelQuery`1<int32> source,
               [5] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegate37',
               [6] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegate38',
               [7] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegate39',
               [8] class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a' 'CS$<>8__locals3b',
               [9] class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' 'CS$<>8__locals36',
               [10] valuetype [mscorlib]System.TimeSpan CS$1$0000,
               [11] bool CS$4$0001)
      IL_0000:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::.ctor()
      IL_0005:  stloc.s    'CS$<>8__locals36'
      IL_0007:  ldloc.s    'CS$<>8__locals36'
      IL_0009:  ldarg.0
      IL_000a:  stfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::'CS$<>8__locals30'
//000156:             {
      IL_000f:  nop
//000157:                 int nextId = -1; // assign each thread a unique id
      IL_0010:  ldloc.s    'CS$<>8__locals36'
      IL_0012:  ldc.i4.m1
      IL_0013:  stfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::nextId
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
      IL_0018:  ldloc.s    'CS$<>8__locals36'
      IL_001a:  ldloc.s    'CS$<>8__locals36'
      IL_001c:  ldftn      instance int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::'<btnVisualize_Click>b__27'()
      IL_0022:  newobj     instance void class [mscorlib]System.Func`1<int32>::.ctor(object,
                                                                                     native int)
      IL_0027:  newobj     instance void class [mscorlib]System.Threading.ThreadLocal`1<int32>::.ctor(class [mscorlib]System.Func`1<!0>)
      IL_002c:  stfld      class [mscorlib]System.Threading.ThreadLocal`1<int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35'::threadId
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0031:  ldnull
      IL_0032:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate37'
      IL_0034:  ldnull
      IL_0035:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate38'
      IL_0037:  ldnull
      IL_0038:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate39'
      IL_003a:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::.ctor()
      IL_003f:  stloc.s    'CS$<>8__locals3b'
      IL_0041:  ldloc.s    'CS$<>8__locals3b'
      IL_0043:  ldloc.s    'CS$<>8__locals36'
      IL_0045:  stfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass35' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals36'
      IL_004a:  ldloc.s    'CS$<>8__locals3b'
      IL_004c:  ldarg.0
      IL_004d:  stfld      class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'CS$<>8__locals30'
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
      IL_0052:  ldloc.s    'CS$<>8__locals3b'
      IL_0054:  ldarg.0
      IL_0055:  ldfld      class [System.Drawing]System.Drawing.Bitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::bmp
      IL_005a:  newobj     instance void [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
      IL_005f:  stfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
//000161:                 {
      .try
      {
        IL_0064:  nop
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
        IL_0065:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
        IL_006a:  stloc.0
//000163:                     if (useParallelFor)
        IL_006b:  ldarg.0
        IL_006c:  ldfld      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::useParallelFor
        IL_0071:  ldc.i4.0
        IL_0072:  ceq
        IL_0074:  stloc.s    CS$4$0001
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_0076:  ldloc.s    CS$4$0001
        IL_0078:  brtrue.s   IL_00b9

//000164:                     {
        IL_007a:  nop
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
        IL_007b:  ldc.i4.0
        IL_007c:  ldarg.0
        IL_007d:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_0082:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
        IL_0087:  stloc.1
        IL_0088:  ldloc.1
        IL_0089:  ldarg.0
        IL_008a:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::numProcs
        IL_008f:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_MaxDegreeOfParallelism(int32)
        IL_0094:  nop
        IL_0095:  ldloc.1
        IL_0096:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate37'
        IL_0098:  brtrue.s   IL_00ab

        IL_009a:  ldloc.s    'CS$<>8__locals3b'
        IL_009c:  ldftn      instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'<btnVisualize_Click>b__28'(int32)
        IL_00a2:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                         native int)
        IL_00a7:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate37'
        IL_00a9:  br.s       IL_00ab

        IL_00ab:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate37'
        IL_00ad:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                          int32,
                                                                                                                                          class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                          class [mscorlib]System.Action`1<int32>)
        IL_00b2:  pop
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
        IL_00b3:  nop
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_00b4:  br         IL_0239

//000173:                     {
        IL_00b9:  nop
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
        IL_00ba:  ldarg.0
        IL_00bb:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedMethod
        IL_00c0:  callvirt   instance !1 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>::get_Item2()
        IL_00c5:  ldc.i4.0
        IL_00c6:  ldarg.0
        IL_00c7:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_00cc:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                        int32)
        IL_00d1:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
        IL_00d6:  callvirt   instance !1 class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::Invoke(!0)
        IL_00db:  stloc.2
//000176: 
//000177:                         if (useParallelForEach)
        IL_00dc:  ldarg.0
        IL_00dd:  ldfld      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::useParallelForEach
        IL_00e2:  ldc.i4.0
        IL_00e3:  ceq
        IL_00e5:  stloc.s    CS$4$0001
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_00e7:  ldloc.s    CS$4$0001
        IL_00e9:  brtrue.s   IL_0124

//000178:                         {
        IL_00eb:  nop
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
        IL_00ec:  ldloc.2
        IL_00ed:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
        IL_00f2:  stloc.3
        IL_00f3:  ldloc.3
        IL_00f4:  ldarg.0
        IL_00f5:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::numProcs
        IL_00fa:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_MaxDegreeOfParallelism(int32)
        IL_00ff:  nop
        IL_0100:  ldloc.3
        IL_0101:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate38'
        IL_0103:  brtrue.s   IL_0116

        IL_0105:  ldloc.s    'CS$<>8__locals3b'
        IL_0107:  ldftn      instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'<btnVisualize_Click>b__29'(int32)
        IL_010d:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                         native int)
        IL_0112:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate38'
        IL_0114:  br.s       IL_0116

        IL_0116:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate38'
        IL_0118:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::ForEach<int32>(class [mscorlib]System.Collections.Concurrent.Partitioner`1<!!0>,
                                                                                                                                                     class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                                     class [mscorlib]System.Action`1<!!0>)
        IL_011d:  pop
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
        IL_011e:  nop
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_011f:  br         IL_0238

//000188:                         {
        IL_0124:  nop
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
        IL_0125:  ldloc.2
        IL_0126:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::AsParallel<int32>(class [mscorlib]System.Collections.Concurrent.Partitioner`1<!!0>)
        IL_012b:  ldarg.0
        IL_012c:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::numProcs
        IL_0131:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::WithDegreeOfParallelism<int32>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                             int32)
        IL_0136:  stloc.s    source
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
        IL_0138:  ldarg.0
        IL_0139:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedMethod
        IL_013e:  callvirt   instance !0 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>::get_Item1()
        IL_0143:  ldstr      "Stripe"
        IL_0148:  call       bool [mscorlib]System.String::op_Equality(string,
                                                                       string)
        IL_014d:  ldc.i4.0
        IL_014e:  ceq
        IL_0150:  stloc.s    CS$4$0001
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_0152:  ldloc.s    CS$4$0001
        IL_0154:  brtrue.s   IL_0183

//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
        IL_0156:  ldloc.s    source
        IL_0158:  ldsfld     class [mscorlib]System.Func`2<int32,bool> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate31'
        IL_015d:  brtrue.s   IL_0172

        IL_015f:  ldnull
        IL_0160:  ldftn      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__2a'(int32)
        IL_0166:  newobj     instance void class [mscorlib]System.Func`2<int32,bool>::.ctor(object,
                                                                                            native int)
        IL_016b:  stsfld     class [mscorlib]System.Func`2<int32,bool> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate31'
        IL_0170:  br.s       IL_0172

        IL_0172:  ldsfld     class [mscorlib]System.Func`2<int32,bool> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate31'
        IL_0177:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::TakeWhile<int32>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                               class [mscorlib]System.Func`2<!!0,bool>)
        IL_017c:  stloc.s    source
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_017e:  br         IL_0218

//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
        IL_0183:  ldarg.0
        IL_0184:  ldfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedMethod
        IL_0189:  callvirt   instance !0 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>::get_Item1()
        IL_018e:  ldstr      "Hash"
        IL_0193:  call       bool [mscorlib]System.String::op_Equality(string,
                                                                       string)
        IL_0198:  ldc.i4.0
        IL_0199:  ceq
        IL_019b:  stloc.s    CS$4$0001
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
        IL_019d:  ldloc.s    CS$4$0001
        IL_019f:  brtrue.s   IL_0218

//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
        IL_01a1:  ldloc.s    source
        IL_01a3:  ldc.i4.0
        IL_01a4:  ldarg.0
        IL_01a5:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
        IL_01aa:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                        int32)
        IL_01af:  call       class [System.Core]System.Linq.ParallelQuery`1<!!0> [System.Core]System.Linq.ParallelEnumerable::AsParallel<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
        IL_01b4:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate32'
        IL_01b9:  brtrue.s   IL_01ce

        IL_01bb:  ldnull
        IL_01bc:  ldftn      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__2b'(int32)
        IL_01c2:  newobj     instance void class [mscorlib]System.Func`2<int32,int32>::.ctor(object,
                                                                                             native int)
        IL_01c7:  stsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate32'
        IL_01cc:  br.s       IL_01ce

        IL_01ce:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate32'
        IL_01d3:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate33'
        IL_01d8:  brtrue.s   IL_01ed

        IL_01da:  ldnull
        IL_01db:  ldftn      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__2c'(int32)
        IL_01e1:  newobj     instance void class [mscorlib]System.Func`2<int32,int32>::.ctor(object,
                                                                                             native int)
        IL_01e6:  stsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate33'
        IL_01eb:  br.s       IL_01ed

        IL_01ed:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate33'
        IL_01f2:  ldsfld     class [mscorlib]System.Func`3<int32,int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate34'
        IL_01f7:  brtrue.s   IL_020c

        IL_01f9:  ldnull
        IL_01fa:  ldftn      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__2d'(int32,
                                                                                                                     int32)
        IL_0200:  newobj     instance void class [mscorlib]System.Func`3<int32,int32,int32>::.ctor(object,
                                                                                                   native int)
        IL_0205:  stsfld     class [mscorlib]System.Func`3<int32,int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate34'
        IL_020a:  br.s       IL_020c

        IL_020c:  ldsfld     class [mscorlib]System.Func`3<int32,int32,int32> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'CS$<>9__CachedAnonymousMethodDelegate34'
        IL_0211:  call       class [System.Core]System.Linq.ParallelQuery`1<!!3> [System.Core]System.Linq.ParallelEnumerable::Join<int32,int32,int32,int32>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                                                                                            class [System.Core]System.Linq.ParallelQuery`1<!!1>,
                                                                                                                                                            class [mscorlib]System.Func`2<!!0,!!2>,
                                                                                                                                                            class [mscorlib]System.Func`2<!!1,!!2>,
                                                                                                                                                            class [mscorlib]System.Func`3<!!0,!!1,!!3>)
        IL_0216:  stloc.s    source
//000194:                             source.ForAll(i =>
        IL_0218:  ldloc.s    source
        IL_021a:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate39'
        IL_021c:  brtrue.s   IL_022f

        IL_021e:  ldloc.s    'CS$<>8__locals3b'
        IL_0220:  ldftn      instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::'<btnVisualize_Click>b__2e'(int32)
        IL_0226:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                         native int)
        IL_022b:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate39'
        IL_022d:  br.s       IL_022f

        IL_022f:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate39'
        IL_0231:  call       void [System.Core]System.Linq.ParallelEnumerable::ForAll<int32>(class [System.Core]System.Linq.ParallelQuery`1<!!0>,
                                                                                             class [mscorlib]System.Action`1<!!0>)
        IL_0236:  nop
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
        IL_0237:  nop
//000201:                     }
        IL_0238:  nop
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
        IL_0239:  ldloc.0
        IL_023a:  callvirt   instance valuetype [mscorlib]System.TimeSpan [System]System.Diagnostics.Stopwatch::get_Elapsed()
        IL_023f:  stloc.s    CS$1$0000
        IL_0241:  leave.s    IL_0261

//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      }  // end .try
      finally
      {
        IL_0243:  ldloc.s    'CS$<>8__locals3b'
        IL_0245:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
        IL_024a:  ldnull
        IL_024b:  ceq
        IL_024d:  stloc.s    CS$4$0001
        IL_024f:  ldloc.s    CS$4$0001
        IL_0251:  brtrue.s   IL_0260

        IL_0253:  ldloc.s    'CS$<>8__locals3b'
        IL_0255:  ldfld      class [ParallelExtensionsExtras]Microsoft.Drawing.FastBitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'/'<>c__DisplayClass3a'::fastBmp
        IL_025a:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_025f:  nop
        IL_0260:  endfinally
      }  // end handler
      IL_0261:  nop
      IL_0262:  ldloc.s    CS$1$0000
      IL_0264:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__26'

    .method private hidebysig static bool 
            '<btnVisualize_Click>b__2a'(int32 elem) cil managed
    {
      // Code size       6 (0x6)
      .maxstack  1
      .locals init ([0] bool CS$1$0000)
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
      IL_0000:  ldc.i4.1
      IL_0001:  stloc.0
      IL_0002:  br.s       IL_0004

//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0004:  ldloc.0
      IL_0005:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__2a'

    .method private hidebysig static int32 
            '<btnVisualize_Click>b__2b'(int32 i) cil managed
    {
      // Code size       6 (0x6)
      .maxstack  1
      .locals init ([0] int32 CS$1$0000)
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
      IL_0000:  ldarg.0
      IL_0001:  stloc.0
      IL_0002:  br.s       IL_0004

//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0004:  ldloc.0
      IL_0005:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__2b'

    .method private hidebysig static int32 
            '<btnVisualize_Click>b__2c'(int32 i) cil managed
    {
      // Code size       6 (0x6)
      .maxstack  1
      .locals init ([0] int32 CS$1$0000)
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
      IL_0000:  ldarg.0
      IL_0001:  stloc.0
      IL_0002:  br.s       IL_0004

//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0004:  ldloc.0
      IL_0005:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__2c'

    .method private hidebysig static int32 
            '<btnVisualize_Click>b__2d'(int32 i,
                                        int32 ignore) cil managed
    {
      // Code size       6 (0x6)
      .maxstack  1
      .locals init ([0] int32 CS$1$0000)
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
      IL_0000:  ldarg.0
      IL_0001:  stloc.0
      IL_0002:  br.s       IL_0004

//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_0004:  ldloc.0
      IL_0005:  ret
    } // end of method '<>c__DisplayClass2f'::'<btnVisualize_Click>b__2d'

  } // end of class '<>c__DisplayClass2f'

  .field private static literal string PartitioningStripe = "Stripe"
  .field private static literal string PartitioningHash = "Hash"
  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pbPartitionedImage
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnVisualize
  .field private class [System.Windows.Forms]System.Windows.Forms.ListView lvPartitioningMethods
  .field private class [System.Windows.Forms]System.Windows.Forms.ListView lvWorkloads
  .field private class [System.Windows.Forms]System.Windows.Forms.Label label1
  .field private class [System.Windows.Forms]System.Windows.Forms.Label label2
  .field private class [System.Windows.Forms]System.Windows.Forms.Label lblTime
  .field private class [System.Windows.Forms]System.Windows.Forms.TrackBar tbWorkFactor
  .field private class [System.Windows.Forms]System.Windows.Forms.Label label3
  .field private class [System.Windows.Forms]System.Windows.Forms.RadioButton rbParallelFor
  .field private class [System.Windows.Forms]System.Windows.Forms.RadioButton rbParallelForEach
  .field private class [System.Windows.Forms]System.Windows.Forms.RadioButton rbPLINQ
  .field private class [System.Windows.Forms]System.Windows.Forms.GroupBox groupBox1
  .field private class [System.Windows.Forms]System.Windows.Forms.Label label4
  .field private class [System.Windows.Forms]System.Windows.Forms.TrackBar tbCores
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolTip toolTip1
  .field private valuetype [System.Drawing]System.Drawing.Color[] _colors
  .field private int32 _workFactor
  .field private static class [mscorlib]System.Random _randomnessSeed
  .field private static class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random> _localRandom
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate15'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate16'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate17'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate18'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate19'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate1a'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate1b'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate1c'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> 'CS$<>9__CachedAnonymousMethodDelegate1d'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`2<int32,int32> 'CS$<>9__CachedAnonymousMethodDelegate20'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Func`1<class [mscorlib]System.Random> 'CS$<>9__CachedAnonymousMethodDelegate3e'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer VisualizePartitioning.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             this.components = new System.ComponentModel.Container();
//000032:             this.pbPartitionedImage = new System.Windows.Forms.PictureBox();
//000033:             this.btnVisualize = new System.Windows.Forms.Button();
//000034:             this.lvPartitioningMethods = new System.Windows.Forms.ListView();
//000035:             this.lvWorkloads = new System.Windows.Forms.ListView();
//000036:             this.label1 = new System.Windows.Forms.Label();
//000037:             this.label2 = new System.Windows.Forms.Label();
//000038:             this.lblTime = new System.Windows.Forms.Label();
//000039:             this.tbWorkFactor = new System.Windows.Forms.TrackBar();
//000040:             this.label3 = new System.Windows.Forms.Label();
//000041:             this.rbParallelFor = new System.Windows.Forms.RadioButton();
//000042:             this.rbParallelForEach = new System.Windows.Forms.RadioButton();
//000043:             this.rbPLINQ = new System.Windows.Forms.RadioButton();
//000044:             this.groupBox1 = new System.Windows.Forms.GroupBox();
//000045:             this.label4 = new System.Windows.Forms.Label();
//000046:             this.tbCores = new System.Windows.Forms.TrackBar();
//000047:             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
//000048:             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).BeginInit();
//000049:             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).BeginInit();
//000050:             this.groupBox1.SuspendLayout();
//000051:             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).BeginInit();
//000052:             this.SuspendLayout();
//000053:             // 
//000054:             // pbPartitionedImage
//000055:             // 
//000056:             this.pbPartitionedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000057:                         | System.Windows.Forms.AnchorStyles.Left)
//000058:                         | System.Windows.Forms.AnchorStyles.Right)));
//000059:             this.pbPartitionedImage.BackColor = System.Drawing.Color.Black;
//000060:             this.pbPartitionedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
//000061:             this.pbPartitionedImage.Location = new System.Drawing.Point(12, 12);
//000062:             this.pbPartitionedImage.Name = "pbPartitionedImage";
//000063:             this.pbPartitionedImage.Size = new System.Drawing.Size(539, 522);
//000064:             this.pbPartitionedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
//000065:             this.pbPartitionedImage.TabIndex = 0;
//000066:             this.pbPartitionedImage.TabStop = false;
//000067:             // 
//000068:             // btnVisualize
//000069:             // 
//000070:             this.btnVisualize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000071:             this.btnVisualize.Location = new System.Drawing.Point(557, 490);
//000072:             this.btnVisualize.Name = "btnVisualize";
//000073:             this.btnVisualize.Size = new System.Drawing.Size(75, 23);
//000074:             this.btnVisualize.TabIndex = 1;
//000075:             this.btnVisualize.Text = "Visualize";
//000076:             this.btnVisualize.UseVisualStyleBackColor = true;
//000077:             this.btnVisualize.Click += new System.EventHandler(this.btnVisualize_Click);
//000078:             // 
//000079:             // lvPartitioningMethods
//000080:             // 
//000081:             this.lvPartitioningMethods.Activation = System.Windows.Forms.ItemActivation.OneClick;
//000082:             this.lvPartitioningMethods.Alignment = System.Windows.Forms.ListViewAlignment.Default;
//000083:             this.lvPartitioningMethods.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000084:             this.lvPartitioningMethods.AutoArrange = false;
//000085:             this.lvPartitioningMethods.Enabled = false;
//000086:             this.lvPartitioningMethods.FullRowSelect = true;
//000087:             this.lvPartitioningMethods.GridLines = true;
//000088:             this.lvPartitioningMethods.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
//000089:             this.lvPartitioningMethods.Location = new System.Drawing.Point(559, 127);
//000090:             this.lvPartitioningMethods.MultiSelect = false;
//000091:             this.lvPartitioningMethods.Name = "lvPartitioningMethods";
//000092:             this.lvPartitioningMethods.ShowGroups = false;
//000093:             this.lvPartitioningMethods.Size = new System.Drawing.Size(126, 150);
//000094:             this.lvPartitioningMethods.TabIndex = 2;
//000095:             this.lvPartitioningMethods.UseCompatibleStateImageBehavior = false;
//000096:             this.lvPartitioningMethods.View = System.Windows.Forms.View.List;
//000097:             // 
//000098:             // lvWorkloads
//000099:             // 
//000100:             this.lvWorkloads.Activation = System.Windows.Forms.ItemActivation.OneClick;
//000101:             this.lvWorkloads.Alignment = System.Windows.Forms.ListViewAlignment.Default;
//000102:             this.lvWorkloads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000103:             this.lvWorkloads.AutoArrange = false;
//000104:             this.lvWorkloads.FullRowSelect = true;
//000105:             this.lvWorkloads.GridLines = true;
//000106:             this.lvWorkloads.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
//000107:             this.lvWorkloads.HideSelection = false;
//000108:             this.lvWorkloads.Location = new System.Drawing.Point(559, 296);
//000109:             this.lvWorkloads.MultiSelect = false;
//000110:             this.lvWorkloads.Name = "lvWorkloads";
//000111:             this.lvWorkloads.ShowGroups = false;
//000112:             this.lvWorkloads.Size = new System.Drawing.Size(126, 77);
//000113:             this.lvWorkloads.TabIndex = 3;
//000114:             this.lvWorkloads.UseCompatibleStateImageBehavior = false;
//000115:             this.lvWorkloads.View = System.Windows.Forms.View.List;
//000116:             // 
//000117:             // label1
//000118:             // 
//000119:             this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000120:             this.label1.AutoSize = true;
//000121:             this.label1.Location = new System.Drawing.Point(556, 280);
//000122:             this.label1.Name = "label1";
//000123:             this.label1.Size = new System.Drawing.Size(53, 13);
//000124:             this.label1.TabIndex = 4;
//000125:             this.label1.Text = "Workload";
//000126:             // 
//000127:             // label2
//000128:             // 
//000129:             this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000130:             this.label2.AutoSize = true;
//000131:             this.label2.Location = new System.Drawing.Point(557, 111);
//000132:             this.label2.Name = "label2";
//000133:             this.label2.Size = new System.Drawing.Size(59, 13);
//000134:             this.label2.TabIndex = 5;
//000135:             this.label2.Text = "Partitioning";
//000136:             // 
//000137:             // lblTime
//000138:             // 
//000139:             this.lblTime.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000140:             this.lblTime.AutoSize = true;
//000141:             this.lblTime.Location = new System.Drawing.Point(556, 516);
//000142:             this.lblTime.Name = "lblTime";
//000143:             this.lblTime.Size = new System.Drawing.Size(36, 13);
//000144:             this.lblTime.TabIndex = 6;
//000145:             this.lblTime.Text = "Time: ";
//000146:             // 
//000147:             // tbWorkFactor
//000148:             // 
//000149:             this.tbWorkFactor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000150:             this.tbWorkFactor.LargeChange = 1;
//000151:             this.tbWorkFactor.Location = new System.Drawing.Point(558, 408);
//000152:             this.tbWorkFactor.Maximum = 1000;
//000153:             this.tbWorkFactor.Minimum = 1;
//000154:             this.tbWorkFactor.Name = "tbWorkFactor";
//000155:             this.tbWorkFactor.Size = new System.Drawing.Size(123, 45);
//000156:             this.tbWorkFactor.TabIndex = 7;
//000157:             this.tbWorkFactor.TickFrequency = 100;
//000158:             this.tbWorkFactor.TickStyle = System.Windows.Forms.TickStyle.None;
//000159:             this.tbWorkFactor.Value = 1;
//000160:             this.tbWorkFactor.ValueChanged += new System.EventHandler(this.tbWorkFactor_ValueChanged);
//000161:             // 
//000162:             // label3
//000163:             // 
//000164:             this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000165:             this.label3.AutoSize = true;
//000166:             this.label3.Location = new System.Drawing.Point(557, 385);
//000167:             this.label3.Name = "label3";
//000168:             this.label3.Size = new System.Drawing.Size(66, 13);
//000169:             this.label3.TabIndex = 8;
//000170:             this.label3.Text = "Work Factor";
//000171:             // 
//000172:             // rbParallelFor
//000173:             // 
//000174:             this.rbParallelFor.AutoSize = true;
//000175:             this.rbParallelFor.Checked = true;
//000176:             this.rbParallelFor.Location = new System.Drawing.Point(7, 18);
//000177:             this.rbParallelFor.Name = "rbParallelFor";
//000178:             this.rbParallelFor.Size = new System.Drawing.Size(77, 17);
//000179:             this.rbParallelFor.TabIndex = 9;
//000180:             this.rbParallelFor.TabStop = true;
//000181:             this.rbParallelFor.Text = "Parallel.For";
//000182:             this.rbParallelFor.UseVisualStyleBackColor = true;
//000183:             this.rbParallelFor.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
//000184:             // 
//000185:             // rbParallelForEach
//000186:             // 
//000187:             this.rbParallelForEach.AutoSize = true;
//000188:             this.rbParallelForEach.Location = new System.Drawing.Point(6, 41);
//000189:             this.rbParallelForEach.Name = "rbParallelForEach";
//000190:             this.rbParallelForEach.Size = new System.Drawing.Size(102, 17);
//000191:             this.rbParallelForEach.TabIndex = 10;
//000192:             this.rbParallelForEach.TabStop = true;
//000193:             this.rbParallelForEach.Text = "Parallel.ForEach";
//000194:             this.rbParallelForEach.UseVisualStyleBackColor = true;
//000195:             this.rbParallelForEach.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
//000196:             // 
//000197:             // rbPLINQ
//000198:             // 
//000199:             this.rbPLINQ.AutoSize = true;
//000200:             this.rbPLINQ.Location = new System.Drawing.Point(6, 64);
//000201:             this.rbPLINQ.Name = "rbPLINQ";
//000202:             this.rbPLINQ.Size = new System.Drawing.Size(57, 17);
//000203:             this.rbPLINQ.TabIndex = 11;
//000204:             this.rbPLINQ.TabStop = true;
//000205:             this.rbPLINQ.Text = "PLINQ";
//000206:             this.rbPLINQ.UseVisualStyleBackColor = true;
//000207:             this.rbPLINQ.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
//000208:             // 
//000209:             // groupBox1
//000210:             // 
//000211:             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000212:             this.groupBox1.Controls.Add(this.rbParallelForEach);
//000213:             this.groupBox1.Controls.Add(this.rbPLINQ);
//000214:             this.groupBox1.Controls.Add(this.rbParallelFor);
//000215:             this.groupBox1.Location = new System.Drawing.Point(557, 12);
//000216:             this.groupBox1.Name = "groupBox1";
//000217:             this.groupBox1.Size = new System.Drawing.Size(130, 91);
//000218:             this.groupBox1.TabIndex = 12;
//000219:             this.groupBox1.TabStop = false;
//000220:             this.groupBox1.Text = "API";
//000221:             // 
//000222:             // label4
//000223:             // 
//000224:             this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000225:             this.label4.AutoSize = true;
//000226:             this.label4.Location = new System.Drawing.Point(556, 436);
//000227:             this.label4.Name = "label4";
//000228:             this.label4.Size = new System.Drawing.Size(34, 13);
//000229:             this.label4.TabIndex = 14;
//000230:             this.label4.Text = "Cores";
//000231:             // 
//000232:             // tbCores
//000233:             // 
//000234:             this.tbCores.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
//000235:             this.tbCores.LargeChange = 1;
//000236:             this.tbCores.Location = new System.Drawing.Point(557, 459);
//000237:             this.tbCores.Maximum = 100;
//000238:             this.tbCores.Minimum = 1;
//000239:             this.tbCores.Name = "tbCores";
//000240:             this.tbCores.Size = new System.Drawing.Size(123, 45);
//000241:             this.tbCores.TabIndex = 13;
//000242:             this.tbCores.TickStyle = System.Windows.Forms.TickStyle.None;
//000243:             this.tbCores.Value = 1;
//000244:             this.tbCores.ValueChanged += new System.EventHandler(this.tbCores_ValueChanged);
//000245:             // 
//000246:             // MainForm
//000247:             // 
//000248:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000249:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000250:             this.ClientSize = new System.Drawing.Size(695, 547);
//000251:             this.Controls.Add(this.btnVisualize);
//000252:             this.Controls.Add(this.label4);
//000253:             this.Controls.Add(this.tbCores);
//000254:             this.Controls.Add(this.groupBox1);
//000255:             this.Controls.Add(this.label3);
//000256:             this.Controls.Add(this.tbWorkFactor);
//000257:             this.Controls.Add(this.lblTime);
//000258:             this.Controls.Add(this.label2);
//000259:             this.Controls.Add(this.label1);
//000260:             this.Controls.Add(this.lvWorkloads);
//000261:             this.Controls.Add(this.lvPartitioningMethods);
//000262:             this.Controls.Add(this.pbPartitionedImage);
//000263:             this.Name = "MainForm";
//000264:             this.Text = "Visualize Partitioning";
//000265:             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).EndInit();
//000266:             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).EndInit();
//000267:             this.groupBox1.ResumeLayout(false);
//000268:             this.groupBox1.PerformLayout();
//000269:             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).EndInit();
//000270:             this.ResumeLayout(false);
//000271:             this.PerformLayout();
//000272: 
//000273:         }
//000274: 
//000275:         #endregion
//000276: 
//000277:         private System.Windows.Forms.PictureBox pbPartitionedImage;
//000278:         private System.Windows.Forms.Button btnVisualize;
//000279:         private System.Windows.Forms.ListView lvPartitioningMethods;
//000280:         private System.Windows.Forms.ListView lvWorkloads;
//000281:         private System.Windows.Forms.Label label1;
//000282:         private System.Windows.Forms.Label label2;
//000283:         private System.Windows.Forms.Label lblTime;
//000284:         private System.Windows.Forms.TrackBar tbWorkFactor;
//000285:         private System.Windows.Forms.Label label3;
//000286:         private System.Windows.Forms.RadioButton rbParallelFor;
//000287:         private System.Windows.Forms.RadioButton rbParallelForEach;
//000288:         private System.Windows.Forms.RadioButton rbPLINQ;
//000289:         private System.Windows.Forms.GroupBox groupBox1;
//000290:         private System.Windows.Forms.Label label4;
//000291:         private System.Windows.Forms.TrackBar tbCores;
//000292:         private System.Windows.Forms.ToolTip toolTip1;
//000293:     }
//000294: }
//000295: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer VisualizePartitioning.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       3033 (0xbd9)
    .maxstack  4
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             this.components = new System.ComponentModel.Container();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System]System.ComponentModel.Container::.ctor()
    IL_0007:  stfld      class [System]System.ComponentModel.IContainer VisualizePartitioning.MainForm::components
//000032:             this.pbPartitionedImage = new System.Windows.Forms.PictureBox();
    IL_000c:  ldarg.0
    IL_000d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0012:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
//000033:             this.btnVisualize = new System.Windows.Forms.Button();
    IL_0017:  ldarg.0
    IL_0018:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_001d:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
//000034:             this.lvPartitioningMethods = new System.Windows.Forms.ListView();
    IL_0022:  ldarg.0
    IL_0023:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ListView::.ctor()
    IL_0028:  stfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
//000035:             this.lvWorkloads = new System.Windows.Forms.ListView();
    IL_002d:  ldarg.0
    IL_002e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ListView::.ctor()
    IL_0033:  stfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
//000036:             this.label1 = new System.Windows.Forms.Label();
    IL_0038:  ldarg.0
    IL_0039:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_003e:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
//000037:             this.label2 = new System.Windows.Forms.Label();
    IL_0043:  ldarg.0
    IL_0044:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_0049:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
//000038:             this.lblTime = new System.Windows.Forms.Label();
    IL_004e:  ldarg.0
    IL_004f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_0054:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
//000039:             this.tbWorkFactor = new System.Windows.Forms.TrackBar();
    IL_0059:  ldarg.0
    IL_005a:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_005f:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
//000040:             this.label3 = new System.Windows.Forms.Label();
    IL_0064:  ldarg.0
    IL_0065:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_006a:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
//000041:             this.rbParallelFor = new System.Windows.Forms.RadioButton();
    IL_006f:  ldarg.0
    IL_0070:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::.ctor()
    IL_0075:  stfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
//000042:             this.rbParallelForEach = new System.Windows.Forms.RadioButton();
    IL_007a:  ldarg.0
    IL_007b:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::.ctor()
    IL_0080:  stfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
//000043:             this.rbPLINQ = new System.Windows.Forms.RadioButton();
    IL_0085:  ldarg.0
    IL_0086:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::.ctor()
    IL_008b:  stfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
//000044:             this.groupBox1 = new System.Windows.Forms.GroupBox();
    IL_0090:  ldarg.0
    IL_0091:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.GroupBox::.ctor()
    IL_0096:  stfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
//000045:             this.label4 = new System.Windows.Forms.Label();
    IL_009b:  ldarg.0
    IL_009c:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Label::.ctor()
    IL_00a1:  stfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
//000046:             this.tbCores = new System.Windows.Forms.TrackBar();
    IL_00a6:  ldarg.0
    IL_00a7:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::.ctor()
    IL_00ac:  stfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
//000047:             this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
    IL_00b1:  ldarg.0
    IL_00b2:  ldarg.0
    IL_00b3:  ldfld      class [System]System.ComponentModel.IContainer VisualizePartitioning.MainForm::components
    IL_00b8:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolTip::.ctor(class [System]System.ComponentModel.IContainer)
    IL_00bd:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolTip VisualizePartitioning.MainForm::toolTip1
//000048:             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).BeginInit();
    IL_00c2:  ldarg.0
    IL_00c3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_00c8:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_00cd:  nop
//000049:             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).BeginInit();
    IL_00ce:  ldarg.0
    IL_00cf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_00d4:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_00d9:  nop
//000050:             this.groupBox1.SuspendLayout();
    IL_00da:  ldarg.0
    IL_00db:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_00e0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00e5:  nop
//000051:             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).BeginInit();
    IL_00e6:  ldarg.0
    IL_00e7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_00ec:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::BeginInit()
    IL_00f1:  nop
//000052:             this.SuspendLayout();
    IL_00f2:  ldarg.0
    IL_00f3:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_00f8:  nop
//000053:             // 
//000054:             // pbPartitionedImage
//000055:             // 
//000056:             this.pbPartitionedImage.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_00f9:  ldarg.0
    IL_00fa:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_00ff:  ldc.i4.s   15
    IL_0101:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0106:  nop
//000057:                         | System.Windows.Forms.AnchorStyles.Left)
//000058:                         | System.Windows.Forms.AnchorStyles.Right)));
//000059:             this.pbPartitionedImage.BackColor = System.Drawing.Color.Black;
    IL_0107:  ldarg.0
    IL_0108:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_010d:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Black()
    IL_0112:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0117:  nop
//000060:             this.pbPartitionedImage.BorderStyle = System.Windows.Forms.BorderStyle.Fixed3D;
    IL_0118:  ldarg.0
    IL_0119:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_011e:  ldc.i4.2
    IL_011f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_0124:  nop
//000061:             this.pbPartitionedImage.Location = new System.Drawing.Point(12, 12);
    IL_0125:  ldarg.0
    IL_0126:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_012b:  ldc.i4.s   12
    IL_012d:  ldc.i4.s   12
    IL_012f:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0134:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0139:  nop
//000062:             this.pbPartitionedImage.Name = "pbPartitionedImage";
    IL_013a:  ldarg.0
    IL_013b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0140:  ldstr      "pbPartitionedImage"
    IL_0145:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_014a:  nop
//000063:             this.pbPartitionedImage.Size = new System.Drawing.Size(539, 522);
    IL_014b:  ldarg.0
    IL_014c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0151:  ldc.i4     0x21b
    IL_0156:  ldc.i4     0x20a
    IL_015b:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0160:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0165:  nop
//000064:             this.pbPartitionedImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
    IL_0166:  ldarg.0
    IL_0167:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_016c:  ldc.i4.1
    IL_016d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0172:  nop
//000065:             this.pbPartitionedImage.TabIndex = 0;
    IL_0173:  ldarg.0
    IL_0174:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0179:  ldc.i4.0
    IL_017a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_017f:  nop
//000066:             this.pbPartitionedImage.TabStop = false;
    IL_0180:  ldarg.0
    IL_0181:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0186:  ldc.i4.0
    IL_0187:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_018c:  nop
//000067:             // 
//000068:             // btnVisualize
//000069:             // 
//000070:             this.btnVisualize.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_018d:  ldarg.0
    IL_018e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_0193:  ldc.i4.s   9
    IL_0195:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_019a:  nop
//000071:             this.btnVisualize.Location = new System.Drawing.Point(557, 490);
    IL_019b:  ldarg.0
    IL_019c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_01a1:  ldc.i4     0x22d
    IL_01a6:  ldc.i4     0x1ea
    IL_01ab:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_01b0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01b5:  nop
//000072:             this.btnVisualize.Name = "btnVisualize";
    IL_01b6:  ldarg.0
    IL_01b7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_01bc:  ldstr      "btnVisualize"
    IL_01c1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01c6:  nop
//000073:             this.btnVisualize.Size = new System.Drawing.Size(75, 23);
    IL_01c7:  ldarg.0
    IL_01c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_01cd:  ldc.i4.s   75
    IL_01cf:  ldc.i4.s   23
    IL_01d1:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_01d6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_01db:  nop
//000074:             this.btnVisualize.TabIndex = 1;
    IL_01dc:  ldarg.0
    IL_01dd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_01e2:  ldc.i4.1
    IL_01e3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_01e8:  nop
//000075:             this.btnVisualize.Text = "Visualize";
    IL_01e9:  ldarg.0
    IL_01ea:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_01ef:  ldstr      "Visualize"
    IL_01f4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_01f9:  nop
//000076:             this.btnVisualize.UseVisualStyleBackColor = true;
    IL_01fa:  ldarg.0
    IL_01fb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_0200:  ldc.i4.1
    IL_0201:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_0206:  nop
//000077:             this.btnVisualize.Click += new System.EventHandler(this.btnVisualize_Click);
    IL_0207:  ldarg.0
    IL_0208:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_020d:  ldarg.0
    IL_020e:  ldftn      instance void VisualizePartitioning.MainForm::btnVisualize_Click(object,
                                                                                          class [mscorlib]System.EventArgs)
    IL_0214:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0219:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_021e:  nop
//000078:             // 
//000079:             // lvPartitioningMethods
//000080:             // 
//000081:             this.lvPartitioningMethods.Activation = System.Windows.Forms.ItemActivation.OneClick;
    IL_021f:  ldarg.0
    IL_0220:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0225:  ldc.i4.1
    IL_0226:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_Activation(valuetype [System.Windows.Forms]System.Windows.Forms.ItemActivation)
    IL_022b:  nop
//000082:             this.lvPartitioningMethods.Alignment = System.Windows.Forms.ListViewAlignment.Default;
    IL_022c:  ldarg.0
    IL_022d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0232:  ldc.i4.0
    IL_0233:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_Alignment(valuetype [System.Windows.Forms]System.Windows.Forms.ListViewAlignment)
    IL_0238:  nop
//000083:             this.lvPartitioningMethods.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0239:  ldarg.0
    IL_023a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_023f:  ldc.i4.s   9
    IL_0241:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0246:  nop
//000084:             this.lvPartitioningMethods.AutoArrange = false;
    IL_0247:  ldarg.0
    IL_0248:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_024d:  ldc.i4.0
    IL_024e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_AutoArrange(bool)
    IL_0253:  nop
//000085:             this.lvPartitioningMethods.Enabled = false;
    IL_0254:  ldarg.0
    IL_0255:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_025a:  ldc.i4.0
    IL_025b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0260:  nop
//000086:             this.lvPartitioningMethods.FullRowSelect = true;
    IL_0261:  ldarg.0
    IL_0262:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0267:  ldc.i4.1
    IL_0268:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_FullRowSelect(bool)
    IL_026d:  nop
//000087:             this.lvPartitioningMethods.GridLines = true;
    IL_026e:  ldarg.0
    IL_026f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0274:  ldc.i4.1
    IL_0275:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_GridLines(bool)
    IL_027a:  nop
//000088:             this.lvPartitioningMethods.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
    IL_027b:  ldarg.0
    IL_027c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0281:  ldc.i4.0
    IL_0282:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_HeaderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ColumnHeaderStyle)
    IL_0287:  nop
//000089:             this.lvPartitioningMethods.Location = new System.Drawing.Point(559, 127);
    IL_0288:  ldarg.0
    IL_0289:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_028e:  ldc.i4     0x22f
    IL_0293:  ldc.i4.s   127
    IL_0295:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_029a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_029f:  nop
//000090:             this.lvPartitioningMethods.MultiSelect = false;
    IL_02a0:  ldarg.0
    IL_02a1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02a6:  ldc.i4.0
    IL_02a7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_MultiSelect(bool)
    IL_02ac:  nop
//000091:             this.lvPartitioningMethods.Name = "lvPartitioningMethods";
    IL_02ad:  ldarg.0
    IL_02ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02b3:  ldstr      "lvPartitioningMethods"
    IL_02b8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_02bd:  nop
//000092:             this.lvPartitioningMethods.ShowGroups = false;
    IL_02be:  ldarg.0
    IL_02bf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02c4:  ldc.i4.0
    IL_02c5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_ShowGroups(bool)
    IL_02ca:  nop
//000093:             this.lvPartitioningMethods.Size = new System.Drawing.Size(126, 150);
    IL_02cb:  ldarg.0
    IL_02cc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02d1:  ldc.i4.s   126
    IL_02d3:  ldc.i4     0x96
    IL_02d8:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_02dd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_02e2:  nop
//000094:             this.lvPartitioningMethods.TabIndex = 2;
    IL_02e3:  ldarg.0
    IL_02e4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02e9:  ldc.i4.2
    IL_02ea:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_02ef:  nop
//000095:             this.lvPartitioningMethods.UseCompatibleStateImageBehavior = false;
    IL_02f0:  ldarg.0
    IL_02f1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_02f6:  ldc.i4.0
    IL_02f7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_UseCompatibleStateImageBehavior(bool)
    IL_02fc:  nop
//000096:             this.lvPartitioningMethods.View = System.Windows.Forms.View.List;
    IL_02fd:  ldarg.0
    IL_02fe:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0303:  ldc.i4.3
    IL_0304:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_View(valuetype [System.Windows.Forms]System.Windows.Forms.View)
    IL_0309:  nop
//000097:             // 
//000098:             // lvWorkloads
//000099:             // 
//000100:             this.lvWorkloads.Activation = System.Windows.Forms.ItemActivation.OneClick;
    IL_030a:  ldarg.0
    IL_030b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0310:  ldc.i4.1
    IL_0311:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_Activation(valuetype [System.Windows.Forms]System.Windows.Forms.ItemActivation)
    IL_0316:  nop
//000101:             this.lvWorkloads.Alignment = System.Windows.Forms.ListViewAlignment.Default;
    IL_0317:  ldarg.0
    IL_0318:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_031d:  ldc.i4.0
    IL_031e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_Alignment(valuetype [System.Windows.Forms]System.Windows.Forms.ListViewAlignment)
    IL_0323:  nop
//000102:             this.lvWorkloads.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0324:  ldarg.0
    IL_0325:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_032a:  ldc.i4.s   9
    IL_032c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0331:  nop
//000103:             this.lvWorkloads.AutoArrange = false;
    IL_0332:  ldarg.0
    IL_0333:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0338:  ldc.i4.0
    IL_0339:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_AutoArrange(bool)
    IL_033e:  nop
//000104:             this.lvWorkloads.FullRowSelect = true;
    IL_033f:  ldarg.0
    IL_0340:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0345:  ldc.i4.1
    IL_0346:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_FullRowSelect(bool)
    IL_034b:  nop
//000105:             this.lvWorkloads.GridLines = true;
    IL_034c:  ldarg.0
    IL_034d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0352:  ldc.i4.1
    IL_0353:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_GridLines(bool)
    IL_0358:  nop
//000106:             this.lvWorkloads.HeaderStyle = System.Windows.Forms.ColumnHeaderStyle.None;
    IL_0359:  ldarg.0
    IL_035a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_035f:  ldc.i4.0
    IL_0360:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_HeaderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.ColumnHeaderStyle)
    IL_0365:  nop
//000107:             this.lvWorkloads.HideSelection = false;
    IL_0366:  ldarg.0
    IL_0367:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_036c:  ldc.i4.0
    IL_036d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_HideSelection(bool)
    IL_0372:  nop
//000108:             this.lvWorkloads.Location = new System.Drawing.Point(559, 296);
    IL_0373:  ldarg.0
    IL_0374:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0379:  ldc.i4     0x22f
    IL_037e:  ldc.i4     0x128
    IL_0383:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0388:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_038d:  nop
//000109:             this.lvWorkloads.MultiSelect = false;
    IL_038e:  ldarg.0
    IL_038f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0394:  ldc.i4.0
    IL_0395:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_MultiSelect(bool)
    IL_039a:  nop
//000110:             this.lvWorkloads.Name = "lvWorkloads";
    IL_039b:  ldarg.0
    IL_039c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03a1:  ldstr      "lvWorkloads"
    IL_03a6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_03ab:  nop
//000111:             this.lvWorkloads.ShowGroups = false;
    IL_03ac:  ldarg.0
    IL_03ad:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03b2:  ldc.i4.0
    IL_03b3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_ShowGroups(bool)
    IL_03b8:  nop
//000112:             this.lvWorkloads.Size = new System.Drawing.Size(126, 77);
    IL_03b9:  ldarg.0
    IL_03ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03bf:  ldc.i4.s   126
    IL_03c1:  ldc.i4.s   77
    IL_03c3:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_03c8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_03cd:  nop
//000113:             this.lvWorkloads.TabIndex = 3;
    IL_03ce:  ldarg.0
    IL_03cf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03d4:  ldc.i4.3
    IL_03d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_03da:  nop
//000114:             this.lvWorkloads.UseCompatibleStateImageBehavior = false;
    IL_03db:  ldarg.0
    IL_03dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03e1:  ldc.i4.0
    IL_03e2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_UseCompatibleStateImageBehavior(bool)
    IL_03e7:  nop
//000115:             this.lvWorkloads.View = System.Windows.Forms.View.List;
    IL_03e8:  ldarg.0
    IL_03e9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_03ee:  ldc.i4.3
    IL_03ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_View(valuetype [System.Windows.Forms]System.Windows.Forms.View)
    IL_03f4:  nop
//000116:             // 
//000117:             // label1
//000118:             // 
//000119:             this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_03f5:  ldarg.0
    IL_03f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_03fb:  ldc.i4.s   9
    IL_03fd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0402:  nop
//000120:             this.label1.AutoSize = true;
    IL_0403:  ldarg.0
    IL_0404:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0409:  ldc.i4.1
    IL_040a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_040f:  nop
//000121:             this.label1.Location = new System.Drawing.Point(556, 280);
    IL_0410:  ldarg.0
    IL_0411:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0416:  ldc.i4     0x22c
    IL_041b:  ldc.i4     0x118
    IL_0420:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0425:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_042a:  nop
//000122:             this.label1.Name = "label1";
    IL_042b:  ldarg.0
    IL_042c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0431:  ldstr      "label1"
    IL_0436:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_043b:  nop
//000123:             this.label1.Size = new System.Drawing.Size(53, 13);
    IL_043c:  ldarg.0
    IL_043d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0442:  ldc.i4.s   53
    IL_0444:  ldc.i4.s   13
    IL_0446:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_044b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0450:  nop
//000124:             this.label1.TabIndex = 4;
    IL_0451:  ldarg.0
    IL_0452:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0457:  ldc.i4.4
    IL_0458:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_045d:  nop
//000125:             this.label1.Text = "Workload";
    IL_045e:  ldarg.0
    IL_045f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0464:  ldstr      "Workload"
    IL_0469:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_046e:  nop
//000126:             // 
//000127:             // label2
//000128:             // 
//000129:             this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_046f:  ldarg.0
    IL_0470:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_0475:  ldc.i4.s   9
    IL_0477:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_047c:  nop
//000130:             this.label2.AutoSize = true;
    IL_047d:  ldarg.0
    IL_047e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_0483:  ldc.i4.1
    IL_0484:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0489:  nop
//000131:             this.label2.Location = new System.Drawing.Point(557, 111);
    IL_048a:  ldarg.0
    IL_048b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_0490:  ldc.i4     0x22d
    IL_0495:  ldc.i4.s   111
    IL_0497:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_049c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_04a1:  nop
//000132:             this.label2.Name = "label2";
    IL_04a2:  ldarg.0
    IL_04a3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_04a8:  ldstr      "label2"
    IL_04ad:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_04b2:  nop
//000133:             this.label2.Size = new System.Drawing.Size(59, 13);
    IL_04b3:  ldarg.0
    IL_04b4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_04b9:  ldc.i4.s   59
    IL_04bb:  ldc.i4.s   13
    IL_04bd:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_04c2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_04c7:  nop
//000134:             this.label2.TabIndex = 5;
    IL_04c8:  ldarg.0
    IL_04c9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_04ce:  ldc.i4.5
    IL_04cf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_04d4:  nop
//000135:             this.label2.Text = "Partitioning";
    IL_04d5:  ldarg.0
    IL_04d6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_04db:  ldstr      "Partitioning"
    IL_04e0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_04e5:  nop
//000136:             // 
//000137:             // lblTime
//000138:             // 
//000139:             this.lblTime.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_04e6:  ldarg.0
    IL_04e7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_04ec:  ldc.i4.s   9
    IL_04ee:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_04f3:  nop
//000140:             this.lblTime.AutoSize = true;
    IL_04f4:  ldarg.0
    IL_04f5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_04fa:  ldc.i4.1
    IL_04fb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0500:  nop
//000141:             this.lblTime.Location = new System.Drawing.Point(556, 516);
    IL_0501:  ldarg.0
    IL_0502:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0507:  ldc.i4     0x22c
    IL_050c:  ldc.i4     0x204
    IL_0511:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0516:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_051b:  nop
//000142:             this.lblTime.Name = "lblTime";
    IL_051c:  ldarg.0
    IL_051d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0522:  ldstr      "lblTime"
    IL_0527:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_052c:  nop
//000143:             this.lblTime.Size = new System.Drawing.Size(36, 13);
    IL_052d:  ldarg.0
    IL_052e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0533:  ldc.i4.s   36
    IL_0535:  ldc.i4.s   13
    IL_0537:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_053c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0541:  nop
//000144:             this.lblTime.TabIndex = 6;
    IL_0542:  ldarg.0
    IL_0543:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0548:  ldc.i4.6
    IL_0549:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_054e:  nop
//000145:             this.lblTime.Text = "Time: ";
    IL_054f:  ldarg.0
    IL_0550:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0555:  ldstr      "Time: "
    IL_055a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_055f:  nop
//000146:             // 
//000147:             // tbWorkFactor
//000148:             // 
//000149:             this.tbWorkFactor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0560:  ldarg.0
    IL_0561:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0566:  ldc.i4.s   9
    IL_0568:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_056d:  nop
//000150:             this.tbWorkFactor.LargeChange = 1;
    IL_056e:  ldarg.0
    IL_056f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0574:  ldc.i4.1
    IL_0575:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_LargeChange(int32)
    IL_057a:  nop
//000151:             this.tbWorkFactor.Location = new System.Drawing.Point(558, 408);
    IL_057b:  ldarg.0
    IL_057c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0581:  ldc.i4     0x22e
    IL_0586:  ldc.i4     0x198
    IL_058b:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0590:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0595:  nop
//000152:             this.tbWorkFactor.Maximum = 1000;
    IL_0596:  ldarg.0
    IL_0597:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_059c:  ldc.i4     0x3e8
    IL_05a1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_05a6:  nop
//000153:             this.tbWorkFactor.Minimum = 1;
    IL_05a7:  ldarg.0
    IL_05a8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05ad:  ldc.i4.1
    IL_05ae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_05b3:  nop
//000154:             this.tbWorkFactor.Name = "tbWorkFactor";
    IL_05b4:  ldarg.0
    IL_05b5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05ba:  ldstr      "tbWorkFactor"
    IL_05bf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_05c4:  nop
//000155:             this.tbWorkFactor.Size = new System.Drawing.Size(123, 45);
    IL_05c5:  ldarg.0
    IL_05c6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05cb:  ldc.i4.s   123
    IL_05cd:  ldc.i4.s   45
    IL_05cf:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_05d4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_05d9:  nop
//000156:             this.tbWorkFactor.TabIndex = 7;
    IL_05da:  ldarg.0
    IL_05db:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05e0:  ldc.i4.7
    IL_05e1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_05e6:  nop
//000157:             this.tbWorkFactor.TickFrequency = 100;
    IL_05e7:  ldarg.0
    IL_05e8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05ed:  ldc.i4.s   100
    IL_05ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickFrequency(int32)
    IL_05f4:  nop
//000158:             this.tbWorkFactor.TickStyle = System.Windows.Forms.TickStyle.None;
    IL_05f5:  ldarg.0
    IL_05f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_05fb:  ldc.i4.0
    IL_05fc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickStyle(valuetype [System.Windows.Forms]System.Windows.Forms.TickStyle)
    IL_0601:  nop
//000159:             this.tbWorkFactor.Value = 1;
    IL_0602:  ldarg.0
    IL_0603:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0608:  ldc.i4.1
    IL_0609:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_060e:  nop
//000160:             this.tbWorkFactor.ValueChanged += new System.EventHandler(this.tbWorkFactor_ValueChanged);
    IL_060f:  ldarg.0
    IL_0610:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0615:  ldarg.0
    IL_0616:  ldftn      instance void VisualizePartitioning.MainForm::tbWorkFactor_ValueChanged(object,
                                                                                                 class [mscorlib]System.EventArgs)
    IL_061c:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0621:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0626:  nop
//000161:             // 
//000162:             // label3
//000163:             // 
//000164:             this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0627:  ldarg.0
    IL_0628:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_062d:  ldc.i4.s   9
    IL_062f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0634:  nop
//000165:             this.label3.AutoSize = true;
    IL_0635:  ldarg.0
    IL_0636:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_063b:  ldc.i4.1
    IL_063c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0641:  nop
//000166:             this.label3.Location = new System.Drawing.Point(557, 385);
    IL_0642:  ldarg.0
    IL_0643:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0648:  ldc.i4     0x22d
    IL_064d:  ldc.i4     0x181
    IL_0652:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0657:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_065c:  nop
//000167:             this.label3.Name = "label3";
    IL_065d:  ldarg.0
    IL_065e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0663:  ldstr      "label3"
    IL_0668:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_066d:  nop
//000168:             this.label3.Size = new System.Drawing.Size(66, 13);
    IL_066e:  ldarg.0
    IL_066f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0674:  ldc.i4.s   66
    IL_0676:  ldc.i4.s   13
    IL_0678:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_067d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0682:  nop
//000169:             this.label3.TabIndex = 8;
    IL_0683:  ldarg.0
    IL_0684:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0689:  ldc.i4.8
    IL_068a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_068f:  nop
//000170:             this.label3.Text = "Work Factor";
    IL_0690:  ldarg.0
    IL_0691:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0696:  ldstr      "Work Factor"
    IL_069b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_06a0:  nop
//000171:             // 
//000172:             // rbParallelFor
//000173:             // 
//000174:             this.rbParallelFor.AutoSize = true;
    IL_06a1:  ldarg.0
    IL_06a2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06a7:  ldc.i4.1
    IL_06a8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_06ad:  nop
//000175:             this.rbParallelFor.Checked = true;
    IL_06ae:  ldarg.0
    IL_06af:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06b4:  ldc.i4.1
    IL_06b5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_Checked(bool)
    IL_06ba:  nop
//000176:             this.rbParallelFor.Location = new System.Drawing.Point(7, 18);
    IL_06bb:  ldarg.0
    IL_06bc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06c1:  ldc.i4.7
    IL_06c2:  ldc.i4.s   18
    IL_06c4:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_06c9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_06ce:  nop
//000177:             this.rbParallelFor.Name = "rbParallelFor";
    IL_06cf:  ldarg.0
    IL_06d0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06d5:  ldstr      "rbParallelFor"
    IL_06da:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_06df:  nop
//000178:             this.rbParallelFor.Size = new System.Drawing.Size(77, 17);
    IL_06e0:  ldarg.0
    IL_06e1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06e6:  ldc.i4.s   77
    IL_06e8:  ldc.i4.s   17
    IL_06ea:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_06ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_06f4:  nop
//000179:             this.rbParallelFor.TabIndex = 9;
    IL_06f5:  ldarg.0
    IL_06f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_06fb:  ldc.i4.s   9
    IL_06fd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0702:  nop
//000180:             this.rbParallelFor.TabStop = true;
    IL_0703:  ldarg.0
    IL_0704:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_0709:  ldc.i4.1
    IL_070a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_TabStop(bool)
    IL_070f:  nop
//000181:             this.rbParallelFor.Text = "Parallel.For";
    IL_0710:  ldarg.0
    IL_0711:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_0716:  ldstr      "Parallel.For"
    IL_071b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0720:  nop
//000182:             this.rbParallelFor.UseVisualStyleBackColor = true;
    IL_0721:  ldarg.0
    IL_0722:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_0727:  ldc.i4.1
    IL_0728:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_072d:  nop
//000183:             this.rbParallelFor.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
    IL_072e:  ldarg.0
    IL_072f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_0734:  ldarg.0
    IL_0735:  ldftn      instance void VisualizePartitioning.MainForm::rbAPI_CheckedChanged(object,
                                                                                            class [mscorlib]System.EventArgs)
    IL_073b:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0740:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_0745:  nop
//000184:             // 
//000185:             // rbParallelForEach
//000186:             // 
//000187:             this.rbParallelForEach.AutoSize = true;
    IL_0746:  ldarg.0
    IL_0747:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_074c:  ldc.i4.1
    IL_074d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0752:  nop
//000188:             this.rbParallelForEach.Location = new System.Drawing.Point(6, 41);
    IL_0753:  ldarg.0
    IL_0754:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_0759:  ldc.i4.6
    IL_075a:  ldc.i4.s   41
    IL_075c:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0761:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0766:  nop
//000189:             this.rbParallelForEach.Name = "rbParallelForEach";
    IL_0767:  ldarg.0
    IL_0768:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_076d:  ldstr      "rbParallelForEach"
    IL_0772:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0777:  nop
//000190:             this.rbParallelForEach.Size = new System.Drawing.Size(102, 17);
    IL_0778:  ldarg.0
    IL_0779:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_077e:  ldc.i4.s   102
    IL_0780:  ldc.i4.s   17
    IL_0782:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0787:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_078c:  nop
//000191:             this.rbParallelForEach.TabIndex = 10;
    IL_078d:  ldarg.0
    IL_078e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_0793:  ldc.i4.s   10
    IL_0795:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_079a:  nop
//000192:             this.rbParallelForEach.TabStop = true;
    IL_079b:  ldarg.0
    IL_079c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_07a1:  ldc.i4.1
    IL_07a2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_TabStop(bool)
    IL_07a7:  nop
//000193:             this.rbParallelForEach.Text = "Parallel.ForEach";
    IL_07a8:  ldarg.0
    IL_07a9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_07ae:  ldstr      "Parallel.ForEach"
    IL_07b3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_07b8:  nop
//000194:             this.rbParallelForEach.UseVisualStyleBackColor = true;
    IL_07b9:  ldarg.0
    IL_07ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_07bf:  ldc.i4.1
    IL_07c0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_07c5:  nop
//000195:             this.rbParallelForEach.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
    IL_07c6:  ldarg.0
    IL_07c7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_07cc:  ldarg.0
    IL_07cd:  ldftn      instance void VisualizePartitioning.MainForm::rbAPI_CheckedChanged(object,
                                                                                            class [mscorlib]System.EventArgs)
    IL_07d3:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_07d8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_07dd:  nop
//000196:             // 
//000197:             // rbPLINQ
//000198:             // 
//000199:             this.rbPLINQ.AutoSize = true;
    IL_07de:  ldarg.0
    IL_07df:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_07e4:  ldc.i4.1
    IL_07e5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_07ea:  nop
//000200:             this.rbPLINQ.Location = new System.Drawing.Point(6, 64);
    IL_07eb:  ldarg.0
    IL_07ec:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_07f1:  ldc.i4.6
    IL_07f2:  ldc.i4.s   64
    IL_07f4:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_07f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_07fe:  nop
//000201:             this.rbPLINQ.Name = "rbPLINQ";
    IL_07ff:  ldarg.0
    IL_0800:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0805:  ldstr      "rbPLINQ"
    IL_080a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_080f:  nop
//000202:             this.rbPLINQ.Size = new System.Drawing.Size(57, 17);
    IL_0810:  ldarg.0
    IL_0811:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0816:  ldc.i4.s   57
    IL_0818:  ldc.i4.s   17
    IL_081a:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_081f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0824:  nop
//000203:             this.rbPLINQ.TabIndex = 11;
    IL_0825:  ldarg.0
    IL_0826:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_082b:  ldc.i4.s   11
    IL_082d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0832:  nop
//000204:             this.rbPLINQ.TabStop = true;
    IL_0833:  ldarg.0
    IL_0834:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0839:  ldc.i4.1
    IL_083a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::set_TabStop(bool)
    IL_083f:  nop
//000205:             this.rbPLINQ.Text = "PLINQ";
    IL_0840:  ldarg.0
    IL_0841:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0846:  ldstr      "PLINQ"
    IL_084b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0850:  nop
//000206:             this.rbPLINQ.UseVisualStyleBackColor = true;
    IL_0851:  ldarg.0
    IL_0852:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0857:  ldc.i4.1
    IL_0858:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_085d:  nop
//000207:             this.rbPLINQ.CheckedChanged += new System.EventHandler(this.rbAPI_CheckedChanged);
    IL_085e:  ldarg.0
    IL_085f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0864:  ldarg.0
    IL_0865:  ldftn      instance void VisualizePartitioning.MainForm::rbAPI_CheckedChanged(object,
                                                                                            class [mscorlib]System.EventArgs)
    IL_086b:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0870:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.RadioButton::add_CheckedChanged(class [mscorlib]System.EventHandler)
    IL_0875:  nop
//000208:             // 
//000209:             // groupBox1
//000210:             // 
//000211:             this.groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0876:  ldarg.0
    IL_0877:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_087c:  ldc.i4.s   9
    IL_087e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0883:  nop
//000212:             this.groupBox1.Controls.Add(this.rbParallelForEach);
    IL_0884:  ldarg.0
    IL_0885:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_088a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_088f:  ldarg.0
    IL_0890:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_0895:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_089a:  nop
//000213:             this.groupBox1.Controls.Add(this.rbPLINQ);
    IL_089b:  ldarg.0
    IL_089c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_08a1:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_08a6:  ldarg.0
    IL_08a7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_08ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_08b1:  nop
//000214:             this.groupBox1.Controls.Add(this.rbParallelFor);
    IL_08b2:  ldarg.0
    IL_08b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_08b8:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_08bd:  ldarg.0
    IL_08be:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_08c3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_08c8:  nop
//000215:             this.groupBox1.Location = new System.Drawing.Point(557, 12);
    IL_08c9:  ldarg.0
    IL_08ca:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_08cf:  ldc.i4     0x22d
    IL_08d4:  ldc.i4.s   12
    IL_08d6:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_08db:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_08e0:  nop
//000216:             this.groupBox1.Name = "groupBox1";
    IL_08e1:  ldarg.0
    IL_08e2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_08e7:  ldstr      "groupBox1"
    IL_08ec:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_08f1:  nop
//000217:             this.groupBox1.Size = new System.Drawing.Size(130, 91);
    IL_08f2:  ldarg.0
    IL_08f3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_08f8:  ldc.i4     0x82
    IL_08fd:  ldc.i4.s   91
    IL_08ff:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0904:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0909:  nop
//000218:             this.groupBox1.TabIndex = 12;
    IL_090a:  ldarg.0
    IL_090b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_0910:  ldc.i4.s   12
    IL_0912:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0917:  nop
//000219:             this.groupBox1.TabStop = false;
    IL_0918:  ldarg.0
    IL_0919:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_091e:  ldc.i4.0
    IL_091f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.GroupBox::set_TabStop(bool)
    IL_0924:  nop
//000220:             this.groupBox1.Text = "API";
    IL_0925:  ldarg.0
    IL_0926:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_092b:  ldstr      "API"
    IL_0930:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0935:  nop
//000221:             // 
//000222:             // label4
//000223:             // 
//000224:             this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_0936:  ldarg.0
    IL_0937:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_093c:  ldc.i4.s   9
    IL_093e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0943:  nop
//000225:             this.label4.AutoSize = true;
    IL_0944:  ldarg.0
    IL_0945:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_094a:  ldc.i4.1
    IL_094b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_AutoSize(bool)
    IL_0950:  nop
//000226:             this.label4.Location = new System.Drawing.Point(556, 436);
    IL_0951:  ldarg.0
    IL_0952:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_0957:  ldc.i4     0x22c
    IL_095c:  ldc.i4     0x1b4
    IL_0961:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0966:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_096b:  nop
//000227:             this.label4.Name = "label4";
    IL_096c:  ldarg.0
    IL_096d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_0972:  ldstr      "label4"
    IL_0977:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_097c:  nop
//000228:             this.label4.Size = new System.Drawing.Size(34, 13);
    IL_097d:  ldarg.0
    IL_097e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_0983:  ldc.i4.s   34
    IL_0985:  ldc.i4.s   13
    IL_0987:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_098c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0991:  nop
//000229:             this.label4.TabIndex = 14;
    IL_0992:  ldarg.0
    IL_0993:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_0998:  ldc.i4.s   14
    IL_099a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_099f:  nop
//000230:             this.label4.Text = "Cores";
    IL_09a0:  ldarg.0
    IL_09a1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_09a6:  ldstr      "Cores"
    IL_09ab:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_09b0:  nop
//000231:             // 
//000232:             // tbCores
//000233:             // 
//000234:             this.tbCores.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
    IL_09b1:  ldarg.0
    IL_09b2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_09b7:  ldc.i4.s   9
    IL_09b9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_09be:  nop
//000235:             this.tbCores.LargeChange = 1;
    IL_09bf:  ldarg.0
    IL_09c0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_09c5:  ldc.i4.1
    IL_09c6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_LargeChange(int32)
    IL_09cb:  nop
//000236:             this.tbCores.Location = new System.Drawing.Point(557, 459);
    IL_09cc:  ldarg.0
    IL_09cd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_09d2:  ldc.i4     0x22d
    IL_09d7:  ldc.i4     0x1cb
    IL_09dc:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_09e1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_09e6:  nop
//000237:             this.tbCores.Maximum = 100;
    IL_09e7:  ldarg.0
    IL_09e8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_09ed:  ldc.i4.s   100
    IL_09ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_09f4:  nop
//000238:             this.tbCores.Minimum = 1;
    IL_09f5:  ldarg.0
    IL_09f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_09fb:  ldc.i4.1
    IL_09fc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0a01:  nop
//000239:             this.tbCores.Name = "tbCores";
    IL_0a02:  ldarg.0
    IL_0a03:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a08:  ldstr      "tbCores"
    IL_0a0d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0a12:  nop
//000240:             this.tbCores.Size = new System.Drawing.Size(123, 45);
    IL_0a13:  ldarg.0
    IL_0a14:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a19:  ldc.i4.s   123
    IL_0a1b:  ldc.i4.s   45
    IL_0a1d:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0a22:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0a27:  nop
//000241:             this.tbCores.TabIndex = 13;
    IL_0a28:  ldarg.0
    IL_0a29:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a2e:  ldc.i4.s   13
    IL_0a30:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0a35:  nop
//000242:             this.tbCores.TickStyle = System.Windows.Forms.TickStyle.None;
    IL_0a36:  ldarg.0
    IL_0a37:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a3c:  ldc.i4.0
    IL_0a3d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_TickStyle(valuetype [System.Windows.Forms]System.Windows.Forms.TickStyle)
    IL_0a42:  nop
//000243:             this.tbCores.Value = 1;
    IL_0a43:  ldarg.0
    IL_0a44:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a49:  ldc.i4.1
    IL_0a4a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_0a4f:  nop
//000244:             this.tbCores.ValueChanged += new System.EventHandler(this.tbCores_ValueChanged);
    IL_0a50:  ldarg.0
    IL_0a51:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0a56:  ldarg.0
    IL_0a57:  ldftn      instance void VisualizePartitioning.MainForm::tbCores_ValueChanged(object,
                                                                                            class [mscorlib]System.EventArgs)
    IL_0a5d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0a62:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::add_ValueChanged(class [mscorlib]System.EventHandler)
    IL_0a67:  nop
//000245:             // 
//000246:             // MainForm
//000247:             // 
//000248:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0a68:  ldarg.0
    IL_0a69:  ldc.r4     6.
    IL_0a6e:  ldc.r4     13.
    IL_0a73:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0a78:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_0a7d:  nop
//000249:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_0a7e:  ldarg.0
    IL_0a7f:  ldc.i4.1
    IL_0a80:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_0a85:  nop
//000250:             this.ClientSize = new System.Drawing.Size(695, 547);
    IL_0a86:  ldarg.0
    IL_0a87:  ldc.i4     0x2b7
    IL_0a8c:  ldc.i4     0x223
    IL_0a91:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0a96:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_0a9b:  nop
//000251:             this.Controls.Add(this.btnVisualize);
    IL_0a9c:  ldarg.0
    IL_0a9d:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0aa2:  ldarg.0
    IL_0aa3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_0aa8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0aad:  nop
//000252:             this.Controls.Add(this.label4);
    IL_0aae:  ldarg.0
    IL_0aaf:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0ab4:  ldarg.0
    IL_0ab5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label4
    IL_0aba:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0abf:  nop
//000253:             this.Controls.Add(this.tbCores);
    IL_0ac0:  ldarg.0
    IL_0ac1:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0ac6:  ldarg.0
    IL_0ac7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0acc:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0ad1:  nop
//000254:             this.Controls.Add(this.groupBox1);
    IL_0ad2:  ldarg.0
    IL_0ad3:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0ad8:  ldarg.0
    IL_0ad9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_0ade:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0ae3:  nop
//000255:             this.Controls.Add(this.label3);
    IL_0ae4:  ldarg.0
    IL_0ae5:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0aea:  ldarg.0
    IL_0aeb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label3
    IL_0af0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0af5:  nop
//000256:             this.Controls.Add(this.tbWorkFactor);
    IL_0af6:  ldarg.0
    IL_0af7:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0afc:  ldarg.0
    IL_0afd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0b02:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b07:  nop
//000257:             this.Controls.Add(this.lblTime);
    IL_0b08:  ldarg.0
    IL_0b09:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b0e:  ldarg.0
    IL_0b0f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::lblTime
    IL_0b14:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b19:  nop
//000258:             this.Controls.Add(this.label2);
    IL_0b1a:  ldarg.0
    IL_0b1b:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b20:  ldarg.0
    IL_0b21:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label2
    IL_0b26:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b2b:  nop
//000259:             this.Controls.Add(this.label1);
    IL_0b2c:  ldarg.0
    IL_0b2d:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b32:  ldarg.0
    IL_0b33:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Label VisualizePartitioning.MainForm::label1
    IL_0b38:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b3d:  nop
//000260:             this.Controls.Add(this.lvWorkloads);
    IL_0b3e:  ldarg.0
    IL_0b3f:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b44:  ldarg.0
    IL_0b45:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0b4a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b4f:  nop
//000261:             this.Controls.Add(this.lvPartitioningMethods);
    IL_0b50:  ldarg.0
    IL_0b51:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b56:  ldarg.0
    IL_0b57:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0b5c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b61:  nop
//000262:             this.Controls.Add(this.pbPartitionedImage);
    IL_0b62:  ldarg.0
    IL_0b63:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0b68:  ldarg.0
    IL_0b69:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0b6e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0b73:  nop
//000263:             this.Name = "MainForm";
    IL_0b74:  ldarg.0
    IL_0b75:  ldstr      "MainForm"
    IL_0b7a:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0b7f:  nop
//000264:             this.Text = "Visualize Partitioning";
    IL_0b80:  ldarg.0
    IL_0b81:  ldstr      "Visualize Partitioning"
    IL_0b86:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0b8b:  nop
//000265:             ((System.ComponentModel.ISupportInitialize)(this.pbPartitionedImage)).EndInit();
    IL_0b8c:  ldarg.0
    IL_0b8d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0b92:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0b97:  nop
//000266:             ((System.ComponentModel.ISupportInitialize)(this.tbWorkFactor)).EndInit();
    IL_0b98:  ldarg.0
    IL_0b99:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0b9e:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0ba3:  nop
//000267:             this.groupBox1.ResumeLayout(false);
    IL_0ba4:  ldarg.0
    IL_0ba5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_0baa:  ldc.i4.0
    IL_0bab:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0bb0:  nop
//000268:             this.groupBox1.PerformLayout();
    IL_0bb1:  ldarg.0
    IL_0bb2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.GroupBox VisualizePartitioning.MainForm::groupBox1
    IL_0bb7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_0bbc:  nop
//000269:             ((System.ComponentModel.ISupportInitialize)(this.tbCores)).EndInit();
    IL_0bbd:  ldarg.0
    IL_0bbe:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0bc3:  callvirt   instance void [System]System.ComponentModel.ISupportInitialize::EndInit()
    IL_0bc8:  nop
//000270:             this.ResumeLayout(false);
    IL_0bc9:  ldarg.0
    IL_0bca:  ldc.i4.0
    IL_0bcb:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0bd0:  nop
//000271:             this.PerformLayout();
    IL_0bd1:  ldarg.0
    IL_0bd2:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_0bd7:  nop
//000272: 
//000273:         }
    IL_0bd8:  ret
  } // end of method MainForm::InitializeComponent

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       80 (0x50)
    .maxstack  3
//000008:         private System.ComponentModel.IContainer components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.IContainer VisualizePartitioning.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs' 
//000041:         public MainForm()
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_000d:  nop
//000042:         {
    IL_000e:  nop
//000043:             InitializeComponent();
    IL_000f:  ldarg.0
    IL_0010:  call       instance void VisualizePartitioning.MainForm::InitializeComponent()
    IL_0015:  nop
//000044: 
//000045:             // Configure the workloads and the color palette.  The partitioning methods initialization will be done
//000046:             // when the radio button is changed to Parallel.ForEach or PLINQ.  The color palette will be
//000047:             // initialized when the cores trackbar changes value.
//000048:             InitializeWorkloads();
    IL_0016:  ldarg.0
    IL_0017:  call       instance void VisualizePartitioning.MainForm::InitializeWorkloads()
    IL_001c:  nop
//000049: 
//000050:             // Configure number of cores
//000051:             tbCores.Minimum = 1;
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0023:  ldc.i4.1
    IL_0024:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Minimum(int32)
    IL_0029:  nop
//000052:             tbCores.Maximum = Environment.ProcessorCount * 2;
    IL_002a:  ldarg.0
    IL_002b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0030:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
    IL_0035:  ldc.i4.2
    IL_0036:  mul
    IL_0037:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Maximum(int32)
    IL_003c:  nop
//000053:             tbCores.Value = Environment.ProcessorCount;
    IL_003d:  ldarg.0
    IL_003e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0043:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
    IL_0048:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.TrackBar::set_Value(int32)
    IL_004d:  nop
//000054:         }
    IL_004e:  nop
    IL_004f:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          InitializeColorPalette() cil managed
  {
    // Code size       66 (0x42)
    .maxstack  5
    .locals init ([0] class VisualizePartitioning.MainForm/'<>c__DisplayClass1' 'CS$<>8__locals2')
//000055: 
//000056:         /// <summary>Initializes the color palette to use when rendering threads.</summary>
//000057:         private void InitializeColorPalette()
//000058:         {
//000059:             Random random = new Random(8); // Change seed value to change the palette used
//000060:             _colors = (from i in Enumerable.Range(0, tbCores.Value)
//000061:                        select Color.FromArgb(random.Next(128) + 127, random.Next(128) + 127, random.Next(128) + 127)).ToArray();
//000062:         }
//000063: 
//000064:         /// <summary>Initializes the workloads list view.</summary>
//000065:         private void InitializeWorkloads()
//000066:         {
//000067:             lvWorkloads.Items.Clear();
//000068:             var workloads = new List<Tuple<string, Func<int, int, int>>>();
//000069: 
//000070:             // NOTE: To add a new workload, simply add a new entry below with a name and corresponding function
//000071:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
//000072:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0000:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass1'::.ctor()
    IL_0005:  stloc.0
//000058:         {
    IL_0006:  nop
//000059:             Random random = new Random(8); // Change seed value to change the palette used
    IL_0007:  ldloc.0
    IL_0008:  ldc.i4.8
    IL_0009:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
    IL_000e:  stfld      class [mscorlib]System.Random VisualizePartitioning.MainForm/'<>c__DisplayClass1'::random
//000060:             _colors = (from i in Enumerable.Range(0, tbCores.Value)
    IL_0013:  ldarg.0
    IL_0014:  ldc.i4.0
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_001b:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0020:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<int32> [System.Core]System.Linq.Enumerable::Range(int32,
                                                                                                                                    int32)
    IL_0025:  ldloc.0
    IL_0026:  ldftn      instance valuetype [System.Drawing]System.Drawing.Color VisualizePartitioning.MainForm/'<>c__DisplayClass1'::'<InitializeColorPalette>b__0'(int32)
    IL_002c:  newobj     instance void class [mscorlib]System.Func`2<int32,valuetype [System.Drawing]System.Drawing.Color>::.ctor(object,
                                                                                                                                  native int)
    IL_0031:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<int32,valuetype [System.Drawing]System.Drawing.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                         class [mscorlib]System.Func`2<!!0,!!1>)
    IL_0036:  call       !!0[] [System.Core]System.Linq.Enumerable::ToArray<valuetype [System.Drawing]System.Drawing.Color>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_003b:  stfld      valuetype [System.Drawing]System.Drawing.Color[] VisualizePartitioning.MainForm::_colors
//000061:                        select Color.FromArgb(random.Next(128) + 127, random.Next(128) + 127, random.Next(128) + 127)).ToArray();
//000062:         }
    IL_0040:  nop
    IL_0041:  ret
  } // end of method MainForm::InitializeColorPalette

  .method private hidebysig instance void 
          InitializeWorkloads() cil managed
  {
    // Code size       252 (0xfc)
    .maxstack  5
    .locals init ([0] class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>> workloads,
             [1] class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> workload,
             [2] class [System.Windows.Forms]System.Windows.Forms.ListViewItem '<>g__initLocal3',
             [3] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>> CS$5$0000,
             [4] bool CS$4$0001)
//000063: 
//000064:         /// <summary>Initializes the workloads list view.</summary>
//000065:         private void InitializeWorkloads()
//000066:         {
    IL_0000:  nop
//000067:             lvWorkloads.Items.Clear();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_0007:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
    IL_000c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::Clear()
    IL_0011:  nop
//000068:             var workloads = new List<Tuple<string, Func<int, int, int>>>();
    IL_0012:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::.ctor()
    IL_0017:  stloc.0
//000069: 
//000070:             // NOTE: To add a new workload, simply add a new entry below with a name and corresponding function
//000071:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
    IL_0018:  ldloc.0
    IL_0019:  ldstr      "Constant"
    IL_001e:  ldarg.0
    IL_001f:  ldftn      instance int32 VisualizePartitioning.MainForm::'<InitializeWorkloads>b__4'(int32,
                                                                                                    int32)
    IL_0025:  newobj     instance void class [mscorlib]System.Func`3<int32,int32,int32>::.ctor(object,
                                                                                               native int)
    IL_002a:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`3<int32,int32,int32>>(!!0,
                                                                                                                                                         !!1)
    IL_002f:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::Add(!0)
    IL_0034:  nop
//000072:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
    IL_0035:  ldloc.0
    IL_0036:  ldstr      "Increasing Linear"
    IL_003b:  ldarg.0
    IL_003c:  ldftn      instance int32 VisualizePartitioning.MainForm::'<InitializeWorkloads>b__5'(int32,
                                                                                                    int32)
    IL_0042:  newobj     instance void class [mscorlib]System.Func`3<int32,int32,int32>::.ctor(object,
                                                                                               native int)
    IL_0047:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`3<int32,int32,int32>>(!!0,
                                                                                                                                                         !!1)
    IL_004c:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::Add(!0)
    IL_0051:  nop
//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
    IL_0052:  ldloc.0
    IL_0053:  ldstr      "Decreasing Linear"
    IL_0058:  ldarg.0
    IL_0059:  ldftn      instance int32 VisualizePartitioning.MainForm::'<InitializeWorkloads>b__6'(int32,
                                                                                                    int32)
    IL_005f:  newobj     instance void class [mscorlib]System.Func`3<int32,int32,int32>::.ctor(object,
                                                                                               native int)
    IL_0064:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`3<int32,int32,int32>>(!!0,
                                                                                                                                                         !!1)
    IL_0069:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::Add(!0)
    IL_006e:  nop
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
    IL_006f:  ldloc.0
    IL_0070:  ldstr      "Random"
    IL_0075:  ldarg.0
    IL_0076:  ldftn      instance int32 VisualizePartitioning.MainForm::'<InitializeWorkloads>b__7'(int32,
                                                                                                    int32)
    IL_007c:  newobj     instance void class [mscorlib]System.Func`3<int32,int32,int32>::.ctor(object,
                                                                                               native int)
    IL_0081:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`3<int32,int32,int32>>(!!0,
                                                                                                                                                         !!1)
    IL_0086:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::Add(!0)
    IL_008b:  nop
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
    IL_008c:  nop
    IL_008d:  ldloc.0
    IL_008e:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::GetEnumerator()
    IL_0093:  stloc.3
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    .try
    {
      IL_0094:  br.s       IL_00c4

//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
      IL_0096:  ldloca.s   CS$5$0000
      IL_0098:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::get_Current()
      IL_009d:  stloc.1
      IL_009e:  ldarg.0
      IL_009f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
      IL_00a4:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
      IL_00a9:  ldloc.1
      IL_00aa:  callvirt   instance !0 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>::get_Item1()
      IL_00af:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::.ctor(string)
      IL_00b4:  stloc.2
      IL_00b5:  ldloc.2
      IL_00b6:  ldloc.1
      IL_00b7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::set_Tag(object)
      IL_00bc:  nop
      IL_00bd:  ldloc.2
      IL_00be:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::Add(class [System.Windows.Forms]System.Windows.Forms.ListViewItem)
      IL_00c3:  pop
      IL_00c4:  ldloca.s   CS$5$0000
      IL_00c6:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>::MoveNext()
      IL_00cb:  stloc.s    CS$4$0001
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_00cd:  ldloc.s    CS$4$0001
      IL_00cf:  brtrue.s   IL_0096

      IL_00d1:  leave.s    IL_00e2

    }  // end .try
    finally
    {
      IL_00d3:  ldloca.s   CS$5$0000
      IL_00d5:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>>
      IL_00db:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00e0:  nop
      IL_00e1:  endfinally
    }  // end handler
    IL_00e2:  nop
//000077:             lvWorkloads.Items[0].Selected = true;
    IL_00e3:  ldarg.0
    IL_00e4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_00e9:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
    IL_00ee:  ldc.i4.0
    IL_00ef:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::get_Item(int32)
    IL_00f4:  ldc.i4.1
    IL_00f5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::set_Selected(bool)
    IL_00fa:  nop
//000078:         }
    IL_00fb:  ret
  } // end of method MainForm::InitializeWorkloads

  .method private hidebysig instance void 
          InitializePartitioningMethods() cil managed
  {
    // Code size       605 (0x25d)
    .maxstack  5
    .locals init ([0] bool usingPLINQ,
             [1] class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>> partitioningMethods,
             [2] class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> 'method',
             [3] class [System.Windows.Forms]System.Windows.Forms.ListViewItem '<>g__initLocal8',
             [4] bool CS$4$0000,
             [5] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>> CS$5$0001)
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
    IL_0000:  nop
//000083:             lvPartitioningMethods.Items.Clear();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0007:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
    IL_000c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::Clear()
    IL_0011:  nop
//000084:             bool usingPLINQ = rbPLINQ.Checked;
    IL_0012:  ldarg.0
    IL_0013:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbPLINQ
    IL_0018:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.RadioButton::get_Checked()
    IL_001d:  stloc.0
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
    IL_001e:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::.ctor()
    IL_0023:  stloc.1
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
    IL_0024:  ldloc.0
    IL_0025:  ldc.i4.0
    IL_0026:  ceq
    IL_0028:  stloc.s    CS$4$0000
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_002a:  ldloc.s    CS$4$0000
    IL_002c:  brtrue.s   IL_0060

//000090:             {
    IL_002e:  nop
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_002f:  ldloc.1
    IL_0030:  ldstr      "Static"
    IL_0035:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate15'
    IL_003a:  brtrue.s   IL_004f

    IL_003c:  ldnull
    IL_003d:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__9'(int32[])
    IL_0043:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_0048:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate15'
    IL_004d:  br.s       IL_004f

    IL_004f:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate15'
    IL_0054:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_0059:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_005e:  nop
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
    IL_005f:  nop
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_0060:  ldloc.1
    IL_0061:  ldstr      "Load Balance"
    IL_0066:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate16'
    IL_006b:  brtrue.s   IL_0080

    IL_006d:  ldnull
    IL_006e:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__a'(int32[])
    IL_0074:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_0079:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate16'
    IL_007e:  br.s       IL_0080

    IL_0080:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate16'
    IL_0085:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_008a:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_008f:  nop
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_0090:  ldloc.1
    IL_0091:  ldstr      "Dynamic(1)"
    IL_0096:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate17'
    IL_009b:  brtrue.s   IL_00b0

    IL_009d:  ldnull
    IL_009e:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__b'(int32[])
    IL_00a4:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_00a9:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate17'
    IL_00ae:  br.s       IL_00b0

    IL_00b0:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate17'
    IL_00b5:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_00ba:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_00bf:  nop
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_00c0:  ldloc.1
    IL_00c1:  ldstr      "Dynamic(16)"
    IL_00c6:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate18'
    IL_00cb:  brtrue.s   IL_00e0

    IL_00cd:  ldnull
    IL_00ce:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__c'(int32[])
    IL_00d4:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_00d9:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate18'
    IL_00de:  br.s       IL_00e0

    IL_00e0:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate18'
    IL_00e5:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_00ea:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_00ef:  nop
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_00f0:  ldloc.1
    IL_00f1:  ldstr      "Guided"
    IL_00f6:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate19'
    IL_00fb:  brtrue.s   IL_0110

    IL_00fd:  ldnull
    IL_00fe:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__d'(int32[])
    IL_0104:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_0109:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate19'
    IL_010e:  br.s       IL_0110

    IL_0110:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate19'
    IL_0115:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_011a:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_011f:  nop
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_0120:  ldloc.1
    IL_0121:  ldstr      "Grow Exponential"
    IL_0126:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1a'
    IL_012b:  brtrue.s   IL_0140

    IL_012d:  ldnull
    IL_012e:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__f'(int32[])
    IL_0134:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_0139:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1a'
    IL_013e:  br.s       IL_0140

    IL_0140:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1a'
    IL_0145:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_014a:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_014f:  nop
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_0150:  ldloc.1
    IL_0151:  ldstr      "Random"
    IL_0156:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1b'
    IL_015b:  brtrue.s   IL_0170

    IL_015d:  ldnull
    IL_015e:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__11'(int32[])
    IL_0164:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_0169:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1b'
    IL_016e:  br.s       IL_0170

    IL_0170:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1b'
    IL_0175:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_017a:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_017f:  nop
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
    IL_0180:  ldloc.0
    IL_0181:  ldc.i4.0
    IL_0182:  ceq
    IL_0184:  stloc.s    CS$4$0000
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0186:  ldloc.s    CS$4$0000
    IL_0188:  brtrue.s   IL_01ec

//000116:             {
    IL_018a:  nop
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_018b:  ldloc.1
    IL_018c:  ldstr      "Stripe"
    IL_0191:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_0196:  brtrue.s   IL_01ab

    IL_0198:  ldnull
    IL_0199:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__13'(int32[])
    IL_019f:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_01a4:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_01a9:  br.s       IL_01ab

    IL_01ab:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1c'
    IL_01b0:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_01b5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_01ba:  nop
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
    IL_01bb:  ldloc.1
    IL_01bc:  ldstr      "Hash"
    IL_01c1:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_01c6:  brtrue.s   IL_01db

    IL_01c8:  ldnull
    IL_01c9:  ldftn      class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__14'(int32[])
    IL_01cf:  newobj     instance void class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>::.ctor(object,
                                                                                                                                                        native int)
    IL_01d4:  stsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_01d9:  br.s       IL_01db

    IL_01db:  ldsfld     class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate1d'
    IL_01e0:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>(!!0,
                                                                                                                                                                                                                  !!1)
    IL_01e5:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::Add(!0)
    IL_01ea:  nop
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
    IL_01eb:  nop
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
    IL_01ec:  nop
    IL_01ed:  ldloc.1
    IL_01ee:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::GetEnumerator()
    IL_01f3:  stloc.s    CS$5$0001
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    .try
    {
      IL_01f5:  br.s       IL_0225

//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
      IL_01f7:  ldloca.s   CS$5$0001
      IL_01f9:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::get_Current()
      IL_01fe:  stloc.2
      IL_01ff:  ldarg.0
      IL_0200:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
      IL_0205:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
      IL_020a:  ldloc.2
      IL_020b:  callvirt   instance !0 class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>::get_Item1()
      IL_0210:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::.ctor(string)
      IL_0215:  stloc.3
      IL_0216:  ldloc.3
      IL_0217:  ldloc.2
      IL_0218:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::set_Tag(object)
      IL_021d:  nop
      IL_021e:  ldloc.3
      IL_021f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::Add(class [System.Windows.Forms]System.Windows.Forms.ListViewItem)
      IL_0224:  pop
      IL_0225:  ldloca.s   CS$5$0001
      IL_0227:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>::MoveNext()
      IL_022c:  stloc.s    CS$4$0000
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
      IL_022e:  ldloc.s    CS$4$0000
      IL_0230:  brtrue.s   IL_01f7

      IL_0232:  leave.s    IL_0243

    }  // end .try
    finally
    {
      IL_0234:  ldloca.s   CS$5$0001
      IL_0236:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>>
      IL_023c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0241:  nop
      IL_0242:  endfinally
    }  // end handler
    IL_0243:  nop
//000127:             lvPartitioningMethods.Items[0].Selected = true;
    IL_0244:  ldarg.0
    IL_0245:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_024a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_Items()
    IL_024f:  ldc.i4.0
    IL_0250:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/ListViewItemCollection::get_Item(int32)
    IL_0255:  ldc.i4.1
    IL_0256:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListViewItem::set_Selected(bool)
    IL_025b:  nop
//000128:         }
    IL_025c:  ret
  } // end of method MainForm::InitializePartitioningMethods

  .method private hidebysig instance void 
          btnVisualize_Click(object sender,
                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       343 (0x157)
    .maxstack  4
    .locals init ([0] class VisualizePartitioning.MainForm/'<>c__DisplayClass2f' 'CS$<>8__locals30',
             [1] bool CS$4$0000)
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0000:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.0
    IL_0008:  stfld      class VisualizePartitioning.MainForm VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<>4__this'
//000132:         {
    IL_000d:  nop
//000133:             int numProcs = tbCores.Value;
    IL_000e:  ldloc.0
    IL_000f:  ldarg.0
    IL_0010:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0015:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_001a:  stfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::numProcs
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
    IL_001f:  ldloc.0
    IL_0020:  ldarg.0
    IL_0021:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0026:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Width()
    IL_002b:  stfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::width
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox VisualizePartitioning.MainForm::pbPartitionedImage
    IL_0037:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.Control::get_Height()
    IL_003c:  stfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
    IL_0041:  ldloc.0
    IL_0042:  ldarg.0
    IL_0043:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_0048:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.RadioButton::get_Checked()
    IL_004d:  stfld      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::useParallelFor
    IL_0052:  ldloc.0
    IL_0053:  ldarg.0
    IL_0054:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelForEach
    IL_0059:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.RadioButton::get_Checked()
    IL_005e:  stfld      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::useParallelForEach
//000136:             _workFactor = tbWorkFactor.Value;
    IL_0063:  ldarg.0
    IL_0064:  ldarg.0
    IL_0065:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_006a:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_006f:  stfld      int32 VisualizePartitioning.MainForm::_workFactor
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
    IL_0074:  ldloc.0
    IL_0075:  ldnull
    IL_0076:  stfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedMethod
//000140:             if (!useParallelFor)
    IL_007b:  ldloc.0
    IL_007c:  ldfld      bool VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::useParallelFor
    IL_0081:  stloc.1
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0082:  ldloc.1
    IL_0083:  brtrue.s   IL_00c7

//000141:             {
    IL_0085:  nop
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
    IL_0086:  ldarg.0
    IL_0087:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_008c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/SelectedIndexCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_SelectedIndices()
    IL_0091:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.ListView/SelectedIndexCollection::get_Count()
    IL_0096:  ldc.i4.0
    IL_0097:  ceq
    IL_0099:  ldc.i4.0
    IL_009a:  ceq
    IL_009c:  stloc.1
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_009d:  ldloc.1
    IL_009e:  brtrue.s   IL_00a5

//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
    IL_00a0:  br         IL_0156

//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
    IL_00a5:  ldloc.0
    IL_00a6:  ldarg.0
    IL_00a7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_00ac:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_SelectedItems()
    IL_00b1:  ldc.i4.0
    IL_00b2:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection::get_Item(int32)
    IL_00b7:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.ListViewItem::get_Tag()
    IL_00bc:  castclass  class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>>
    IL_00c1:  stfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`2<int32[],class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32>>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedMethod
//000144:             }
    IL_00c6:  nop
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
    IL_00c7:  ldarg.0
    IL_00c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_00cd:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_SelectedItems()
    IL_00d2:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection::get_Count()
    IL_00d7:  ldc.i4.0
    IL_00d8:  ceq
    IL_00da:  ldc.i4.0
    IL_00db:  ceq
    IL_00dd:  stloc.1
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_00de:  ldloc.1
    IL_00df:  brtrue.s   IL_00e3

//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
    IL_00e1:  br.s       IL_0156

//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
    IL_00e3:  ldloc.0
    IL_00e4:  ldarg.0
    IL_00e5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvWorkloads
    IL_00ea:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection [System.Windows.Forms]System.Windows.Forms.ListView::get_SelectedItems()
    IL_00ef:  ldc.i4.0
    IL_00f0:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ListViewItem [System.Windows.Forms]System.Windows.Forms.ListView/SelectedListViewItemCollection::get_Item(int32)
    IL_00f5:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.ListViewItem::get_Tag()
    IL_00fa:  castclass  class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>>
    IL_00ff:  stfld      class [mscorlib]System.Tuple`2<string,class [mscorlib]System.Func`3<int32,int32,int32>> VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::selectedWorkload
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
    IL_0104:  ldloc.0
    IL_0105:  ldloc.0
    IL_0106:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::width
    IL_010b:  ldloc.0
    IL_010c:  ldfld      int32 VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::height
    IL_0111:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32)
    IL_0116:  stfld      class [System.Drawing]System.Drawing.Bitmap VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::bmp
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
    IL_011b:  ldarg.0
    IL_011c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button VisualizePartitioning.MainForm::btnVisualize
    IL_0121:  ldc.i4.0
    IL_0122:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0127:  nop
//000155:             Task.Factory.StartNew(() =>
    IL_0128:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_012d:  ldloc.0
    IL_012e:  ldftn      instance valuetype [mscorlib]System.TimeSpan VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__26'()
    IL_0134:  newobj     instance void class [mscorlib]System.Func`1<valuetype [mscorlib]System.TimeSpan>::.ctor(object,
                                                                                                                 native int)
    IL_0139:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<valuetype [mscorlib]System.TimeSpan>(class [mscorlib]System.Func`1<!!0>)
    IL_013e:  ldloc.0
    IL_013f:  ldftn      instance void VisualizePartitioning.MainForm/'<>c__DisplayClass2f'::'<btnVisualize_Click>b__25'(class [mscorlib]System.Threading.Tasks.Task`1<valuetype [mscorlib]System.TimeSpan>)
    IL_0145:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task`1<valuetype [mscorlib]System.TimeSpan>>::.ctor(object,
                                                                                                                                                                  native int)
    IL_014a:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_014f:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task class [mscorlib]System.Threading.Tasks.Task`1<valuetype [mscorlib]System.TimeSpan>::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task`1<!0>>,
                                                                                                                                                                               class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_0154:  pop
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
    IL_0155:  nop
    IL_0156:  ret
  } // end of method MainForm::btnVisualize_Click

  .method private hidebysig static int32 
          DoWork(int32 workAmount) cil managed noinlining nooptimization
  {
    // Code size       29 (0x1d)
    .maxstack  2
    .locals init ([0] int32 'value',
             [1] int32 i,
             [2] int32 CS$1$0000,
             [3] bool CS$4$0001)
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
    IL_0000:  nop
//000226:             int value = 1;
    IL_0001:  ldc.i4.1
    IL_0002:  stloc.0
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
    IL_0003:  ldc.i4.0
    IL_0004:  stloc.1
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0005:  br.s       IL_000f

//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
    IL_0007:  ldloc.0
    IL_0008:  ldarg.0
    IL_0009:  mul
    IL_000a:  stloc.0
    IL_000b:  ldloc.1
    IL_000c:  ldc.i4.1
    IL_000d:  add
    IL_000e:  stloc.1
    IL_000f:  ldloc.1
    IL_0010:  ldarg.0
    IL_0011:  clt
    IL_0013:  stloc.3
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0014:  ldloc.3
    IL_0015:  brtrue.s   IL_0007

//000228:             return value;
    IL_0017:  ldloc.0
    IL_0018:  stloc.2
    IL_0019:  br.s       IL_001b

//000229:         }
    IL_001b:  ldloc.2
    IL_001c:  ret
  } // end of method MainForm::DoWork

  .method private hidebysig instance void 
          rbAPI_CheckedChanged(object sender,
                               class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       61 (0x3d)
    .maxstack  8
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
    IL_0000:  nop
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.RadioButton VisualizePartitioning.MainForm::rbParallelFor
    IL_000d:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.RadioButton::get_Checked()
    IL_0012:  ldc.i4.0
    IL_0013:  ceq
    IL_0015:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_001a:  nop
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ListView VisualizePartitioning.MainForm::lvPartitioningMethods
    IL_0027:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.Control::get_Enabled()
    IL_002c:  ldc.i4.0
    IL_002d:  ceq
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ListView::set_HideSelection(bool)
    IL_0034:  nop
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
    IL_0035:  ldarg.0
    IL_0036:  call       instance void VisualizePartitioning.MainForm::InitializePartitioningMethods()
    IL_003b:  nop
//000242:         }
    IL_003c:  ret
  } // end of method MainForm::rbAPI_CheckedChanged

  .method private hidebysig instance void 
          tbCores_ValueChanged(object sender,
                               class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       74 (0x4a)
    .maxstack  3
    .locals init ([0] int32 worker,
             [1] int32 io,
             [2] int32 CS$0$0000)
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
    IL_0000:  nop
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolTip VisualizePartitioning.MainForm::toolTip1
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_000d:  ldarg.0
    IL_000e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_0013:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0018:  stloc.2
    IL_0019:  ldloca.s   CS$0$0000
    IL_001b:  call       instance string [mscorlib]System.Int32::ToString()
    IL_0020:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolTip::SetToolTip(class [System.Windows.Forms]System.Windows.Forms.Control,
                                                                                                      string)
    IL_0025:  nop
//000247:             InitializeColorPalette();
    IL_0026:  ldarg.0
    IL_0027:  call       instance void VisualizePartitioning.MainForm::InitializeColorPalette()
    IL_002c:  nop
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
    IL_002d:  ldloca.s   worker
    IL_002f:  ldloca.s   io
    IL_0031:  call       void [mscorlib]System.Threading.ThreadPool::GetMinThreads(int32&,
                                                                                   int32&)
    IL_0036:  nop
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
    IL_0037:  ldarg.0
    IL_0038:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbCores
    IL_003d:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0042:  ldloc.1
    IL_0043:  call       bool [mscorlib]System.Threading.ThreadPool::SetMinThreads(int32,
                                                                                   int32)
    IL_0048:  pop
//000251:         }
    IL_0049:  ret
  } // end of method MainForm::tbCores_ValueChanged

  .method private hidebysig instance void 
          tbWorkFactor_ValueChanged(object sender,
                                    class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       39 (0x27)
    .maxstack  3
    .locals init ([0] int32 CS$0$0000)
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
    IL_0000:  nop
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolTip VisualizePartitioning.MainForm::toolTip1
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_000d:  ldarg.0
    IL_000e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.TrackBar VisualizePartitioning.MainForm::tbWorkFactor
    IL_0013:  callvirt   instance int32 [System.Windows.Forms]System.Windows.Forms.TrackBar::get_Value()
    IL_0018:  stloc.0
    IL_0019:  ldloca.s   CS$0$0000
    IL_001b:  call       instance string [mscorlib]System.Int32::ToString()
    IL_0020:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolTip::SetToolTip(class [System.Windows.Forms]System.Windows.Forms.Control,
                                                                                                      string)
    IL_0025:  nop
//000256:         }
    IL_0026:  ret
  } // end of method MainForm::tbWorkFactor_ValueChanged

  .method private hidebysig instance int32 
          '<InitializeWorkloads>b__4'(int32 size,
                                      int32 current) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       17 (0x11)
    .maxstack  2
    .locals init ([0] int32 CS$1$0000)
//000071:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Constant", (size, current) => 1000 * _workFactor));
    IL_0000:  ldc.i4     0x3e8
    IL_0005:  ldarg.0
    IL_0006:  ldfld      int32 VisualizePartitioning.MainForm::_workFactor
    IL_000b:  mul
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000072:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method MainForm::'<InitializeWorkloads>b__4'

  .method private hidebysig instance int32 
          '<InitializeWorkloads>b__5'(int32 size,
                                      int32 current) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       19 (0x13)
    .maxstack  2
    .locals init ([0] int32 CS$1$0000)
//000072:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Increasing Linear", (size, current) => 200 * current * _workFactor));
    IL_0000:  ldc.i4     0xc8
    IL_0005:  ldarg.2
    IL_0006:  mul
    IL_0007:  ldarg.0
    IL_0008:  ldfld      int32 VisualizePartitioning.MainForm::_workFactor
    IL_000d:  mul
    IL_000e:  stloc.0
    IL_000f:  br.s       IL_0011

//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0011:  ldloc.0
    IL_0012:  ret
  } // end of method MainForm::'<InitializeWorkloads>b__5'

  .method private hidebysig instance int32 
          '<InitializeWorkloads>b__6'(int32 size,
                                      int32 current) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       21 (0x15)
    .maxstack  3
    .locals init ([0] int32 CS$1$0000)
//000073:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Decreasing Linear", (size, current) => 200 * (size - current) * _workFactor));
    IL_0000:  ldc.i4     0xc8
    IL_0005:  ldarg.1
    IL_0006:  ldarg.2
    IL_0007:  sub
    IL_0008:  mul
    IL_0009:  ldarg.0
    IL_000a:  ldfld      int32 VisualizePartitioning.MainForm::_workFactor
    IL_000f:  mul
    IL_0010:  stloc.0
    IL_0011:  br.s       IL_0013

//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0013:  ldloc.0
    IL_0014:  ret
  } // end of method MainForm::'<InitializeWorkloads>b__6'

  .method private hidebysig instance int32 
          '<InitializeWorkloads>b__7'(int32 size,
                                      int32 current) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       34 (0x22)
    .maxstack  3
    .locals init ([0] int32 CS$1$0000)
//000074:             workloads.Add(Tuple.Create<string, Func<int, int, int>>("Random", (size, current) => _localRandom.Value.Next(100, 10000) * _workFactor));
    IL_0000:  ldsfld     class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::_localRandom
    IL_0005:  callvirt   instance !0 class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random>::get_Value()
    IL_000a:  ldc.i4.s   100
    IL_000c:  ldc.i4     0x2710
    IL_0011:  callvirt   instance int32 [mscorlib]System.Random::Next(int32,
                                                                      int32)
    IL_0016:  ldarg.0
    IL_0017:  ldfld      int32 VisualizePartitioning.MainForm::_workFactor
    IL_001c:  mul
    IL_001d:  stloc.0
    IL_001e:  br.s       IL_0020

//000075:             
//000076:             foreach (var workload in workloads) lvWorkloads.Items.Add(new ListViewItem(workload.Item1) { Tag = workload });
//000077:             lvWorkloads.Items[0].Selected = true;
//000078:         }
//000079: 
//000080:         /// <summary>Initializes the partitioning methods list view.</summary>
//000081:         private void InitializePartitioningMethods()
//000082:         {
//000083:             lvPartitioningMethods.Items.Clear();
//000084:             bool usingPLINQ = rbPLINQ.Checked;
//000085:             var partitioningMethods = new List<Tuple<string, Func<int[], Partitioner<int>>>>();
//000086: 
//000087:             // Static partitioning using the Partitioner.Create overload requires static partitioner support,
//000088:             // which Parallel.ForEach does not provide.
//000089:             if (usingPLINQ)
//000090:             {
//000091:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000092:                     "Static", e => Partitioner.Create(e, false)));
//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0020:  ldloc.0
    IL_0021:  ret
  } // end of method MainForm::'<InitializeWorkloads>b__7'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__9'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000092:                     "Static", e => Partitioner.Create(e, false)));
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.0
    IL_0002:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [mscorlib]System.Collections.Concurrent.Partitioner::Create<int32>(!!0[],
                                                                                                                                                                      bool)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000093:             }
//000094: 
//000095:             // Add a bunch of partitioning approaches that work with both PLINQ and Parallel.ForEach
//000096:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__9'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__a'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000097:                 "Load Balance", e => Partitioner.Create(e, true)));
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.1
    IL_0002:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [mscorlib]System.Collections.Concurrent.Partitioner::Create<int32>(!!0[],
                                                                                                                                                                      bool)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000098:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__a'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__b'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       12 (0xc)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000099:                 "Dynamic(1)", e => ChunkPartitioner.Create(e, 1)));
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.1
    IL_0002:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [ParallelExtensionsExtras]System.Collections.Concurrent.Partitioners.ChunkPartitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                        int32)
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

//000100:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__b'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__c'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       13 (0xd)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000101:                 "Dynamic(16)", e => ChunkPartitioner.Create(e, 16)));
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.s   16
    IL_0003:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [ParallelExtensionsExtras]System.Collections.Concurrent.Partitioners.ChunkPartitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                        int32)
    IL_0008:  stloc.0
    IL_0009:  br.s       IL_000b

//000102:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000b:  ldloc.0
    IL_000c:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__c'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__d'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       41 (0x29)
    .maxstack  4
    .locals init ([0] class VisualizePartitioning.MainForm/'<>c__DisplayClass1e' 'CS$<>8__locals1f',
             [1] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
    IL_0000:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.0
    IL_0008:  stfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::e
//000103:                 "Guided", e => ChunkPartitioner.Create(e, prev =>
    IL_000d:  ldloc.0
    IL_000e:  ldfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::e
    IL_0013:  ldloc.0
    IL_0014:  ldftn      instance int32 VisualizePartitioning.MainForm/'<>c__DisplayClass1e'::'<InitializePartitioningMethods>b__e'(int32)
    IL_001a:  newobj     instance void class [mscorlib]System.Func`2<int32,int32>::.ctor(object,
                                                                                         native int)
    IL_001f:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [ParallelExtensionsExtras]System.Collections.Concurrent.Partitioners.ChunkPartitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                        class [mscorlib]System.Func`2<int32,int32>)
    IL_0024:  stloc.1
    IL_0025:  br.s       IL_0027

//000104:                 {
//000105:                     if (prev <= 0) return e.Length <= 1 ? 1 : e.Length / (Environment.ProcessorCount * 3);
//000106:                     var next = prev / 2;
//000107:                     return next <= 0 ? prev : next;
//000108:                 })));
//000109:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0027:  ldloc.1
    IL_0028:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__d'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__f'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
    IL_0000:  ldarg.0
    IL_0001:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate20'
    IL_0006:  brtrue.s   IL_001b

    IL_0008:  ldnull
    IL_0009:  ldftn      int32 VisualizePartitioning.MainForm::'<InitializePartitioningMethods>b__10'(int32)
    IL_000f:  newobj     instance void class [mscorlib]System.Func`2<int32,int32>::.ctor(object,
                                                                                         native int)
    IL_0014:  stsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate20'
    IL_0019:  br.s       IL_001b

    IL_001b:  ldsfld     class [mscorlib]System.Func`2<int32,int32> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate20'
    IL_0020:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [ParallelExtensionsExtras]System.Collections.Concurrent.Partitioners.ChunkPartitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                        class [mscorlib]System.Func`2<int32,int32>)
    IL_0025:  stloc.0
    IL_0026:  br.s       IL_0028

//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0028:  ldloc.0
    IL_0029:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__f'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__11'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       41 (0x29)
    .maxstack  4
    .locals init ([0] class VisualizePartitioning.MainForm/'<>c__DisplayClass21' 'CS$<>8__locals22',
             [1] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
    IL_0000:  newobj     instance void VisualizePartitioning.MainForm/'<>c__DisplayClass21'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.0
    IL_0008:  stfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass21'::e
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
    IL_000d:  ldloc.0
    IL_000e:  ldfld      int32[] VisualizePartitioning.MainForm/'<>c__DisplayClass21'::e
    IL_0013:  ldloc.0
    IL_0014:  ldftn      instance int32 VisualizePartitioning.MainForm/'<>c__DisplayClass21'::'<InitializePartitioningMethods>b__12'(int32)
    IL_001a:  newobj     instance void class [mscorlib]System.Func`2<int32,int32>::.ctor(object,
                                                                                         native int)
    IL_001f:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [ParallelExtensionsExtras]System.Collections.Concurrent.Partitioners.ChunkPartitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                        class [mscorlib]System.Func`2<int32,int32>)
    IL_0024:  stloc.1
    IL_0025:  br.s       IL_0027

//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0027:  ldloc.1
    IL_0028:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__11'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__13'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
    IL_0000:  ldarg.0
    IL_0001:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [mscorlib]System.Collections.Concurrent.Partitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__13'

  .method private hidebysig static class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> 
          '<InitializePartitioningMethods>b__14'(int32[] e) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Collections.Concurrent.Partitioner`1<int32> CS$1$0000)
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
    IL_0000:  ldarg.0
    IL_0001:  call       class [mscorlib]System.Collections.Concurrent.OrderablePartitioner`1<!!0> [mscorlib]System.Collections.Concurrent.Partitioner::Create<int32>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__14'

  .method private hidebysig static int32 
          '<InitializePartitioningMethods>b__10'(int32 prev) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       15 (0xf)
    .maxstack  2
    .locals init ([0] int32 CS$1$0000)
//000110:                 "Grow Exponential", e => ChunkPartitioner.Create(e, prev => prev <= 0 ? 1 : prev * 2)));
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.0
    IL_0002:  ble.s      IL_0009

    IL_0004:  ldarg.0
    IL_0005:  ldc.i4.2
    IL_0006:  mul
    IL_0007:  br.s       IL_000a

    IL_0009:  ldc.i4.1
    IL_000a:  stloc.0
    IL_000b:  br.s       IL_000d

//000111:             partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000112:                 "Random", e => ChunkPartitioner.Create(e, prev => _localRandom.Value.Next(e.Length))));
//000113: 
//000114:             // Special-case some PLINQ-only hashing
//000115:             if (usingPLINQ)
//000116:             {
//000117:                 // The actual enabling of these partitioning schemes is done later, as they can't 
//000118:                 // be encoded in a partitioner but rather are based on what operators are used in the PLINQ query.
//000119:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000120:                     PartitioningStripe, e => Partitioner.Create(e)));
//000121:                 partitioningMethods.Add(Tuple.Create<string, Func<int[], Partitioner<int>>>(
//000122:                     PartitioningHash, e => Partitioner.Create(e)));
//000123:             }
//000124: 
//000125:             // Dump the partitioners into the list view
//000126:             foreach (var method in partitioningMethods) lvPartitioningMethods.Items.Add(new ListViewItem(method.Item1) { Tag = method });
//000127:             lvPartitioningMethods.Items[0].Selected = true;
//000128:         }
//000129: 
//000130:         /// <summary>Visualize the partitioning.</summary>
//000131:         private void btnVisualize_Click(object sender, EventArgs e)
//000132:         {
//000133:             int numProcs = tbCores.Value;
//000134:             int width = pbPartitionedImage.Width, height = pbPartitionedImage.Height;
//000135:             bool useParallelFor = rbParallelFor.Checked, useParallelForEach = rbParallelForEach.Checked;
//000136:             _workFactor = tbWorkFactor.Value;
//000137: 
//000138:             // If we're using Parallel.ForEach or PLINQ, ensure a partitioning scheme was selected and use it
//000139:             Tuple<string, Func<int[], Partitioner<int>>> selectedMethod = null;
//000140:             if (!useParallelFor)
//000141:             {
//000142:                 if (lvPartitioningMethods.SelectedIndices.Count == 0) return;
//000143:                 else selectedMethod = (Tuple<string, Func<int[], Partitioner<int>>>)lvPartitioningMethods.SelectedItems[0].Tag;
//000144:             }
//000145: 
//000146:             // Make sure a workload was selected and use it
//000147:             if (lvWorkloads.SelectedItems.Count == 0) return;
//000148:             var selectedWorkload = (Tuple<string, Func<int, int, int>>)lvWorkloads.SelectedItems[0].Tag;
//000149: 
//000150:             // Create a new Bitmap to store the rendered output
//000151:             var bmp = new Bitmap(width, height);
//000152: 
//000153:             // Disable the start button and kick off the background work
//000154:             btnVisualize.Enabled = false;
//000155:             Task.Factory.StartNew(() =>
//000156:             {
//000157:                 int nextId = -1; // assign each thread a unique id
//000158:                 var threadId = new ThreadLocal<int>(() => Interlocked.Increment(ref nextId));
//000159: 
//000160:                 using (FastBitmap fastBmp = new FastBitmap(bmp)) // get faster access to the Bitmap's contents
//000161:                 {
//000162:                     var sw = Stopwatch.StartNew(); // time the operation
//000163:                     if (useParallelFor)
//000164:                     {
//000165:                         Parallel.For(0, height, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000166:                         {
//000167:                             int id = threadId.Value;
//000168:                             DoWork(selectedWorkload.Item2(height, i));
//000169:                             for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000170:                         });
//000171:                     }
//000172:                     else
//000173:                     {
//000174:                         // Create the partitioner to be used
//000175:                         var partitioner = selectedMethod.Item2(Enumerable.Range(0, height).ToArray());
//000176: 
//000177:                         if (useParallelForEach)
//000178:                         {
//000179:                             // Run the work with Parallel.ForEach
//000180:                             Parallel.ForEach(partitioner, new ParallelOptions { MaxDegreeOfParallelism = numProcs }, i =>
//000181:                             {
//000182:                                 int id = threadId.Value;
//000183:                                 DoWork(selectedWorkload.Item2(height, i));
//000184:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000185:                             });
//000186:                         }
//000187:                         else // PLINQ
//000188:                         {
//000189:                             // Run the work with PLINQ.  If a special partitioning method was selected, use relevant query operators
//000190:                             // to get PLINQ to use that partitioning approach.
//000191:                             var source = partitioner.AsParallel().WithDegreeOfParallelism(numProcs);
//000192:                             if (selectedMethod.Item1 == PartitioningStripe) source = source.TakeWhile(elem => true);
//000193:                             else if (selectedMethod.Item1 == PartitioningHash) source = source.Join(Enumerable.Range(0, height).AsParallel(), i => i, i => i, (i, ignore) => i);
//000194:                             source.ForAll(i =>
//000195:                             {
//000196:                                 int id = threadId.Value;
//000197:                                 DoWork(selectedWorkload.Item2(height, i));
//000198:                                 for (int j = 0; j < width; j++) fastBmp.SetColor(j, i, _colors[id % _colors.Length]);
//000199:                             });
//000200:                         }
//000201:                     }
//000202: 
//000203:                     // Return the total time from the task
//000204:                     return sw.Elapsed;
//000205:                 }
//000206: 
//000207:                 // When the work completes, run the following on the UI thread
//000208:             }).ContinueWith(t =>
//000209:             {
//000210:                 // Dispose of the old image (if there was one) and display the new one
//000211:                 var old = pbPartitionedImage.Image;
//000212:                 pbPartitionedImage.Image = bmp;
//000213:                 if (old != null) old.Dispose();
//000214: 
//000215:                 // Re-enable controls on the form and display the elapsed time
//000216:                 btnVisualize.Enabled = true;
//000217:                 lblTime.Text = "Time: " + t.Result.ToString();
//000218:             }, TaskScheduler.FromCurrentSynchronizationContext());
//000219:         }
//000220: 
//000221:         /// <summary>Does an amount of work relative to the amount requested.</summary>
//000222:         /// <param name="workAmount">The amount of work to perform.</param>
//000223:         [MethodImpl(MethodImplOptions.NoOptimization | MethodImplOptions.NoInlining)]
//000224:         private static int DoWork(int workAmount)
//000225:         {
//000226:             int value = 1;
//000227:             for (int i = 0; i < workAmount; i++) value *= workAmount;
//000228:             return value;
//000229:         }
//000230: 
//000231:         /// <summary>Update relevant portions of the form when the API radio buttons are checked.</summary>
//000232:         /// <param name="sender">The radio button.</param>
//000233:         /// <param name="e">The event args.</param>
//000234:         private void rbAPI_CheckedChanged(object sender, EventArgs e)
//000235:         {
//000236:             lvPartitioningMethods.Enabled = !rbParallelFor.Checked;
//000237:             lvPartitioningMethods.HideSelection = !lvPartitioningMethods.Enabled;
//000238: 
//000239:             // Recreate partitioning methods every time a radio button is checked,
//000240:             // as which API is selected determines which partitioning methods are available
//000241:             InitializePartitioningMethods();
//000242:         }
//000243: 
//000244:         private void tbCores_ValueChanged(object sender, EventArgs e)
//000245:         {
//000246:             toolTip1.SetToolTip(tbCores, tbCores.Value.ToString());
//000247:             InitializeColorPalette();
//000248:             int worker, io;
//000249:             ThreadPool.GetMinThreads(out worker, out io);
//000250:             ThreadPool.SetMinThreads(tbCores.Value, io);
//000251:         }
//000252: 
//000253:         private void tbWorkFactor_ValueChanged(object sender, EventArgs e)
//000254:         {
//000255:             toolTip1.SetToolTip(tbWorkFactor, tbWorkFactor.Value.ToString());
//000256:         }
//000257:     }
//000258: }
    IL_000d:  ldloc.0
    IL_000e:  ret
  } // end of method MainForm::'<InitializePartitioningMethods>b__10'

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       52 (0x34)
    .maxstack  8
//000037:         private static Random _randomnessSeed = new Random();
    IL_0000:  newobj     instance void [mscorlib]System.Random::.ctor()
    IL_0005:  stsfld     class [mscorlib]System.Random VisualizePartitioning.MainForm::_randomnessSeed
//000038:         /// <summary>A thread-safe source of randomness for all threads that need random values.</summary>
//000039:         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
    IL_000a:  ldsfld     class [mscorlib]System.Func`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate3e'
    IL_000f:  brtrue.s   IL_0024

    IL_0011:  ldnull
    IL_0012:  ldftn      class [mscorlib]System.Random VisualizePartitioning.MainForm::'<.cctor>b__3d'()
    IL_0018:  newobj     instance void class [mscorlib]System.Func`1<class [mscorlib]System.Random>::.ctor(object,
                                                                                                           native int)
    IL_001d:  stsfld     class [mscorlib]System.Func`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate3e'
    IL_0022:  br.s       IL_0024

    IL_0024:  ldsfld     class [mscorlib]System.Func`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::'CS$<>9__CachedAnonymousMethodDelegate3e'
    IL_0029:  newobj     instance void class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random>::.ctor(class [mscorlib]System.Func`1<!0>)
    IL_002e:  stsfld     class [mscorlib]System.Threading.ThreadLocal`1<class [mscorlib]System.Random> VisualizePartitioning.MainForm::_localRandom
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs' 
    IL_0033:  ret
  } // end of method MainForm::.cctor

  .method private hidebysig static class [mscorlib]System.Random 
          '<.cctor>b__3d'() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       55 (0x37)
    .maxstack  2
    .locals init ([0] bool '<>s__LockTaken3c',
             [1] class [mscorlib]System.Random CS$1$0000,
             [2] class [mscorlib]System.Random CS$2$0001,
             [3] bool CS$4$0002)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs' 
//000039:         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
    IL_0000:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs' 
    IL_0001:  ldc.i4.0
    IL_0002:  stloc.0
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.cs' 
//000039:         private static ThreadLocal<Random> _localRandom = new ThreadLocal<Random>(delegate { lock (_randomnessSeed) return new Random(_randomnessSeed.Next()); });
    .try
    {
      IL_0003:  ldsfld     class [mscorlib]System.Random VisualizePartitioning.MainForm::_randomnessSeed
      IL_0008:  dup
      IL_0009:  stloc.2
      IL_000a:  ldloca.s   '<>s__LockTaken3c'
      IL_000c:  call       void [mscorlib]System.Threading.Monitor::Enter(object,
                                                                          bool&)
      IL_0011:  nop
      IL_0012:  ldsfld     class [mscorlib]System.Random VisualizePartitioning.MainForm::_randomnessSeed
      IL_0017:  callvirt   instance int32 [mscorlib]System.Random::Next()
      IL_001c:  newobj     instance void [mscorlib]System.Random::.ctor(int32)
      IL_0021:  stloc.1
      IL_0022:  leave.s    IL_0034

// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\MainForm.Designer.cs' 
    }  // end .try
    finally
    {
      IL_0024:  ldloc.0
      IL_0025:  ldc.i4.0
      IL_0026:  ceq
      IL_0028:  stloc.3
      IL_0029:  ldloc.3
      IL_002a:  brtrue.s   IL_0033

      IL_002c:  ldloc.2
      IL_002d:  call       void [mscorlib]System.Threading.Monitor::Exit(object)
      IL_0032:  nop
      IL_0033:  endfinally
    }  // end handler
    IL_0034:  nop
    IL_0035:  ldloc.1
    IL_0036:  ret
  } // end of method MainForm::'<.cctor>b__3d'

} // end of class VisualizePartitioning.MainForm

.class private auto ansi sealed beforefieldinit VisualizePartitioning.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class VisualizePartitioning.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class VisualizePartitioning.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class VisualizePartitioning.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Settings.Designer.cs' 
//000025:             {
    IL_0000:  nop
//000026:                 return defaultInstance;
    IL_0001:  ldsfld     class VisualizePartitioning.Properties.Settings VisualizePartitioning.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000027:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000020:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void VisualizePartitioning.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  VisualizePartitioning.Properties.Settings
    IL_000f:  stsfld     class VisualizePartitioning.Properties.Settings VisualizePartitioning.Properties.Settings::defaultInstance
//000021: 
//000022:         public static Settings Default
//000023:         {
//000024:             get
//000025:             {
//000026:                 return defaultInstance;
//000027:             }
//000028:         }
//000029:     }
//000030: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class VisualizePartitioning.Properties.Settings
          Default()
  {
    .get class VisualizePartitioning.Properties.Settings VisualizePartitioning.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class VisualizePartitioning.Properties.Settings

.class private auto ansi beforefieldinit VisualizePartitioning.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\VisualizePartitioning\VisualizePartitioning_CSharp\Properties\Resources.Designer.cs' 
//000032:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000033:         internal Resources()
//000034:         {
    IL_0007:  nop
//000035:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       60 (0x3c)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000036: 
//000037:         /// <summary>
//000038:         ///   Returns the cached ResourceManager instance used by this class.
//000039:         /// </summary>
//000040:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000041:         internal static global::System.Resources.ResourceManager ResourceManager
//000042:         {
//000043:             get
//000044:             {
    IL_0000:  nop
//000045:                 if ((resourceMan == null))
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager VisualizePartitioning.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  ceq
    IL_0009:  ldc.i4.0
    IL_000a:  ceq
    IL_000c:  stloc.2
//000046:                 {
//000047:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("VisualizePartitioning.Properties.Resources", typeof(Resources).Assembly);
//000048:                     resourceMan = temp;
//000049:                 }
//000050:                 return resourceMan;
//000051:             }
//000052:         }
//000053: 
//000054:         /// <summary>
//000055:         ///   Overrides the current thread's CurrentUICulture property for all
//000056:         ///   resource lookups using this strongly typed resource class.
//000057:         /// </summary>
//000058:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000059:         internal static global::System.Globalization.CultureInfo Culture
//000060:         {
//000061:             get
//000062:             {
//000063:                 return resourceCulture;
//000064:             }
//000065:             set
//000066:             {
//000067:                 resourceCulture = value;
//000068:             }
//000069:         }
//000070:     }
//000071: }
    IL_000d:  ldloc.2
    IL_000e:  brtrue.s   IL_0032

//000046:                 {
    IL_0010:  nop
//000047:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("VisualizePartitioning.Properties.Resources", typeof(Resources).Assembly);
    IL_0011:  ldstr      "VisualizePartitioning.Properties.Resources"
    IL_0016:  ldtoken    VisualizePartitioning.Properties.Resources
    IL_001b:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0020:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0025:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002a:  stloc.0
//000048:                     resourceMan = temp;
    IL_002b:  ldloc.0
    IL_002c:  stsfld     class [mscorlib]System.Resources.ResourceManager VisualizePartitioning.Properties.Resources::resourceMan
//000049:                 }
    IL_0031:  nop
//000050:                 return resourceMan;
    IL_0032:  ldsfld     class [mscorlib]System.Resources.ResourceManager VisualizePartitioning.Properties.Resources::resourceMan
    IL_0037:  stloc.1
    IL_0038:  br.s       IL_003a

//000051:             }
    IL_003a:  ldloc.1
    IL_003b:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000052:         }
//000053: 
//000054:         /// <summary>
//000055:         ///   Overrides the current thread's CurrentUICulture property for all
//000056:         ///   resource lookups using this strongly typed resource class.
//000057:         /// </summary>
//000058:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000059:         internal static global::System.Globalization.CultureInfo Culture
//000060:         {
//000061:             get
//000062:             {
    IL_0000:  nop
//000063:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo VisualizePartitioning.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000064:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000065:             set
//000066:             {
    IL_0000:  nop
//000067:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo VisualizePartitioning.Properties.Resources::resourceCulture
//000068:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager VisualizePartitioning.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Globalization.CultureInfo VisualizePartitioning.Properties.Resources::get_Culture()
    .set void VisualizePartitioning.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
  } // end of property Resources::Culture
} // end of class VisualizePartitioning.Properties.Resources


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
