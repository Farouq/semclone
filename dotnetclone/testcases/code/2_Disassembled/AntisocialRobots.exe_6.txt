
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern PresentationFramework
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly extern System.Xaml
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern PresentationCore
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern WindowsBase
{
  .publickeytoken = (31 BF 38 56 AD 36 4E 35 )                         // 1.8V.6N5
  .ver 4:0:0:0
}
.assembly AntisocialRobots
{
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 10 41 6E 74 69 73 6F 63 69 61 6C 52 6F 62   // ...AntisocialRob
                                                                                              6F 74 73 00 00 )                                  // ots..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 29 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ..).NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 2C 50 72   // ,Version=v4.0,Pr
                                                                                                        6F 66 69 6C 65 3D 43 6C 69 65 6E 74 01 00 54 0E   // ofile=Client..T.
                                                                                                        14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C 61   // .FrameworkDispla
                                                                                                        79 4E 61 6D 65 1F 2E 4E 45 54 20 46 72 61 6D 65   // yName..NET Frame
                                                                                                        77 6F 72 6B 20 34 20 43 6C 69 65 6E 74 20 50 72   // work 4 Client Pr
                                                                                                        6F 66 69 6C 65 )                                  // ofile
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 10 41 6E 74 69 73 6F 63 69 61 6C 52 6F 62   // ...AntisocialRob
                                                                                                6F 74 73 00 00 )                                  // ots..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [PresentationFramework]System.Windows.ThemeInfoAttribute::.ctor(valuetype [PresentationFramework]System.Windows.ResourceDictionaryLocation,
                                                                                        valuetype [PresentationFramework]System.Windows.ResourceDictionaryLocation) = ( 01 00 00 00 00 00 01 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public AntisocialRobots.g.resources
{
  // Offset: 0x00000000 Length: 0x0001401C
}
.module AntisocialRobots.exe
// MVID: {30C1D203-411A-4032-B4E1-88AF2A41B218}
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x012E0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private sequential ansi sealed beforefieldinit AntisocialRobots.RoomPoint
       extends [mscorlib]System.ValueType
{
  .field public int32 X
  .field public int32 Y
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(int32 x,
                               int32 y) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\RoomPoint.cs' 
//000032:         {
    IL_0000:  nop
//000033:             X = x;
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  stfld      int32 AntisocialRobots.RoomPoint::X
//000034:             Y = y;
    IL_0008:  ldarg.0
    IL_0009:  ldarg.2
    IL_000a:  stfld      int32 AntisocialRobots.RoomPoint::Y
//000035:         }
    IL_000f:  ret
  } // end of method RoomPoint::.ctor

  .method public hidebysig instance float64 
          DistanceTo(valuetype AntisocialRobots.RoomPoint other) cil managed
  {
    // Code size       52 (0x34)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000036: 
//000037:         /// <summary>
//000038:         /// Returns the distance from this point to another point.
//000039:         /// </summary>
//000040:         /// <param name="other">The other point.</param>
//000041:         public double DistanceTo(RoomPoint other) { return Math.Sqrt(Square(other.X - X) + Square(other.Y - Y)); }
    IL_0000:  nop
    IL_0001:  ldarga.s   other
    IL_0003:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0008:  ldarg.0
    IL_0009:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_000e:  sub
    IL_000f:  conv.r8
    IL_0010:  call       float64 AntisocialRobots.RoomPoint::Square(float64)
    IL_0015:  ldarga.s   other
    IL_0017:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_001c:  ldarg.0
    IL_001d:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0022:  sub
    IL_0023:  conv.r8
    IL_0024:  call       float64 AntisocialRobots.RoomPoint::Square(float64)
    IL_0029:  add
    IL_002a:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_002f:  stloc.0
    IL_0030:  br.s       IL_0032

    IL_0032:  ldloc.0
    IL_0033:  ret
  } // end of method RoomPoint::DistanceTo

  .method public hidebysig instance float64 
          AngleTo(valuetype AntisocialRobots.RoomPoint other) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000042: 
//000043:         /// <summary>
//000044:         /// Returns the angle from this point to another point, measured in clockwise radians from
//000045:         /// the ray pointing to the right of this point.
//000046:         /// </summary>
//000047:         /// <param name="other">The other point.</param>
//000048:         public double AngleTo(RoomPoint other) { return Math.Atan2(other.Y - Y, other.X - X); }
    IL_0000:  nop
    IL_0001:  ldarga.s   other
    IL_0003:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0008:  ldarg.0
    IL_0009:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_000e:  sub
    IL_000f:  conv.r8
    IL_0010:  ldarga.s   other
    IL_0012:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0017:  ldarg.0
    IL_0018:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_001d:  sub
    IL_001e:  conv.r8
    IL_001f:  call       float64 [mscorlib]System.Math::Atan2(float64,
                                                              float64)
    IL_0024:  stloc.0
    IL_0025:  br.s       IL_0027

    IL_0027:  ldloc.0
    IL_0028:  ret
  } // end of method RoomPoint::AngleTo

  .method public hidebysig static float64 
          Square(float64 n) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  2
    .locals init ([0] float64 CS$1$0000)
//000049: 
//000050:         /// <summary>
//000051:         /// Returns the square of a given number.
//000052:         /// </summary>
//000053:         /// <param name="n">The number to square.</param>
//000054:         public static double Square(double n) { return n * n; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  mul
    IL_0004:  stloc.0
    IL_0005:  br.s       IL_0007

    IL_0007:  ldloc.0
    IL_0008:  ret
  } // end of method RoomPoint::Square

} // end of class AntisocialRobots.RoomPoint

.class public auto ansi beforefieldinit AntisocialRobots.App
       extends [PresentationFramework]System.Windows.Application
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 16 50 72 65 73 65 6E 74 61 74 69 6F 6E 42   // ...PresentationB
                                                                                                  75 69 6C 64 54 61 73 6B 73 07 34 2E 30 2E 30 2E   // uildTasks.4.0.0.
                                                                                                  30 00 00 )                                        // 0..
  .method public hidebysig instance void 
          InitializeComponent() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       20 (0x14)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\App.g.cs' 
//000047:         public void InitializeComponent() {
    IL_0000:  nop
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\App.xaml' 
//000004:              StartupUri="MainWindow.xaml">
    IL_0001:  ldarg.0
    IL_0002:  ldstr      "MainWindow.xaml"
    IL_0007:  ldc.i4.2
    IL_0008:  newobj     instance void [System]System.Uri::.ctor(string,
                                                                 valuetype [System]System.UriKind)
    IL_000d:  call       instance void [PresentationFramework]System.Windows.Application::set_StartupUri(class [System]System.Uri)
    IL_0012:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\App.g.cs' 
    IL_0013:  ret
  } // end of method App::InitializeComponent

  .method public hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       22 (0x16)
    .maxstack  1
    .locals init ([0] class AntisocialRobots.App app)
    IL_0000:  nop
    IL_0001:  newobj     instance void AntisocialRobots.App::.ctor()
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  callvirt   instance void AntisocialRobots.App::InitializeComponent()
    IL_000d:  nop
    IL_000e:  ldloc.0
    IL_000f:  callvirt   instance int32 [PresentationFramework]System.Windows.Application::Run()
    IL_0014:  pop
    IL_0015:  ret
  } // end of method App::Main

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [PresentationFramework]System.Windows.Application::.ctor()
    IL_0006:  ret
  } // end of method App::.ctor

} // end of class AntisocialRobots.App

.class private auto ansi beforefieldinit AntisocialRobots.Robot
       extends [mscorlib]System.Object
{
  .field public class [PresentationFramework]System.Windows.Shapes.Ellipse Element
  .field public valuetype AntisocialRobots.RoomPoint Location
  .field public int32 LastMovedFrame
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method Robot::.ctor

} // end of class AntisocialRobots.Robot

.class public auto ansi beforefieldinit AntisocialRobots.MainWindow
       extends [PresentationFramework]System.Windows.Window
       implements [System.Xaml]System.Windows.Markup.IComponentConnector
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 16 50 72 65 73 65 6E 74 61 74 69 6F 6E 42   // ...PresentationB
                                                                                                  75 69 6C 64 54 61 73 6B 73 07 34 2E 30 2E 30 2E   // uildTasks.4.0.0.
                                                                                                  30 00 00 )                                        // 0..
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass6'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [mscorlib]System.Action clearState
    .field public class [mscorlib]System.Action recomputeAndRedraw
    .field public class AntisocialRobots.MainWindow '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass6'::.ctor

    .method public hidebysig instance void 
            '<.ctor>b__1'(object _,
                          class [PresentationCore]System.Windows.Input.KeyEventArgs e) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  2
      .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\MainWindow.xaml.cs' 
//000074:             KeyDown += (_, e) => { if (e.Key == Key.F5) clearState(); };
      IL_0000:  nop
      IL_0001:  ldarg.2
      IL_0002:  callvirt   instance valuetype [WindowsBase]System.Windows.Input.Key [PresentationCore]System.Windows.Input.KeyEventArgs::get_Key()
      IL_0007:  ldc.i4.s   94
      IL_0009:  ceq
      IL_000b:  ldc.i4.0
      IL_000c:  ceq
      IL_000e:  stloc.0
//000075: 
//000076:             // Render loop, started when the window loads
//000077:             Action recomputeAndRedraw = null;
//000078:             recomputeAndRedraw = delegate
//000079:             {
//000080:                 Dispatcher.BeginInvoke((Action)delegate
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_000f:  ldloc.0
      IL_0010:  brtrue.s   IL_001e

//000074:             KeyDown += (_, e) => { if (e.Key == Key.F5) clearState(); };
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::clearState
      IL_0018:  callvirt   instance void [mscorlib]System.Action::Invoke()
      IL_001d:  nop
//000075: 
//000076:             // Render loop, started when the window loads
//000077:             Action recomputeAndRedraw = null;
//000078:             recomputeAndRedraw = delegate
//000079:             {
//000080:                 Dispatcher.BeginInvoke((Action)delegate
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_001e:  ret
    } // end of method '<>c__DisplayClass6'::'<.ctor>b__1'

    .method public hidebysig instance void 
            '<.ctor>b__2'() cil managed
    {
      // Code size       38 (0x26)
      .maxstack  8
//000079:             {
      IL_0000:  nop
//000080:                 Dispatcher.BeginInvoke((Action)delegate
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<>4__this'
      IL_0007:  call       instance class [WindowsBase]System.Windows.Threading.Dispatcher [WindowsBase]System.Windows.Threading.DispatcherObject::get_Dispatcher()
      IL_000c:  ldarg.0
      IL_000d:  ldftn      instance void AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<.ctor>b__3'()
      IL_0013:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_0018:  ldc.i4.4
      IL_0019:  ldc.i4.0
      IL_001a:  newarr     [mscorlib]System.Object
      IL_001f:  callvirt   instance class [WindowsBase]System.Windows.Threading.DispatcherOperation [WindowsBase]System.Windows.Threading.Dispatcher::BeginInvoke(class [mscorlib]System.Delegate,
                                                                                                                                                                  valuetype [WindowsBase]System.Windows.Threading.DispatcherPriority,
                                                                                                                                                                  object[])
      IL_0024:  pop
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_0025:  ret
    } // end of method '<>c__DisplayClass6'::'<.ctor>b__2'

    .method public hidebysig instance void 
            '<.ctor>b__4'(object A_1,
                          class [PresentationCore]System.Windows.RoutedEventArgs A_2) cil managed
    {
      // Code size       31 (0x1f)
      .maxstack  8
//000087:             {
      IL_0000:  nop
//000088:                 _framesPerSecondStopwatch.Start();
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<>4__this'
      IL_0007:  ldfld      class [System]System.Diagnostics.Stopwatch AntisocialRobots.MainWindow::_framesPerSecondStopwatch
      IL_000c:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Start()
      IL_0011:  nop
//000089:                 recomputeAndRedraw();
      IL_0012:  ldarg.0
      IL_0013:  ldfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::recomputeAndRedraw
      IL_0018:  callvirt   instance void [mscorlib]System.Action::Invoke()
      IL_001d:  nop
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_001e:  ret
    } // end of method '<>c__DisplayClass6'::'<.ctor>b__4'

    .method public hidebysig instance void 
            '<.ctor>b__3'() cil managed
    {
      // Code size       26 (0x1a)
      .maxstack  8
//000081:                 {
      IL_0000:  nop
//000082:                     PerformSimulationStep();
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<>4__this'
      IL_0007:  call       instance void AntisocialRobots.MainWindow::PerformSimulationStep()
      IL_000c:  nop
//000083:                     recomputeAndRedraw();
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::recomputeAndRedraw
      IL_0013:  callvirt   instance void [mscorlib]System.Action::Invoke()
      IL_0018:  nop
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_0019:  ret
    } // end of method '<>c__DisplayClass6'::'<.ctor>b__3'

  } // end of class '<>c__DisplayClass6'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassc'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 stripe
    .field public class AntisocialRobots.MainWindow '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassc'::.ctor

    .method public hidebysig instance void 
            '<PerformSimulationStep>b__a'(class AntisocialRobots.Robot robot) cil managed
    {
      // Code size       109 (0x6d)
      .maxstack  3
      .locals init ([0] bool CS$4$0000)
//000227:                     {
      IL_0000:  nop
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
      IL_0001:  ldarg.1
      IL_0002:  ldfld      int32 AntisocialRobots.Robot::LastMovedFrame
      IL_0007:  ldarg.0
      IL_0008:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClassc'::'<>4__this'
      IL_000d:  ldfld      int32 AntisocialRobots.MainWindow::_frameIndex
      IL_0012:  bge.s      IL_0047

      IL_0014:  ldarg.1
      IL_0015:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
      IL_001a:  ldfld      int32 AntisocialRobots.RoomPoint::X
      IL_001f:  ldc.i4.3
      IL_0020:  rem
      IL_0021:  ldarg.0
      IL_0022:  ldfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
      IL_0027:  ldc.i4.3
      IL_0028:  rem
      IL_0029:  bne.un.s   IL_0047

      IL_002b:  ldarg.1
      IL_002c:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
      IL_0031:  ldfld      int32 AntisocialRobots.RoomPoint::Y
      IL_0036:  ldc.i4.3
      IL_0037:  rem
      IL_0038:  ldarg.0
      IL_0039:  ldfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
      IL_003e:  ldc.i4.3
      IL_003f:  div
      IL_0040:  ceq
      IL_0042:  ldc.i4.0
      IL_0043:  ceq
      IL_0045:  br.s       IL_0048

      IL_0047:  ldc.i4.1
      IL_0048:  stloc.0
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_0049:  ldloc.0
      IL_004a:  brtrue.s   IL_006c

//000229:                         {
      IL_004c:  nop
//000230:                             SimulateOneStep(robot);
      IL_004d:  ldarg.0
      IL_004e:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClassc'::'<>4__this'
      IL_0053:  ldarg.1
      IL_0054:  call       instance void AntisocialRobots.MainWindow::SimulateOneStep(class AntisocialRobots.Robot)
      IL_0059:  nop
//000231:                             robot.LastMovedFrame = _frameIndex;
      IL_005a:  ldarg.1
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClassc'::'<>4__this'
      IL_0061:  ldfld      int32 AntisocialRobots.MainWindow::_frameIndex
      IL_0066:  stfld      int32 AntisocialRobots.Robot::LastMovedFrame
//000232:                         }
      IL_006b:  nop
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_006c:  ret
    } // end of method '<>c__DisplayClassc'::'<PerformSimulationStep>b__a'

  } // end of class '<>c__DisplayClassc'

  .field private static literal int32 ROOM_SIZE = int32(0x000000C8)
  .field private static literal int32 FramesPerSample = int32(0x0000000A)
  .field private class AntisocialRobots.Robot[0...,0...] _roomCells
  .field private class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> _robots
  .field private valuetype [PresentationCore]System.Windows.Media.Color _nextColor
  .field private class [System]System.Diagnostics.Stopwatch _framesPerSecondStopwatch
  .field private int32 _frameIndex
  .field assembly class [PresentationFramework]System.Windows.Controls.TextBlock txtStatus
  .field assembly class [PresentationFramework]System.Windows.Controls.CheckBox chkParallel
  .field assembly class [PresentationFramework]System.Windows.Controls.Border RoomParent
  .field assembly class [PresentationFramework]System.Windows.Controls.Canvas Room
  .field assembly class [PresentationCore]System.Windows.Media.ScaleTransform RoomScaleTransform
  .field private bool _contentLoaded
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       162 (0xa2)
    .maxstack  4
    .locals init ([0] class AntisocialRobots.MainWindow/'<>c__DisplayClass6' 'CS$<>8__locals7',
             [1] class [mscorlib]System.Action 'CS$<>9__CachedAnonymousMethodDelegate5')
    IL_0000:  ldnull
    IL_0001:  stloc.1
//000045:         Color _nextColor = Color.FromRgb(240, 10, 0);
    IL_0002:  ldarg.0
    IL_0003:  ldc.i4     0xf0
    IL_0008:  ldc.i4.s   10
    IL_000a:  ldc.i4.0
    IL_000b:  call       valuetype [PresentationCore]System.Windows.Media.Color [PresentationCore]System.Windows.Media.Color::FromRgb(uint8,
                                                                                                                                      uint8,
                                                                                                                                      uint8)
    IL_0010:  stfld      valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
//000046: 
//000047:         /// <summary>
//000048:         /// Calculates frames per second, by measuring the time required to display FramesPerSample
//000049:         /// frames.
//000050:         /// </summary>
//000051:         Stopwatch _framesPerSecondStopwatch = new Stopwatch();
    IL_0015:  ldarg.0
    IL_0016:  newobj     instance void [System]System.Diagnostics.Stopwatch::.ctor()
    IL_001b:  stfld      class [System]System.Diagnostics.Stopwatch AntisocialRobots.MainWindow::_framesPerSecondStopwatch
//000052: 
//000053:         /// <summary>The current frame number, starting from frame zero.</summary>
//000054:         int _frameIndex;
//000055: 
//000056:         /// <summary>The number of frames included in one frames per second measurement.</summary>
//000057:         const int FramesPerSample = 10;
//000058: 
//000059:         /// <summary>Initializes an instance of this class.</summary>
//000060:         public MainWindow()
    IL_0020:  ldarg.0
    IL_0021:  call       instance void [PresentationFramework]System.Windows.Window::.ctor()
    IL_0026:  nop
//000061:         {
//000062:             InitializeComponent();
//000063: 
//000064:             // Initializes robot state
//000065:             Action clearState = () =>
//000066:             {
//000067:                 _roomCells = new Robot[ROOM_SIZE, ROOM_SIZE];
//000068:                 _robots = new List<Robot>();
//000069:                 Room.Children.Clear();
//000070:             };
//000071:             clearState();
//000072: 
//000073:             // When F5 is pressed, reset state
//000074:             KeyDown += (_, e) => { if (e.Key == Key.F5) clearState(); };
//000075: 
//000076:             // Render loop, started when the window loads
//000077:             Action recomputeAndRedraw = null;
//000078:             recomputeAndRedraw = delegate
//000079:             {
//000080:                 Dispatcher.BeginInvoke((Action)delegate
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0027:  newobj     instance void AntisocialRobots.MainWindow/'<>c__DisplayClass6'::.ctor()
    IL_002c:  stloc.0
    IL_002d:  ldloc.0
    IL_002e:  ldarg.0
    IL_002f:  stfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<>4__this'
//000061:         {
    IL_0034:  nop
//000062:             InitializeComponent();
    IL_0035:  ldarg.0
    IL_0036:  call       instance void AntisocialRobots.MainWindow::InitializeComponent()
    IL_003b:  nop
//000063: 
//000064:             // Initializes robot state
//000065:             Action clearState = () =>
    IL_003c:  ldloc.0
    IL_003d:  ldloc.1
    IL_003e:  brtrue.s   IL_004f

    IL_0040:  ldarg.0
    IL_0041:  ldftn      instance void AntisocialRobots.MainWindow::'<.ctor>b__0'()
    IL_0047:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_004c:  stloc.1
    IL_004d:  br.s       IL_004f

    IL_004f:  ldloc.1
    IL_0050:  stfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::clearState
//000066:             {
//000067:                 _roomCells = new Robot[ROOM_SIZE, ROOM_SIZE];
//000068:                 _robots = new List<Robot>();
//000069:                 Room.Children.Clear();
//000070:             };
//000071:             clearState();
    IL_0055:  ldloc.0
    IL_0056:  ldfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::clearState
    IL_005b:  callvirt   instance void [mscorlib]System.Action::Invoke()
    IL_0060:  nop
//000072: 
//000073:             // When F5 is pressed, reset state
//000074:             KeyDown += (_, e) => { if (e.Key == Key.F5) clearState(); };
    IL_0061:  ldarg.0
    IL_0062:  ldloc.0
    IL_0063:  ldftn      instance void AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<.ctor>b__1'(object,
                                                                                                       class [PresentationCore]System.Windows.Input.KeyEventArgs)
    IL_0069:  newobj     instance void [PresentationCore]System.Windows.Input.KeyEventHandler::.ctor(object,
                                                                                                     native int)
    IL_006e:  call       instance void [PresentationCore]System.Windows.UIElement::add_KeyDown(class [PresentationCore]System.Windows.Input.KeyEventHandler)
    IL_0073:  nop
//000075: 
//000076:             // Render loop, started when the window loads
//000077:             Action recomputeAndRedraw = null;
    IL_0074:  ldloc.0
    IL_0075:  ldnull
    IL_0076:  stfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::recomputeAndRedraw
//000078:             recomputeAndRedraw = delegate
    IL_007b:  ldloc.0
    IL_007c:  ldloc.0
    IL_007d:  ldftn      instance void AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<.ctor>b__2'()
    IL_0083:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0088:  stfld      class [mscorlib]System.Action AntisocialRobots.MainWindow/'<>c__DisplayClass6'::recomputeAndRedraw
//000079:             {
//000080:                 Dispatcher.BeginInvoke((Action)delegate
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
    IL_008d:  ldarg.0
    IL_008e:  ldloc.0
    IL_008f:  ldftn      instance void AntisocialRobots.MainWindow/'<>c__DisplayClass6'::'<.ctor>b__4'(object,
                                                                                                       class [PresentationCore]System.Windows.RoutedEventArgs)
    IL_0095:  newobj     instance void [PresentationCore]System.Windows.RoutedEventHandler::.ctor(object,
                                                                                                  native int)
    IL_009a:  call       instance void [PresentationFramework]System.Windows.FrameworkElement::add_Loaded(class [PresentationCore]System.Windows.RoutedEventHandler)
    IL_009f:  nop
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
    IL_00a0:  nop
    IL_00a1:  ret
  } // end of method MainWindow::.ctor

  .method private hidebysig instance void 
          RoomParent_SizeChanged(object sender,
                                 class [PresentationFramework]System.Windows.SizeChangedEventArgs e) cil managed
  {
    // Code size       141 (0x8d)
    .maxstack  6
    .locals init ([0] float64 size,
             [1] float64 marginX,
             [2] float64 marginY)
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
    IL_0000:  nop
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
    IL_0007:  callvirt   instance float64 [PresentationFramework]System.Windows.FrameworkElement::get_ActualWidth()
    IL_000c:  ldarg.0
    IL_000d:  ldfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
    IL_0012:  callvirt   instance float64 [PresentationFramework]System.Windows.FrameworkElement::get_ActualHeight()
    IL_0017:  call       float64 [mscorlib]System.Math::Min(float64,
                                                            float64)
    IL_001c:  stloc.0
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [PresentationCore]System.Windows.Media.ScaleTransform AntisocialRobots.MainWindow::RoomScaleTransform
    IL_0023:  ldloc.0
    IL_0024:  callvirt   instance void [PresentationCore]System.Windows.Media.ScaleTransform::set_ScaleX(float64)
    IL_0029:  nop
//000106:             RoomScaleTransform.ScaleY = size;
    IL_002a:  ldarg.0
    IL_002b:  ldfld      class [PresentationCore]System.Windows.Media.ScaleTransform AntisocialRobots.MainWindow::RoomScaleTransform
    IL_0030:  ldloc.0
    IL_0031:  callvirt   instance void [PresentationCore]System.Windows.Media.ScaleTransform::set_ScaleY(float64)
    IL_0036:  nop
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
    IL_0037:  ldarg.0
    IL_0038:  ldfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
    IL_003d:  callvirt   instance float64 [PresentationFramework]System.Windows.FrameworkElement::get_ActualWidth()
    IL_0042:  ldloc.0
    IL_0043:  sub
    IL_0044:  ldc.r8     2.
    IL_004d:  div
    IL_004e:  stloc.1
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
    IL_0055:  callvirt   instance float64 [PresentationFramework]System.Windows.FrameworkElement::get_ActualHeight()
    IL_005a:  ldloc.0
    IL_005b:  sub
    IL_005c:  ldc.r8     2.
    IL_0065:  div
    IL_0066:  stloc.2
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
    IL_0067:  ldarg.0
    IL_0068:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_006d:  ldloc.1
    IL_006e:  ldloc.2
    IL_006f:  ldc.r8     0.0
    IL_0078:  ldc.r8     0.0
    IL_0081:  newobj     instance void [PresentationFramework]System.Windows.Thickness::.ctor(float64,
                                                                                              float64,
                                                                                              float64,
                                                                                              float64)
    IL_0086:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_Margin(valuetype [PresentationFramework]System.Windows.Thickness)
    IL_008b:  nop
//000112:         }
    IL_008c:  ret
  } // end of method MainWindow::RoomParent_SizeChanged

  .method private hidebysig instance void 
          Room_MouseLeftButtonDown(object sender,
                                   class [PresentationCore]System.Windows.Input.MouseButtonEventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
    IL_0000:  nop
//000117:             CreateRobot(MousePositionToRoomPoint(e));
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldarg.2
    IL_0004:  call       instance valuetype AntisocialRobots.RoomPoint AntisocialRobots.MainWindow::MousePositionToRoomPoint(class [PresentationCore]System.Windows.Input.MouseEventArgs)
    IL_0009:  call       instance void AntisocialRobots.MainWindow::CreateRobot(valuetype AntisocialRobots.RoomPoint)
    IL_000e:  nop
//000118:         }
    IL_000f:  ret
  } // end of method MainWindow::Room_MouseLeftButtonDown

  .method private hidebysig instance void 
          Room_MouseMove(object sender,
                         class [PresentationCore]System.Windows.Input.MouseEventArgs e) cil managed
  {
    // Code size       37 (0x25)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
    IL_0000:  nop
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance class [PresentationCore]System.Windows.Input.MouseDevice [PresentationCore]System.Windows.Input.MouseEventArgs::get_MouseDevice()
    IL_0007:  callvirt   instance valuetype [PresentationCore]System.Windows.Input.MouseButtonState [PresentationCore]System.Windows.Input.MouseDevice::get_LeftButton()
    IL_000c:  ldc.i4.1
    IL_000d:  ceq
    IL_000f:  ldc.i4.0
    IL_0010:  ceq
    IL_0012:  stloc.0
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0013:  ldloc.0
    IL_0014:  brtrue.s   IL_0024

//000127:                 CreateRobot(MousePositionToRoomPoint(e));
    IL_0016:  ldarg.0
    IL_0017:  ldarg.0
    IL_0018:  ldarg.2
    IL_0019:  call       instance valuetype AntisocialRobots.RoomPoint AntisocialRobots.MainWindow::MousePositionToRoomPoint(class [PresentationCore]System.Windows.Input.MouseEventArgs)
    IL_001e:  call       instance void AntisocialRobots.MainWindow::CreateRobot(valuetype AntisocialRobots.RoomPoint)
    IL_0023:  nop
//000128:         }
    IL_0024:  ret
  } // end of method MainWindow::Room_MouseMove

  .method private hidebysig instance void 
          CreateRobot(valuetype AntisocialRobots.RoomPoint pt) cil managed
  {
    // Code size       211 (0xd3)
    .maxstack  4
    .locals init ([0] class AntisocialRobots.Robot robot,
             [1] class AntisocialRobots.Robot '<>g__initLocal8',
             [2] class [PresentationFramework]System.Windows.Shapes.Ellipse '<>g__initLocal9',
             [3] bool CS$4$0000)
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
    IL_0000:  nop
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
    IL_0007:  ldarga.s   pt
    IL_0009:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_000e:  ldarga.s   pt
    IL_0010:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0015:  call       instance class AntisocialRobots.Robot class AntisocialRobots.Robot[0...,0...]::Get(int32,
                                                                                                            int32)
    IL_001a:  ldnull
    IL_001b:  ceq
    IL_001d:  stloc.3
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_001e:  ldloc.3
    IL_001f:  brtrue.s   IL_0026

//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
    IL_0021:  br         IL_00d2

//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
    IL_0026:  newobj     instance void AntisocialRobots.Robot::.ctor()
    IL_002b:  stloc.1
    IL_002c:  ldloc.1
    IL_002d:  ldarg.1
    IL_002e:  stfld      valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_0033:  ldloc.1
    IL_0034:  newobj     instance void [PresentationFramework]System.Windows.Shapes.Ellipse::.ctor()
    IL_0039:  stloc.2
    IL_003a:  ldloc.2
    IL_003b:  ldc.r8     5.0000000000000001e-003
    IL_0044:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_Width(float64)
    IL_0049:  nop
    IL_004a:  ldloc.2
    IL_004b:  ldc.r8     5.0000000000000001e-003
    IL_0054:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_Height(float64)
    IL_0059:  nop
    IL_005a:  ldloc.2
    IL_005b:  ldc.i4.0
    IL_005c:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_HorizontalAlignment(valuetype [PresentationFramework]System.Windows.HorizontalAlignment)
    IL_0061:  nop
    IL_0062:  ldloc.2
    IL_0063:  ldc.i4.0
    IL_0064:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::set_VerticalAlignment(valuetype [PresentationFramework]System.Windows.VerticalAlignment)
    IL_0069:  nop
    IL_006a:  ldloc.2
    IL_006b:  ldarg.0
    IL_006c:  ldfld      valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0071:  newobj     instance void [PresentationCore]System.Windows.Media.SolidColorBrush::.ctor(valuetype [PresentationCore]System.Windows.Media.Color)
    IL_0076:  callvirt   instance void [PresentationFramework]System.Windows.Shapes.Shape::set_Fill(class [PresentationCore]System.Windows.Media.Brush)
    IL_007b:  nop
    IL_007c:  ldloc.2
    IL_007d:  stfld      class [PresentationFramework]System.Windows.Shapes.Ellipse AntisocialRobots.Robot::Element
    IL_0082:  ldloc.1
    IL_0083:  stloc.0
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
    IL_0084:  ldarg.0
    IL_0085:  ldloc.0
    IL_0086:  ldarg.1
    IL_0087:  call       instance void AntisocialRobots.MainWindow::SetRobotElementPosition(class AntisocialRobots.Robot,
                                                                                            valuetype AntisocialRobots.RoomPoint)
    IL_008c:  nop
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
    IL_008d:  ldarg.0
    IL_008e:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_0093:  callvirt   instance class [PresentationFramework]System.Windows.Controls.UIElementCollection [PresentationFramework]System.Windows.Controls.Panel::get_Children()
    IL_0098:  ldloc.0
    IL_0099:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse AntisocialRobots.Robot::Element
    IL_009e:  callvirt   instance int32 [PresentationFramework]System.Windows.Controls.UIElementCollection::Add(class [PresentationCore]System.Windows.UIElement)
    IL_00a3:  pop
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
    IL_00a4:  ldarg.0
    IL_00a5:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_00aa:  ldloc.0
    IL_00ab:  callvirt   instance void class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::Add(!0)
    IL_00b0:  nop
//000159:             _roomCells[pt.X, pt.Y] = robot;
    IL_00b1:  ldarg.0
    IL_00b2:  ldfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
    IL_00b7:  ldarga.s   pt
    IL_00b9:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_00be:  ldarga.s   pt
    IL_00c0:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_00c5:  ldloc.0
    IL_00c6:  call       instance void class AntisocialRobots.Robot[0...,0...]::Set(int32,
                                                                                    int32,
                                                                                    class AntisocialRobots.Robot)
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
    IL_00cb:  ldarg.0
    IL_00cc:  call       instance void AntisocialRobots.MainWindow::MoveNextColor()
    IL_00d1:  nop
//000163:         }
    IL_00d2:  ret
  } // end of method MainWindow::CreateRobot

  .method private hidebysig instance void 
          MoveNextColor() cil managed
  {
    // Code size       417 (0x1a1)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
    IL_0000:  nop
//000168:             if (_nextColor.B == 0)
    IL_0001:  ldarg.0
    IL_0002:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0007:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_B()
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  ldc.i4.0
    IL_0010:  ceq
    IL_0012:  stloc.0
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0013:  ldloc.0
    IL_0014:  brtrue.s   IL_0095

//000169:             {
    IL_0016:  nop
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
    IL_0017:  ldarg.0
    IL_0018:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_001d:  ldarg.0
    IL_001e:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0023:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_R()
    IL_0028:  ldc.i4.s   10
    IL_002a:  sub
    IL_002b:  ldc.i4.0
    IL_002c:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_0031:  conv.u1
    IL_0032:  call       instance void [PresentationCore]System.Windows.Media.Color::set_R(uint8)
    IL_0037:  nop
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
    IL_0038:  ldarg.0
    IL_0039:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_003e:  ldarg.0
    IL_003f:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0044:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_G()
    IL_0049:  ldc.i4.s   10
    IL_004b:  add
    IL_004c:  ldc.i4.0
    IL_004d:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_0052:  conv.u1
    IL_0053:  call       instance void [PresentationCore]System.Windows.Media.Color::set_G(uint8)
    IL_0058:  nop
//000172:                 if (_nextColor.R == 0)
    IL_0059:  ldarg.0
    IL_005a:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_005f:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_R()
    IL_0064:  ldc.i4.0
    IL_0065:  ceq
    IL_0067:  ldc.i4.0
    IL_0068:  ceq
    IL_006a:  stloc.0
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_006b:  ldloc.0
    IL_006c:  brtrue.s   IL_008f

//000173:                 {
    IL_006e:  nop
//000174:                     _nextColor.G = 240;
    IL_006f:  ldarg.0
    IL_0070:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0075:  ldc.i4     0xf0
    IL_007a:  call       instance void [PresentationCore]System.Windows.Media.Color::set_G(uint8)
    IL_007f:  nop
//000175:                     _nextColor.B = 10;
    IL_0080:  ldarg.0
    IL_0081:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0086:  ldc.i4.s   10
    IL_0088:  call       instance void [PresentationCore]System.Windows.Media.Color::set_B(uint8)
    IL_008d:  nop
//000176:                 }
    IL_008e:  nop
//000177:             }
    IL_008f:  nop
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0090:  br         IL_01a0

//000178:             else if (_nextColor.G > 0)
    IL_0095:  ldarg.0
    IL_0096:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_009b:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_G()
    IL_00a0:  ldc.i4.0
    IL_00a1:  cgt
    IL_00a3:  ldc.i4.0
    IL_00a4:  ceq
    IL_00a6:  stloc.0
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_00a7:  ldloc.0
    IL_00a8:  brtrue.s   IL_0126

//000179:             {
    IL_00aa:  nop
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
    IL_00ab:  ldarg.0
    IL_00ac:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_00b1:  ldarg.0
    IL_00b2:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_00b7:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_G()
    IL_00bc:  ldc.i4.s   10
    IL_00be:  sub
    IL_00bf:  ldc.i4.0
    IL_00c0:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_00c5:  conv.u1
    IL_00c6:  call       instance void [PresentationCore]System.Windows.Media.Color::set_G(uint8)
    IL_00cb:  nop
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
    IL_00cc:  ldarg.0
    IL_00cd:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_00d2:  ldarg.0
    IL_00d3:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_00d8:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_B()
    IL_00dd:  ldc.i4.s   10
    IL_00df:  add
    IL_00e0:  ldc.i4.0
    IL_00e1:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_00e6:  conv.u1
    IL_00e7:  call       instance void [PresentationCore]System.Windows.Media.Color::set_B(uint8)
    IL_00ec:  nop
//000182:                 if (_nextColor.G == 0)
    IL_00ed:  ldarg.0
    IL_00ee:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_00f3:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_G()
    IL_00f8:  ldc.i4.0
    IL_00f9:  ceq
    IL_00fb:  ldc.i4.0
    IL_00fc:  ceq
    IL_00fe:  stloc.0
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_00ff:  ldloc.0
    IL_0100:  brtrue.s   IL_0123

//000183:                 {
    IL_0102:  nop
//000184:                     _nextColor.B = 240;
    IL_0103:  ldarg.0
    IL_0104:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0109:  ldc.i4     0xf0
    IL_010e:  call       instance void [PresentationCore]System.Windows.Media.Color::set_B(uint8)
    IL_0113:  nop
//000185:                     _nextColor.R = 10;
    IL_0114:  ldarg.0
    IL_0115:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_011a:  ldc.i4.s   10
    IL_011c:  call       instance void [PresentationCore]System.Windows.Media.Color::set_R(uint8)
    IL_0121:  nop
//000186:                 }
    IL_0122:  nop
//000187:             }
    IL_0123:  nop
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0124:  br.s       IL_01a0

//000189:             {
    IL_0126:  nop
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
    IL_0127:  ldarg.0
    IL_0128:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_012d:  ldarg.0
    IL_012e:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0133:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_B()
    IL_0138:  ldc.i4.s   10
    IL_013a:  sub
    IL_013b:  ldc.i4.0
    IL_013c:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_0141:  conv.u1
    IL_0142:  call       instance void [PresentationCore]System.Windows.Media.Color::set_B(uint8)
    IL_0147:  nop
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
    IL_0148:  ldarg.0
    IL_0149:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_014e:  ldarg.0
    IL_014f:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0154:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_R()
    IL_0159:  ldc.i4.s   10
    IL_015b:  add
    IL_015c:  ldc.i4.0
    IL_015d:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_0162:  conv.u1
    IL_0163:  call       instance void [PresentationCore]System.Windows.Media.Color::set_R(uint8)
    IL_0168:  nop
//000192:                 if (_nextColor.B == 0)
    IL_0169:  ldarg.0
    IL_016a:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_016f:  call       instance uint8 [PresentationCore]System.Windows.Media.Color::get_B()
    IL_0174:  ldc.i4.0
    IL_0175:  ceq
    IL_0177:  ldc.i4.0
    IL_0178:  ceq
    IL_017a:  stloc.0
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_017b:  ldloc.0
    IL_017c:  brtrue.s   IL_019f

//000193:                 {
    IL_017e:  nop
//000194:                     _nextColor.R = 240;
    IL_017f:  ldarg.0
    IL_0180:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0185:  ldc.i4     0xf0
    IL_018a:  call       instance void [PresentationCore]System.Windows.Media.Color::set_R(uint8)
    IL_018f:  nop
//000195:                     _nextColor.G = 10;
    IL_0190:  ldarg.0
    IL_0191:  ldflda     valuetype [PresentationCore]System.Windows.Media.Color AntisocialRobots.MainWindow::_nextColor
    IL_0196:  ldc.i4.s   10
    IL_0198:  call       instance void [PresentationCore]System.Windows.Media.Color::set_G(uint8)
    IL_019d:  nop
//000196:                 }
    IL_019e:  nop
//000197:             }
    IL_019f:  nop
//000198:         }
    IL_01a0:  ret
  } // end of method MainWindow::MoveNextColor

  .method private hidebysig instance void 
          SetRobotElementPosition(class AntisocialRobots.Robot robot,
                                  valuetype AntisocialRobots.RoomPoint pt) cil managed
  {
    // Code size       62 (0x3e)
    .maxstack  8
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
    IL_0000:  nop
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
    IL_0001:  ldarg.1
    IL_0002:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse AntisocialRobots.Robot::Element
    IL_0007:  ldarga.s   pt
    IL_0009:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_000e:  conv.r8
    IL_000f:  ldc.r8     200.
    IL_0018:  div
    IL_0019:  call       void [PresentationFramework]System.Windows.Controls.Canvas::SetLeft(class [PresentationCore]System.Windows.UIElement,
                                                                                             float64)
    IL_001e:  nop
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
    IL_001f:  ldarg.1
    IL_0020:  ldfld      class [PresentationFramework]System.Windows.Shapes.Ellipse AntisocialRobots.Robot::Element
    IL_0025:  ldarga.s   pt
    IL_0027:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_002c:  conv.r8
    IL_002d:  ldc.r8     200.
    IL_0036:  div
    IL_0037:  call       void [PresentationFramework]System.Windows.Controls.Canvas::SetTop(class [PresentationCore]System.Windows.UIElement,
                                                                                            float64)
    IL_003c:  nop
//000207:         }
    IL_003d:  ret
  } // end of method MainWindow::SetRobotElementPosition

  .method private hidebysig instance valuetype AntisocialRobots.RoomPoint 
          MousePositionToRoomPoint(class [PresentationCore]System.Windows.Input.MouseEventArgs e) cil managed
  {
    // Code size       60 (0x3c)
    .maxstack  3
    .locals init ([0] valuetype [WindowsBase]System.Windows.Point pt,
             [1] valuetype AntisocialRobots.RoomPoint CS$1$0000)
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
    IL_0000:  nop
//000213:             Point pt = e.GetPosition(Room);
    IL_0001:  ldarg.1
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_0008:  callvirt   instance valuetype [WindowsBase]System.Windows.Point [PresentationCore]System.Windows.Input.MouseEventArgs::GetPosition(class [PresentationCore]System.Windows.IInputElement)
    IL_000d:  stloc.0
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
    IL_000e:  ldloca.s   pt
    IL_0010:  call       instance float64 [WindowsBase]System.Windows.Point::get_X()
    IL_0015:  ldc.r8     200.
    IL_001e:  mul
    IL_001f:  conv.i4
    IL_0020:  ldloca.s   pt
    IL_0022:  call       instance float64 [WindowsBase]System.Windows.Point::get_Y()
    IL_0027:  ldc.r8     200.
    IL_0030:  mul
    IL_0031:  conv.i4
    IL_0032:  newobj     instance void AntisocialRobots.RoomPoint::.ctor(int32,
                                                                         int32)
    IL_0037:  stloc.1
    IL_0038:  br.s       IL_003a

//000215:         }
    IL_003a:  ldloc.1
    IL_003b:  ret
  } // end of method MainWindow::MousePositionToRoomPoint

  .method private hidebysig instance void 
          PerformSimulationStep() cil managed
  {
    // Code size       395 (0x18b)
    .maxstack  4
    .locals init ([0] class [mscorlib]System.Action`1<class AntisocialRobots.Robot> 'CS$<>9__CachedAnonymousMethodDelegateb',
             [1] class AntisocialRobots.MainWindow/'<>c__DisplayClassc' 'CS$<>8__localsd',
             [2] class AntisocialRobots.Robot robot,
             [3] float64 fps,
             [4] valuetype [mscorlib]System.Nullable`1<bool> CS$0$0000,
             [5] bool CS$4$0001,
             [6] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot> CS$5$0002,
             [7] int32 CS$0$0003)
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
    IL_0000:  nop
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [PresentationFramework]System.Windows.Controls.CheckBox AntisocialRobots.MainWindow::chkParallel
    IL_0007:  callvirt   instance valuetype [mscorlib]System.Nullable`1<bool> [PresentationFramework]System.Windows.Controls.Primitives.ToggleButton::get_IsChecked()
    IL_000c:  stloc.s    CS$0$0000
    IL_000e:  ldloca.s   CS$0$0000
    IL_0010:  call       instance !0 valuetype [mscorlib]System.Nullable`1<bool>::get_Value()
    IL_0015:  ldc.i4.0
    IL_0016:  ceq
    IL_0018:  stloc.s    CS$4$0001
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_001a:  ldloc.s    CS$4$0001
    IL_001c:  brtrue.s   IL_0079

//000223:             {
    IL_001e:  nop
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_001f:  ldnull
    IL_0020:  stloc.0
    IL_0021:  newobj     instance void AntisocialRobots.MainWindow/'<>c__DisplayClassc'::.ctor()
    IL_0026:  stloc.1
    IL_0027:  ldloc.1
    IL_0028:  ldarg.0
    IL_0029:  stfld      class AntisocialRobots.MainWindow AntisocialRobots.MainWindow/'<>c__DisplayClassc'::'<>4__this'
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
    IL_002e:  ldloc.1
    IL_002f:  ldc.i4.0
    IL_0030:  stfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0035:  br.s       IL_0066

//000225:                 {
    IL_0037:  nop
//000226:                     Parallel.ForEach(_robots, robot =>
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_003e:  ldloc.0
    IL_003f:  brtrue.s   IL_0050

    IL_0041:  ldloc.1
    IL_0042:  ldftn      instance void AntisocialRobots.MainWindow/'<>c__DisplayClassc'::'<PerformSimulationStep>b__a'(class AntisocialRobots.Robot)
    IL_0048:  newobj     instance void class [mscorlib]System.Action`1<class AntisocialRobots.Robot>::.ctor(object,
                                                                                                            native int)
    IL_004d:  stloc.0
    IL_004e:  br.s       IL_0050

    IL_0050:  ldloc.0
    IL_0051:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::ForEach<class AntisocialRobots.Robot>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                        class [mscorlib]System.Action`1<!!0>)
    IL_0056:  pop
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
    IL_0057:  nop
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
    IL_0058:  ldloc.1
    IL_0059:  dup
    IL_005a:  ldfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
    IL_005f:  ldc.i4.1
    IL_0060:  add
    IL_0061:  stfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
    IL_0066:  ldloc.1
    IL_0067:  ldfld      int32 AntisocialRobots.MainWindow/'<>c__DisplayClassc'::stripe
    IL_006c:  ldc.i4.s   9
    IL_006e:  clt
    IL_0070:  stloc.s    CS$4$0001
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0072:  ldloc.s    CS$4$0001
    IL_0074:  brtrue.s   IL_0037

//000235:             }
    IL_0076:  nop
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0077:  br.s       IL_00c8

//000237:             {
    IL_0079:  nop
//000238:                 foreach (Robot robot in _robots)
    IL_007a:  nop
    IL_007b:  ldarg.0
    IL_007c:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_0081:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::GetEnumerator()
    IL_0086:  stloc.s    CS$5$0002
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    .try
    {
      IL_0088:  br.s       IL_00a8

//000238:                 foreach (Robot robot in _robots)
      IL_008a:  ldloca.s   CS$5$0002
      IL_008c:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::get_Current()
      IL_0091:  stloc.2
//000239:                 {
      IL_0092:  nop
//000240:                     SimulateOneStep(robot);
      IL_0093:  ldarg.0
      IL_0094:  ldloc.2
      IL_0095:  call       instance void AntisocialRobots.MainWindow::SimulateOneStep(class AntisocialRobots.Robot)
      IL_009a:  nop
//000241:                     robot.LastMovedFrame = _frameIndex;
      IL_009b:  ldloc.2
      IL_009c:  ldarg.0
      IL_009d:  ldfld      int32 AntisocialRobots.MainWindow::_frameIndex
      IL_00a2:  stfld      int32 AntisocialRobots.Robot::LastMovedFrame
//000242:                 }
      IL_00a7:  nop
//000238:                 foreach (Robot robot in _robots)
      IL_00a8:  ldloca.s   CS$5$0002
      IL_00aa:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::MoveNext()
      IL_00af:  stloc.s    CS$4$0001
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_00b1:  ldloc.s    CS$4$0001
      IL_00b3:  brtrue.s   IL_008a

      IL_00b5:  leave.s    IL_00c6

    }  // end .try
    finally
    {
      IL_00b7:  ldloca.s   CS$5$0002
      IL_00b9:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>
      IL_00bf:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00c4:  nop
      IL_00c5:  endfinally
    }  // end handler
    IL_00c6:  nop
//000243:             }
    IL_00c7:  nop
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
    IL_00c8:  nop
    IL_00c9:  ldarg.0
    IL_00ca:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_00cf:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::GetEnumerator()
    IL_00d4:  stloc.s    CS$5$0002
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    .try
    {
      IL_00d6:  br.s       IL_00ee

//000246:             foreach (Robot robot in _robots)
      IL_00d8:  ldloca.s   CS$5$0002
      IL_00da:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::get_Current()
      IL_00df:  stloc.2
//000247:                 SetRobotElementPosition(robot, robot.Location);
      IL_00e0:  ldarg.0
      IL_00e1:  ldloc.2
      IL_00e2:  ldloc.2
      IL_00e3:  ldfld      valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
      IL_00e8:  call       instance void AntisocialRobots.MainWindow::SetRobotElementPosition(class AntisocialRobots.Robot,
                                                                                              valuetype AntisocialRobots.RoomPoint)
      IL_00ed:  nop
//000246:             foreach (Robot robot in _robots)
      IL_00ee:  ldloca.s   CS$5$0002
      IL_00f0:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::MoveNext()
      IL_00f5:  stloc.s    CS$4$0001
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_00f7:  ldloc.s    CS$4$0001
      IL_00f9:  brtrue.s   IL_00d8

      IL_00fb:  leave.s    IL_010c

    }  // end .try
    finally
    {
      IL_00fd:  ldloca.s   CS$5$0002
      IL_00ff:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>
      IL_0105:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_010a:  nop
      IL_010b:  endfinally
    }  // end handler
    IL_010c:  nop
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
    IL_010d:  ldarg.0
    IL_010e:  dup
    IL_010f:  ldfld      int32 AntisocialRobots.MainWindow::_frameIndex
    IL_0114:  ldc.i4.1
    IL_0115:  add
    IL_0116:  dup
    IL_0117:  stloc.s    CS$0$0003
    IL_0119:  stfld      int32 AntisocialRobots.MainWindow::_frameIndex
    IL_011e:  ldloc.s    CS$0$0003
    IL_0120:  ldc.i4.s   10
    IL_0122:  rem
    IL_0123:  ldc.i4.0
    IL_0124:  ceq
    IL_0126:  ldc.i4.0
    IL_0127:  ceq
    IL_0129:  stloc.s    CS$4$0001
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_012b:  ldloc.s    CS$4$0001
    IL_012d:  brtrue.s   IL_018a

//000251:             {
    IL_012f:  nop
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
    IL_0130:  ldc.r8     1000.
    IL_0139:  ldarg.0
    IL_013a:  ldfld      class [System]System.Diagnostics.Stopwatch AntisocialRobots.MainWindow::_framesPerSecondStopwatch
    IL_013f:  callvirt   instance int64 [System]System.Diagnostics.Stopwatch::get_ElapsedMilliseconds()
    IL_0144:  conv.r8
    IL_0145:  div
    IL_0146:  ldc.r8     10.
    IL_014f:  mul
    IL_0150:  stloc.3
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
    IL_0151:  ldarg.0
    IL_0152:  ldfld      class [PresentationFramework]System.Windows.Controls.TextBlock AntisocialRobots.MainWindow::txtStatus
    IL_0157:  ldstr      "{0} robots, {1:n1} fps"
    IL_015c:  ldarg.0
    IL_015d:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_0162:  callvirt   instance int32 class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::get_Count()
    IL_0167:  box        [mscorlib]System.Int32
    IL_016c:  ldloc.3
    IL_016d:  box        [mscorlib]System.Double
    IL_0172:  call       string [mscorlib]System.String::Format(string,
                                                                object,
                                                                object)
    IL_0177:  callvirt   instance void [PresentationFramework]System.Windows.Controls.TextBlock::set_Text(string)
    IL_017c:  nop
//000254:                 _framesPerSecondStopwatch.Restart();
    IL_017d:  ldarg.0
    IL_017e:  ldfld      class [System]System.Diagnostics.Stopwatch AntisocialRobots.MainWindow::_framesPerSecondStopwatch
    IL_0183:  callvirt   instance void [System]System.Diagnostics.Stopwatch::Restart()
    IL_0188:  nop
//000255:             }
    IL_0189:  nop
//000256:         }
    IL_018a:  ret
  } // end of method MainWindow::PerformSimulationStep

  .method private hidebysig instance void 
          SimulateOneStep(class AntisocialRobots.Robot r) cil managed
  {
    // Code size       687 (0x2af)
    .maxstack  4
    .locals init ([0] valuetype AntisocialRobots.RoomPoint ptR,
             [1] float64 vectorX,
             [2] float64 vectorY,
             [3] class AntisocialRobots.Robot s,
             [4] valuetype AntisocialRobots.RoomPoint ptS,
             [5] float64 inverseSquareDistance,
             [6] float64 angle,
             [7] float64 degrees,
             [8] int32 direction,
             [9] valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot> CS$5$0000,
             [10] bool CS$4$0001)
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
    IL_0000:  nop
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
    IL_0001:  ldarg.1
    IL_0002:  ldfld      valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_0007:  stloc.0
//000264:             double vectorX = 0, vectorY = 0;
    IL_0008:  ldc.r8     0.0
    IL_0011:  stloc.1
    IL_0012:  ldc.r8     0.0
    IL_001b:  stloc.2
//000265: 
//000266:             foreach (Robot s in _robots)
    IL_001c:  nop
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
    IL_0023:  callvirt   instance valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<!0> class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::GetEnumerator()
    IL_0028:  stloc.s    CS$5$0000
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    .try
    {
      IL_002a:  br.s       IL_008c

//000266:             foreach (Robot s in _robots)
      IL_002c:  ldloca.s   CS$5$0000
      IL_002e:  call       instance !0 valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::get_Current()
      IL_0033:  stloc.3
//000267:             {
      IL_0034:  nop
//000268:                 if (r == s) continue;
      IL_0035:  ldarg.1
      IL_0036:  ldloc.3
      IL_0037:  ceq
      IL_0039:  ldc.i4.0
      IL_003a:  ceq
      IL_003c:  stloc.s    CS$4$0001
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_003e:  ldloc.s    CS$4$0001
      IL_0040:  brtrue.s   IL_0044

//000268:                 if (r == s) continue;
      IL_0042:  br.s       IL_008c

//000269:                 RoomPoint ptS = s.Location;
      IL_0044:  ldloc.3
      IL_0045:  ldfld      valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
      IL_004a:  stloc.s    ptS
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
      IL_004c:  ldc.r8     1.
      IL_0055:  ldloca.s   ptR
      IL_0057:  ldloc.s    ptS
      IL_0059:  call       instance float64 AntisocialRobots.RoomPoint::DistanceTo(valuetype AntisocialRobots.RoomPoint)
      IL_005e:  call       float64 AntisocialRobots.RoomPoint::Square(float64)
      IL_0063:  div
      IL_0064:  stloc.s    inverseSquareDistance
//000271:                 double angle = ptR.AngleTo(ptS);
      IL_0066:  ldloca.s   ptR
      IL_0068:  ldloc.s    ptS
      IL_006a:  call       instance float64 AntisocialRobots.RoomPoint::AngleTo(valuetype AntisocialRobots.RoomPoint)
      IL_006f:  stloc.s    angle
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
      IL_0071:  ldloc.1
      IL_0072:  ldloc.s    inverseSquareDistance
      IL_0074:  ldloc.s    angle
      IL_0076:  call       float64 [mscorlib]System.Math::Cos(float64)
      IL_007b:  mul
      IL_007c:  sub
      IL_007d:  stloc.1
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
      IL_007e:  ldloc.2
      IL_007f:  ldloc.s    inverseSquareDistance
      IL_0081:  ldloc.s    angle
      IL_0083:  call       float64 [mscorlib]System.Math::Sin(float64)
      IL_0088:  mul
      IL_0089:  sub
      IL_008a:  stloc.2
//000274:             }
      IL_008b:  nop
//000266:             foreach (Robot s in _robots)
      IL_008c:  ldloca.s   CS$5$0000
      IL_008e:  call       instance bool valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>::MoveNext()
      IL_0093:  stloc.s    CS$4$0001
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
      IL_0095:  ldloc.s    CS$4$0001
      IL_0097:  brtrue.s   IL_002c

      IL_0099:  leave.s    IL_00aa

    }  // end .try
    finally
    {
      IL_009b:  ldloca.s   CS$5$0000
      IL_009d:  constrained. valuetype [mscorlib]System.Collections.Generic.List`1/Enumerator<class AntisocialRobots.Robot>
      IL_00a3:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00a8:  nop
      IL_00a9:  endfinally
    }  // end handler
    IL_00aa:  nop
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
    IL_00ab:  ldloc.2
    IL_00ac:  ldloc.1
    IL_00ad:  call       float64 [mscorlib]System.Math::Atan2(float64,
                                                              float64)
    IL_00b2:  ldc.r8     180.
    IL_00bb:  mul
    IL_00bc:  ldc.r8     3.1415926535897931
    IL_00c5:  div
    IL_00c6:  stloc.s    degrees
//000277: 
//000278:             degrees += 22.5;
    IL_00c8:  ldloc.s    degrees
    IL_00ca:  ldc.r8     22.5
    IL_00d3:  add
    IL_00d4:  stloc.s    degrees
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_00d6:  br.s       IL_00e6

//000279:             while (degrees < 0) degrees += 360;
    IL_00d8:  ldloc.s    degrees
    IL_00da:  ldc.r8     360.
    IL_00e3:  add
    IL_00e4:  stloc.s    degrees
    IL_00e6:  ldloc.s    degrees
    IL_00e8:  ldc.r8     0.0
    IL_00f1:  clt
    IL_00f3:  stloc.s    CS$4$0001
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_00f5:  ldloc.s    CS$4$0001
    IL_00f7:  brtrue.s   IL_00d8

    IL_00f9:  br.s       IL_0109

//000280:             while (degrees >= 360) degrees -= 360;
    IL_00fb:  ldloc.s    degrees
    IL_00fd:  ldc.r8     360.
    IL_0106:  sub
    IL_0107:  stloc.s    degrees
    IL_0109:  ldloc.s    degrees
    IL_010b:  ldc.r8     360.
    IL_0114:  clt.un
    IL_0116:  ldc.i4.0
    IL_0117:  ceq
    IL_0119:  stloc.s    CS$4$0001
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_011b:  ldloc.s    CS$4$0001
    IL_011d:  brtrue.s   IL_00fb

//000282:             int direction = (int)(degrees * 8 / 360);
    IL_011f:  ldloc.s    degrees
    IL_0121:  ldc.r8     8.
    IL_012a:  mul
    IL_012b:  ldc.r8     360.
    IL_0134:  div
    IL_0135:  conv.i4
    IL_0136:  stloc.s    direction
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
    IL_0138:  ldloc.s    direction
    IL_013a:  ldc.i4.7
    IL_013b:  beq.s      IL_014b

    IL_013d:  ldloc.s    direction
    IL_013f:  brfalse.s  IL_014b

    IL_0141:  ldloc.s    direction
    IL_0143:  ldc.i4.1
    IL_0144:  ceq
    IL_0146:  ldc.i4.0
    IL_0147:  ceq
    IL_0149:  br.s       IL_014c

    IL_014b:  ldc.i4.0
    IL_014c:  stloc.s    CS$4$0001
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_014e:  ldloc.s    CS$4$0001
    IL_0150:  brtrue.s   IL_016e

//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
    IL_0152:  ldloca.s   ptR
    IL_0154:  ldloca.s   ptR
    IL_0156:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_015b:  ldc.i4.1
    IL_015c:  add
    IL_015d:  ldc.i4     0xc7
    IL_0162:  call       int32 [mscorlib]System.Math::Min(int32,
                                                          int32)
    IL_0167:  stfld      int32 AntisocialRobots.RoomPoint::X
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_016c:  br.s       IL_019f

//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
    IL_016e:  ldloc.s    direction
    IL_0170:  ldc.i4.3
    IL_0171:  beq.s      IL_0182

    IL_0173:  ldloc.s    direction
    IL_0175:  ldc.i4.4
    IL_0176:  beq.s      IL_0182

    IL_0178:  ldloc.s    direction
    IL_017a:  ldc.i4.5
    IL_017b:  ceq
    IL_017d:  ldc.i4.0
    IL_017e:  ceq
    IL_0180:  br.s       IL_0183

    IL_0182:  ldc.i4.0
    IL_0183:  stloc.s    CS$4$0001
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0185:  ldloc.s    CS$4$0001
    IL_0187:  brtrue.s   IL_019f

//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
    IL_0189:  ldloca.s   ptR
    IL_018b:  ldloca.s   ptR
    IL_018d:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0192:  ldc.i4.1
    IL_0193:  sub
    IL_0194:  ldc.i4.0
    IL_0195:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_019a:  stfld      int32 AntisocialRobots.RoomPoint::X
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
    IL_019f:  ldloc.s    direction
    IL_01a1:  ldc.i4.1
    IL_01a2:  beq.s      IL_01b3

    IL_01a4:  ldloc.s    direction
    IL_01a6:  ldc.i4.2
    IL_01a7:  beq.s      IL_01b3

    IL_01a9:  ldloc.s    direction
    IL_01ab:  ldc.i4.3
    IL_01ac:  ceq
    IL_01ae:  ldc.i4.0
    IL_01af:  ceq
    IL_01b1:  br.s       IL_01b4

    IL_01b3:  ldc.i4.0
    IL_01b4:  stloc.s    CS$4$0001
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_01b6:  ldloc.s    CS$4$0001
    IL_01b8:  brtrue.s   IL_01d6

//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
    IL_01ba:  ldloca.s   ptR
    IL_01bc:  ldloca.s   ptR
    IL_01be:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_01c3:  ldc.i4.1
    IL_01c4:  add
    IL_01c5:  ldc.i4     0xc7
    IL_01ca:  call       int32 [mscorlib]System.Math::Min(int32,
                                                          int32)
    IL_01cf:  stfld      int32 AntisocialRobots.RoomPoint::Y
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_01d4:  br.s       IL_0207

//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
    IL_01d6:  ldloc.s    direction
    IL_01d8:  ldc.i4.5
    IL_01d9:  beq.s      IL_01ea

    IL_01db:  ldloc.s    direction
    IL_01dd:  ldc.i4.6
    IL_01de:  beq.s      IL_01ea

    IL_01e0:  ldloc.s    direction
    IL_01e2:  ldc.i4.7
    IL_01e3:  ceq
    IL_01e5:  ldc.i4.0
    IL_01e6:  ceq
    IL_01e8:  br.s       IL_01eb

    IL_01ea:  ldc.i4.0
    IL_01eb:  stloc.s    CS$4$0001
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_01ed:  ldloc.s    CS$4$0001
    IL_01ef:  brtrue.s   IL_0207

//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
    IL_01f1:  ldloca.s   ptR
    IL_01f3:  ldloca.s   ptR
    IL_01f5:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_01fa:  ldc.i4.1
    IL_01fb:  sub
    IL_01fc:  ldc.i4.0
    IL_01fd:  call       int32 [mscorlib]System.Math::Max(int32,
                                                          int32)
    IL_0202:  stfld      int32 AntisocialRobots.RoomPoint::Y
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
    IL_0207:  ldloca.s   ptR
    IL_0209:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_020e:  ldarg.1
    IL_020f:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_0214:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0219:  bne.un.s   IL_022f

    IL_021b:  ldloca.s   ptR
    IL_021d:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0222:  ldarg.1
    IL_0223:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_0228:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_022d:  beq.s      IL_0250

    IL_022f:  ldarg.0
    IL_0230:  ldfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
    IL_0235:  ldloca.s   ptR
    IL_0237:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_023c:  ldloca.s   ptR
    IL_023e:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0243:  call       instance class AntisocialRobots.Robot class AntisocialRobots.Robot[0...,0...]::Get(int32,
                                                                                                            int32)
    IL_0248:  ldnull
    IL_0249:  ceq
    IL_024b:  ldc.i4.0
    IL_024c:  ceq
    IL_024e:  br.s       IL_0251

    IL_0250:  ldc.i4.1
    IL_0251:  stloc.s    CS$4$0001
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0253:  ldloc.s    CS$4$0001
    IL_0255:  brtrue.s   IL_02ae

//000295:             {
    IL_0257:  nop
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
    IL_0258:  ldarg.0
    IL_0259:  ldfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
    IL_025e:  ldarg.1
    IL_025f:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_0264:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0269:  ldarg.1
    IL_026a:  ldflda     valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
    IL_026f:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_0274:  ldnull
    IL_0275:  call       instance void class AntisocialRobots.Robot[0...,0...]::Set(int32,
                                                                                    int32,
                                                                                    class AntisocialRobots.Robot)
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
    IL_027a:  ldarg.0
    IL_027b:  ldfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
    IL_0280:  ldloca.s   ptR
    IL_0282:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_0287:  ldloca.s   ptR
    IL_0289:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_028e:  ldarg.1
    IL_028f:  call       instance void class AntisocialRobots.Robot[0...,0...]::Set(int32,
                                                                                    int32,
                                                                                    class AntisocialRobots.Robot)
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
    IL_0294:  ldarg.1
    IL_0295:  ldloca.s   ptR
    IL_0297:  ldfld      int32 AntisocialRobots.RoomPoint::X
    IL_029c:  ldloca.s   ptR
    IL_029e:  ldfld      int32 AntisocialRobots.RoomPoint::Y
    IL_02a3:  newobj     instance void AntisocialRobots.RoomPoint::.ctor(int32,
                                                                         int32)
    IL_02a8:  stfld      valuetype AntisocialRobots.RoomPoint AntisocialRobots.Robot::Location
//000299:             }
    IL_02ad:  nop
//000300:         }
    IL_02ae:  ret
  } // end of method MainWindow::SimulateOneStep

  .method public hidebysig newslot virtual final 
          instance void  InitializeComponent() cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       45 (0x2d)
    .maxstack  3
    .locals init ([0] class [System]System.Uri resourceLocater,
             [1] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool AntisocialRobots.MainWindow::_contentLoaded
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  stloc.1
    IL_000b:  ldloc.1
    IL_000c:  brtrue.s   IL_0011

    IL_000e:  nop
    IL_000f:  br.s       IL_002c

    IL_0011:  ldarg.0
    IL_0012:  ldc.i4.1
    IL_0013:  stfld      bool AntisocialRobots.MainWindow::_contentLoaded
    IL_0018:  ldstr      "/AntisocialRobots;component/mainwindow.xaml"
    IL_001d:  ldc.i4.2
    IL_001e:  newobj     instance void [System]System.Uri::.ctor(string,
                                                                 valuetype [System]System.UriKind)
    IL_0023:  stloc.0
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\MainWindow.xaml' 
//000001: ?<Window x:Class="AntisocialRobots.MainWindow"
    IL_0024:  ldarg.0
    IL_0025:  ldloc.0
    IL_0026:  call       void [PresentationFramework]System.Windows.Application::LoadComponent(object,
                                                                                               class [System]System.Uri)
    IL_002b:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_002c:  ret
  } // end of method MainWindow::InitializeComponent

  .method private hidebysig newslot virtual final 
          instance void  System.Windows.Markup.IComponentConnector.Connect(int32 connectionId,
                                                                           object target) cil managed
  {
    .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 01 00 00 00 00 00 ) 
    .override [System.Xaml]System.Windows.Markup.IComponentConnector::Connect
    // Code size       189 (0xbd)
    .maxstack  4
    .locals init ([0] int32 CS$4$0000)
    IL_0000:  nop
    IL_0001:  ldarg.1
    IL_0002:  stloc.0
    IL_0003:  ldloc.0
    IL_0004:  ldc.i4.1
    IL_0005:  sub
    IL_0006:  switch     ( 
                          IL_0024,
                          IL_0035,
                          IL_0043,
                          IL_0069,
                          IL_00a7)
    IL_001f:  br         IL_00b5

    IL_0024:  ldarg.0
    IL_0025:  ldarg.2
    IL_0026:  castclass  [PresentationFramework]System.Windows.Controls.TextBlock
    IL_002b:  stfld      class [PresentationFramework]System.Windows.Controls.TextBlock AntisocialRobots.MainWindow::txtStatus
    IL_0030:  br         IL_00bc

    IL_0035:  ldarg.0
    IL_0036:  ldarg.2
    IL_0037:  castclass  [PresentationFramework]System.Windows.Controls.CheckBox
    IL_003c:  stfld      class [PresentationFramework]System.Windows.Controls.CheckBox AntisocialRobots.MainWindow::chkParallel
    IL_0041:  br.s       IL_00bc

    IL_0043:  ldarg.0
    IL_0044:  ldarg.2
    IL_0045:  castclass  [PresentationFramework]System.Windows.Controls.Border
    IL_004a:  stfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\MainWindow.xaml' 
//000015:         <Border x:Name="RoomParent" Grid.Row="1" Margin="5" SizeChanged="RoomParent_SizeChanged" Background="Gray" CornerRadius="15">
    IL_004f:  ldarg.0
    IL_0050:  ldfld      class [PresentationFramework]System.Windows.Controls.Border AntisocialRobots.MainWindow::RoomParent
    IL_0055:  ldarg.0
    IL_0056:  ldftn      instance void AntisocialRobots.MainWindow::RoomParent_SizeChanged(object,
                                                                                           class [PresentationFramework]System.Windows.SizeChangedEventArgs)
    IL_005c:  newobj     instance void [PresentationFramework]System.Windows.SizeChangedEventHandler::.ctor(object,
                                                                                                            native int)
    IL_0061:  callvirt   instance void [PresentationFramework]System.Windows.FrameworkElement::add_SizeChanged(class [PresentationFramework]System.Windows.SizeChangedEventHandler)
    IL_0066:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_0067:  br.s       IL_00bc

    IL_0069:  ldarg.0
    IL_006a:  ldarg.2
    IL_006b:  castclass  [PresentationFramework]System.Windows.Controls.Canvas
    IL_0070:  stfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
// Source File 'c:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\MainWindow.xaml' 
//000017:                     MouseLeftButtonDown="Room_MouseLeftButtonDown" MouseMove="Room_MouseMove">
    IL_0075:  ldarg.0
    IL_0076:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_007b:  ldarg.0
    IL_007c:  ldftn      instance void AntisocialRobots.MainWindow::Room_MouseLeftButtonDown(object,
                                                                                             class [PresentationCore]System.Windows.Input.MouseButtonEventArgs)
    IL_0082:  newobj     instance void [PresentationCore]System.Windows.Input.MouseButtonEventHandler::.ctor(object,
                                                                                                             native int)
    IL_0087:  callvirt   instance void [PresentationCore]System.Windows.UIElement::add_MouseLeftButtonDown(class [PresentationCore]System.Windows.Input.MouseButtonEventHandler)
    IL_008c:  nop
    IL_008d:  ldarg.0
    IL_008e:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_0093:  ldarg.0
    IL_0094:  ldftn      instance void AntisocialRobots.MainWindow::Room_MouseMove(object,
                                                                                   class [PresentationCore]System.Windows.Input.MouseEventArgs)
    IL_009a:  newobj     instance void [PresentationCore]System.Windows.Input.MouseEventHandler::.ctor(object,
                                                                                                       native int)
    IL_009f:  callvirt   instance void [PresentationCore]System.Windows.UIElement::add_MouseMove(class [PresentationCore]System.Windows.Input.MouseEventHandler)
    IL_00a4:  nop
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\obj\Debug\MainWindow.g.cs' 
    IL_00a5:  br.s       IL_00bc

    IL_00a7:  ldarg.0
    IL_00a8:  ldarg.2
    IL_00a9:  castclass  [PresentationCore]System.Windows.Media.ScaleTransform
    IL_00ae:  stfld      class [PresentationCore]System.Windows.Media.ScaleTransform AntisocialRobots.MainWindow::RoomScaleTransform
    IL_00b3:  br.s       IL_00bc

    IL_00b5:  ldarg.0
    IL_00b6:  ldc.i4.1
    IL_00b7:  stfld      bool AntisocialRobots.MainWindow::_contentLoaded
    IL_00bc:  ret
  } // end of method MainWindow::System.Windows.Markup.IComponentConnector.Connect

  .method private hidebysig instance void 
          '<.ctor>b__0'() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       51 (0x33)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\AntisocialRobots\AntisocialRobots_CSharp\MainWindow.xaml.cs' 
//000066:             {
    IL_0000:  nop
//000067:                 _roomCells = new Robot[ROOM_SIZE, ROOM_SIZE];
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4     0xc8
    IL_0007:  ldc.i4     0xc8
    IL_000c:  newobj     instance void class AntisocialRobots.Robot[0...,0...]::.ctor(int32,
                                                                                      int32)
    IL_0011:  stfld      class AntisocialRobots.Robot[0...,0...] AntisocialRobots.MainWindow::_roomCells
//000068:                 _robots = new List<Robot>();
    IL_0016:  ldarg.0
    IL_0017:  newobj     instance void class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot>::.ctor()
    IL_001c:  stfld      class [mscorlib]System.Collections.Generic.List`1<class AntisocialRobots.Robot> AntisocialRobots.MainWindow::_robots
//000069:                 Room.Children.Clear();
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class [PresentationFramework]System.Windows.Controls.Canvas AntisocialRobots.MainWindow::Room
    IL_0027:  callvirt   instance class [PresentationFramework]System.Windows.Controls.UIElementCollection [PresentationFramework]System.Windows.Controls.Panel::get_Children()
    IL_002c:  callvirt   instance void [PresentationFramework]System.Windows.Controls.UIElementCollection::Clear()
    IL_0031:  nop
//000070:             };
//000071:             clearState();
//000072: 
//000073:             // When F5 is pressed, reset state
//000074:             KeyDown += (_, e) => { if (e.Key == Key.F5) clearState(); };
//000075: 
//000076:             // Render loop, started when the window loads
//000077:             Action recomputeAndRedraw = null;
//000078:             recomputeAndRedraw = delegate
//000079:             {
//000080:                 Dispatcher.BeginInvoke((Action)delegate
//000081:                 {
//000082:                     PerformSimulationStep();
//000083:                     recomputeAndRedraw();
//000084:                 }, DispatcherPriority.Background);
//000085:             };
//000086:             Loaded += delegate
//000087:             {
//000088:                 _framesPerSecondStopwatch.Start();
//000089:                 recomputeAndRedraw();
//000090:             };
//000091:         }
//000092: 
//000093:         /// <summary>
//000094:         /// Called when the size of the RoomParent (the control containing the canvas that
//000095:         /// displays the robots) changes.
//000096:         /// </summary>
//000097:         private void RoomParent_SizeChanged(object sender, SizeChangedEventArgs e)
//000098:         {
//000099:             // Set size to the width/height of the largest square that fits within
//000100:             // RoomParent (the control containing the canvas that holds robots)
//000101:             double size = Math.Min(RoomParent.ActualWidth, RoomParent.ActualHeight);
//000102: 
//000103:             // Room is set to be 1.0 units wide x 1.0 units high -- apply a scaling
//000104:             // transform so that it fills RoomParent
//000105:             RoomScaleTransform.ScaleX = size;
//000106:             RoomScaleTransform.ScaleY = size;
//000107: 
//000108:             // Center Room within the RoomParent
//000109:             double marginX = (RoomParent.ActualWidth - size) / 2;
//000110:             double marginY = (RoomParent.ActualHeight - size) / 2;
//000111:             Room.Margin = new Thickness(marginX, marginY, 0, 0);
//000112:         }
//000113: 
//000114:         /// <summary>Called when the user clicks on the canvas containing the robots.</summary>
//000115:         private void Room_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
//000116:         {
//000117:             CreateRobot(MousePositionToRoomPoint(e));
//000118:         }
//000119: 
//000120:         /// <summary>
//000121:         /// Called when the users moves the mouse, or holds the mouse button, over the canvas
//000122:         /// containing the robots.
//000123:         /// </summary>
//000124:         private void Room_MouseMove(object sender, MouseEventArgs e)
//000125:         {
//000126:             if (e.MouseDevice.LeftButton == MouseButtonState.Pressed)
//000127:                 CreateRobot(MousePositionToRoomPoint(e));
//000128:         }
//000129: 
//000130:         /// <summary>Creates a robot, which is placed at a given location with the room.</summary>
//000131:         /// <param name="pt">Where the robot should be placed, in RoomPoint coordinates.</param>
//000132:         void CreateRobot(RoomPoint pt)
//000133:         {
//000134:             // Do nothing if there's already a robot here
//000135:             if (_roomCells[pt.X, pt.Y] != null) return;
//000136: 
//000137:             // Create the new robot
//000138:             Robot robot = new Robot()
//000139:             {
//000140:                 Location = pt,
//000141:                 Element = new Ellipse()
//000142:                 {
//000143:                     Width = 1.0 / ROOM_SIZE,
//000144:                     Height = 1.0 / ROOM_SIZE,
//000145:                     HorizontalAlignment = HorizontalAlignment.Left,
//000146:                     VerticalAlignment = VerticalAlignment.Top,
//000147:                     Fill = new SolidColorBrush(_nextColor)
//000148:                 }
//000149:             };
//000150: 
//000151:             // Set the position of the robot within Room
//000152:             SetRobotElementPosition(robot, pt);
//000153: 
//000154:             // Add the robot to Room
//000155:             Room.Children.Add(robot.Element);
//000156: 
//000157:             // Add the robot to our data structures
//000158:             _robots.Add(robot);
//000159:             _roomCells[pt.X, pt.Y] = robot;
//000160: 
//000161:             // Advance _nextColor to the next color to use
//000162:             MoveNextColor();
//000163:         }
//000164: 
//000165:         /// <summary>Advances to the next color in the rotation.</summary>
//000166:         private void MoveNextColor()
//000167:         {
//000168:             if (_nextColor.B == 0)
//000169:             {
//000170:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R - 10, 0);
//000171:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G + 10, 0);
//000172:                 if (_nextColor.R == 0)
//000173:                 {
//000174:                     _nextColor.G = 240;
//000175:                     _nextColor.B = 10;
//000176:                 }
//000177:             }
//000178:             else if (_nextColor.G > 0)
//000179:             {
//000180:                 _nextColor.G = (byte)Math.Max((int)_nextColor.G - 10, 0);
//000181:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B + 10, 0);
//000182:                 if (_nextColor.G == 0)
//000183:                 {
//000184:                     _nextColor.B = 240;
//000185:                     _nextColor.R = 10;
//000186:                 }
//000187:             }
//000188:             else
//000189:             {
//000190:                 _nextColor.B = (byte)Math.Max((int)_nextColor.B - 10, 0);
//000191:                 _nextColor.R = (byte)Math.Max((int)_nextColor.R + 10, 0);
//000192:                 if (_nextColor.B == 0)
//000193:                 {
//000194:                     _nextColor.R = 240;
//000195:                     _nextColor.G = 10;
//000196:                 }
//000197:             }
//000198:         }
//000199: 
//000200:         /// <summary>Sets the position of the Robot.Element for a given robot to a given point.</summary>
//000201:         /// <param name="robot">The robot.</param>
//000202:         /// <param name="pt">The location in RoomPoint coordinates.</param>
//000203:         void SetRobotElementPosition(Robot robot, RoomPoint pt)
//000204:         {
//000205:             Canvas.SetLeft(robot.Element, ((double)pt.X) / ROOM_SIZE);
//000206:             Canvas.SetTop(robot.Element, ((double)pt.Y) / ROOM_SIZE);
//000207:         }
//000208: 
//000209:         /// <summary>Converts a mouse position to a RoomPoint.</summary>
//000210:         /// <param name="e">The event arguments containing the mouse position.</param>
//000211:         RoomPoint MousePositionToRoomPoint(MouseEventArgs e)
//000212:         {
//000213:             Point pt = e.GetPosition(Room);
//000214:             return new RoomPoint((int)(pt.X * ROOM_SIZE), (int)(pt.Y * ROOM_SIZE));
//000215:         }
//000216: 
//000217:         /// <summary>Performs one step of the simulation.</summary>
//000218:         void PerformSimulationStep()
//000219:         {
//000220:             // Calculate a new position for each robot, update _roomCells and each
//000221:             // Robot.Location with that information
//000222:             if (chkParallel.IsChecked.Value)
//000223:             {
//000224:                 for (int stripe = 0; stripe < 9; stripe++) // use striping to avoid races
//000225:                 {
//000226:                     Parallel.ForEach(_robots, robot =>
//000227:                     {
//000228:                         if (robot.LastMovedFrame < _frameIndex && (robot.Location.X % 3) == (stripe % 3) && (robot.Location.Y % 3) == (stripe / 3))
//000229:                         {
//000230:                             SimulateOneStep(robot);
//000231:                             robot.LastMovedFrame = _frameIndex;
//000232:                         }
//000233:                     });
//000234:                 }
//000235:             }
//000236:             else
//000237:             {
//000238:                 foreach (Robot robot in _robots)
//000239:                 {
//000240:                     SimulateOneStep(robot);
//000241:                     robot.LastMovedFrame = _frameIndex;
//000242:                 }
//000243:             }
//000244: 
//000245:             // update the on-screen position of all robots
//000246:             foreach (Robot robot in _robots)
//000247:                 SetRobotElementPosition(robot, robot.Location);
//000248: 
//000249:             // Update statistics
//000250:             if ((++_frameIndex % FramesPerSample) == 0)
//000251:             {
//000252:                 double fps = (1000 / (double)_framesPerSecondStopwatch.ElapsedMilliseconds) * FramesPerSample;
//000253:                 txtStatus.Text = String.Format("{0} robots, {1:n1} fps", _robots.Count, fps);
//000254:                 _framesPerSecondStopwatch.Restart();
//000255:             }
//000256:         }
//000257: 
//000258:         /// <summary>Performs one step of the simulation for one robot.</summary>
//000259:         /// <param name="r">The robot to perform the simulation step for.</param>
//000260:         void SimulateOneStep(Robot r)
//000261:         {
//000262:             // Set ptR to the location of the robot in room coordinates
//000263:             RoomPoint ptR = r.Location;
//000264:             double vectorX = 0, vectorY = 0;
//000265: 
//000266:             foreach (Robot s in _robots)
//000267:             {
//000268:                 if (r == s) continue;
//000269:                 RoomPoint ptS = s.Location;
//000270:                 double inverseSquareDistance = 1.0 / RoomPoint.Square(ptR.DistanceTo(ptS));
//000271:                 double angle = ptR.AngleTo(ptS);
//000272:                 vectorX -= inverseSquareDistance * Math.Cos(angle);
//000273:                 vectorY -= inverseSquareDistance * Math.Sin(angle);
//000274:             }
//000275: 
//000276:             double degrees = Math.Atan2(vectorY, vectorX) * 180 / Math.PI;
//000277: 
//000278:             degrees += 22.5;
//000279:             while (degrees < 0) degrees += 360;
//000280:             while (degrees >= 360) degrees -= 360;
//000281: 
//000282:             int direction = (int)(degrees * 8 / 360);
//000283: 
//000284:             if ((direction == 7) || (direction == 0) || (direction == 1))
//000285:                 ptR.X = Math.Min(ptR.X + 1, ROOM_SIZE - 1);
//000286:             else if ((direction == 3) || (direction == 4) || (direction == 5))
//000287:                 ptR.X = Math.Max(ptR.X - 1, 0);
//000288: 
//000289:             if ((direction == 1) || (direction == 2) || (direction == 3))
//000290:                 ptR.Y = Math.Min(ptR.Y + 1, ROOM_SIZE - 1);
//000291:             else if ((direction == 5) || (direction == 6) || (direction == 7))
//000292:                 ptR.Y = Math.Max(ptR.Y - 1, 0);
//000293: 
//000294:             if (((ptR.X != r.Location.X) || (ptR.Y != r.Location.Y)) && _roomCells[ptR.X, ptR.Y] == null)
//000295:             {
//000296:                 _roomCells[r.Location.X, r.Location.Y] = null;
//000297:                 _roomCells[ptR.X, ptR.Y] = r;
//000298:                 r.Location = new RoomPoint(ptR.X, ptR.Y);
//000299:             }
//000300:         }
//000301:     }
//000302: }
    IL_0032:  ret
  } // end of method MainWindow::'<.ctor>b__0'

} // end of class AntisocialRobots.MainWindow


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
