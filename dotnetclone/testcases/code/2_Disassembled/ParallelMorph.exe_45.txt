
//  Microsoft (R) .NET Framework IL Disassembler.  Version 4.0.30319.1
//  Copyright (c) Microsoft Corporation.  All rights reserved.



// Metadata version: v4.0.30319
.module extern avifil32.dll
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Windows.Forms
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly extern System.Drawing
{
  .publickeytoken = (B0 3F 5F 7F 11 D5 0A 3A )                         // .?_....:
  .ver 4:0:0:0
}
.assembly extern System.Core
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}
.assembly ParallelMorph
{
  .custom instance void [mscorlib]System.Runtime.CompilerServices.RuntimeCompatibilityAttribute::.ctor() = ( 01 00 01 00 54 02 16 57 72 61 70 4E 6F 6E 45 78   // ....T..WrapNonEx
                                                                                                             63 65 70 74 69 6F 6E 54 68 72 6F 77 73 01 )       // ceptionThrows.
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilationRelaxationsAttribute::.ctor(int32) = ( 01 00 08 00 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyCompanyAttribute::.ctor(string) = ( 01 00 15 4D 69 63 72 6F 73 6F 66 74 20 43 6F 72   // ...Microsoft Cor
                                                                                                70 6F 72 61 74 69 6F 6E 00 00 )                   // poration..

  // --- The following custom attribute is added automatically, do not uncomment -------
  //  .custom instance void [mscorlib]System.Diagnostics.DebuggableAttribute::.ctor(valuetype [mscorlib]System.Diagnostics.DebuggableAttribute/DebuggingModes) = ( 01 00 07 01 00 00 00 00 ) 

  .custom instance void [System.Core]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyTitleAttribute::.ctor(string) = ( 01 00 0E 50 61 72 61 6C 6C 65 6C 20 4D 6F 72 70   // ...Parallel Morp
                                                                                              68 00 00 )                                        // h..
  .custom instance void [mscorlib]System.Reflection.AssemblyDescriptionAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyConfigurationAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Reflection.AssemblyProductAttribute::.ctor(string) = ( 01 00 0E 50 61 72 61 6C 6C 65 6C 20 4D 6F 72 70   // ...Parallel Morp
                                                                                                68 00 00 )                                        // h..
  .custom instance void [mscorlib]System.Reflection.AssemblyCopyrightAttribute::.ctor(string) = ( 01 00 39 43 6F 70 79 72 69 67 68 74 20 C2 A9 20   // ..9Copyright .. 
                                                                                                  4D 69 63 72 6F 73 6F 66 74 20 43 6F 72 70 6F 72   // Microsoft Corpor
                                                                                                  61 74 69 6F 6E 2E 20 20 41 6C 6C 20 72 69 67 68   // ation.  All righ
                                                                                                  74 73 20 72 65 73 65 72 76 65 64 2E 00 00 )       // ts reserved...
  .custom instance void [mscorlib]System.Reflection.AssemblyTrademarkAttribute::.ctor(string) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.ComVisibleAttribute::.ctor(bool) = ( 01 00 00 00 00 ) 
  .custom instance void [mscorlib]System.Runtime.InteropServices.GuidAttribute::.ctor(string) = ( 01 00 24 31 30 31 33 63 65 64 31 2D 30 33 32 36   // ..$1013ced1-0326
                                                                                                  2D 34 33 35 31 2D 62 37 39 39 2D 38 30 66 39 32   // -4351-b799-80f92
                                                                                                  39 35 65 66 33 61 34 00 00 )                      // 95ef3a4..
  .custom instance void [mscorlib]System.Reflection.AssemblyFileVersionAttribute::.ctor(string) = ( 01 00 07 31 2E 30 2E 30 2E 30 00 00 )             // ...1.0.0.0..
  .custom instance void [mscorlib]System.Runtime.Versioning.TargetFrameworkAttribute::.ctor(string) = ( 01 00 1A 2E 4E 45 54 46 72 61 6D 65 77 6F 72 6B   // ....NETFramework
                                                                                                        2C 56 65 72 73 69 6F 6E 3D 76 34 2E 30 01 00 54   // ,Version=v4.0..T
                                                                                                        0E 14 46 72 61 6D 65 77 6F 72 6B 44 69 73 70 6C   // ..FrameworkDispl
                                                                                                        61 79 4E 61 6D 65 10 2E 4E 45 54 20 46 72 61 6D   // ayName..NET Fram
                                                                                                        65 77 6F 72 6B 20 34 )                            // ework 4
  .permissionset reqmin
             = {[mscorlib]System.Security.Permissions.SecurityPermissionAttribute = {property bool 'SkipVerification' = bool(true)}}
  .hash algorithm 0x00008004
  .ver 1:0:0:0
}
.mresource public ParallelMorph.Properties.Resources.resources
{
  // Offset: 0x00000000 Length: 0x000000B4
}
.mresource public ParallelMorph.MainForm.resources
{
  // Offset: 0x000000B8 Length: 0x00014470
}
.mresource public ParallelMorph.EditSettings.resources
{
  // Offset: 0x00014530 Length: 0x000000B4
}
.module ParallelMorph.exe
// MVID: {68B28625-D4A0-453A-92D9-7A1AC0976252}
.custom instance void [mscorlib]System.Security.UnverifiableCodeAttribute::.ctor() = ( 01 00 00 00 ) 
.imagebase 0x00400000
.file alignment 0x00000200
.stackreserve 0x00100000
.subsystem 0x0002       // WINDOWS_GUI
.corflags 0x00000001    //  ILONLY
// Image base: 0x011F0000


// =============== CLASS MEMBERS DECLARATION ===================

.class private abstract auto ansi sealed beforefieldinit ParallelMorph.Program
       extends [mscorlib]System.Object
{
  .method private hidebysig static void  Main() cil managed
  {
    .entrypoint
    .custom instance void [mscorlib]System.STAThreadAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       26 (0x1a)
    .maxstack  8
    .language '{3F5162F8-07C6-11D3-9053-00C04FA302A1}', '{994B45C4-E6E9-11D2-903F-00C04FA302A1}', '{5A869D0B-6611-11D3-BD2A-0000F80849BD}'
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Program.cs' 
//000019:         {
    IL_0000:  nop
//000020:             Application.EnableVisualStyles();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::EnableVisualStyles()
    IL_0006:  nop
//000021:             Application.SetCompatibleTextRenderingDefault(false);
    IL_0007:  ldc.i4.0
    IL_0008:  call       void [System.Windows.Forms]System.Windows.Forms.Application::SetCompatibleTextRenderingDefault(bool)
    IL_000d:  nop
//000022:             Application.Run(new MainForm());
    IL_000e:  newobj     instance void ParallelMorph.MainForm::.ctor()
    IL_0013:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Run(class [System.Windows.Forms]System.Windows.Forms.Form)
    IL_0018:  nop
//000023:         }
    IL_0019:  ret
  } // end of method Program::Main

} // end of class ParallelMorph.Program

.class public auto ansi beforefieldinit ParallelMorph.MainForm
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass2'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public float32 startImageScaleFactor
    .field public valuetype [System.Drawing]System.Drawing.PointF endImageScaleFactor
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass2'::.ctor

    .method public hidebysig instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> 
            '<PrepareUIDataForMorph>b__1'(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> pair) cil managed
    {
      // Code size       268 (0x10c)
      .maxstack  5
      .locals init ([0] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> CS$1$0000,
               [1] valuetype [System.Drawing]System.Drawing.PointF CS$0$0001)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs' 
//000133:                  select Tuple.Create(
      IL_0000:  ldarg.1
      IL_0001:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0006:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_000b:  stloc.1
      IL_000c:  ldloca.s   CS$0$0001
      IL_000e:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_0013:  ldarg.0
      IL_0014:  ldfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
      IL_0019:  mul
      IL_001a:  ldarg.1
      IL_001b:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0020:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0025:  stloc.1
      IL_0026:  ldloca.s   CS$0$0001
      IL_0028:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_002d:  ldarg.0
      IL_002e:  ldfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
      IL_0033:  mul
      IL_0034:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_0039:  ldarg.1
      IL_003a:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_003f:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_0044:  stloc.1
      IL_0045:  ldloca.s   CS$0$0001
      IL_0047:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_004c:  ldarg.0
      IL_004d:  ldfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
      IL_0052:  mul
      IL_0053:  ldarg.1
      IL_0054:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0059:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_005e:  stloc.1
      IL_005f:  ldloca.s   CS$0$0001
      IL_0061:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_0066:  ldarg.0
      IL_0067:  ldfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
      IL_006c:  mul
      IL_006d:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_0072:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_0077:  ldarg.1
      IL_0078:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_007d:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0082:  stloc.1
      IL_0083:  ldloca.s   CS$0$0001
      IL_0085:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_008a:  ldarg.0
      IL_008b:  ldflda     valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.MainForm/'<>c__DisplayClass2'::endImageScaleFactor
      IL_0090:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_0095:  mul
      IL_0096:  ldarg.1
      IL_0097:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_009c:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_00a1:  stloc.1
      IL_00a2:  ldloca.s   CS$0$0001
      IL_00a4:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_00a9:  ldarg.0
      IL_00aa:  ldflda     valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.MainForm/'<>c__DisplayClass2'::endImageScaleFactor
      IL_00af:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_00b4:  mul
      IL_00b5:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_00ba:  ldarg.1
      IL_00bb:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00c0:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_00c5:  stloc.1
      IL_00c6:  ldloca.s   CS$0$0001
      IL_00c8:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_00cd:  ldarg.0
      IL_00ce:  ldflda     valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.MainForm/'<>c__DisplayClass2'::endImageScaleFactor
      IL_00d3:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
      IL_00d8:  mul
      IL_00d9:  ldarg.1
      IL_00da:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00df:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_00e4:  stloc.1
      IL_00e5:  ldloca.s   CS$0$0001
      IL_00e7:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_00ec:  ldarg.0
      IL_00ed:  ldflda     valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.MainForm/'<>c__DisplayClass2'::endImageScaleFactor
      IL_00f2:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
      IL_00f7:  mul
      IL_00f8:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_00fd:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_0102:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<class ParallelMorph.Line,class ParallelMorph.Line>(!!0,
                                                                                                                                                     !!1)
      IL_0107:  stloc.0
      IL_0108:  br.s       IL_010a

//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_010a:  ldloc.0
      IL_010b:  ret
    } // end of method '<>c__DisplayClass2'::'<PrepareUIDataForMorph>b__1'

  } // end of class '<>c__DisplayClass2'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassa'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassf'
           extends [mscorlib]System.Object
    {
      .field public class ParallelMorph.MainForm/'<>c__DisplayClassa' 'CS$<>8__localsb'
      .field public class [System.Drawing]System.Drawing.Bitmap clonedBmp
      .method public hidebysig specialname rtspecialname 
              instance void  .ctor() cil managed
      {
        // Code size       7 (0x7)
        .maxstack  8
        IL_0000:  ldarg.0
        IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
        IL_0006:  ret
      } // end of method '<>c__DisplayClassf'::.ctor

      .method public hidebysig instance void 
              '<btnMorph_Click>b__9'() cil managed
      {
        // Code size       67 (0x43)
        .maxstack  2
        .locals init ([0] class [System.Drawing]System.Drawing.Image oldImage,
                 [1] bool CS$4$0000)
//000189:                         {
        IL_0000:  nop
//000190:                             Image oldImage = pbInProgressMorph.Image;
        IL_0001:  ldarg.0
        IL_0002:  ldfld      class ParallelMorph.MainForm/'<>c__DisplayClassa' ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::'CS$<>8__localsb'
        IL_0007:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
        IL_000c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
        IL_0011:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
        IL_0016:  stloc.0
//000191:                             pbInProgressMorph.Image = clonedBmp;
        IL_0017:  ldarg.0
        IL_0018:  ldfld      class ParallelMorph.MainForm/'<>c__DisplayClassa' ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::'CS$<>8__localsb'
        IL_001d:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
        IL_0022:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
        IL_0027:  ldarg.0
        IL_0028:  ldfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::clonedBmp
        IL_002d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
        IL_0032:  nop
//000192:                             if (oldImage != null) oldImage.Dispose();
        IL_0033:  ldloc.0
        IL_0034:  ldnull
        IL_0035:  ceq
        IL_0037:  stloc.1
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
        IL_0038:  ldloc.1
        IL_0039:  brtrue.s   IL_0042

//000192:                             if (oldImage != null) oldImage.Dispose();
        IL_003b:  ldloc.0
        IL_003c:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
        IL_0041:  nop
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
        IL_0042:  ret
      } // end of method '<>c__DisplayClassf'::'<btnMorph_Click>b__9'

    } // end of class '<>c__DisplayClassf'

    .field public valuetype ParallelMorph.OutputMode outputMode
    .field public string outputPath
    .field public class ParallelMorph.UiSettings settings
    .field public class ParallelMorph.LinePairCollection lines
    .field public class [System.Drawing]System.Drawing.Bitmap startImage
    .field public class [System.Drawing]System.Drawing.Bitmap endImage
    .field public class [System]System.Diagnostics.Stopwatch startTime
    .field public class ParallelMorph.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassa'::.ctor

    .method public hidebysig instance void 
            '<btnMorph_Click>b__6'(class [mscorlib]System.Threading.Tasks.Task t) cil managed
    {
      // Code size       313 (0x139)
      .maxstack  4
      .locals init ([0] class [System.Drawing]System.Drawing.Image oldImage,
               [1] bool CS$4$0000,
               [2] object[] CS$0$0001,
               [3] valuetype [mscorlib]System.TimeSpan CS$0$0002)
//000202:             {
      IL_0000:  nop
//000203:                 _morpher = null;
      IL_0001:  ldarg.0
      IL_0002:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0007:  ldnull
      IL_0008:  stfld      class ParallelMorph.ComputeMorph ParallelMorph.MainForm::_morpher
//000204:                 btnMorph.Enabled = true;
      IL_000d:  ldarg.0
      IL_000e:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0013:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
      IL_0018:  ldc.i4.1
      IL_0019:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_001e:  nop
//000205:                 btnCancel.Visible = false;
      IL_001f:  ldarg.0
      IL_0020:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0025:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
      IL_002a:  ldc.i4.0
      IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
      IL_0030:  nop
//000206:                 pbMorphStatus.Visible = false;
      IL_0031:  ldarg.0
      IL_0032:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0037:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
      IL_003c:  ldc.i4.0
      IL_003d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
      IL_0042:  nop
//000207:                 splitContainer1.Visible = true;
      IL_0043:  ldarg.0
      IL_0044:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0049:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
      IL_004e:  ldc.i4.1
      IL_004f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
      IL_0054:  nop
//000208:                 menuStrip1.Enabled = true;
      IL_0055:  ldarg.0
      IL_0056:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_005b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
      IL_0060:  ldc.i4.1
      IL_0061:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
      IL_0066:  nop
//000209:                 pbInProgressMorph.Visible = false;
      IL_0067:  ldarg.0
      IL_0068:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_006d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
      IL_0072:  ldc.i4.0
      IL_0073:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
      IL_0078:  nop
//000210:                 if (pbInProgressMorph.Image != null)
      IL_0079:  ldarg.0
      IL_007a:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_007f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
      IL_0084:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
      IL_0089:  ldnull
      IL_008a:  ceq
      IL_008c:  stloc.1
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_008d:  ldloc.1
      IL_008e:  brtrue.s   IL_00bc

//000211:                 {
      IL_0090:  nop
//000212:                     Image oldImage = pbInProgressMorph.Image;
      IL_0091:  ldarg.0
      IL_0092:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0097:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
      IL_009c:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
      IL_00a1:  stloc.0
//000213:                     pbInProgressMorph.Image = null;
      IL_00a2:  ldarg.0
      IL_00a3:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_00a8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
      IL_00ad:  ldnull
      IL_00ae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_00b3:  nop
//000214:                     oldImage.Dispose();
      IL_00b4:  ldloc.0
      IL_00b5:  callvirt   instance void [System.Drawing]System.Drawing.Image::Dispose()
      IL_00ba:  nop
//000215:                 }
      IL_00bb:  nop
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
      IL_00bc:  ldarg.0
      IL_00bd:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_00c2:  ldc.i4.4
      IL_00c3:  newarr     [mscorlib]System.Object
      IL_00c8:  stloc.2
      IL_00c9:  ldloc.2
      IL_00ca:  ldc.i4.0
      IL_00cb:  ldstr      "Parallel Morph - "
      IL_00d0:  stelem.ref
      IL_00d1:  ldloc.2
      IL_00d2:  ldc.i4.1
      IL_00d3:  ldarg.1
      IL_00d4:  callvirt   instance valuetype [mscorlib]System.Threading.Tasks.TaskStatus [mscorlib]System.Threading.Tasks.Task::get_Status()
      IL_00d9:  box        [mscorlib]System.Threading.Tasks.TaskStatus
      IL_00de:  stelem.ref
      IL_00df:  ldloc.2
      IL_00e0:  ldc.i4.2
      IL_00e1:  ldstr      " - "
      IL_00e6:  stelem.ref
      IL_00e7:  ldloc.2
      IL_00e8:  ldc.i4.3
      IL_00e9:  ldarg.0
      IL_00ea:  ldfld      class [System]System.Diagnostics.Stopwatch ParallelMorph.MainForm/'<>c__DisplayClassa'::startTime
      IL_00ef:  callvirt   instance valuetype [mscorlib]System.TimeSpan [System]System.Diagnostics.Stopwatch::get_Elapsed()
      IL_00f4:  stloc.3
      IL_00f5:  ldloca.s   CS$0$0002
      IL_00f7:  constrained. [mscorlib]System.TimeSpan
      IL_00fd:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0102:  stelem.ref
      IL_0103:  ldloc.2
      IL_0104:  call       string [mscorlib]System.String::Concat(object[])
      IL_0109:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
      IL_010e:  nop
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
      IL_010f:  ldarg.1
      IL_0110:  callvirt   instance bool [mscorlib]System.Threading.Tasks.Task::get_IsFaulted()
      IL_0115:  ldc.i4.0
      IL_0116:  ceq
      IL_0118:  stloc.1
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0119:  ldloc.1
      IL_011a:  brtrue.s   IL_0138

//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
      IL_011c:  ldarg.0
      IL_011d:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0122:  ldarg.1
      IL_0123:  callvirt   instance class [mscorlib]System.AggregateException [mscorlib]System.Threading.Tasks.Task::get_Exception()
      IL_0128:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_012d:  ldstr      "Morph Error"
      IL_0132:  call       valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.MessageBox::Show(class [System.Windows.Forms]System.Windows.Forms.IWin32Window,
                                                                                                                                                         string,
                                                                                                                                                         string)
      IL_0137:  pop
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0138:  ret
    } // end of method '<>c__DisplayClassa'::'<btnMorph_Click>b__6'

    .method public hidebysig instance void 
            '<btnMorph_Click>b__7'() cil managed
    {
      // Code size       177 (0xb1)
      .maxstack  6
      .locals init ([0] class ParallelMorph.IImageWriter tempImageWriter,
               [1] class ParallelMorph.PassthroughImageWriter imageWriter,
               [2] class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap> 'CS$<>9__CachedAnonymousMethodDelegatee',
               [3] class ParallelMorph.IImageWriter CS$0$0000,
               [4] class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] CS$0$0001,
               [5] bool CS$4$0002)
      IL_0000:  ldnull
      IL_0001:  stloc.2
//000178:             {
      IL_0002:  nop
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
      IL_0003:  ldarg.0
      IL_0004:  ldfld      valuetype ParallelMorph.OutputMode ParallelMorph.MainForm/'<>c__DisplayClassa'::outputMode
      IL_0009:  brfalse.s  IL_001f

      IL_000b:  ldarg.0
      IL_000c:  ldfld      string ParallelMorph.MainForm/'<>c__DisplayClassa'::outputPath
      IL_0011:  ldstr      "MorphFrame"
      IL_0016:  newobj     instance void ParallelMorph.JpgImageWriter::.ctor(string,
                                                                             string)
      IL_001b:  stloc.3
      IL_001c:  ldloc.3
      IL_001d:  br.s       IL_004b

      IL_001f:  ldarg.0
      IL_0020:  ldfld      string ParallelMorph.MainForm/'<>c__DisplayClassa'::outputPath
      IL_0025:  ldarg.0
      IL_0026:  ldfld      class ParallelMorph.UiSettings ParallelMorph.MainForm/'<>c__DisplayClassa'::settings
      IL_002b:  callvirt   instance int32 ParallelMorph.UiSettings::get_FramesPerSecond()
      IL_0030:  ldarg.0
      IL_0031:  ldfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::startImage
      IL_0036:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
      IL_003b:  ldarg.0
      IL_003c:  ldfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::startImage
      IL_0041:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
      IL_0046:  newobj     instance void ParallelMorph.AviImageWriter::.ctor(string,
                                                                             int32,
                                                                             int32,
                                                                             int32)
      IL_004b:  stloc.0
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
      .try
      {
        IL_004c:  nop
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
        IL_004d:  ldloc.0
        IL_004e:  ldc.i4.1
        IL_004f:  newarr     class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>
        IL_0054:  stloc.s    CS$0$0001
        IL_0056:  ldloc.s    CS$0$0001
        IL_0058:  ldc.i4.0
        IL_0059:  ldloc.2
        IL_005a:  brtrue.s   IL_006b

        IL_005c:  ldarg.0
        IL_005d:  ldftn      instance void ParallelMorph.MainForm/'<>c__DisplayClassa'::'<btnMorph_Click>b__8'(class [System.Drawing]System.Drawing.Bitmap)
        IL_0063:  newobj     instance void class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>::.ctor(object,
                                                                                                                               native int)
        IL_0068:  stloc.2
        IL_0069:  br.s       IL_006b

        IL_006b:  ldloc.2
        IL_006c:  stelem.ref
        IL_006d:  ldloc.s    CS$0$0001
        IL_006f:  newobj     instance void ParallelMorph.PassthroughImageWriter::.ctor(class ParallelMorph.IImageWriter,
                                                                                       class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[])
        IL_0074:  stloc.1
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
        IL_0075:  ldarg.0
        IL_0076:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
        IL_007b:  ldfld      class ParallelMorph.ComputeMorph ParallelMorph.MainForm::_morpher
        IL_0080:  ldloc.1
        IL_0081:  ldarg.0
        IL_0082:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm/'<>c__DisplayClassa'::lines
        IL_0087:  ldarg.0
        IL_0088:  ldfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::startImage
        IL_008d:  ldarg.0
        IL_008e:  ldfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::endImage
        IL_0093:  callvirt   instance void ParallelMorph.ComputeMorph::Render(class ParallelMorph.IImageWriter,
                                                                              class ParallelMorph.LinePairCollection,
                                                                              class [System.Drawing]System.Drawing.Bitmap,
                                                                              class [System.Drawing]System.Drawing.Bitmap)
        IL_0098:  nop
//000198:                 }
        IL_0099:  nop
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
        IL_009a:  leave.s    IL_00ae

      }  // end .try
      finally
      {
        IL_009c:  ldloc.0
        IL_009d:  ldnull
        IL_009e:  ceq
        IL_00a0:  stloc.s    CS$4$0002
        IL_00a2:  ldloc.s    CS$4$0002
        IL_00a4:  brtrue.s   IL_00ad

        IL_00a6:  ldloc.0
        IL_00a7:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_00ac:  nop
        IL_00ad:  endfinally
      }  // end handler
      IL_00ae:  nop
//000201:             }, cancellationToken).ContinueWith(t =>
      IL_00af:  nop
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_00b0:  ret
    } // end of method '<>c__DisplayClassa'::'<btnMorph_Click>b__7'

    .method private hidebysig instance void 
            '<btnMorph_Click>b__8'(class [System.Drawing]System.Drawing.Bitmap bmp) cil managed
    {
      // Code size       57 (0x39)
      .maxstack  4
      .locals init ([0] class ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf' 'CS$<>8__locals10')
      IL_0000:  newobj     instance void ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::.ctor()
      IL_0005:  stloc.0
      IL_0006:  ldloc.0
      IL_0007:  ldarg.0
      IL_0008:  stfld      class ParallelMorph.MainForm/'<>c__DisplayClassa' ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::'CS$<>8__localsb'
//000186:                     {
      IL_000d:  nop
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
      IL_000e:  ldloc.0
      IL_000f:  ldarg.1
      IL_0010:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image)
      IL_0015:  stfld      class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::clonedBmp
//000188:                         _uiThread.StartNew(() =>
      IL_001a:  ldarg.0
      IL_001b:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
      IL_0020:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory ParallelMorph.MainForm::_uiThread
      IL_0025:  ldloc.0
      IL_0026:  ldftn      instance void ParallelMorph.MainForm/'<>c__DisplayClassa'/'<>c__DisplayClassf'::'<btnMorph_Click>b__9'()
      IL_002c:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                        native int)
      IL_0031:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action)
      IL_0036:  pop
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
      IL_0037:  nop
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0038:  ret
    } // end of method '<>c__DisplayClassa'::'<btnMorph_Click>b__8'

  } // end of class '<>c__DisplayClassa'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassc'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class [System]System.ComponentModel.ProgressChangedEventArgs pe
    .field public class ParallelMorph.MainForm '<>4__this'
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassc'::.ctor

    .method public hidebysig instance int32 
            '<btnMorph_Click>b__5'() cil managed
    {
      // Code size       36 (0x24)
      .maxstack  3
      .locals init ([0] int32 CS$1$0000,
               [1] int32 CS$0$0001)
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
      IL_0000:  ldarg.0
      IL_0001:  ldfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassc'::'<>4__this'
      IL_0006:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
      IL_000b:  ldarg.0
      IL_000c:  ldfld      class [System]System.ComponentModel.ProgressChangedEventArgs ParallelMorph.MainForm/'<>c__DisplayClassc'::pe
      IL_0011:  callvirt   instance int32 [System]System.ComponentModel.ProgressChangedEventArgs::get_ProgressPercentage()
      IL_0016:  dup
      IL_0017:  stloc.1
      IL_0018:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ProgressBar::set_Value(int32)
      IL_001d:  nop
      IL_001e:  ldloc.1
      IL_001f:  stloc.0
      IL_0020:  br.s       IL_0022

//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0022:  ldloc.0
      IL_0023:  ret
    } // end of method '<>c__DisplayClassc'::'<btnMorph_Click>b__5'

  } // end of class '<>c__DisplayClassc'

  .field private class [System]System.ComponentModel.IContainer components
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnMorph
  .field private class [System.Windows.Forms]System.Windows.Forms.ColumnHeader columnHeader1
  .field private class [System.Windows.Forms]System.Windows.Forms.ColumnHeader columnHeader2
  .field private class [System.Windows.Forms]System.Windows.Forms.ProgressBar pbMorphStatus
  .field private class [System.Windows.Forms]System.Windows.Forms.SplitContainer splitContainer1
  .field private class [System.Windows.Forms]System.Windows.Forms.MenuStrip menuStrip1
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem newToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem openToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem saveToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator toolStripSeparator2
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem toolsToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem optionsToolStripMenuItem
  .field private class ParallelMorph.LinedPictureBox pbStartImage
  .field private class ParallelMorph.LinedPictureBox pbEndImage
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem sizeModeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem autoSizeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem zoomToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.Button btnCancel
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolTip toolTip1
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem processingModeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem sequentialProcessingModeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem parallelProcessingModeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem outputToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem aviOutputToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem imagesOutputToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem outputSizeToolStripMenuItem
  .field private class [System.Windows.Forms]System.Windows.Forms.PictureBox pbInProgressMorph
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox outputSizeToolStripTextBox
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator toolStripMenuItem2
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator toolStripMenuItem1
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator toolStripMenuItem3
  .field private class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem morphInfoToolStripMenuItem
  .field private class ParallelMorph.UiSettings _morphSettings
  .field private class ParallelMorph.LinePairCollection _lines
  .field private int32 _currentLineImageNumber
  .field private int32 _currentLineEnd
  .field private bool _lineCreationInProcess
  .field private class [mscorlib]System.Threading.Tasks.TaskFactory _uiThread
  .field private class ParallelMorph.ComputeMorph _morpher
  .field private class [mscorlib]System.Threading.CancellationTokenSource _currentCancellationSource
  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.Designer.cs' 
//000015:         {
    IL_0000:  nop
//000016:             if (disposing && (components != null))
    IL_0001:  ldarg.1
    IL_0002:  brfalse.s  IL_000f

    IL_0004:  ldarg.0
    IL_0005:  ldfld      class [System]System.ComponentModel.IContainer ParallelMorph.MainForm::components
    IL_000a:  ldnull
    IL_000b:  ceq
    IL_000d:  br.s       IL_0010

    IL_000f:  ldc.i4.1
    IL_0010:  stloc.0
//000017:             {
//000018:                 components.Dispose();
//000019:             }
//000020:             base.Dispose(disposing);
//000021:         }
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
//000031:             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
//000032:             this.pbMorphStatus = new System.Windows.Forms.ProgressBar();
//000033:             this.btnMorph = new System.Windows.Forms.Button();
//000034:             this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
//000035:             this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
//000036:             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
//000037:             this.menuStrip1 = new System.Windows.Forms.MenuStrip();
//000038:             this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000039:             this.newToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000040:             this.openToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000041:             this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000042:             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
//000043:             this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000044:             this.toolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000045:             this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000046:             this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
//000047:             this.outputSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000048:             this.outputSizeToolStripTextBox = new System.Windows.Forms.ToolStripTextBox();
//000049:             this.outputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000050:             this.imagesOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000051:             this.aviOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000052:             this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
//000053:             this.sizeModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000054:             this.autoSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000055:             this.zoomToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000056:             this.processingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000057:             this.sequentialProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000058:             this.parallelProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000059:             this.btnCancel = new System.Windows.Forms.Button();
//000060:             this.toolTip1 = new System.Windows.Forms.ToolTip();
//000061:             this.pbInProgressMorph = new System.Windows.Forms.PictureBox();
//000062:             this.morphInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
//000063:             this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripSeparator();
//000064:             this.pbStartImage = new ParallelMorph.LinedPictureBox();
//000065:             this.pbEndImage = new ParallelMorph.LinedPictureBox();
//000066:             this.splitContainer1.Panel1.SuspendLayout();
//000067:             this.splitContainer1.Panel2.SuspendLayout();
//000068:             this.splitContainer1.SuspendLayout();
//000069:             this.menuStrip1.SuspendLayout();
//000070:             this.SuspendLayout();
//000071:             // 
//000072:             // pbMorphStatus
//000073:             // 
//000074:             this.pbMorphStatus.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
//000075:                         | System.Windows.Forms.AnchorStyles.Right)));
//000076:             this.pbMorphStatus.Location = new System.Drawing.Point(12, 350);
//000077:             this.pbMorphStatus.Name = "pbMorphStatus";
//000078:             this.pbMorphStatus.Size = new System.Drawing.Size(492, 23);
//000079:             this.pbMorphStatus.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
//000080:             this.pbMorphStatus.TabIndex = 8;
//000081:             this.pbMorphStatus.Visible = false;
//000082:             // 
//000083:             // btnMorph
//000084:             // 
//000085:             this.btnMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
//000086:             this.btnMorph.Enabled = false;
//000087:             this.btnMorph.Location = new System.Drawing.Point(510, 350);
//000088:             this.btnMorph.Name = "btnMorph";
//000089:             this.btnMorph.Size = new System.Drawing.Size(127, 23);
//000090:             this.btnMorph.TabIndex = 4;
//000091:             this.btnMorph.Text = "Morph";
//000092:             this.btnMorph.UseVisualStyleBackColor = true;
//000093:             this.btnMorph.Click += new System.EventHandler(this.btnMorph_Click);
//000094:             // 
//000095:             // splitContainer1
//000096:             // 
//000097:             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000098:                         | System.Windows.Forms.AnchorStyles.Left)
//000099:                         | System.Windows.Forms.AnchorStyles.Right)));
//000100:             this.splitContainer1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
//000101:             this.splitContainer1.Location = new System.Drawing.Point(12, 27);
//000102:             this.splitContainer1.Name = "splitContainer1";
//000103:             // 
//000104:             // splitContainer1.Panel1
//000105:             // 
//000106:             this.splitContainer1.Panel1.AutoScroll = true;
//000107:             this.splitContainer1.Panel1.Controls.Add(this.pbStartImage);
//000108:             this.splitContainer1.Panel1.DoubleClick += new System.EventHandler(this.splitContainer1_Panel1_DoubleClick);
//000109:             // 
//000110:             // splitContainer1.Panel2
//000111:             // 
//000112:             this.splitContainer1.Panel2.AutoScroll = true;
//000113:             this.splitContainer1.Panel2.Controls.Add(this.pbEndImage);
//000114:             this.splitContainer1.Panel2.DoubleClick += new System.EventHandler(this.splitContainer1_Panel2_DoubleClick);
//000115:             this.splitContainer1.Size = new System.Drawing.Size(625, 317);
//000116:             this.splitContainer1.SplitterDistance = 312;
//000117:             this.splitContainer1.TabIndex = 9;
//000118:             // 
//000119:             // menuStrip1
//000120:             // 
//000121:             this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000122:             this.fileToolStripMenuItem,
//000123:             this.toolsToolStripMenuItem});
//000124:             this.menuStrip1.Location = new System.Drawing.Point(0, 0);
//000125:             this.menuStrip1.Name = "menuStrip1";
//000126:             this.menuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.Professional;
//000127:             this.menuStrip1.Size = new System.Drawing.Size(649, 24);
//000128:             this.menuStrip1.TabIndex = 10;
//000129:             this.menuStrip1.Text = "menuStrip1";
//000130:             // 
//000131:             // fileToolStripMenuItem
//000132:             // 
//000133:             this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000134:             this.newToolStripMenuItem,
//000135:             this.openToolStripMenuItem,
//000136:             this.saveToolStripMenuItem,
//000137:             this.toolStripSeparator2,
//000138:             this.exitToolStripMenuItem});
//000139:             this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
//000140:             this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
//000141:             this.fileToolStripMenuItem.Text = "&File";
//000142:             // 
//000143:             // newToolStripMenuItem
//000144:             // 
//000145:             this.newToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("newToolStripMenuItem.Image")));
//000146:             this.newToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
//000147:             this.newToolStripMenuItem.Name = "newToolStripMenuItem";
//000148:             this.newToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.N)));
//000149:             this.newToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
//000150:             this.newToolStripMenuItem.Text = "&New";
//000151:             this.newToolStripMenuItem.Click += new System.EventHandler(this.newToolStripMenuItem_Click);
//000152:             // 
//000153:             // openToolStripMenuItem
//000154:             // 
//000155:             this.openToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("openToolStripMenuItem.Image")));
//000156:             this.openToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
//000157:             this.openToolStripMenuItem.Name = "openToolStripMenuItem";
//000158:             this.openToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
//000159:             this.openToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
//000160:             this.openToolStripMenuItem.Text = "&Open";
//000161:             this.openToolStripMenuItem.Click += new System.EventHandler(this.openToolStripMenuItem_Click);
//000162:             // 
//000163:             // saveToolStripMenuItem
//000164:             // 
//000165:             this.saveToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("saveToolStripMenuItem.Image")));
//000166:             this.saveToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
//000167:             this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
//000168:             this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
//000169:             this.saveToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
//000170:             this.saveToolStripMenuItem.Text = "&Save";
//000171:             this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
//000172:             // 
//000173:             // toolStripSeparator2
//000174:             // 
//000175:             this.toolStripSeparator2.Name = "toolStripSeparator2";
//000176:             this.toolStripSeparator2.Size = new System.Drawing.Size(143, 6);
//000177:             // 
//000178:             // exitToolStripMenuItem
//000179:             // 
//000180:             this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
//000181:             this.exitToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
//000182:             this.exitToolStripMenuItem.Text = "E&xit";
//000183:             this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
//000184:             // 
//000185:             // toolsToolStripMenuItem
//000186:             // 
//000187:             this.toolsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000188:             this.optionsToolStripMenuItem,
//000189:             this.toolStripMenuItem2,
//000190:             this.outputSizeToolStripMenuItem,
//000191:             this.outputToolStripMenuItem,
//000192:             this.toolStripMenuItem1,
//000193:             this.sizeModeToolStripMenuItem,
//000194:             this.processingModeToolStripMenuItem,
//000195:             this.toolStripMenuItem3,
//000196:             this.morphInfoToolStripMenuItem});
//000197:             this.toolsToolStripMenuItem.Name = "toolsToolStripMenuItem";
//000198:             this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48, 20);
//000199:             this.toolsToolStripMenuItem.Text = "&Tools";
//000200:             // 
//000201:             // optionsToolStripMenuItem
//000202:             // 
//000203:             this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
//000204:             this.optionsToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000205:             this.optionsToolStripMenuItem.Text = "&Options...";
//000206:             this.optionsToolStripMenuItem.Click += new System.EventHandler(this.optionsToolStripMenuItem_Click);
//000207:             // 
//000208:             // toolStripMenuItem2
//000209:             // 
//000210:             this.toolStripMenuItem2.Name = "toolStripMenuItem2";
//000211:             this.toolStripMenuItem2.Size = new System.Drawing.Size(162, 6);
//000212:             // 
//000213:             // outputSizeToolStripMenuItem
//000214:             // 
//000215:             this.outputSizeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000216:             this.outputSizeToolStripTextBox});
//000217:             this.outputSizeToolStripMenuItem.Name = "outputSizeToolStripMenuItem";
//000218:             this.outputSizeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000219:             this.outputSizeToolStripMenuItem.Text = "Output Size";
//000220:             // 
//000221:             // outputSizeToolStripTextBox
//000222:             // 
//000223:             this.outputSizeToolStripTextBox.MaxLength = 3;
//000224:             this.outputSizeToolStripTextBox.Name = "outputSizeToolStripTextBox";
//000225:             this.outputSizeToolStripTextBox.Size = new System.Drawing.Size(100, 23);
//000226:             this.outputSizeToolStripTextBox.Text = "100";
//000227:             // 
//000228:             // outputToolStripMenuItem
//000229:             // 
//000230:             this.outputToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000231:             this.imagesOutputToolStripMenuItem,
//000232:             this.aviOutputToolStripMenuItem});
//000233:             this.outputToolStripMenuItem.Name = "outputToolStripMenuItem";
//000234:             this.outputToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000235:             this.outputToolStripMenuItem.Text = "Output Type";
//000236:             // 
//000237:             // imagesOutputToolStripMenuItem
//000238:             // 
//000239:             this.imagesOutputToolStripMenuItem.Checked = true;
//000240:             this.imagesOutputToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
//000241:             this.imagesOutputToolStripMenuItem.Name = "imagesOutputToolStripMenuItem";
//000242:             this.imagesOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
//000243:             this.imagesOutputToolStripMenuItem.Text = "Images";
//000244:             this.imagesOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
//000245:             // 
//000246:             // aviOutputToolStripMenuItem
//000247:             // 
//000248:             this.aviOutputToolStripMenuItem.Name = "aviOutputToolStripMenuItem";
//000249:             this.aviOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
//000250:             this.aviOutputToolStripMenuItem.Text = "AVI";
//000251:             this.aviOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
//000252:             // 
//000253:             // toolStripMenuItem1
//000254:             // 
//000255:             this.toolStripMenuItem1.Name = "toolStripMenuItem1";
//000256:             this.toolStripMenuItem1.Size = new System.Drawing.Size(162, 6);
//000257:             // 
//000258:             // sizeModeToolStripMenuItem
//000259:             // 
//000260:             this.sizeModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000261:             this.autoSizeToolStripMenuItem,
//000262:             this.zoomToolStripMenuItem});
//000263:             this.sizeModeToolStripMenuItem.Name = "sizeModeToolStripMenuItem";
//000264:             this.sizeModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000265:             this.sizeModeToolStripMenuItem.Text = "View Mode";
//000266:             // 
//000267:             // autoSizeToolStripMenuItem
//000268:             // 
//000269:             this.autoSizeToolStripMenuItem.Name = "autoSizeToolStripMenuItem";
//000270:             this.autoSizeToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
//000271:             this.autoSizeToolStripMenuItem.Text = "AutoSize";
//000272:             this.autoSizeToolStripMenuItem.Click += new System.EventHandler(this.autoSizeToolStripMenuItem_Click);
//000273:             // 
//000274:             // zoomToolStripMenuItem
//000275:             // 
//000276:             this.zoomToolStripMenuItem.Checked = true;
//000277:             this.zoomToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
//000278:             this.zoomToolStripMenuItem.Name = "zoomToolStripMenuItem";
//000279:             this.zoomToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
//000280:             this.zoomToolStripMenuItem.Text = "Zoom";
//000281:             this.zoomToolStripMenuItem.Click += new System.EventHandler(this.zoomToolStripMenuItem_Click);
//000282:             // 
//000283:             // processingModeToolStripMenuItem
//000284:             // 
//000285:             this.processingModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
//000286:             this.sequentialProcessingModeToolStripMenuItem,
//000287:             this.parallelProcessingModeToolStripMenuItem});
//000288:             this.processingModeToolStripMenuItem.Name = "processingModeToolStripMenuItem";
//000289:             this.processingModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000290:             this.processingModeToolStripMenuItem.Text = "Processing Mode";
//000291:             // 
//000292:             // sequentialProcessingModeToolStripMenuItem
//000293:             // 
//000294:             this.sequentialProcessingModeToolStripMenuItem.Checked = true;
//000295:             this.sequentialProcessingModeToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
//000296:             this.sequentialProcessingModeToolStripMenuItem.Name = "sequentialProcessingModeToolStripMenuItem";
//000297:             this.sequentialProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
//000298:             this.sequentialProcessingModeToolStripMenuItem.Text = "Sequential";
//000299:             this.sequentialProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
//000300:             // 
//000301:             // parallelProcessingModeToolStripMenuItem
//000302:             // 
//000303:             this.parallelProcessingModeToolStripMenuItem.Name = "parallelProcessingModeToolStripMenuItem";
//000304:             this.parallelProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
//000305:             this.parallelProcessingModeToolStripMenuItem.Text = "Parallel";
//000306:             this.parallelProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
//000307:             // 
//000308:             // btnCancel
//000309:             // 
//000310:             this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
//000311:             this.btnCancel.Location = new System.Drawing.Point(509, 350);
//000312:             this.btnCancel.Name = "btnCancel";
//000313:             this.btnCancel.Size = new System.Drawing.Size(127, 23);
//000314:             this.btnCancel.TabIndex = 11;
//000315:             this.btnCancel.Text = "Cancel";
//000316:             this.btnCancel.UseVisualStyleBackColor = true;
//000317:             this.btnCancel.Visible = false;
//000318:             this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
//000319:             // 
//000320:             // pbInProgressMorph
//000321:             // 
//000322:             this.pbInProgressMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
//000323:                         | System.Windows.Forms.AnchorStyles.Left)
//000324:                         | System.Windows.Forms.AnchorStyles.Right)));
//000325:             this.pbInProgressMorph.BackColor = System.Drawing.SystemColors.ControlLightLight;
//000326:             this.pbInProgressMorph.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
//000327:             this.pbInProgressMorph.Location = new System.Drawing.Point(12, 27);
//000328:             this.pbInProgressMorph.Name = "pbInProgressMorph";
//000329:             this.pbInProgressMorph.Size = new System.Drawing.Size(625, 317);
//000330:             this.pbInProgressMorph.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
//000331:             this.pbInProgressMorph.TabIndex = 12;
//000332:             this.pbInProgressMorph.TabStop = false;
//000333:             this.pbInProgressMorph.Visible = false;
//000334:             // 
//000335:             // morphInfoToolStripMenuItem
//000336:             // 
//000337:             this.morphInfoToolStripMenuItem.Name = "morphInfoToolStripMenuItem";
//000338:             this.morphInfoToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
//000339:             this.morphInfoToolStripMenuItem.Text = "Morph Info...";
//000340:             this.morphInfoToolStripMenuItem.Click += new System.EventHandler(this.morphInfoToolStripMenuItem_Click);
//000341:             // 
//000342:             // toolStripMenuItem3
//000343:             // 
//000344:             this.toolStripMenuItem3.Name = "toolStripMenuItem3";
//000345:             this.toolStripMenuItem3.Size = new System.Drawing.Size(162, 6);
//000346:             // 
//000347:             // pbStartImage
//000348:             // 
//000349:             this.pbStartImage.ImageNumber = 0;
//000350:             this.pbStartImage.LinePairs = null;
//000351:             this.pbStartImage.Location = new System.Drawing.Point(0, 0);
//000352:             this.pbStartImage.Name = "pbStartImage";
//000353:             this.pbStartImage.Size = new System.Drawing.Size(310, 315);
//000354:             this.pbStartImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
//000355:             this.pbStartImage.TabIndex = 0;
//000356:             this.pbStartImage.TabStop = false;
//000357:             this.pbStartImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
//000358:             this.pbStartImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
//000359:             this.pbStartImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
//000360:             this.pbStartImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
//000361:             // 
//000362:             // pbEndImage
//000363:             // 
//000364:             this.pbEndImage.ImageNumber = 0;
//000365:             this.pbEndImage.LinePairs = null;
//000366:             this.pbEndImage.Location = new System.Drawing.Point(0, 0);
//000367:             this.pbEndImage.Name = "pbEndImage";
//000368:             this.pbEndImage.Size = new System.Drawing.Size(307, 315);
//000369:             this.pbEndImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
//000370:             this.pbEndImage.TabIndex = 0;
//000371:             this.pbEndImage.TabStop = false;
//000372:             this.pbEndImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
//000373:             this.pbEndImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
//000374:             this.pbEndImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
//000375:             this.pbEndImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
//000376:             // 
//000377:             // MainForm
//000378:             // 
//000379:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
//000380:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
//000381:             this.ClientSize = new System.Drawing.Size(649, 385);
//000382:             this.Controls.Add(this.pbInProgressMorph);
//000383:             this.Controls.Add(this.btnCancel);
//000384:             this.Controls.Add(this.splitContainer1);
//000385:             this.Controls.Add(this.btnMorph);
//000386:             this.Controls.Add(this.pbMorphStatus);
//000387:             this.Controls.Add(this.menuStrip1);
//000388:             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
//000389:             this.KeyPreview = true;
//000390:             this.MainMenuStrip = this.menuStrip1;
//000391:             this.Name = "MainForm";
//000392:             this.Text = "Parallel Morph";
//000393:             this.Load += new System.EventHandler(this.Form1_Load);
//000394:             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.frmMainForm_KeyDown);
//000395:             this.splitContainer1.Panel1.ResumeLayout(false);
//000396:             this.splitContainer1.Panel1.PerformLayout();
//000397:             this.splitContainer1.Panel2.ResumeLayout(false);
//000398:             this.splitContainer1.Panel2.PerformLayout();
//000399:             this.splitContainer1.ResumeLayout(false);
//000400:             this.menuStrip1.ResumeLayout(false);
//000401:             this.menuStrip1.PerformLayout();
//000402:             this.ResumeLayout(false);
//000403:             this.PerformLayout();
//000404: 
//000405:         }
//000406: 
//000407:         #endregion
//000408: 
//000409:         private System.Windows.Forms.Button btnMorph;
//000410:         private System.Windows.Forms.ColumnHeader columnHeader1;
//000411:         private System.Windows.Forms.ColumnHeader columnHeader2;
//000412:         private System.Windows.Forms.ProgressBar pbMorphStatus;
//000413:         private System.Windows.Forms.SplitContainer splitContainer1;
//000414:         private System.Windows.Forms.MenuStrip menuStrip1;
//000415:         private System.Windows.Forms.ToolStripMenuItem fileToolStripMenuItem;
//000416:         private System.Windows.Forms.ToolStripMenuItem newToolStripMenuItem;
//000417:         private System.Windows.Forms.ToolStripMenuItem openToolStripMenuItem;
//000418:         private System.Windows.Forms.ToolStripMenuItem saveToolStripMenuItem;
//000419:         private System.Windows.Forms.ToolStripSeparator toolStripSeparator2;
//000420:         private System.Windows.Forms.ToolStripMenuItem exitToolStripMenuItem;
//000421:         private System.Windows.Forms.ToolStripMenuItem toolsToolStripMenuItem;
//000422:         private System.Windows.Forms.ToolStripMenuItem optionsToolStripMenuItem;
//000423:         private ParallelMorph.LinedPictureBox pbStartImage;
//000424:         private ParallelMorph.LinedPictureBox pbEndImage;
//000425:         private System.Windows.Forms.ToolStripMenuItem sizeModeToolStripMenuItem;
//000426:         private System.Windows.Forms.ToolStripMenuItem autoSizeToolStripMenuItem;
//000427:         private System.Windows.Forms.ToolStripMenuItem zoomToolStripMenuItem;
//000428:         private System.Windows.Forms.Button btnCancel;
//000429:         private System.Windows.Forms.ToolTip toolTip1;
//000430:         private System.Windows.Forms.ToolStripMenuItem processingModeToolStripMenuItem;
//000431:         private System.Windows.Forms.ToolStripMenuItem sequentialProcessingModeToolStripMenuItem;
//000432:         private System.Windows.Forms.ToolStripMenuItem parallelProcessingModeToolStripMenuItem;
//000433:         private System.Windows.Forms.ToolStripMenuItem outputToolStripMenuItem;
//000434:         private System.Windows.Forms.ToolStripMenuItem aviOutputToolStripMenuItem;
//000435:         private System.Windows.Forms.ToolStripMenuItem imagesOutputToolStripMenuItem;
//000436:         private System.Windows.Forms.ToolStripMenuItem outputSizeToolStripMenuItem;
//000437:         private System.Windows.Forms.PictureBox pbInProgressMorph;
//000438:         private System.Windows.Forms.ToolStripTextBox outputSizeToolStripTextBox;
//000439:         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem2;
//000440:         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem1;
//000441:         private System.Windows.Forms.ToolStripSeparator toolStripMenuItem3;
//000442:         private System.Windows.Forms.ToolStripMenuItem morphInfoToolStripMenuItem;
//000443:     }
//000444: }
//000445: 
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_0022

//000017:             {
    IL_0014:  nop
//000018:                 components.Dispose();
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class [System]System.ComponentModel.IContainer ParallelMorph.MainForm::components
    IL_001b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
    IL_0020:  nop
//000019:             }
    IL_0021:  nop
//000020:             base.Dispose(disposing);
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_0029:  nop
//000021:         }
    IL_002a:  ret
  } // end of method MainForm::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       4459 (0x116b)
    .maxstack  4
    .locals init ([0] class [System]System.ComponentModel.ComponentResourceManager resources,
             [1] class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[] CS$0$0000)
//000022: 
//000023:         #region Windows Form Designer generated code
//000024: 
//000025:         /// <summary>
//000026:         /// Required method for Designer support - do not modify
//000027:         /// the contents of this method with the code editor.
//000028:         /// </summary>
//000029:         private void InitializeComponent()
//000030:         {
    IL_0000:  nop
//000031:             System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm));
    IL_0001:  ldtoken    ParallelMorph.MainForm
    IL_0006:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_000b:  newobj     instance void [System]System.ComponentModel.ComponentResourceManager::.ctor(class [mscorlib]System.Type)
    IL_0010:  stloc.0
//000032:             this.pbMorphStatus = new System.Windows.Forms.ProgressBar();
    IL_0011:  ldarg.0
    IL_0012:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ProgressBar::.ctor()
    IL_0017:  stfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
//000033:             this.btnMorph = new System.Windows.Forms.Button();
    IL_001c:  ldarg.0
    IL_001d:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_0022:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
//000034:             this.columnHeader1 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
    IL_0027:  ldarg.0
    IL_0028:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ColumnHeader::.ctor()
    IL_002d:  stfld      class [System.Windows.Forms]System.Windows.Forms.ColumnHeader ParallelMorph.MainForm::columnHeader1
//000035:             this.columnHeader2 = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
    IL_0032:  ldarg.0
    IL_0033:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ColumnHeader::.ctor()
    IL_0038:  stfld      class [System.Windows.Forms]System.Windows.Forms.ColumnHeader ParallelMorph.MainForm::columnHeader2
//000036:             this.splitContainer1 = new System.Windows.Forms.SplitContainer();
    IL_003d:  ldarg.0
    IL_003e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.SplitContainer::.ctor()
    IL_0043:  stfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
//000037:             this.menuStrip1 = new System.Windows.Forms.MenuStrip();
    IL_0048:  ldarg.0
    IL_0049:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MenuStrip::.ctor()
    IL_004e:  stfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
//000038:             this.fileToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0053:  ldarg.0
    IL_0054:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0059:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
//000039:             this.newToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_005e:  ldarg.0
    IL_005f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0064:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
//000040:             this.openToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0069:  ldarg.0
    IL_006a:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_006f:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
//000041:             this.saveToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0074:  ldarg.0
    IL_0075:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_007a:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
//000042:             this.toolStripSeparator2 = new System.Windows.Forms.ToolStripSeparator();
    IL_007f:  ldarg.0
    IL_0080:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_0085:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripSeparator2
//000043:             this.exitToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_008a:  ldarg.0
    IL_008b:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0090:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
//000044:             this.toolsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0095:  ldarg.0
    IL_0096:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_009b:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
//000045:             this.optionsToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00a0:  ldarg.0
    IL_00a1:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00a6:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
//000046:             this.toolStripMenuItem2 = new System.Windows.Forms.ToolStripSeparator();
    IL_00ab:  ldarg.0
    IL_00ac:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_00b1:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem2
//000047:             this.outputSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00b6:  ldarg.0
    IL_00b7:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00bc:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
//000048:             this.outputSizeToolStripTextBox = new System.Windows.Forms.ToolStripTextBox();
    IL_00c1:  ldarg.0
    IL_00c2:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox::.ctor()
    IL_00c7:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
//000049:             this.outputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00cc:  ldarg.0
    IL_00cd:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00d2:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
//000050:             this.imagesOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00d7:  ldarg.0
    IL_00d8:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00dd:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
//000051:             this.aviOutputToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00e2:  ldarg.0
    IL_00e3:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00e8:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
//000052:             this.toolStripMenuItem1 = new System.Windows.Forms.ToolStripSeparator();
    IL_00ed:  ldarg.0
    IL_00ee:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_00f3:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem1
//000053:             this.sizeModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_00f8:  ldarg.0
    IL_00f9:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_00fe:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
//000054:             this.autoSizeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0103:  ldarg.0
    IL_0104:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0109:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
//000055:             this.zoomToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_010e:  ldarg.0
    IL_010f:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0114:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
//000056:             this.processingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0119:  ldarg.0
    IL_011a:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_011f:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
//000057:             this.sequentialProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_0124:  ldarg.0
    IL_0125:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_012a:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
//000058:             this.parallelProcessingModeToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_012f:  ldarg.0
    IL_0130:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0135:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
//000059:             this.btnCancel = new System.Windows.Forms.Button();
    IL_013a:  ldarg.0
    IL_013b:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.Button::.ctor()
    IL_0140:  stfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
//000060:             this.toolTip1 = new System.Windows.Forms.ToolTip();
    IL_0145:  ldarg.0
    IL_0146:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolTip::.ctor()
    IL_014b:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolTip ParallelMorph.MainForm::toolTip1
//000061:             this.pbInProgressMorph = new System.Windows.Forms.PictureBox();
    IL_0150:  ldarg.0
    IL_0151:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0156:  stfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
//000062:             this.morphInfoToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
    IL_015b:  ldarg.0
    IL_015c:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::.ctor()
    IL_0161:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
//000063:             this.toolStripMenuItem3 = new System.Windows.Forms.ToolStripSeparator();
    IL_0166:  ldarg.0
    IL_0167:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator::.ctor()
    IL_016c:  stfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem3
//000064:             this.pbStartImage = new ParallelMorph.LinedPictureBox();
    IL_0171:  ldarg.0
    IL_0172:  newobj     instance void ParallelMorph.LinedPictureBox::.ctor()
    IL_0177:  stfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
//000065:             this.pbEndImage = new ParallelMorph.LinedPictureBox();
    IL_017c:  ldarg.0
    IL_017d:  newobj     instance void ParallelMorph.LinedPictureBox::.ctor()
    IL_0182:  stfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
//000066:             this.splitContainer1.Panel1.SuspendLayout();
    IL_0187:  ldarg.0
    IL_0188:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_018d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_0192:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0197:  nop
//000067:             this.splitContainer1.Panel2.SuspendLayout();
    IL_0198:  ldarg.0
    IL_0199:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_019e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_01a3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_01a8:  nop
//000068:             this.splitContainer1.SuspendLayout();
    IL_01a9:  ldarg.0
    IL_01aa:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_01af:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_01b4:  nop
//000069:             this.menuStrip1.SuspendLayout();
    IL_01b5:  ldarg.0
    IL_01b6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_01bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_01c0:  nop
//000070:             this.SuspendLayout();
    IL_01c1:  ldarg.0
    IL_01c2:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_01c7:  nop
//000071:             // 
//000072:             // pbMorphStatus
//000073:             // 
//000074:             this.pbMorphStatus.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)
    IL_01c8:  ldarg.0
    IL_01c9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_01ce:  ldc.i4.s   14
    IL_01d0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_01d5:  nop
//000075:                         | System.Windows.Forms.AnchorStyles.Right)));
//000076:             this.pbMorphStatus.Location = new System.Drawing.Point(12, 350);
    IL_01d6:  ldarg.0
    IL_01d7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_01dc:  ldc.i4.s   12
    IL_01de:  ldc.i4     0x15e
    IL_01e3:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_01e8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_01ed:  nop
//000077:             this.pbMorphStatus.Name = "pbMorphStatus";
    IL_01ee:  ldarg.0
    IL_01ef:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_01f4:  ldstr      "pbMorphStatus"
    IL_01f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_01fe:  nop
//000078:             this.pbMorphStatus.Size = new System.Drawing.Size(492, 23);
    IL_01ff:  ldarg.0
    IL_0200:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_0205:  ldc.i4     0x1ec
    IL_020a:  ldc.i4.s   23
    IL_020c:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0211:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0216:  nop
//000079:             this.pbMorphStatus.Style = System.Windows.Forms.ProgressBarStyle.Continuous;
    IL_0217:  ldarg.0
    IL_0218:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_021d:  ldc.i4.1
    IL_021e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ProgressBar::set_Style(valuetype [System.Windows.Forms]System.Windows.Forms.ProgressBarStyle)
    IL_0223:  nop
//000080:             this.pbMorphStatus.TabIndex = 8;
    IL_0224:  ldarg.0
    IL_0225:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_022a:  ldc.i4.8
    IL_022b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0230:  nop
//000081:             this.pbMorphStatus.Visible = false;
    IL_0231:  ldarg.0
    IL_0232:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_0237:  ldc.i4.0
    IL_0238:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_023d:  nop
//000082:             // 
//000083:             // btnMorph
//000084:             // 
//000085:             this.btnMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
    IL_023e:  ldarg.0
    IL_023f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_0244:  ldc.i4.s   10
    IL_0246:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_024b:  nop
//000086:             this.btnMorph.Enabled = false;
    IL_024c:  ldarg.0
    IL_024d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_0252:  ldc.i4.0
    IL_0253:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0258:  nop
//000087:             this.btnMorph.Location = new System.Drawing.Point(510, 350);
    IL_0259:  ldarg.0
    IL_025a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_025f:  ldc.i4     0x1fe
    IL_0264:  ldc.i4     0x15e
    IL_0269:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_026e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0273:  nop
//000088:             this.btnMorph.Name = "btnMorph";
    IL_0274:  ldarg.0
    IL_0275:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_027a:  ldstr      "btnMorph"
    IL_027f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0284:  nop
//000089:             this.btnMorph.Size = new System.Drawing.Size(127, 23);
    IL_0285:  ldarg.0
    IL_0286:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_028b:  ldc.i4.s   127
    IL_028d:  ldc.i4.s   23
    IL_028f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0294:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0299:  nop
//000090:             this.btnMorph.TabIndex = 4;
    IL_029a:  ldarg.0
    IL_029b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_02a0:  ldc.i4.4
    IL_02a1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_02a6:  nop
//000091:             this.btnMorph.Text = "Morph";
    IL_02a7:  ldarg.0
    IL_02a8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_02ad:  ldstr      "Morph"
    IL_02b2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_02b7:  nop
//000092:             this.btnMorph.UseVisualStyleBackColor = true;
    IL_02b8:  ldarg.0
    IL_02b9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_02be:  ldc.i4.1
    IL_02bf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_02c4:  nop
//000093:             this.btnMorph.Click += new System.EventHandler(this.btnMorph_Click);
    IL_02c5:  ldarg.0
    IL_02c6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_02cb:  ldarg.0
    IL_02cc:  ldftn      instance void ParallelMorph.MainForm::btnMorph_Click(object,
                                                                              class [mscorlib]System.EventArgs)
    IL_02d2:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_02d7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_02dc:  nop
//000094:             // 
//000095:             // splitContainer1
//000096:             // 
//000097:             this.splitContainer1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_02dd:  ldarg.0
    IL_02de:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_02e3:  ldc.i4.s   15
    IL_02e5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_02ea:  nop
//000098:                         | System.Windows.Forms.AnchorStyles.Left)
//000099:                         | System.Windows.Forms.AnchorStyles.Right)));
//000100:             this.splitContainer1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
    IL_02eb:  ldarg.0
    IL_02ec:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_02f1:  ldc.i4.1
    IL_02f2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.SplitContainer::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_02f7:  nop
//000101:             this.splitContainer1.Location = new System.Drawing.Point(12, 27);
    IL_02f8:  ldarg.0
    IL_02f9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_02fe:  ldc.i4.s   12
    IL_0300:  ldc.i4.s   27
    IL_0302:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0307:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_030c:  nop
//000102:             this.splitContainer1.Name = "splitContainer1";
    IL_030d:  ldarg.0
    IL_030e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_0313:  ldstr      "splitContainer1"
    IL_0318:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_031d:  nop
//000103:             // 
//000104:             // splitContainer1.Panel1
//000105:             // 
//000106:             this.splitContainer1.Panel1.AutoScroll = true;
    IL_031e:  ldarg.0
    IL_031f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_0324:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_0329:  ldc.i4.1
    IL_032a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ScrollableControl::set_AutoScroll(bool)
    IL_032f:  nop
//000107:             this.splitContainer1.Panel1.Controls.Add(this.pbStartImage);
    IL_0330:  ldarg.0
    IL_0331:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_0336:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_033b:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_0340:  ldarg.0
    IL_0341:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0346:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_034b:  nop
//000108:             this.splitContainer1.Panel1.DoubleClick += new System.EventHandler(this.splitContainer1_Panel1_DoubleClick);
    IL_034c:  ldarg.0
    IL_034d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_0352:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_0357:  ldarg.0
    IL_0358:  ldftn      instance void ParallelMorph.MainForm::splitContainer1_Panel1_DoubleClick(object,
                                                                                                  class [mscorlib]System.EventArgs)
    IL_035e:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0363:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DoubleClick(class [mscorlib]System.EventHandler)
    IL_0368:  nop
//000109:             // 
//000110:             // splitContainer1.Panel2
//000111:             // 
//000112:             this.splitContainer1.Panel2.AutoScroll = true;
    IL_0369:  ldarg.0
    IL_036a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_036f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_0374:  ldc.i4.1
    IL_0375:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ScrollableControl::set_AutoScroll(bool)
    IL_037a:  nop
//000113:             this.splitContainer1.Panel2.Controls.Add(this.pbEndImage);
    IL_037b:  ldarg.0
    IL_037c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_0381:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_0386:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_038b:  ldarg.0
    IL_038c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0391:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_0396:  nop
//000114:             this.splitContainer1.Panel2.DoubleClick += new System.EventHandler(this.splitContainer1_Panel2_DoubleClick);
    IL_0397:  ldarg.0
    IL_0398:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_039d:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_03a2:  ldarg.0
    IL_03a3:  ldftn      instance void ParallelMorph.MainForm::splitContainer1_Panel2_DoubleClick(object,
                                                                                                  class [mscorlib]System.EventArgs)
    IL_03a9:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_03ae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DoubleClick(class [mscorlib]System.EventHandler)
    IL_03b3:  nop
//000115:             this.splitContainer1.Size = new System.Drawing.Size(625, 317);
    IL_03b4:  ldarg.0
    IL_03b5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_03ba:  ldc.i4     0x271
    IL_03bf:  ldc.i4     0x13d
    IL_03c4:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_03c9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_03ce:  nop
//000116:             this.splitContainer1.SplitterDistance = 312;
    IL_03cf:  ldarg.0
    IL_03d0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_03d5:  ldc.i4     0x138
    IL_03da:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.SplitContainer::set_SplitterDistance(int32)
    IL_03df:  nop
//000117:             this.splitContainer1.TabIndex = 9;
    IL_03e0:  ldarg.0
    IL_03e1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_03e6:  ldc.i4.s   9
    IL_03e8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_03ed:  nop
//000118:             // 
//000119:             // menuStrip1
//000120:             // 
//000121:             this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_03ee:  ldarg.0
    IL_03ef:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_03f4:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStrip::get_Items()
    IL_03f9:  ldc.i4.2
    IL_03fa:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_03ff:  stloc.1
    IL_0400:  ldloc.1
    IL_0401:  ldc.i4.0
    IL_0402:  ldarg.0
    IL_0403:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
    IL_0408:  stelem.ref
    IL_0409:  ldloc.1
    IL_040a:  ldc.i4.1
    IL_040b:  ldarg.0
    IL_040c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
    IL_0411:  stelem.ref
    IL_0412:  ldloc.1
    IL_0413:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_0418:  nop
//000122:             this.fileToolStripMenuItem,
//000123:             this.toolsToolStripMenuItem});
//000124:             this.menuStrip1.Location = new System.Drawing.Point(0, 0);
    IL_0419:  ldarg.0
    IL_041a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_041f:  ldc.i4.0
    IL_0420:  ldc.i4.0
    IL_0421:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0426:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_042b:  nop
//000125:             this.menuStrip1.Name = "menuStrip1";
    IL_042c:  ldarg.0
    IL_042d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_0432:  ldstr      "menuStrip1"
    IL_0437:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_043c:  nop
//000126:             this.menuStrip1.RenderMode = System.Windows.Forms.ToolStripRenderMode.Professional;
    IL_043d:  ldarg.0
    IL_043e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_0443:  ldc.i4.2
    IL_0444:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStrip::set_RenderMode(valuetype [System.Windows.Forms]System.Windows.Forms.ToolStripRenderMode)
    IL_0449:  nop
//000127:             this.menuStrip1.Size = new System.Drawing.Size(649, 24);
    IL_044a:  ldarg.0
    IL_044b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_0450:  ldc.i4     0x289
    IL_0455:  ldc.i4.s   24
    IL_0457:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_045c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0461:  nop
//000128:             this.menuStrip1.TabIndex = 10;
    IL_0462:  ldarg.0
    IL_0463:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_0468:  ldc.i4.s   10
    IL_046a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_046f:  nop
//000129:             this.menuStrip1.Text = "menuStrip1";
    IL_0470:  ldarg.0
    IL_0471:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_0476:  ldstr      "menuStrip1"
    IL_047b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0480:  nop
//000130:             // 
//000131:             // fileToolStripMenuItem
//000132:             // 
//000133:             this.fileToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0481:  ldarg.0
    IL_0482:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
    IL_0487:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_048c:  ldc.i4.5
    IL_048d:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_0492:  stloc.1
    IL_0493:  ldloc.1
    IL_0494:  ldc.i4.0
    IL_0495:  ldarg.0
    IL_0496:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_049b:  stelem.ref
    IL_049c:  ldloc.1
    IL_049d:  ldc.i4.1
    IL_049e:  ldarg.0
    IL_049f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_04a4:  stelem.ref
    IL_04a5:  ldloc.1
    IL_04a6:  ldc.i4.2
    IL_04a7:  ldarg.0
    IL_04a8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_04ad:  stelem.ref
    IL_04ae:  ldloc.1
    IL_04af:  ldc.i4.3
    IL_04b0:  ldarg.0
    IL_04b1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripSeparator2
    IL_04b6:  stelem.ref
    IL_04b7:  ldloc.1
    IL_04b8:  ldc.i4.4
    IL_04b9:  ldarg.0
    IL_04ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
    IL_04bf:  stelem.ref
    IL_04c0:  ldloc.1
    IL_04c1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_04c6:  nop
//000134:             this.newToolStripMenuItem,
//000135:             this.openToolStripMenuItem,
//000136:             this.saveToolStripMenuItem,
//000137:             this.toolStripSeparator2,
//000138:             this.exitToolStripMenuItem});
//000139:             this.fileToolStripMenuItem.Name = "fileToolStripMenuItem";
    IL_04c7:  ldarg.0
    IL_04c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
    IL_04cd:  ldstr      "fileToolStripMenuItem"
    IL_04d2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_04d7:  nop
//000140:             this.fileToolStripMenuItem.Size = new System.Drawing.Size(37, 20);
    IL_04d8:  ldarg.0
    IL_04d9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
    IL_04de:  ldc.i4.s   37
    IL_04e0:  ldc.i4.s   20
    IL_04e2:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_04e7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_04ec:  nop
//000141:             this.fileToolStripMenuItem.Text = "&File";
    IL_04ed:  ldarg.0
    IL_04ee:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::fileToolStripMenuItem
    IL_04f3:  ldstr      "&File"
    IL_04f8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_04fd:  nop
//000142:             // 
//000143:             // newToolStripMenuItem
//000144:             // 
//000145:             this.newToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("newToolStripMenuItem.Image")));
    IL_04fe:  ldarg.0
    IL_04ff:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_0504:  ldloc.0
    IL_0505:  ldstr      "newToolStripMenuItem.Image"
    IL_050a:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_050f:  castclass  [System.Drawing]System.Drawing.Image
    IL_0514:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0519:  nop
//000146:             this.newToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_051a:  ldarg.0
    IL_051b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_0520:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0525:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_052a:  nop
//000147:             this.newToolStripMenuItem.Name = "newToolStripMenuItem";
    IL_052b:  ldarg.0
    IL_052c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_0531:  ldstr      "newToolStripMenuItem"
    IL_0536:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_053b:  nop
//000148:             this.newToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.N)));
    IL_053c:  ldarg.0
    IL_053d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_0542:  ldc.i4     0x2004e
    IL_0547:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_ShortcutKeys(valuetype [System.Windows.Forms]System.Windows.Forms.Keys)
    IL_054c:  nop
//000149:             this.newToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
    IL_054d:  ldarg.0
    IL_054e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_0553:  ldc.i4     0x92
    IL_0558:  ldc.i4.s   22
    IL_055a:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_055f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0564:  nop
//000150:             this.newToolStripMenuItem.Text = "&New";
    IL_0565:  ldarg.0
    IL_0566:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_056b:  ldstr      "&New"
    IL_0570:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0575:  nop
//000151:             this.newToolStripMenuItem.Click += new System.EventHandler(this.newToolStripMenuItem_Click);
    IL_0576:  ldarg.0
    IL_0577:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::newToolStripMenuItem
    IL_057c:  ldarg.0
    IL_057d:  ldftn      instance void ParallelMorph.MainForm::newToolStripMenuItem_Click(object,
                                                                                          class [mscorlib]System.EventArgs)
    IL_0583:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0588:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_058d:  nop
//000152:             // 
//000153:             // openToolStripMenuItem
//000154:             // 
//000155:             this.openToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("openToolStripMenuItem.Image")));
    IL_058e:  ldarg.0
    IL_058f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_0594:  ldloc.0
    IL_0595:  ldstr      "openToolStripMenuItem.Image"
    IL_059a:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_059f:  castclass  [System.Drawing]System.Drawing.Image
    IL_05a4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_05a9:  nop
//000156:             this.openToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_05aa:  ldarg.0
    IL_05ab:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_05b0:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_05b5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_05ba:  nop
//000157:             this.openToolStripMenuItem.Name = "openToolStripMenuItem";
    IL_05bb:  ldarg.0
    IL_05bc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_05c1:  ldstr      "openToolStripMenuItem"
    IL_05c6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_05cb:  nop
//000158:             this.openToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));
    IL_05cc:  ldarg.0
    IL_05cd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_05d2:  ldc.i4     0x2004f
    IL_05d7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_ShortcutKeys(valuetype [System.Windows.Forms]System.Windows.Forms.Keys)
    IL_05dc:  nop
//000159:             this.openToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
    IL_05dd:  ldarg.0
    IL_05de:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_05e3:  ldc.i4     0x92
    IL_05e8:  ldc.i4.s   22
    IL_05ea:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_05ef:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_05f4:  nop
//000160:             this.openToolStripMenuItem.Text = "&Open";
    IL_05f5:  ldarg.0
    IL_05f6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_05fb:  ldstr      "&Open"
    IL_0600:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0605:  nop
//000161:             this.openToolStripMenuItem.Click += new System.EventHandler(this.openToolStripMenuItem_Click);
    IL_0606:  ldarg.0
    IL_0607:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::openToolStripMenuItem
    IL_060c:  ldarg.0
    IL_060d:  ldftn      instance void ParallelMorph.MainForm::openToolStripMenuItem_Click(object,
                                                                                           class [mscorlib]System.EventArgs)
    IL_0613:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0618:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_061d:  nop
//000162:             // 
//000163:             // saveToolStripMenuItem
//000164:             // 
//000165:             this.saveToolStripMenuItem.Image = ((System.Drawing.Image)(resources.GetObject("saveToolStripMenuItem.Image")));
    IL_061e:  ldarg.0
    IL_061f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_0624:  ldloc.0
    IL_0625:  ldstr      "saveToolStripMenuItem.Image"
    IL_062a:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_062f:  castclass  [System.Drawing]System.Drawing.Image
    IL_0634:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0639:  nop
//000166:             this.saveToolStripMenuItem.ImageTransparentColor = System.Drawing.Color.Magenta;
    IL_063a:  ldarg.0
    IL_063b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_0640:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::get_Magenta()
    IL_0645:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_ImageTransparentColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_064a:  nop
//000167:             this.saveToolStripMenuItem.Name = "saveToolStripMenuItem";
    IL_064b:  ldarg.0
    IL_064c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_0651:  ldstr      "saveToolStripMenuItem"
    IL_0656:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_065b:  nop
//000168:             this.saveToolStripMenuItem.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));
    IL_065c:  ldarg.0
    IL_065d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_0662:  ldc.i4     0x20053
    IL_0667:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_ShortcutKeys(valuetype [System.Windows.Forms]System.Windows.Forms.Keys)
    IL_066c:  nop
//000169:             this.saveToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
    IL_066d:  ldarg.0
    IL_066e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_0673:  ldc.i4     0x92
    IL_0678:  ldc.i4.s   22
    IL_067a:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_067f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0684:  nop
//000170:             this.saveToolStripMenuItem.Text = "&Save";
    IL_0685:  ldarg.0
    IL_0686:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_068b:  ldstr      "&Save"
    IL_0690:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0695:  nop
//000171:             this.saveToolStripMenuItem.Click += new System.EventHandler(this.saveToolStripMenuItem_Click);
    IL_0696:  ldarg.0
    IL_0697:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::saveToolStripMenuItem
    IL_069c:  ldarg.0
    IL_069d:  ldftn      instance void ParallelMorph.MainForm::saveToolStripMenuItem_Click(object,
                                                                                           class [mscorlib]System.EventArgs)
    IL_06a3:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_06a8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_06ad:  nop
//000172:             // 
//000173:             // toolStripSeparator2
//000174:             // 
//000175:             this.toolStripSeparator2.Name = "toolStripSeparator2";
    IL_06ae:  ldarg.0
    IL_06af:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripSeparator2
    IL_06b4:  ldstr      "toolStripSeparator2"
    IL_06b9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_06be:  nop
//000176:             this.toolStripSeparator2.Size = new System.Drawing.Size(143, 6);
    IL_06bf:  ldarg.0
    IL_06c0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripSeparator2
    IL_06c5:  ldc.i4     0x8f
    IL_06ca:  ldc.i4.6
    IL_06cb:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_06d0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_06d5:  nop
//000177:             // 
//000178:             // exitToolStripMenuItem
//000179:             // 
//000180:             this.exitToolStripMenuItem.Name = "exitToolStripMenuItem";
    IL_06d6:  ldarg.0
    IL_06d7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
    IL_06dc:  ldstr      "exitToolStripMenuItem"
    IL_06e1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_06e6:  nop
//000181:             this.exitToolStripMenuItem.Size = new System.Drawing.Size(146, 22);
    IL_06e7:  ldarg.0
    IL_06e8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
    IL_06ed:  ldc.i4     0x92
    IL_06f2:  ldc.i4.s   22
    IL_06f4:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_06f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_06fe:  nop
//000182:             this.exitToolStripMenuItem.Text = "E&xit";
    IL_06ff:  ldarg.0
    IL_0700:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
    IL_0705:  ldstr      "E&xit"
    IL_070a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_070f:  nop
//000183:             this.exitToolStripMenuItem.Click += new System.EventHandler(this.exitToolStripMenuItem_Click);
    IL_0710:  ldarg.0
    IL_0711:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::exitToolStripMenuItem
    IL_0716:  ldarg.0
    IL_0717:  ldftn      instance void ParallelMorph.MainForm::exitToolStripMenuItem_Click(object,
                                                                                           class [mscorlib]System.EventArgs)
    IL_071d:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0722:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0727:  nop
//000184:             // 
//000185:             // toolsToolStripMenuItem
//000186:             // 
//000187:             this.toolsToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0728:  ldarg.0
    IL_0729:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
    IL_072e:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_0733:  ldc.i4.s   9
    IL_0735:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_073a:  stloc.1
    IL_073b:  ldloc.1
    IL_073c:  ldc.i4.0
    IL_073d:  ldarg.0
    IL_073e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
    IL_0743:  stelem.ref
    IL_0744:  ldloc.1
    IL_0745:  ldc.i4.1
    IL_0746:  ldarg.0
    IL_0747:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem2
    IL_074c:  stelem.ref
    IL_074d:  ldloc.1
    IL_074e:  ldc.i4.2
    IL_074f:  ldarg.0
    IL_0750:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
    IL_0755:  stelem.ref
    IL_0756:  ldloc.1
    IL_0757:  ldc.i4.3
    IL_0758:  ldarg.0
    IL_0759:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
    IL_075e:  stelem.ref
    IL_075f:  ldloc.1
    IL_0760:  ldc.i4.4
    IL_0761:  ldarg.0
    IL_0762:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem1
    IL_0767:  stelem.ref
    IL_0768:  ldloc.1
    IL_0769:  ldc.i4.5
    IL_076a:  ldarg.0
    IL_076b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
    IL_0770:  stelem.ref
    IL_0771:  ldloc.1
    IL_0772:  ldc.i4.6
    IL_0773:  ldarg.0
    IL_0774:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
    IL_0779:  stelem.ref
    IL_077a:  ldloc.1
    IL_077b:  ldc.i4.7
    IL_077c:  ldarg.0
    IL_077d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem3
    IL_0782:  stelem.ref
    IL_0783:  ldloc.1
    IL_0784:  ldc.i4.8
    IL_0785:  ldarg.0
    IL_0786:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
    IL_078b:  stelem.ref
    IL_078c:  ldloc.1
    IL_078d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_0792:  nop
//000188:             this.optionsToolStripMenuItem,
//000189:             this.toolStripMenuItem2,
//000190:             this.outputSizeToolStripMenuItem,
//000191:             this.outputToolStripMenuItem,
//000192:             this.toolStripMenuItem1,
//000193:             this.sizeModeToolStripMenuItem,
//000194:             this.processingModeToolStripMenuItem,
//000195:             this.toolStripMenuItem3,
//000196:             this.morphInfoToolStripMenuItem});
//000197:             this.toolsToolStripMenuItem.Name = "toolsToolStripMenuItem";
    IL_0793:  ldarg.0
    IL_0794:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
    IL_0799:  ldstr      "toolsToolStripMenuItem"
    IL_079e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_07a3:  nop
//000198:             this.toolsToolStripMenuItem.Size = new System.Drawing.Size(48, 20);
    IL_07a4:  ldarg.0
    IL_07a5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
    IL_07aa:  ldc.i4.s   48
    IL_07ac:  ldc.i4.s   20
    IL_07ae:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_07b3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_07b8:  nop
//000199:             this.toolsToolStripMenuItem.Text = "&Tools";
    IL_07b9:  ldarg.0
    IL_07ba:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::toolsToolStripMenuItem
    IL_07bf:  ldstr      "&Tools"
    IL_07c4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_07c9:  nop
//000200:             // 
//000201:             // optionsToolStripMenuItem
//000202:             // 
//000203:             this.optionsToolStripMenuItem.Name = "optionsToolStripMenuItem";
    IL_07ca:  ldarg.0
    IL_07cb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
    IL_07d0:  ldstr      "optionsToolStripMenuItem"
    IL_07d5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_07da:  nop
//000204:             this.optionsToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_07db:  ldarg.0
    IL_07dc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
    IL_07e1:  ldc.i4     0xa5
    IL_07e6:  ldc.i4.s   22
    IL_07e8:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_07ed:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_07f2:  nop
//000205:             this.optionsToolStripMenuItem.Text = "&Options...";
    IL_07f3:  ldarg.0
    IL_07f4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
    IL_07f9:  ldstr      "&Options..."
    IL_07fe:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0803:  nop
//000206:             this.optionsToolStripMenuItem.Click += new System.EventHandler(this.optionsToolStripMenuItem_Click);
    IL_0804:  ldarg.0
    IL_0805:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::optionsToolStripMenuItem
    IL_080a:  ldarg.0
    IL_080b:  ldftn      instance void ParallelMorph.MainForm::optionsToolStripMenuItem_Click(object,
                                                                                              class [mscorlib]System.EventArgs)
    IL_0811:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0816:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_081b:  nop
//000207:             // 
//000208:             // toolStripMenuItem2
//000209:             // 
//000210:             this.toolStripMenuItem2.Name = "toolStripMenuItem2";
    IL_081c:  ldarg.0
    IL_081d:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem2
    IL_0822:  ldstr      "toolStripMenuItem2"
    IL_0827:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_082c:  nop
//000211:             this.toolStripMenuItem2.Size = new System.Drawing.Size(162, 6);
    IL_082d:  ldarg.0
    IL_082e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem2
    IL_0833:  ldc.i4     0xa2
    IL_0838:  ldc.i4.6
    IL_0839:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_083e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0843:  nop
//000212:             // 
//000213:             // outputSizeToolStripMenuItem
//000214:             // 
//000215:             this.outputSizeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0844:  ldarg.0
    IL_0845:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
    IL_084a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_084f:  ldc.i4.1
    IL_0850:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_0855:  stloc.1
    IL_0856:  ldloc.1
    IL_0857:  ldc.i4.0
    IL_0858:  ldarg.0
    IL_0859:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_085e:  stelem.ref
    IL_085f:  ldloc.1
    IL_0860:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_0865:  nop
//000216:             this.outputSizeToolStripTextBox});
//000217:             this.outputSizeToolStripMenuItem.Name = "outputSizeToolStripMenuItem";
    IL_0866:  ldarg.0
    IL_0867:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
    IL_086c:  ldstr      "outputSizeToolStripMenuItem"
    IL_0871:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0876:  nop
//000218:             this.outputSizeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_0877:  ldarg.0
    IL_0878:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
    IL_087d:  ldc.i4     0xa5
    IL_0882:  ldc.i4.s   22
    IL_0884:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0889:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_088e:  nop
//000219:             this.outputSizeToolStripMenuItem.Text = "Output Size";
    IL_088f:  ldarg.0
    IL_0890:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputSizeToolStripMenuItem
    IL_0895:  ldstr      "Output Size"
    IL_089a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_089f:  nop
//000220:             // 
//000221:             // outputSizeToolStripTextBox
//000222:             // 
//000223:             this.outputSizeToolStripTextBox.MaxLength = 3;
    IL_08a0:  ldarg.0
    IL_08a1:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_08a6:  ldc.i4.3
    IL_08a7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox::set_MaxLength(int32)
    IL_08ac:  nop
//000224:             this.outputSizeToolStripTextBox.Name = "outputSizeToolStripTextBox";
    IL_08ad:  ldarg.0
    IL_08ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_08b3:  ldstr      "outputSizeToolStripTextBox"
    IL_08b8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_08bd:  nop
//000225:             this.outputSizeToolStripTextBox.Size = new System.Drawing.Size(100, 23);
    IL_08be:  ldarg.0
    IL_08bf:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_08c4:  ldc.i4.s   100
    IL_08c6:  ldc.i4.s   23
    IL_08c8:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_08cd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_08d2:  nop
//000226:             this.outputSizeToolStripTextBox.Text = "100";
    IL_08d3:  ldarg.0
    IL_08d4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_08d9:  ldstr      "100"
    IL_08de:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_08e3:  nop
//000227:             // 
//000228:             // outputToolStripMenuItem
//000229:             // 
//000230:             this.outputToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_08e4:  ldarg.0
    IL_08e5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
    IL_08ea:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_08ef:  ldc.i4.2
    IL_08f0:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_08f5:  stloc.1
    IL_08f6:  ldloc.1
    IL_08f7:  ldc.i4.0
    IL_08f8:  ldarg.0
    IL_08f9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_08fe:  stelem.ref
    IL_08ff:  ldloc.1
    IL_0900:  ldc.i4.1
    IL_0901:  ldarg.0
    IL_0902:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_0907:  stelem.ref
    IL_0908:  ldloc.1
    IL_0909:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_090e:  nop
//000231:             this.imagesOutputToolStripMenuItem,
//000232:             this.aviOutputToolStripMenuItem});
//000233:             this.outputToolStripMenuItem.Name = "outputToolStripMenuItem";
    IL_090f:  ldarg.0
    IL_0910:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
    IL_0915:  ldstr      "outputToolStripMenuItem"
    IL_091a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_091f:  nop
//000234:             this.outputToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_0920:  ldarg.0
    IL_0921:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
    IL_0926:  ldc.i4     0xa5
    IL_092b:  ldc.i4.s   22
    IL_092d:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0932:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0937:  nop
//000235:             this.outputToolStripMenuItem.Text = "Output Type";
    IL_0938:  ldarg.0
    IL_0939:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::outputToolStripMenuItem
    IL_093e:  ldstr      "Output Type"
    IL_0943:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0948:  nop
//000236:             // 
//000237:             // imagesOutputToolStripMenuItem
//000238:             // 
//000239:             this.imagesOutputToolStripMenuItem.Checked = true;
    IL_0949:  ldarg.0
    IL_094a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_094f:  ldc.i4.1
    IL_0950:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0955:  nop
//000240:             this.imagesOutputToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
    IL_0956:  ldarg.0
    IL_0957:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_095c:  ldc.i4.1
    IL_095d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_CheckState(valuetype [System.Windows.Forms]System.Windows.Forms.CheckState)
    IL_0962:  nop
//000241:             this.imagesOutputToolStripMenuItem.Name = "imagesOutputToolStripMenuItem";
    IL_0963:  ldarg.0
    IL_0964:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_0969:  ldstr      "imagesOutputToolStripMenuItem"
    IL_096e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0973:  nop
//000242:             this.imagesOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
    IL_0974:  ldarg.0
    IL_0975:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_097a:  ldc.i4.s   112
    IL_097c:  ldc.i4.s   22
    IL_097e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0983:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0988:  nop
//000243:             this.imagesOutputToolStripMenuItem.Text = "Images";
    IL_0989:  ldarg.0
    IL_098a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_098f:  ldstr      "Images"
    IL_0994:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0999:  nop
//000244:             this.imagesOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
    IL_099a:  ldarg.0
    IL_099b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_09a0:  ldarg.0
    IL_09a1:  ldftn      instance void ParallelMorph.MainForm::outputModeToolStripMenuItem_Click(object,
                                                                                                 class [mscorlib]System.EventArgs)
    IL_09a7:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_09ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_09b1:  nop
//000245:             // 
//000246:             // aviOutputToolStripMenuItem
//000247:             // 
//000248:             this.aviOutputToolStripMenuItem.Name = "aviOutputToolStripMenuItem";
    IL_09b2:  ldarg.0
    IL_09b3:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_09b8:  ldstr      "aviOutputToolStripMenuItem"
    IL_09bd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_09c2:  nop
//000249:             this.aviOutputToolStripMenuItem.Size = new System.Drawing.Size(112, 22);
    IL_09c3:  ldarg.0
    IL_09c4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_09c9:  ldc.i4.s   112
    IL_09cb:  ldc.i4.s   22
    IL_09cd:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_09d2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_09d7:  nop
//000250:             this.aviOutputToolStripMenuItem.Text = "AVI";
    IL_09d8:  ldarg.0
    IL_09d9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_09de:  ldstr      "AVI"
    IL_09e3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_09e8:  nop
//000251:             this.aviOutputToolStripMenuItem.Click += new System.EventHandler(this.outputModeToolStripMenuItem_Click);
    IL_09e9:  ldarg.0
    IL_09ea:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_09ef:  ldarg.0
    IL_09f0:  ldftn      instance void ParallelMorph.MainForm::outputModeToolStripMenuItem_Click(object,
                                                                                                 class [mscorlib]System.EventArgs)
    IL_09f6:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_09fb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0a00:  nop
//000252:             // 
//000253:             // toolStripMenuItem1
//000254:             // 
//000255:             this.toolStripMenuItem1.Name = "toolStripMenuItem1";
    IL_0a01:  ldarg.0
    IL_0a02:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem1
    IL_0a07:  ldstr      "toolStripMenuItem1"
    IL_0a0c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0a11:  nop
//000256:             this.toolStripMenuItem1.Size = new System.Drawing.Size(162, 6);
    IL_0a12:  ldarg.0
    IL_0a13:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem1
    IL_0a18:  ldc.i4     0xa2
    IL_0a1d:  ldc.i4.6
    IL_0a1e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0a23:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0a28:  nop
//000257:             // 
//000258:             // sizeModeToolStripMenuItem
//000259:             // 
//000260:             this.sizeModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0a29:  ldarg.0
    IL_0a2a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
    IL_0a2f:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_0a34:  ldc.i4.2
    IL_0a35:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_0a3a:  stloc.1
    IL_0a3b:  ldloc.1
    IL_0a3c:  ldc.i4.0
    IL_0a3d:  ldarg.0
    IL_0a3e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_0a43:  stelem.ref
    IL_0a44:  ldloc.1
    IL_0a45:  ldc.i4.1
    IL_0a46:  ldarg.0
    IL_0a47:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0a4c:  stelem.ref
    IL_0a4d:  ldloc.1
    IL_0a4e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_0a53:  nop
//000261:             this.autoSizeToolStripMenuItem,
//000262:             this.zoomToolStripMenuItem});
//000263:             this.sizeModeToolStripMenuItem.Name = "sizeModeToolStripMenuItem";
    IL_0a54:  ldarg.0
    IL_0a55:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
    IL_0a5a:  ldstr      "sizeModeToolStripMenuItem"
    IL_0a5f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0a64:  nop
//000264:             this.sizeModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_0a65:  ldarg.0
    IL_0a66:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
    IL_0a6b:  ldc.i4     0xa5
    IL_0a70:  ldc.i4.s   22
    IL_0a72:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0a77:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0a7c:  nop
//000265:             this.sizeModeToolStripMenuItem.Text = "View Mode";
    IL_0a7d:  ldarg.0
    IL_0a7e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sizeModeToolStripMenuItem
    IL_0a83:  ldstr      "View Mode"
    IL_0a88:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0a8d:  nop
//000266:             // 
//000267:             // autoSizeToolStripMenuItem
//000268:             // 
//000269:             this.autoSizeToolStripMenuItem.Name = "autoSizeToolStripMenuItem";
    IL_0a8e:  ldarg.0
    IL_0a8f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_0a94:  ldstr      "autoSizeToolStripMenuItem"
    IL_0a99:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0a9e:  nop
//000270:             this.autoSizeToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
    IL_0a9f:  ldarg.0
    IL_0aa0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_0aa5:  ldc.i4.s   120
    IL_0aa7:  ldc.i4.s   22
    IL_0aa9:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0aae:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0ab3:  nop
//000271:             this.autoSizeToolStripMenuItem.Text = "AutoSize";
    IL_0ab4:  ldarg.0
    IL_0ab5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_0aba:  ldstr      "AutoSize"
    IL_0abf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0ac4:  nop
//000272:             this.autoSizeToolStripMenuItem.Click += new System.EventHandler(this.autoSizeToolStripMenuItem_Click);
    IL_0ac5:  ldarg.0
    IL_0ac6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_0acb:  ldarg.0
    IL_0acc:  ldftn      instance void ParallelMorph.MainForm::autoSizeToolStripMenuItem_Click(object,
                                                                                               class [mscorlib]System.EventArgs)
    IL_0ad2:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0ad7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0adc:  nop
//000273:             // 
//000274:             // zoomToolStripMenuItem
//000275:             // 
//000276:             this.zoomToolStripMenuItem.Checked = true;
    IL_0add:  ldarg.0
    IL_0ade:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0ae3:  ldc.i4.1
    IL_0ae4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0ae9:  nop
//000277:             this.zoomToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
    IL_0aea:  ldarg.0
    IL_0aeb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0af0:  ldc.i4.1
    IL_0af1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_CheckState(valuetype [System.Windows.Forms]System.Windows.Forms.CheckState)
    IL_0af6:  nop
//000278:             this.zoomToolStripMenuItem.Name = "zoomToolStripMenuItem";
    IL_0af7:  ldarg.0
    IL_0af8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0afd:  ldstr      "zoomToolStripMenuItem"
    IL_0b02:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0b07:  nop
//000279:             this.zoomToolStripMenuItem.Size = new System.Drawing.Size(120, 22);
    IL_0b08:  ldarg.0
    IL_0b09:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0b0e:  ldc.i4.s   120
    IL_0b10:  ldc.i4.s   22
    IL_0b12:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0b17:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0b1c:  nop
//000280:             this.zoomToolStripMenuItem.Text = "Zoom";
    IL_0b1d:  ldarg.0
    IL_0b1e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0b23:  ldstr      "Zoom"
    IL_0b28:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0b2d:  nop
//000281:             this.zoomToolStripMenuItem.Click += new System.EventHandler(this.zoomToolStripMenuItem_Click);
    IL_0b2e:  ldarg.0
    IL_0b2f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0b34:  ldarg.0
    IL_0b35:  ldftn      instance void ParallelMorph.MainForm::zoomToolStripMenuItem_Click(object,
                                                                                           class [mscorlib]System.EventArgs)
    IL_0b3b:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0b40:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0b45:  nop
//000282:             // 
//000283:             // processingModeToolStripMenuItem
//000284:             // 
//000285:             this.processingModeToolStripMenuItem.DropDownItems.AddRange(new System.Windows.Forms.ToolStripItem[] {
    IL_0b46:  ldarg.0
    IL_0b47:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
    IL_0b4c:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection [System.Windows.Forms]System.Windows.Forms.ToolStripDropDownItem::get_DropDownItems()
    IL_0b51:  ldc.i4.2
    IL_0b52:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripItem
    IL_0b57:  stloc.1
    IL_0b58:  ldloc.1
    IL_0b59:  ldc.i4.0
    IL_0b5a:  ldarg.0
    IL_0b5b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0b60:  stelem.ref
    IL_0b61:  ldloc.1
    IL_0b62:  ldc.i4.1
    IL_0b63:  ldarg.0
    IL_0b64:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0b69:  stelem.ref
    IL_0b6a:  ldloc.1
    IL_0b6b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItemCollection::AddRange(class [System.Windows.Forms]System.Windows.Forms.ToolStripItem[])
    IL_0b70:  nop
//000286:             this.sequentialProcessingModeToolStripMenuItem,
//000287:             this.parallelProcessingModeToolStripMenuItem});
//000288:             this.processingModeToolStripMenuItem.Name = "processingModeToolStripMenuItem";
    IL_0b71:  ldarg.0
    IL_0b72:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
    IL_0b77:  ldstr      "processingModeToolStripMenuItem"
    IL_0b7c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0b81:  nop
//000289:             this.processingModeToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_0b82:  ldarg.0
    IL_0b83:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
    IL_0b88:  ldc.i4     0xa5
    IL_0b8d:  ldc.i4.s   22
    IL_0b8f:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0b94:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0b99:  nop
//000290:             this.processingModeToolStripMenuItem.Text = "Processing Mode";
    IL_0b9a:  ldarg.0
    IL_0b9b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::processingModeToolStripMenuItem
    IL_0ba0:  ldstr      "Processing Mode"
    IL_0ba5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0baa:  nop
//000291:             // 
//000292:             // sequentialProcessingModeToolStripMenuItem
//000293:             // 
//000294:             this.sequentialProcessingModeToolStripMenuItem.Checked = true;
    IL_0bab:  ldarg.0
    IL_0bac:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0bb1:  ldc.i4.1
    IL_0bb2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0bb7:  nop
//000295:             this.sequentialProcessingModeToolStripMenuItem.CheckState = System.Windows.Forms.CheckState.Checked;
    IL_0bb8:  ldarg.0
    IL_0bb9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0bbe:  ldc.i4.1
    IL_0bbf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_CheckState(valuetype [System.Windows.Forms]System.Windows.Forms.CheckState)
    IL_0bc4:  nop
//000296:             this.sequentialProcessingModeToolStripMenuItem.Name = "sequentialProcessingModeToolStripMenuItem";
    IL_0bc5:  ldarg.0
    IL_0bc6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0bcb:  ldstr      "sequentialProcessingModeToolStripMenuItem"
    IL_0bd0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0bd5:  nop
//000297:             this.sequentialProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
    IL_0bd6:  ldarg.0
    IL_0bd7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0bdc:  ldc.i4     0x81
    IL_0be1:  ldc.i4.s   22
    IL_0be3:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0be8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0bed:  nop
//000298:             this.sequentialProcessingModeToolStripMenuItem.Text = "Sequential";
    IL_0bee:  ldarg.0
    IL_0bef:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0bf4:  ldstr      "Sequential"
    IL_0bf9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0bfe:  nop
//000299:             this.sequentialProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
    IL_0bff:  ldarg.0
    IL_0c00:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0c05:  ldarg.0
    IL_0c06:  ldftn      instance void ParallelMorph.MainForm::parallelModeToolStripMenuItem_Click(object,
                                                                                                   class [mscorlib]System.EventArgs)
    IL_0c0c:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0c11:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0c16:  nop
//000300:             // 
//000301:             // parallelProcessingModeToolStripMenuItem
//000302:             // 
//000303:             this.parallelProcessingModeToolStripMenuItem.Name = "parallelProcessingModeToolStripMenuItem";
    IL_0c17:  ldarg.0
    IL_0c18:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0c1d:  ldstr      "parallelProcessingModeToolStripMenuItem"
    IL_0c22:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0c27:  nop
//000304:             this.parallelProcessingModeToolStripMenuItem.Size = new System.Drawing.Size(129, 22);
    IL_0c28:  ldarg.0
    IL_0c29:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0c2e:  ldc.i4     0x81
    IL_0c33:  ldc.i4.s   22
    IL_0c35:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0c3a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0c3f:  nop
//000305:             this.parallelProcessingModeToolStripMenuItem.Text = "Parallel";
    IL_0c40:  ldarg.0
    IL_0c41:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0c46:  ldstr      "Parallel"
    IL_0c4b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0c50:  nop
//000306:             this.parallelProcessingModeToolStripMenuItem.Click += new System.EventHandler(this.parallelModeToolStripMenuItem_Click);
    IL_0c51:  ldarg.0
    IL_0c52:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0c57:  ldarg.0
    IL_0c58:  ldftn      instance void ParallelMorph.MainForm::parallelModeToolStripMenuItem_Click(object,
                                                                                                   class [mscorlib]System.EventArgs)
    IL_0c5e:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0c63:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0c68:  nop
//000307:             // 
//000308:             // btnCancel
//000309:             // 
//000310:             this.btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
    IL_0c69:  ldarg.0
    IL_0c6a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0c6f:  ldc.i4.s   10
    IL_0c71:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0c76:  nop
//000311:             this.btnCancel.Location = new System.Drawing.Point(509, 350);
    IL_0c77:  ldarg.0
    IL_0c78:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0c7d:  ldc.i4     0x1fd
    IL_0c82:  ldc.i4     0x15e
    IL_0c87:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0c8c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0c91:  nop
//000312:             this.btnCancel.Name = "btnCancel";
    IL_0c92:  ldarg.0
    IL_0c93:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0c98:  ldstr      "btnCancel"
    IL_0c9d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0ca2:  nop
//000313:             this.btnCancel.Size = new System.Drawing.Size(127, 23);
    IL_0ca3:  ldarg.0
    IL_0ca4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0ca9:  ldc.i4.s   127
    IL_0cab:  ldc.i4.s   23
    IL_0cad:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0cb2:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0cb7:  nop
//000314:             this.btnCancel.TabIndex = 11;
    IL_0cb8:  ldarg.0
    IL_0cb9:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0cbe:  ldc.i4.s   11
    IL_0cc0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_0cc5:  nop
//000315:             this.btnCancel.Text = "Cancel";
    IL_0cc6:  ldarg.0
    IL_0cc7:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0ccc:  ldstr      "Cancel"
    IL_0cd1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0cd6:  nop
//000316:             this.btnCancel.UseVisualStyleBackColor = true;
    IL_0cd7:  ldarg.0
    IL_0cd8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0cdd:  ldc.i4.1
    IL_0cde:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ButtonBase::set_UseVisualStyleBackColor(bool)
    IL_0ce3:  nop
//000317:             this.btnCancel.Visible = false;
    IL_0ce4:  ldarg.0
    IL_0ce5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0cea:  ldc.i4.0
    IL_0ceb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_0cf0:  nop
//000318:             this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
    IL_0cf1:  ldarg.0
    IL_0cf2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0cf7:  ldarg.0
    IL_0cf8:  ldftn      instance void ParallelMorph.MainForm::btnCancel_Click(object,
                                                                               class [mscorlib]System.EventArgs)
    IL_0cfe:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0d03:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_Click(class [mscorlib]System.EventHandler)
    IL_0d08:  nop
//000319:             // 
//000320:             // pbInProgressMorph
//000321:             // 
//000322:             this.pbInProgressMorph.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
    IL_0d09:  ldarg.0
    IL_0d0a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d0f:  ldc.i4.s   15
    IL_0d11:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Anchor(valuetype [System.Windows.Forms]System.Windows.Forms.AnchorStyles)
    IL_0d16:  nop
//000323:                         | System.Windows.Forms.AnchorStyles.Left)
//000324:                         | System.Windows.Forms.AnchorStyles.Right)));
//000325:             this.pbInProgressMorph.BackColor = System.Drawing.SystemColors.ControlLightLight;
    IL_0d17:  ldarg.0
    IL_0d18:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d1d:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.SystemColors::get_ControlLightLight()
    IL_0d22:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_BackColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0d27:  nop
//000326:             this.pbInProgressMorph.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
    IL_0d28:  ldarg.0
    IL_0d29:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d2e:  ldc.i4.1
    IL_0d2f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_BorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.BorderStyle)
    IL_0d34:  nop
//000327:             this.pbInProgressMorph.Location = new System.Drawing.Point(12, 27);
    IL_0d35:  ldarg.0
    IL_0d36:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d3b:  ldc.i4.s   12
    IL_0d3d:  ldc.i4.s   27
    IL_0d3f:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0d44:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0d49:  nop
//000328:             this.pbInProgressMorph.Name = "pbInProgressMorph";
    IL_0d4a:  ldarg.0
    IL_0d4b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d50:  ldstr      "pbInProgressMorph"
    IL_0d55:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0d5a:  nop
//000329:             this.pbInProgressMorph.Size = new System.Drawing.Size(625, 317);
    IL_0d5b:  ldarg.0
    IL_0d5c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d61:  ldc.i4     0x271
    IL_0d66:  ldc.i4     0x13d
    IL_0d6b:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0d70:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0d75:  nop
//000330:             this.pbInProgressMorph.SizeMode = System.Windows.Forms.PictureBoxSizeMode.Zoom;
    IL_0d76:  ldarg.0
    IL_0d77:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d7c:  ldc.i4.4
    IL_0d7d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0d82:  nop
//000331:             this.pbInProgressMorph.TabIndex = 12;
    IL_0d83:  ldarg.0
    IL_0d84:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d89:  ldc.i4.s   12
    IL_0d8b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_0d90:  nop
//000332:             this.pbInProgressMorph.TabStop = false;
    IL_0d91:  ldarg.0
    IL_0d92:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0d97:  ldc.i4.0
    IL_0d98:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_0d9d:  nop
//000333:             this.pbInProgressMorph.Visible = false;
    IL_0d9e:  ldarg.0
    IL_0d9f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0da4:  ldc.i4.0
    IL_0da5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_0daa:  nop
//000334:             // 
//000335:             // morphInfoToolStripMenuItem
//000336:             // 
//000337:             this.morphInfoToolStripMenuItem.Name = "morphInfoToolStripMenuItem";
    IL_0dab:  ldarg.0
    IL_0dac:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
    IL_0db1:  ldstr      "morphInfoToolStripMenuItem"
    IL_0db6:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0dbb:  nop
//000338:             this.morphInfoToolStripMenuItem.Size = new System.Drawing.Size(165, 22);
    IL_0dbc:  ldarg.0
    IL_0dbd:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
    IL_0dc2:  ldc.i4     0xa5
    IL_0dc7:  ldc.i4.s   22
    IL_0dc9:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0dce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0dd3:  nop
//000339:             this.morphInfoToolStripMenuItem.Text = "Morph Info...";
    IL_0dd4:  ldarg.0
    IL_0dd5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
    IL_0dda:  ldstr      "Morph Info..."
    IL_0ddf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_0de4:  nop
//000340:             this.morphInfoToolStripMenuItem.Click += new System.EventHandler(this.morphInfoToolStripMenuItem_Click);
    IL_0de5:  ldarg.0
    IL_0de6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::morphInfoToolStripMenuItem
    IL_0deb:  ldarg.0
    IL_0dec:  ldftn      instance void ParallelMorph.MainForm::morphInfoToolStripMenuItem_Click(object,
                                                                                                class [mscorlib]System.EventArgs)
    IL_0df2:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0df7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::add_Click(class [mscorlib]System.EventHandler)
    IL_0dfc:  nop
//000341:             // 
//000342:             // toolStripMenuItem3
//000343:             // 
//000344:             this.toolStripMenuItem3.Name = "toolStripMenuItem3";
    IL_0dfd:  ldarg.0
    IL_0dfe:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem3
    IL_0e03:  ldstr      "toolStripMenuItem3"
    IL_0e08:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Name(string)
    IL_0e0d:  nop
//000345:             this.toolStripMenuItem3.Size = new System.Drawing.Size(162, 6);
    IL_0e0e:  ldarg.0
    IL_0e0f:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripSeparator ParallelMorph.MainForm::toolStripMenuItem3
    IL_0e14:  ldc.i4     0xa2
    IL_0e19:  ldc.i4.6
    IL_0e1a:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0e1f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0e24:  nop
//000346:             // 
//000347:             // pbStartImage
//000348:             // 
//000349:             this.pbStartImage.ImageNumber = 0;
    IL_0e25:  ldarg.0
    IL_0e26:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e2b:  ldc.i4.0
    IL_0e2c:  callvirt   instance void ParallelMorph.LinedPictureBox::set_ImageNumber(int32)
    IL_0e31:  nop
//000350:             this.pbStartImage.LinePairs = null;
    IL_0e32:  ldarg.0
    IL_0e33:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e38:  ldnull
    IL_0e39:  callvirt   instance void ParallelMorph.LinedPictureBox::set_LinePairs(class ParallelMorph.LinePairCollection)
    IL_0e3e:  nop
//000351:             this.pbStartImage.Location = new System.Drawing.Point(0, 0);
    IL_0e3f:  ldarg.0
    IL_0e40:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e45:  ldc.i4.0
    IL_0e46:  ldc.i4.0
    IL_0e47:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0e4c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0e51:  nop
//000352:             this.pbStartImage.Name = "pbStartImage";
    IL_0e52:  ldarg.0
    IL_0e53:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e58:  ldstr      "pbStartImage"
    IL_0e5d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0e62:  nop
//000353:             this.pbStartImage.Size = new System.Drawing.Size(310, 315);
    IL_0e63:  ldarg.0
    IL_0e64:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e69:  ldc.i4     0x136
    IL_0e6e:  ldc.i4     0x13b
    IL_0e73:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0e78:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0e7d:  nop
//000354:             this.pbStartImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
    IL_0e7e:  ldarg.0
    IL_0e7f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e84:  ldc.i4.2
    IL_0e85:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0e8a:  nop
//000355:             this.pbStartImage.TabIndex = 0;
    IL_0e8b:  ldarg.0
    IL_0e8c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e91:  ldc.i4.0
    IL_0e92:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_0e97:  nop
//000356:             this.pbStartImage.TabStop = false;
    IL_0e98:  ldarg.0
    IL_0e99:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0e9e:  ldc.i4.0
    IL_0e9f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_0ea4:  nop
//000357:             this.pbStartImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
    IL_0ea5:  ldarg.0
    IL_0ea6:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0eab:  ldarg.0
    IL_0eac:  ldftn      instance void ParallelMorph.MainForm::LoadPictureBoxImage(object,
                                                                                   class [mscorlib]System.EventArgs)
    IL_0eb2:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0eb7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DoubleClick(class [mscorlib]System.EventHandler)
    IL_0ebc:  nop
//000358:             this.pbStartImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
    IL_0ebd:  ldarg.0
    IL_0ebe:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0ec3:  ldarg.0
    IL_0ec4:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseDown(object,
                                                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0eca:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0ecf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseDown(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0ed4:  nop
//000359:             this.pbStartImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
    IL_0ed5:  ldarg.0
    IL_0ed6:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0edb:  ldarg.0
    IL_0edc:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseMove(object,
                                                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0ee2:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0ee7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseMove(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0eec:  nop
//000360:             this.pbStartImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
    IL_0eed:  ldarg.0
    IL_0eee:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0ef3:  ldarg.0
    IL_0ef4:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseUp(object,
                                                                                  class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0efa:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0eff:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseUp(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0f04:  nop
//000361:             // 
//000362:             // pbEndImage
//000363:             // 
//000364:             this.pbEndImage.ImageNumber = 0;
    IL_0f05:  ldarg.0
    IL_0f06:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f0b:  ldc.i4.0
    IL_0f0c:  callvirt   instance void ParallelMorph.LinedPictureBox::set_ImageNumber(int32)
    IL_0f11:  nop
//000365:             this.pbEndImage.LinePairs = null;
    IL_0f12:  ldarg.0
    IL_0f13:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f18:  ldnull
    IL_0f19:  callvirt   instance void ParallelMorph.LinedPictureBox::set_LinePairs(class ParallelMorph.LinePairCollection)
    IL_0f1e:  nop
//000366:             this.pbEndImage.Location = new System.Drawing.Point(0, 0);
    IL_0f1f:  ldarg.0
    IL_0f20:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f25:  ldc.i4.0
    IL_0f26:  ldc.i4.0
    IL_0f27:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0f2c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0f31:  nop
//000367:             this.pbEndImage.Name = "pbEndImage";
    IL_0f32:  ldarg.0
    IL_0f33:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f38:  ldstr      "pbEndImage"
    IL_0f3d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0f42:  nop
//000368:             this.pbEndImage.Size = new System.Drawing.Size(307, 315);
    IL_0f43:  ldarg.0
    IL_0f44:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f49:  ldc.i4     0x133
    IL_0f4e:  ldc.i4     0x13b
    IL_0f53:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0f58:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0f5d:  nop
//000369:             this.pbEndImage.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
    IL_0f5e:  ldarg.0
    IL_0f5f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f64:  ldc.i4.2
    IL_0f65:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0f6a:  nop
//000370:             this.pbEndImage.TabIndex = 0;
    IL_0f6b:  ldarg.0
    IL_0f6c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f71:  ldc.i4.0
    IL_0f72:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabIndex(int32)
    IL_0f77:  nop
//000371:             this.pbEndImage.TabStop = false;
    IL_0f78:  ldarg.0
    IL_0f79:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f7e:  ldc.i4.0
    IL_0f7f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_TabStop(bool)
    IL_0f84:  nop
//000372:             this.pbEndImage.DoubleClick += new System.EventHandler(this.LoadPictureBoxImage);
    IL_0f85:  ldarg.0
    IL_0f86:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0f8b:  ldarg.0
    IL_0f8c:  ldftn      instance void ParallelMorph.MainForm::LoadPictureBoxImage(object,
                                                                                   class [mscorlib]System.EventArgs)
    IL_0f92:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_0f97:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_DoubleClick(class [mscorlib]System.EventHandler)
    IL_0f9c:  nop
//000373:             this.pbEndImage.MouseDown += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseDown);
    IL_0f9d:  ldarg.0
    IL_0f9e:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0fa3:  ldarg.0
    IL_0fa4:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseDown(object,
                                                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0faa:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0faf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseDown(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0fb4:  nop
//000374:             this.pbEndImage.MouseMove += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseMove);
    IL_0fb5:  ldarg.0
    IL_0fb6:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0fbb:  ldarg.0
    IL_0fbc:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseMove(object,
                                                                                    class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0fc2:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0fc7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseMove(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0fcc:  nop
//000375:             this.pbEndImage.MouseUp += new System.Windows.Forms.MouseEventHandler(this.pbAnyImage_MouseUp);
    IL_0fcd:  ldarg.0
    IL_0fce:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0fd3:  ldarg.0
    IL_0fd4:  ldftn      instance void ParallelMorph.MainForm::pbAnyImage_MouseUp(object,
                                                                                  class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs)
    IL_0fda:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.MouseEventHandler::.ctor(object,
                                                                                                           native int)
    IL_0fdf:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::add_MouseUp(class [System.Windows.Forms]System.Windows.Forms.MouseEventHandler)
    IL_0fe4:  nop
//000376:             // 
//000377:             // MainForm
//000378:             // 
//000379:             this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
    IL_0fe5:  ldarg.0
    IL_0fe6:  ldc.r4     6.
    IL_0feb:  ldc.r4     13.
    IL_0ff0:  newobj     instance void [System.Drawing]System.Drawing.SizeF::.ctor(float32,
                                                                                   float32)
    IL_0ff5:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleDimensions(valuetype [System.Drawing]System.Drawing.SizeF)
    IL_0ffa:  nop
//000380:             this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
    IL_0ffb:  ldarg.0
    IL_0ffc:  ldc.i4.1
    IL_0ffd:  call       instance void [System.Windows.Forms]System.Windows.Forms.ContainerControl::set_AutoScaleMode(valuetype [System.Windows.Forms]System.Windows.Forms.AutoScaleMode)
    IL_1002:  nop
//000381:             this.ClientSize = new System.Drawing.Size(649, 385);
    IL_1003:  ldarg.0
    IL_1004:  ldc.i4     0x289
    IL_1009:  ldc.i4     0x181
    IL_100e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_1013:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_1018:  nop
//000382:             this.Controls.Add(this.pbInProgressMorph);
    IL_1019:  ldarg.0
    IL_101a:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_101f:  ldarg.0
    IL_1020:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_1025:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_102a:  nop
//000383:             this.Controls.Add(this.btnCancel);
    IL_102b:  ldarg.0
    IL_102c:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_1031:  ldarg.0
    IL_1032:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_1037:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_103c:  nop
//000384:             this.Controls.Add(this.splitContainer1);
    IL_103d:  ldarg.0
    IL_103e:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_1043:  ldarg.0
    IL_1044:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_1049:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_104e:  nop
//000385:             this.Controls.Add(this.btnMorph);
    IL_104f:  ldarg.0
    IL_1050:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_1055:  ldarg.0
    IL_1056:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_105b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_1060:  nop
//000386:             this.Controls.Add(this.pbMorphStatus);
    IL_1061:  ldarg.0
    IL_1062:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_1067:  ldarg.0
    IL_1068:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_106d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_1072:  nop
//000387:             this.Controls.Add(this.menuStrip1);
    IL_1073:  ldarg.0
    IL_1074:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_1079:  ldarg.0
    IL_107a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_107f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_1084:  nop
//000388:             this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
    IL_1085:  ldarg.0
    IL_1086:  ldloc.0
    IL_1087:  ldstr      "$this.Icon"
    IL_108c:  callvirt   instance object [mscorlib]System.Resources.ResourceManager::GetObject(string)
    IL_1091:  castclass  [System.Drawing]System.Drawing.Icon
    IL_1096:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Icon(class [System.Drawing]System.Drawing.Icon)
    IL_109b:  nop
//000389:             this.KeyPreview = true;
    IL_109c:  ldarg.0
    IL_109d:  ldc.i4.1
    IL_109e:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_KeyPreview(bool)
    IL_10a3:  nop
//000390:             this.MainMenuStrip = this.menuStrip1;
    IL_10a4:  ldarg.0
    IL_10a5:  ldarg.0
    IL_10a6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_10ab:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_MainMenuStrip(class [System.Windows.Forms]System.Windows.Forms.MenuStrip)
    IL_10b0:  nop
//000391:             this.Name = "MainForm";
    IL_10b1:  ldarg.0
    IL_10b2:  ldstr      "MainForm"
    IL_10b7:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_10bc:  nop
//000392:             this.Text = "Parallel Morph";
    IL_10bd:  ldarg.0
    IL_10be:  ldstr      "Parallel Morph"
    IL_10c3:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_10c8:  nop
//000393:             this.Load += new System.EventHandler(this.Form1_Load);
    IL_10c9:  ldarg.0
    IL_10ca:  ldarg.0
    IL_10cb:  ldftn      instance void ParallelMorph.MainForm::Form1_Load(object,
                                                                          class [mscorlib]System.EventArgs)
    IL_10d1:  newobj     instance void [mscorlib]System.EventHandler::.ctor(object,
                                                                            native int)
    IL_10d6:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::add_Load(class [mscorlib]System.EventHandler)
    IL_10db:  nop
//000394:             this.KeyDown += new System.Windows.Forms.KeyEventHandler(this.frmMainForm_KeyDown);
    IL_10dc:  ldarg.0
    IL_10dd:  ldarg.0
    IL_10de:  ldftn      instance void ParallelMorph.MainForm::frmMainForm_KeyDown(object,
                                                                                   class [System.Windows.Forms]System.Windows.Forms.KeyEventArgs)
    IL_10e4:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.KeyEventHandler::.ctor(object,
                                                                                                         native int)
    IL_10e9:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::add_KeyDown(class [System.Windows.Forms]System.Windows.Forms.KeyEventHandler)
    IL_10ee:  nop
//000395:             this.splitContainer1.Panel1.ResumeLayout(false);
    IL_10ef:  ldarg.0
    IL_10f0:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_10f5:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_10fa:  ldc.i4.0
    IL_10fb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_1100:  nop
//000396:             this.splitContainer1.Panel1.PerformLayout();
    IL_1101:  ldarg.0
    IL_1102:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_1107:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel1()
    IL_110c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_1111:  nop
//000397:             this.splitContainer1.Panel2.ResumeLayout(false);
    IL_1112:  ldarg.0
    IL_1113:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_1118:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_111d:  ldc.i4.0
    IL_111e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_1123:  nop
//000398:             this.splitContainer1.Panel2.PerformLayout();
    IL_1124:  ldarg.0
    IL_1125:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_112a:  callvirt   instance class [System.Windows.Forms]System.Windows.Forms.SplitterPanel [System.Windows.Forms]System.Windows.Forms.SplitContainer::get_Panel2()
    IL_112f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_1134:  nop
//000399:             this.splitContainer1.ResumeLayout(false);
    IL_1135:  ldarg.0
    IL_1136:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_113b:  ldc.i4.0
    IL_113c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_1141:  nop
//000400:             this.menuStrip1.ResumeLayout(false);
    IL_1142:  ldarg.0
    IL_1143:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_1148:  ldc.i4.0
    IL_1149:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_114e:  nop
//000401:             this.menuStrip1.PerformLayout();
    IL_114f:  ldarg.0
    IL_1150:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_1155:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_115a:  nop
//000402:             this.ResumeLayout(false);
    IL_115b:  ldarg.0
    IL_115c:  ldc.i4.0
    IL_115d:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_1162:  nop
//000403:             this.PerformLayout();
    IL_1163:  ldarg.0
    IL_1164:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::PerformLayout()
    IL_1169:  nop
//000404: 
//000405:         }
    IL_116a:  ret
  } // end of method MainForm::InitializeComponent

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       56 (0x38)
    .maxstack  8
//000008:         private System.ComponentModel.IContainer components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.IContainer ParallelMorph.MainForm::components
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\MainForm.cs' 
//000024:         private UiSettings _morphSettings = new UiSettings();
    IL_0007:  ldarg.0
    IL_0008:  newobj     instance void ParallelMorph.UiSettings::.ctor()
    IL_000d:  stfld      class ParallelMorph.UiSettings ParallelMorph.MainForm::_morphSettings
//000025:         private LinePairCollection _lines;
//000026:         private int _currentLineImageNumber = 0;
    IL_0012:  ldarg.0
    IL_0013:  ldc.i4.0
    IL_0014:  stfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
//000027:         private int _currentLineEnd = 0;
    IL_0019:  ldarg.0
    IL_001a:  ldc.i4.0
    IL_001b:  stfld      int32 ParallelMorph.MainForm::_currentLineEnd
//000028:         private bool _lineCreationInProcess = false;
    IL_0020:  ldarg.0
    IL_0021:  ldc.i4.0
    IL_0022:  stfld      bool ParallelMorph.MainForm::_lineCreationInProcess
//000029:         private TaskFactory _uiThread;
//000030:         private ComputeMorph _morpher;
//000031:         private CancellationTokenSource _currentCancellationSource;
//000032: 
//000033:         public MainForm()
    IL_0027:  ldarg.0
    IL_0028:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_002d:  nop
//000034:         {
    IL_002e:  nop
//000035:             InitializeComponent();
    IL_002f:  ldarg.0
    IL_0030:  call       instance void ParallelMorph.MainForm::InitializeComponent()
    IL_0035:  nop
//000036:         }
    IL_0036:  nop
    IL_0037:  ret
  } // end of method MainForm::.ctor

  .method private hidebysig instance void 
          Form1_Load(object sender,
                     class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       109 (0x6d)
    .maxstack  4
    .locals init ([0] object CS$0$0000,
             [1] object[] CS$0$0001)
//000037: 
//000038:         private void Form1_Load(object sender, EventArgs e)
//000039:         {
    IL_0000:  nop
//000040:             // Create a Task factory to use for targetting the UI thread
//000041:             _uiThread = new TaskFactory(TaskScheduler.FromCurrentSynchronizationContext());
    IL_0001:  ldarg.0
    IL_0002:  call       class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskScheduler::FromCurrentSynchronizationContext()
    IL_0007:  newobj     instance void [mscorlib]System.Threading.Tasks.TaskFactory::.ctor(class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_000c:  stfld      class [mscorlib]System.Threading.Tasks.TaskFactory ParallelMorph.MainForm::_uiThread
//000042: 
//000043:             // Initialize the picture boxes
//000044:             _lines = new LinePairCollection();
    IL_0011:  ldarg.0
    IL_0012:  newobj     instance void ParallelMorph.LinePairCollection::.ctor()
    IL_0017:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
//000045:             ConfigurePictureBoxes(_lines, null, null);
    IL_001c:  ldarg.0
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0023:  ldnull
    IL_0024:  ldnull
    IL_0025:  call       instance void ParallelMorph.MainForm::ConfigurePictureBoxes(class ParallelMorph.LinePairCollection,
                                                                                     class [System.Drawing]System.Drawing.Image,
                                                                                     class [System.Drawing]System.Drawing.Image)
    IL_002a:  nop
//000046: 
//000047:             // Set up the parallel menu item to reflect the number of cores
//000048:             parallelProcessingModeToolStripMenuItem.Text += " (" + Environment.ProcessorCount + "x)";
    IL_002b:  ldarg.0
    IL_002c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_0031:  dup
    IL_0032:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.ToolStripItem::get_Text()
    IL_0037:  stloc.0
    IL_0038:  ldc.i4.4
    IL_0039:  newarr     [mscorlib]System.Object
    IL_003e:  stloc.1
    IL_003f:  ldloc.1
    IL_0040:  ldc.i4.0
    IL_0041:  ldloc.0
    IL_0042:  stelem.ref
    IL_0043:  ldloc.1
    IL_0044:  ldc.i4.1
    IL_0045:  ldstr      " ("
    IL_004a:  stelem.ref
    IL_004b:  ldloc.1
    IL_004c:  ldc.i4.2
    IL_004d:  call       int32 [mscorlib]System.Environment::get_ProcessorCount()
    IL_0052:  box        [mscorlib]System.Int32
    IL_0057:  stelem.ref
    IL_0058:  ldloc.1
    IL_0059:  ldc.i4.3
    IL_005a:  ldstr      "x)"
    IL_005f:  stelem.ref
    IL_0060:  ldloc.1
    IL_0061:  call       string [mscorlib]System.String::Concat(object[])
    IL_0066:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripItem::set_Text(string)
    IL_006b:  nop
//000049:         }
    IL_006c:  ret
  } // end of method MainForm::Form1_Load

  .method private hidebysig instance void 
          ConfigurePictureBoxes(class ParallelMorph.LinePairCollection lines,
                                class [System.Drawing]System.Drawing.Image startImage,
                                class [System.Drawing]System.Drawing.Image endImage) cil managed
  {
    // Code size       305 (0x131)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000050: 
//000051:         private void ConfigurePictureBoxes(LinePairCollection lines, Image startImage, Image endImage)
//000052:         {
    IL_0000:  nop
//000053:             // The lines collection stores the line pairs.  Configure the start image to selec the 0th line from each pair.
//000054:             pbStartImage.LinePairs = _lines;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  ldarg.0
    IL_0008:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_000d:  callvirt   instance void ParallelMorph.LinedPictureBox::set_LinePairs(class ParallelMorph.LinePairCollection)
    IL_0012:  nop
//000055:             pbStartImage.ImageNumber = 0;
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0019:  ldc.i4.0
    IL_001a:  callvirt   instance void ParallelMorph.LinedPictureBox::set_ImageNumber(int32)
    IL_001f:  nop
//000056:             pbStartImage.Image = startImage;
    IL_0020:  ldarg.0
    IL_0021:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0026:  ldarg.2
    IL_0027:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_002c:  nop
//000057: 
//000058:             // ... and configure the start image to selec the 0th line from each pair.
//000059:             pbEndImage.LinePairs = _lines;
    IL_002d:  ldarg.0
    IL_002e:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0039:  callvirt   instance void ParallelMorph.LinedPictureBox::set_LinePairs(class ParallelMorph.LinePairCollection)
    IL_003e:  nop
//000060:             pbEndImage.ImageNumber = 1;
    IL_003f:  ldarg.0
    IL_0040:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0045:  ldc.i4.1
    IL_0046:  callvirt   instance void ParallelMorph.LinedPictureBox::set_ImageNumber(int32)
    IL_004b:  nop
//000061:             pbEndImage.Image = endImage;
    IL_004c:  ldarg.0
    IL_004d:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0052:  ldarg.3
    IL_0053:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
    IL_0058:  nop
//000062: 
//000063:             if (autoSizeToolStripMenuItem.Checked)
    IL_0059:  ldarg.0
    IL_005a:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_005f:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::get_Checked()
    IL_0064:  ldc.i4.0
    IL_0065:  ceq
    IL_0067:  stloc.0
//000064:             {
//000065:                 pbStartImage.Dock = DockStyle.None;
//000066:                 pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000067:                 pbEndImage.Dock = DockStyle.None;
//000068:                 pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000069:             }
//000070:             else if (zoomToolStripMenuItem.Checked)
//000071:             {
//000072:                 pbStartImage.Dock = DockStyle.Fill;
//000073:                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000074:                 pbEndImage.Dock = DockStyle.Fill;
//000075:                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000076:             }
//000077: 
//000078:             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
//000079: 
//000080:             pbStartImage.Refresh();
//000081:             pbEndImage.Refresh();
//000082:         }
//000083: 
//000084:         private string SelectOutputPath(OutputMode mode)
//000085:         {
//000086:             switch (mode)
//000087:             {
//000088:                 case OutputMode.Movie:
//000089:                     // Get target movie path
//000090:                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
//000092:                     else return null;
//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0068:  ldloc.0
    IL_0069:  brtrue.s   IL_00a3

//000064:             {
    IL_006b:  nop
//000065:                 pbStartImage.Dock = DockStyle.None;
    IL_006c:  ldarg.0
    IL_006d:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0072:  ldc.i4.0
    IL_0073:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0078:  nop
//000066:                 pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
    IL_0079:  ldarg.0
    IL_007a:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_007f:  ldc.i4.2
    IL_0080:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0085:  nop
//000067:                 pbEndImage.Dock = DockStyle.None;
    IL_0086:  ldarg.0
    IL_0087:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_008c:  ldc.i4.0
    IL_008d:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0092:  nop
//000068:                 pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
    IL_0093:  ldarg.0
    IL_0094:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0099:  ldc.i4.2
    IL_009a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_009f:  nop
//000069:             }
    IL_00a0:  nop
//000070:             else if (zoomToolStripMenuItem.Checked)
//000071:             {
//000072:                 pbStartImage.Dock = DockStyle.Fill;
//000073:                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000074:                 pbEndImage.Dock = DockStyle.Fill;
//000075:                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000076:             }
//000077: 
//000078:             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
//000079: 
//000080:             pbStartImage.Refresh();
//000081:             pbEndImage.Refresh();
//000082:         }
//000083: 
//000084:         private string SelectOutputPath(OutputMode mode)
//000085:         {
//000086:             switch (mode)
//000087:             {
//000088:                 case OutputMode.Movie:
//000089:                     // Get target movie path
//000090:                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
//000092:                     else return null;
//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_00a1:  br.s       IL_00eb

//000070:             else if (zoomToolStripMenuItem.Checked)
    IL_00a3:  ldarg.0
    IL_00a4:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_00a9:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::get_Checked()
    IL_00ae:  ldc.i4.0
    IL_00af:  ceq
    IL_00b1:  stloc.0
//000071:             {
//000072:                 pbStartImage.Dock = DockStyle.Fill;
//000073:                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000074:                 pbEndImage.Dock = DockStyle.Fill;
//000075:                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000076:             }
//000077: 
//000078:             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
//000079: 
//000080:             pbStartImage.Refresh();
//000081:             pbEndImage.Refresh();
//000082:         }
//000083: 
//000084:         private string SelectOutputPath(OutputMode mode)
//000085:         {
//000086:             switch (mode)
//000087:             {
//000088:                 case OutputMode.Movie:
//000089:                     // Get target movie path
//000090:                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
//000092:                     else return null;
//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_00b2:  ldloc.0
    IL_00b3:  brtrue.s   IL_00eb

//000071:             {
    IL_00b5:  nop
//000072:                 pbStartImage.Dock = DockStyle.Fill;
    IL_00b6:  ldarg.0
    IL_00b7:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00bc:  ldc.i4.5
    IL_00bd:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_00c2:  nop
//000073:                 pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
    IL_00c3:  ldarg.0
    IL_00c4:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00c9:  ldc.i4.4
    IL_00ca:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_00cf:  nop
//000074:                 pbEndImage.Dock = DockStyle.Fill;
    IL_00d0:  ldarg.0
    IL_00d1:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00d6:  ldc.i4.5
    IL_00d7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_00dc:  nop
//000075:                 pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
    IL_00dd:  ldarg.0
    IL_00de:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00e3:  ldc.i4.4
    IL_00e4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_00e9:  nop
//000076:             }
    IL_00ea:  nop
//000077: 
//000078:             btnMorph.Enabled = pbStartImage.Image != null && pbEndImage.Image != null;
    IL_00eb:  ldarg.0
    IL_00ec:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_00f1:  ldarg.0
    IL_00f2:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00f7:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00fc:  brfalse.s  IL_0111

    IL_00fe:  ldarg.0
    IL_00ff:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0104:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0109:  ldnull
    IL_010a:  ceq
    IL_010c:  ldc.i4.0
    IL_010d:  ceq
    IL_010f:  br.s       IL_0112

    IL_0111:  ldc.i4.0
    IL_0112:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0117:  nop
//000079: 
//000080:             pbStartImage.Refresh();
    IL_0118:  ldarg.0
    IL_0119:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_011e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_0123:  nop
//000081:             pbEndImage.Refresh();
    IL_0124:  ldarg.0
    IL_0125:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_012a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_012f:  nop
//000082:         }
    IL_0130:  ret
  } // end of method MainForm::ConfigurePictureBoxes

  .method private hidebysig instance string 
          SelectOutputPath(valuetype ParallelMorph.OutputMode mode) cil managed
  {
    // Code size       119 (0x77)
    .maxstack  2
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.SaveFileDialog sfd,
             [1] class [System.Windows.Forms]System.Windows.Forms.FolderBrowserDialog fbd,
             [2] class [System.Windows.Forms]System.Windows.Forms.SaveFileDialog '<>g__initLocal0',
             [3] string CS$1$0000,
             [4] valuetype ParallelMorph.OutputMode CS$4$0001,
             [5] bool CS$4$0002)
//000083: 
//000084:         private string SelectOutputPath(OutputMode mode)
//000085:         {
    IL_0000:  nop
//000086:             switch (mode)
    IL_0001:  ldarg.1
    IL_0002:  stloc.s    CS$4$0001
//000087:             {
//000088:                 case OutputMode.Movie:
//000089:                     // Get target movie path
//000090:                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
//000092:                     else return null;
//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0004:  ldloc.s    CS$4$0001
    IL_0006:  switch     ( 
                          IL_0015,
                          IL_0049)
    IL_0013:  br.s       IL_006f

//000090:                     var sfd = new SaveFileDialog() { Filter = "AVI Files (*.avi)|*.avi" };
    IL_0015:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.SaveFileDialog::.ctor()
    IL_001a:  stloc.2
    IL_001b:  ldloc.2
    IL_001c:  ldstr      "AVI Files (*.avi)|*.avi"
    IL_0021:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
    IL_0026:  nop
    IL_0027:  ldloc.2
    IL_0028:  stloc.0
//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
    IL_0029:  ldloc.0
    IL_002a:  ldarg.0
    IL_002b:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
    IL_0030:  ldc.i4.1
    IL_0031:  ceq
    IL_0033:  ldc.i4.0
    IL_0034:  ceq
    IL_0036:  stloc.s    CS$4$0002
//000092:                     else return null;
//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0038:  ldloc.s    CS$4$0002
    IL_003a:  brtrue.s   IL_0045

//000091:                     if (sfd.ShowDialog(this) == DialogResult.OK) return sfd.FileName;
    IL_003c:  ldloc.0
    IL_003d:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
    IL_0042:  stloc.3
    IL_0043:  br.s       IL_0075

//000092:                     else return null;
    IL_0045:  ldnull
    IL_0046:  stloc.3
    IL_0047:  br.s       IL_0075

//000093: 
//000094:                 case OutputMode.ImageSequence:
//000095:                     // Get target directory path
//000096:                     var fbd = new FolderBrowserDialog();
    IL_0049:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.FolderBrowserDialog::.ctor()
    IL_004e:  stloc.1
//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
    IL_004f:  ldloc.1
    IL_0050:  ldarg.0
    IL_0051:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
    IL_0056:  ldc.i4.1
    IL_0057:  ceq
    IL_0059:  ldc.i4.0
    IL_005a:  ceq
    IL_005c:  stloc.s    CS$4$0002
//000098:                     else return null;
//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
//000102:             }
//000103:         }
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_005e:  ldloc.s    CS$4$0002
    IL_0060:  brtrue.s   IL_006b

//000097:                     if (fbd.ShowDialog(this) == DialogResult.OK) return fbd.SelectedPath;
    IL_0062:  ldloc.1
    IL_0063:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FolderBrowserDialog::get_SelectedPath()
    IL_0068:  stloc.3
    IL_0069:  br.s       IL_0075

//000098:                     else return null;
    IL_006b:  ldnull
    IL_006c:  stloc.3
    IL_006d:  br.s       IL_0075

//000099: 
//000100:                 default:
//000101:                     throw new InvalidOperationException();
    IL_006f:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor()
    IL_0074:  throw

//000102:             }
//000103:         }
    IL_0075:  ldloc.3
    IL_0076:  ret
  } // end of method MainForm::SelectOutputPath

  .method private hidebysig instance void 
          PrepareUIDataForMorph([out] class ParallelMorph.UiSettings& settings,
                                [out] class ParallelMorph.LinePairCollection& lines,
                                [out] class [System.Drawing]System.Drawing.Bitmap& newStartImage,
                                [out] class [System.Drawing]System.Drawing.Bitmap& newEndImage) cil managed
  {
    // Code size       222 (0xde)
    .maxstack  4
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap origStartImage,
             [1] class [System.Drawing]System.Drawing.Bitmap origEndImage,
             [2] class [mscorlib]System.Collections.Generic.List`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> newlineList,
             [3] class ParallelMorph.MainForm/'<>c__DisplayClass2' 'CS$<>8__locals3')
//000104: 
//000105:         private void PrepareUIDataForMorph(
//000106:             out UiSettings settings, out LinePairCollection lines,
//000107:             out Bitmap newStartImage, out Bitmap newEndImage)
//000108:         {
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
//000111:             lines = Utilities.DeepClone(_lines);
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
//000141:         }
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0000:  newobj     instance void ParallelMorph.MainForm/'<>c__DisplayClass2'::.ctor()
    IL_0005:  stloc.3
//000108:         {
    IL_0006:  nop
//000109:             // Grab UI data
//000110:             settings = Utilities.DeepClone(_morphSettings);
    IL_0007:  ldarg.1
    IL_0008:  ldarg.0
    IL_0009:  ldfld      class ParallelMorph.UiSettings ParallelMorph.MainForm::_morphSettings
    IL_000e:  call       !!0 ParallelMorph.Utilities::DeepClone<class ParallelMorph.UiSettings>(!!0)
    IL_0013:  stind.ref
//000111:             lines = Utilities.DeepClone(_lines);
    IL_0014:  ldarg.2
    IL_0015:  ldarg.0
    IL_0016:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_001b:  call       !!0 ParallelMorph.Utilities::DeepClone<class ParallelMorph.LinePairCollection>(!!0)
    IL_0020:  stind.ref
//000112: 
//000113:             // Get the original iamges
//000114:             var origStartImage = (Bitmap)pbStartImage.Image;
    IL_0021:  ldarg.0
    IL_0022:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0027:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_002c:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0031:  stloc.0
//000115:             var origEndImage = (Bitmap)pbEndImage.Image;
    IL_0032:  ldarg.0
    IL_0033:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0038:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_003d:  castclass  [System.Drawing]System.Drawing.Bitmap
    IL_0042:  stloc.1
//000116: 
//000117:             // Get a scale factor from the UI
//000118:             float startImageScaleFactor = int.Parse(outputSizeToolStripTextBox.Text) / 100f;
    IL_0043:  ldloc.3
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripTextBox ParallelMorph.MainForm::outputSizeToolStripTextBox
    IL_004a:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.ToolStripItem::get_Text()
    IL_004f:  call       int32 [mscorlib]System.Int32::Parse(string)
    IL_0054:  conv.r4
    IL_0055:  ldc.r4     100.
    IL_005a:  div
    IL_005b:  stfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
//000119: 
//000120:             // Create the starting and ending images.  The starting image is scaled by the UI setting,
//000121:             // and the ending image is created to match the starting image's size.
//000122:             newStartImage = Utilities.CreateNewBitmapFrom(origStartImage, startImageScaleFactor);
    IL_0060:  ldarg.3
    IL_0061:  ldloc.0
    IL_0062:  ldloc.3
    IL_0063:  ldfld      float32 ParallelMorph.MainForm/'<>c__DisplayClass2'::startImageScaleFactor
    IL_0068:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image,
                                                                                                                  float32)
    IL_006d:  stind.ref
//000123:             newEndImage = Utilities.CreateNewBitmapFrom(origEndImage, newStartImage.Width, newStartImage.Height);
    IL_006e:  ldarg.s    newEndImage
    IL_0070:  ldloc.1
    IL_0071:  ldarg.3
    IL_0072:  ldind.ref
    IL_0073:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0078:  ldarg.3
    IL_0079:  ldind.ref
    IL_007a:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_007f:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image,
                                                                                                                  int32,
                                                                                                                  int32)
    IL_0084:  stind.ref
//000124: 
//000125:             // Get a scale factor by comparing the new and old ending images
//000126:             var endImageScaleFactor = new PointF(
    IL_0085:  ldloc.3
    IL_0086:  ldflda     valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.MainForm/'<>c__DisplayClass2'::endImageScaleFactor
    IL_008b:  ldarg.s    newEndImage
    IL_008d:  ldind.ref
    IL_008e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0093:  conv.r4
    IL_0094:  ldloc.1
    IL_0095:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_009a:  conv.r4
    IL_009b:  div
    IL_009c:  ldarg.s    newEndImage
    IL_009e:  ldind.ref
    IL_009f:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_00a4:  conv.r4
    IL_00a5:  ldloc.1
    IL_00a6:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_00ab:  conv.r4
    IL_00ac:  div
    IL_00ad:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_00b2:  stobj      [System.Drawing]System.Drawing.PointF
//000127:                 newEndImage.Width / (float)origEndImage.Width,
//000128:                 newEndImage.Height / (float)origEndImage.Height);
//000129: 
//000130:             // Create new line pairings to cope with the scaling
//000131:             var newlineList =
    IL_00b7:  ldarg.0
    IL_00b8:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_00bd:  ldloc.3
    IL_00be:  ldftn      instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.MainForm/'<>c__DisplayClass2'::'<PrepareUIDataForMorph>b__1'(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
    IL_00c4:  newobj     instance void class [mscorlib]System.Func`2<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>,class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::.ctor(object,
                                                                                                                                                                                                                                                 native int)
    IL_00c9:  call       class [mscorlib]System.Collections.Generic.IEnumerable`1<!!1> [System.Core]System.Linq.Enumerable::Select<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>,class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>,
                                                                                                                                                                                                                                                                                                        class [mscorlib]System.Func`2<!!0,!!1>)
    IL_00ce:  call       class [mscorlib]System.Collections.Generic.List`1<!!0> [System.Core]System.Linq.Enumerable::ToList<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>(class [mscorlib]System.Collections.Generic.IEnumerable`1<!!0>)
    IL_00d3:  stloc.2
//000132:                 (from pair in _lines
//000133:                  select Tuple.Create(
//000134:                      new Line(
//000135:                      new PointF(pair.Item1.Item1.X * startImageScaleFactor, pair.Item1.Item1.Y * startImageScaleFactor),
//000136:                      new PointF(pair.Item1.Item2.X * startImageScaleFactor, pair.Item1.Item2.Y * startImageScaleFactor)),
//000137:                      new Line(
//000138:                      new PointF(pair.Item2.Item1.X * endImageScaleFactor.X, pair.Item2.Item1.Y * endImageScaleFactor.Y),
//000139:                      new PointF(pair.Item2.Item2.X * endImageScaleFactor.X, pair.Item2.Item2.Y * endImageScaleFactor.Y)))).ToList();
//000140:             lines = new LinePairCollection(newlineList);
    IL_00d4:  ldarg.2
    IL_00d5:  ldloc.2
    IL_00d6:  newobj     instance void ParallelMorph.LinePairCollection::.ctor(class [mscorlib]System.Collections.Generic.IList`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>)
    IL_00db:  stind.ref
//000141:         }
    IL_00dc:  nop
    IL_00dd:  ret
  } // end of method MainForm::PrepareUIDataForMorph

  .method private hidebysig instance void 
          btnMorph_Click(object sender,
                         class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       395 (0x18b)
    .maxstack  5
    .locals init ([0] bool useParallelism,
             [1] valuetype [mscorlib]System.Threading.CancellationToken cancellationToken,
             [2] class ParallelMorph.MainForm/'<>c__DisplayClassa' 'CS$<>8__localsb',
             [3] bool CS$4$0000)
//000142: 
//000143:         private void btnMorph_Click(object sender, EventArgs e)
//000144:         {
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0000:  newobj     instance void ParallelMorph.MainForm/'<>c__DisplayClassa'::.ctor()
    IL_0005:  stloc.2
    IL_0006:  ldloc.2
    IL_0007:  ldarg.0
    IL_0008:  stfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassa'::'<>4__this'
//000144:         {
    IL_000d:  nop
//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0014:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0019:  brfalse.s  IL_002e

    IL_001b:  ldarg.0
    IL_001c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0021:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0026:  ldnull
    IL_0027:  ceq
    IL_0029:  ldc.i4.0
    IL_002a:  ceq
    IL_002c:  br.s       IL_002f

    IL_002e:  ldc.i4.0
    IL_002f:  stloc.3
//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
//000150:             string outputPath = SelectOutputPath(outputMode);
//000151:             if (outputPath == null) return;
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0030:  ldloc.3
    IL_0031:  brtrue.s   IL_0038

//000145:             if (pbStartImage.Image == null || pbEndImage.Image == null) return;
    IL_0033:  br         IL_018a

//000146: 
//000147:             // Get the parallel mode, the output mode, and query the user for the output path
//000148:             bool useParallelism = parallelProcessingModeToolStripMenuItem.Checked;
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_003e:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::get_Checked()
    IL_0043:  stloc.0
//000149:             OutputMode outputMode = aviOutputToolStripMenuItem.Checked ? OutputMode.Movie : OutputMode.ImageSequence;
    IL_0044:  ldloc.2
    IL_0045:  ldarg.0
    IL_0046:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_004b:  callvirt   instance bool [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::get_Checked()
    IL_0050:  brtrue.s   IL_0055

    IL_0052:  ldc.i4.1
    IL_0053:  br.s       IL_0056

    IL_0055:  ldc.i4.0
    IL_0056:  stfld      valuetype ParallelMorph.OutputMode ParallelMorph.MainForm/'<>c__DisplayClassa'::outputMode
//000150:             string outputPath = SelectOutputPath(outputMode);
    IL_005b:  ldloc.2
    IL_005c:  ldarg.0
    IL_005d:  ldloc.2
    IL_005e:  ldfld      valuetype ParallelMorph.OutputMode ParallelMorph.MainForm/'<>c__DisplayClassa'::outputMode
    IL_0063:  call       instance string ParallelMorph.MainForm::SelectOutputPath(valuetype ParallelMorph.OutputMode)
    IL_0068:  stfld      string ParallelMorph.MainForm/'<>c__DisplayClassa'::outputPath
//000151:             if (outputPath == null) return;
    IL_006d:  ldloc.2
    IL_006e:  ldfld      string ParallelMorph.MainForm/'<>c__DisplayClassa'::outputPath
    IL_0073:  ldnull
    IL_0074:  ceq
    IL_0076:  ldc.i4.0
    IL_0077:  ceq
    IL_0079:  stloc.3
//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
//000161:             pbMorphStatus.Visible = true;
//000162:             splitContainer1.Visible = false;
//000163:             menuStrip1.Enabled = false;
//000164:             btnCancel.Visible = true;
//000165:             btnCancel.Enabled = true;
//000166:             btnMorph.Enabled = false;
//000167:             pbInProgressMorph.Visible = true;
//000168:             _currentCancellationSource = new CancellationTokenSource();
//000169:             var cancellationToken = _currentCancellationSource.Token;
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_007a:  ldloc.3
    IL_007b:  brtrue.s   IL_0082

//000151:             if (outputPath == null) return;
    IL_007d:  br         IL_018a

//000152: 
//000153:             // Grab UI data
//000154:             UiSettings settings;
//000155:             LinePairCollection lines;
//000156:             Bitmap startImage, endImage;
//000157:             PrepareUIDataForMorph(out settings, out lines, out startImage, out endImage);
    IL_0082:  ldarg.0
    IL_0083:  ldloc.2
    IL_0084:  ldflda     class ParallelMorph.UiSettings ParallelMorph.MainForm/'<>c__DisplayClassa'::settings
    IL_0089:  ldloc.2
    IL_008a:  ldflda     class ParallelMorph.LinePairCollection ParallelMorph.MainForm/'<>c__DisplayClassa'::lines
    IL_008f:  ldloc.2
    IL_0090:  ldflda     class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::startImage
    IL_0095:  ldloc.2
    IL_0096:  ldflda     class [System.Drawing]System.Drawing.Bitmap ParallelMorph.MainForm/'<>c__DisplayClassa'::endImage
    IL_009b:  call       instance void ParallelMorph.MainForm::PrepareUIDataForMorph(class ParallelMorph.UiSettings&,
                                                                                     class ParallelMorph.LinePairCollection&,
                                                                                     class [System.Drawing]System.Drawing.Bitmap&,
                                                                                     class [System.Drawing]System.Drawing.Bitmap&)
    IL_00a0:  nop
//000158: 
//000159:             // Setup UI for run
//000160:             this.Text = "Parallel Morph - Running...";
    IL_00a1:  ldarg.0
    IL_00a2:  ldstr      "Parallel Morph - Running..."
    IL_00a7:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_00ac:  nop
//000161:             pbMorphStatus.Visible = true;
    IL_00ad:  ldarg.0
    IL_00ae:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ProgressBar ParallelMorph.MainForm::pbMorphStatus
    IL_00b3:  ldc.i4.1
    IL_00b4:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_00b9:  nop
//000162:             splitContainer1.Visible = false;
    IL_00ba:  ldarg.0
    IL_00bb:  ldfld      class [System.Windows.Forms]System.Windows.Forms.SplitContainer ParallelMorph.MainForm::splitContainer1
    IL_00c0:  ldc.i4.0
    IL_00c1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_00c6:  nop
//000163:             menuStrip1.Enabled = false;
    IL_00c7:  ldarg.0
    IL_00c8:  ldfld      class [System.Windows.Forms]System.Windows.Forms.MenuStrip ParallelMorph.MainForm::menuStrip1
    IL_00cd:  ldc.i4.0
    IL_00ce:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00d3:  nop
//000164:             btnCancel.Visible = true;
    IL_00d4:  ldarg.0
    IL_00d5:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_00da:  ldc.i4.1
    IL_00db:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_00e0:  nop
//000165:             btnCancel.Enabled = true;
    IL_00e1:  ldarg.0
    IL_00e2:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_00e7:  ldc.i4.1
    IL_00e8:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00ed:  nop
//000166:             btnMorph.Enabled = false;
    IL_00ee:  ldarg.0
    IL_00ef:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_00f4:  ldc.i4.0
    IL_00f5:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_00fa:  nop
//000167:             pbInProgressMorph.Visible = true;
    IL_00fb:  ldarg.0
    IL_00fc:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PictureBox ParallelMorph.MainForm::pbInProgressMorph
    IL_0101:  ldc.i4.1
    IL_0102:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Visible(bool)
    IL_0107:  nop
//000168:             _currentCancellationSource = new CancellationTokenSource();
    IL_0108:  ldarg.0
    IL_0109:  newobj     instance void [mscorlib]System.Threading.CancellationTokenSource::.ctor()
    IL_010e:  stfld      class [mscorlib]System.Threading.CancellationTokenSource ParallelMorph.MainForm::_currentCancellationSource
//000169:             var cancellationToken = _currentCancellationSource.Token;
    IL_0113:  ldarg.0
    IL_0114:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource ParallelMorph.MainForm::_currentCancellationSource
    IL_0119:  callvirt   instance valuetype [mscorlib]System.Threading.CancellationToken [mscorlib]System.Threading.CancellationTokenSource::get_Token()
    IL_011e:  stloc.1
//000170: 
//000171:             // Time how long the operation takes
//000172:             Stopwatch startTime = Stopwatch.StartNew();
    IL_011f:  ldloc.2
    IL_0120:  call       class [System]System.Diagnostics.Stopwatch [System]System.Diagnostics.Stopwatch::StartNew()
    IL_0125:  stfld      class [System]System.Diagnostics.Stopwatch ParallelMorph.MainForm/'<>c__DisplayClassa'::startTime
//000173: 
//000174:             // Create the morpher and launch the algorithm to run asynchronously
//000175:             _morpher = new ComputeMorph(settings, useParallelism, cancellationToken);
    IL_012a:  ldarg.0
    IL_012b:  ldloc.2
    IL_012c:  ldfld      class ParallelMorph.UiSettings ParallelMorph.MainForm/'<>c__DisplayClassa'::settings
    IL_0131:  ldloc.0
    IL_0132:  ldloc.1
    IL_0133:  newobj     instance void ParallelMorph.ComputeMorph::.ctor(class ParallelMorph.ComputeMorphOptions,
                                                                         bool,
                                                                         valuetype [mscorlib]System.Threading.CancellationToken)
    IL_0138:  stfld      class ParallelMorph.ComputeMorph ParallelMorph.MainForm::_morpher
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
    IL_013d:  ldarg.0
    IL_013e:  ldfld      class ParallelMorph.ComputeMorph ParallelMorph.MainForm::_morpher
    IL_0143:  ldarg.0
    IL_0144:  ldftn      instance void ParallelMorph.MainForm::'<btnMorph_Click>b__4'(object,
                                                                                      class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_014a:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventHandler::.ctor(object,
                                                                                                        native int)
    IL_014f:  callvirt   instance void ParallelMorph.ComputeMorph::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    IL_0154:  nop
//000177:             Task.Factory.StartNew(() =>
    IL_0155:  call       class [mscorlib]System.Threading.Tasks.TaskFactory [mscorlib]System.Threading.Tasks.Task::get_Factory()
    IL_015a:  ldloc.2
    IL_015b:  ldftn      instance void ParallelMorph.MainForm/'<>c__DisplayClassa'::'<btnMorph_Click>b__7'()
    IL_0161:  newobj     instance void [mscorlib]System.Action::.ctor(object,
                                                                      native int)
    IL_0166:  ldloc.1
    IL_0167:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.TaskFactory::StartNew(class [mscorlib]System.Action,
                                                                                                                                     valuetype [mscorlib]System.Threading.CancellationToken)
    IL_016c:  ldloc.2
    IL_016d:  ldftn      instance void ParallelMorph.MainForm/'<>c__DisplayClassa'::'<btnMorph_Click>b__6'(class [mscorlib]System.Threading.Tasks.Task)
    IL_0173:  newobj     instance void class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>::.ctor(object,
                                                                                                                           native int)
    IL_0178:  ldarg.0
    IL_0179:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory ParallelMorph.MainForm::_uiThread
    IL_017e:  callvirt   instance class [mscorlib]System.Threading.Tasks.TaskScheduler [mscorlib]System.Threading.Tasks.TaskFactory::get_Scheduler()
    IL_0183:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task [mscorlib]System.Threading.Tasks.Task::ContinueWith(class [mscorlib]System.Action`1<class [mscorlib]System.Threading.Tasks.Task>,
                                                                                                                                  class [mscorlib]System.Threading.Tasks.TaskScheduler)
    IL_0188:  pop
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
    IL_0189:  nop
    IL_018a:  ret
  } // end of method MainForm::btnMorph_Click

  .method private hidebysig instance void 
          frmMainForm_KeyDown(object sender,
                              class [System.Windows.Forms]System.Windows.Forms.KeyEventArgs e) cil managed
  {
    // Code size       180 (0xb4)
    .maxstack  2
    .locals init ([0] valuetype [System.Windows.Forms]System.Windows.Forms.Keys CS$4$0000,
             [1] bool CS$4$0001)
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
    IL_0000:  nop
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.Keys [System.Windows.Forms]System.Windows.Forms.KeyEventArgs::get_KeyCode()
    IL_0007:  stloc.0
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0008:  ldloc.0
    IL_0009:  ldc.i4.s   40
    IL_000b:  bgt.s      IL_002c

    IL_000d:  ldloc.0
    IL_000e:  ldc.i4.8
    IL_000f:  beq.s      IL_0070

    IL_0011:  ldloc.0
    IL_0012:  ldc.i4.s   37
    IL_0014:  sub
    IL_0015:  switch     ( 
                          IL_0046,
                          IL_0054,
                          IL_0038,
                          IL_0062)
    IL_002a:  br.s       IL_009b

    IL_002c:  ldloc.0
    IL_002d:  ldc.i4.s   46
    IL_002f:  beq.s      IL_0070

    IL_0031:  ldloc.0
    IL_0032:  ldc.i4.s   68
    IL_0034:  beq.s      IL_0070

    IL_0036:  br.s       IL_009b

//000229:                 case Keys.Right: _lines.SelectNext(); break;
    IL_0038:  ldarg.0
    IL_0039:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_003e:  callvirt   instance void ParallelMorph.LinePairCollection::SelectNext()
    IL_0043:  nop
    IL_0044:  br.s       IL_009b

//000230:                 case Keys.Left: _lines.SelectPrev(); break;
    IL_0046:  ldarg.0
    IL_0047:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_004c:  callvirt   instance void ParallelMorph.LinePairCollection::SelectPrev()
    IL_0051:  nop
    IL_0052:  br.s       IL_009b

//000231:                 case Keys.Up: _lines.SelectFirst(); break;
    IL_0054:  ldarg.0
    IL_0055:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_005a:  callvirt   instance void ParallelMorph.LinePairCollection::SelectFirst()
    IL_005f:  nop
    IL_0060:  br.s       IL_009b

//000232:                 case Keys.Down: _lines.SelectLast(); break;
    IL_0062:  ldarg.0
    IL_0063:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0068:  callvirt   instance void ParallelMorph.LinePairCollection::SelectLast()
    IL_006d:  nop
    IL_006e:  br.s       IL_009b

//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
    IL_0070:  ldarg.0
    IL_0071:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0076:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_007b:  ldnull
    IL_007c:  ceq
    IL_007e:  stloc.1
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_007f:  ldloc.1
    IL_0080:  brtrue.s   IL_0099

//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
    IL_0082:  ldarg.0
    IL_0083:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0088:  ldarg.0
    IL_0089:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_008e:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_0093:  callvirt   instance bool class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::Remove(!0)
    IL_0098:  pop
//000237:                     break;
    IL_0099:  br.s       IL_009b

//000238:             }
//000239:             pbStartImage.Refresh();
    IL_009b:  ldarg.0
    IL_009c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00a1:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00a6:  nop
//000240:             pbEndImage.Refresh();
    IL_00a7:  ldarg.0
    IL_00a8:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00ad:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00b2:  nop
//000241:         }
    IL_00b3:  ret
  } // end of method MainForm::frmMainForm_KeyDown

  .method private hidebysig instance void 
          SetFoundPairAtPoint(int32 imageNum,
                              valuetype [System.Drawing]System.Drawing.PointF location) cil managed
  {
    // Code size       197 (0xc5)
    .maxstack  5
    .locals init ([0] int32 end,
             [1] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> pair,
             [2] class ParallelMorph.Line line,
             [3] bool CS$4$0000,
             [4] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> CS$5$0001)
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
    IL_0000:  nop
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0007:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_000c:  brfalse.s  IL_002e

    IL_000e:  ldarg.0
    IL_000f:  ldarg.0
    IL_0010:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0015:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_001a:  ldarg.1
    IL_001b:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                     int32)
    IL_0020:  ldarg.2
    IL_0021:  ldc.i4.6
    IL_0022:  ldloca.s   end
    IL_0024:  call       instance bool ParallelMorph.MainForm::LineHitByPoint(class ParallelMorph.Line,
                                                                              valuetype [System.Drawing]System.Drawing.PointF,
                                                                              int32,
                                                                              int32&)
    IL_0029:  ldc.i4.0
    IL_002a:  ceq
    IL_002c:  br.s       IL_002f

    IL_002e:  ldc.i4.1
    IL_002f:  stloc.3
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0030:  ldloc.3
    IL_0031:  brtrue.s   IL_0044

//000251:             {
    IL_0033:  nop
//000252:                 _currentLineImageNumber = imageNum;
    IL_0034:  ldarg.0
    IL_0035:  ldarg.1
    IL_0036:  stfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
//000253:                 _currentLineEnd = end;
    IL_003b:  ldarg.0
    IL_003c:  ldloc.0
    IL_003d:  stfld      int32 ParallelMorph.MainForm::_currentLineEnd
//000254:                 return;
    IL_0042:  br.s       IL_00c3

//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_004a:  ldnull
    IL_004b:  callvirt   instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
    IL_0050:  nop
//000259:             foreach (var pair in _lines)
    IL_0051:  nop
    IL_0052:  ldarg.0
    IL_0053:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0058:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::GetEnumerator()
    IL_005d:  stloc.s    CS$5$0001
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    .try
    {
      IL_005f:  br.s       IL_00a3

//000259:             foreach (var pair in _lines)
      IL_0061:  ldloc.s    CS$5$0001
      IL_0063:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Current()
      IL_0068:  stloc.1
//000260:             {
      IL_0069:  nop
//000261:                 Line line = pair.Item(imageNum);
      IL_006a:  ldloc.1
      IL_006b:  ldarg.1
      IL_006c:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                       int32)
      IL_0071:  stloc.2
//000262:                 if (LineHitByPoint(line, location, radius, out end))
      IL_0072:  ldarg.0
      IL_0073:  ldloc.2
      IL_0074:  ldarg.2
      IL_0075:  ldc.i4.6
      IL_0076:  ldloca.s   end
      IL_0078:  call       instance bool ParallelMorph.MainForm::LineHitByPoint(class ParallelMorph.Line,
                                                                                valuetype [System.Drawing]System.Drawing.PointF,
                                                                                int32,
                                                                                int32&)
      IL_007d:  ldc.i4.0
      IL_007e:  ceq
      IL_0080:  stloc.3
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0081:  ldloc.3
      IL_0082:  brtrue.s   IL_00a2

//000263:                 {
      IL_0084:  nop
//000264:                     _currentLineImageNumber = imageNum;
      IL_0085:  ldarg.0
      IL_0086:  ldarg.1
      IL_0087:  stfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
//000265:                     _currentLineEnd = end;
      IL_008c:  ldarg.0
      IL_008d:  ldloc.0
      IL_008e:  stfld      int32 ParallelMorph.MainForm::_currentLineEnd
//000266:                     _lines.Selected = pair;
      IL_0093:  ldarg.0
      IL_0094:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
      IL_0099:  ldloc.1
      IL_009a:  callvirt   instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
      IL_009f:  nop
//000267:                     return;
      IL_00a0:  leave.s    IL_00c3

//000268:                 }
//000269:             }
      IL_00a2:  nop
//000259:             foreach (var pair in _lines)
      IL_00a3:  ldloc.s    CS$5$0001
      IL_00a5:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_00aa:  stloc.3
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_00ab:  ldloc.3
      IL_00ac:  brtrue.s   IL_0061

      IL_00ae:  leave.s    IL_00c2

    }  // end .try
    finally
    {
      IL_00b0:  ldloc.s    CS$5$0001
      IL_00b2:  ldnull
      IL_00b3:  ceq
      IL_00b5:  stloc.3
      IL_00b6:  ldloc.3
      IL_00b7:  brtrue.s   IL_00c1

      IL_00b9:  ldloc.s    CS$5$0001
      IL_00bb:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00c0:  nop
      IL_00c1:  endfinally
    }  // end handler
    IL_00c2:  nop
    IL_00c3:  nop
//000270:         }
    IL_00c4:  ret
  } // end of method MainForm::SetFoundPairAtPoint

  .method private hidebysig instance bool 
          LineHitByPoint(class ParallelMorph.Line line,
                         valuetype [System.Drawing]System.Drawing.PointF location,
                         int32 radius,
                         [out] int32& end) cil managed
  {
    // Code size       141 (0x8d)
    .maxstack  5
    .locals init ([0] int32 i,
             [1] valuetype [System.Drawing]System.Drawing.PointF p,
             [2] int32 x,
             [3] int32 y,
             [4] bool CS$1$0000,
             [5] bool CS$4$0001,
             [6] valuetype [System.Drawing]System.Drawing.RectangleF CS$0$0002)
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
    IL_0000:  nop
//000274:             end = -1;
    IL_0001:  ldarg.s    end
    IL_0003:  ldc.i4.m1
    IL_0004:  stind.i4
//000275:             for (int i = 0; i < 2; i++)
    IL_0005:  ldc.i4.0
    IL_0006:  stloc.0
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0007:  br.s       IL_007b

//000276:             {
    IL_0009:  nop
//000277:                 PointF p = line[i];
    IL_000a:  ldarg.1
    IL_000b:  ldloc.0
    IL_000c:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item(int32)
    IL_0011:  stloc.1
//000278: 
//000279:                 int x = (int)(p.X - radius);
    IL_0012:  ldloca.s   p
    IL_0014:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0019:  ldarg.3
    IL_001a:  conv.r4
    IL_001b:  sub
    IL_001c:  conv.i4
    IL_001d:  stloc.2
//000280:                 if (x < 0) x = 0;
    IL_001e:  ldloc.2
    IL_001f:  ldc.i4.0
    IL_0020:  clt
    IL_0022:  ldc.i4.0
    IL_0023:  ceq
    IL_0025:  stloc.s    CS$4$0001
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0027:  ldloc.s    CS$4$0001
    IL_0029:  brtrue.s   IL_002d

//000280:                 if (x < 0) x = 0;
    IL_002b:  ldc.i4.0
    IL_002c:  stloc.2
//000281:                 int y = (int)(p.Y - radius);
    IL_002d:  ldloca.s   p
    IL_002f:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0034:  ldarg.3
    IL_0035:  conv.r4
    IL_0036:  sub
    IL_0037:  conv.i4
    IL_0038:  stloc.3
//000282:                 if (y < 0) y = 0;
    IL_0039:  ldloc.3
    IL_003a:  ldc.i4.0
    IL_003b:  clt
    IL_003d:  ldc.i4.0
    IL_003e:  ceq
    IL_0040:  stloc.s    CS$4$0001
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0042:  ldloc.s    CS$4$0001
    IL_0044:  brtrue.s   IL_0048

//000282:                 if (y < 0) y = 0;
    IL_0046:  ldc.i4.0
    IL_0047:  stloc.3
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
    IL_0048:  ldloc.2
    IL_0049:  conv.r4
    IL_004a:  ldloc.3
    IL_004b:  conv.r4
    IL_004c:  ldarg.3
    IL_004d:  ldc.i4.2
    IL_004e:  mul
    IL_004f:  conv.r4
    IL_0050:  ldarg.3
    IL_0051:  ldc.i4.2
    IL_0052:  mul
    IL_0053:  conv.r4
    IL_0054:  newobj     instance void [System.Drawing]System.Drawing.RectangleF::.ctor(float32,
                                                                                        float32,
                                                                                        float32,
                                                                                        float32)
    IL_0059:  stloc.s    CS$0$0002
    IL_005b:  ldloca.s   CS$0$0002
    IL_005d:  ldarg.2
    IL_005e:  call       instance bool [System.Drawing]System.Drawing.RectangleF::Contains(valuetype [System.Drawing]System.Drawing.PointF)
    IL_0063:  ldc.i4.0
    IL_0064:  ceq
    IL_0066:  stloc.s    CS$4$0001
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0068:  ldloc.s    CS$4$0001
    IL_006a:  brtrue.s   IL_0076

//000285:                 {
    IL_006c:  nop
//000286:                     end = i;
    IL_006d:  ldarg.s    end
    IL_006f:  ldloc.0
    IL_0070:  stind.i4
//000287:                     return true;
    IL_0071:  ldc.i4.1
    IL_0072:  stloc.s    CS$1$0000
    IL_0074:  br.s       IL_008a

//000288:                 }
//000289:             }
    IL_0076:  nop
//000275:             for (int i = 0; i < 2; i++)
    IL_0077:  ldloc.0
    IL_0078:  ldc.i4.1
    IL_0079:  add
    IL_007a:  stloc.0
    IL_007b:  ldloc.0
    IL_007c:  ldc.i4.2
    IL_007d:  clt
    IL_007f:  stloc.s    CS$4$0001
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0081:  ldloc.s    CS$4$0001
    IL_0083:  brtrue.s   IL_0009

//000290:             return false;
    IL_0085:  ldc.i4.0
    IL_0086:  stloc.s    CS$1$0000
    IL_0088:  br.s       IL_008a

//000291:         }
    IL_008a:  ldloc.s    CS$1$0000
    IL_008c:  ret
  } // end of method MainForm::LineHitByPoint

  .method private hidebysig instance void 
          HandleMouseDown(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e,
                          class ParallelMorph.LinedPictureBox pb) cil managed
  {
    // Code size       180 (0xb4)
    .maxstack  5
    .locals init ([0] valuetype [System.Drawing]System.Drawing.PointF point,
             [1] bool CS$4$0000)
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
    IL_0000:  nop
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_000c:  brfalse.s  IL_001e

    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0014:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0019:  ldnull
    IL_001a:  ceq
    IL_001c:  br.s       IL_001f

    IL_001e:  ldc.i4.1
    IL_001f:  stloc.1
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0020:  ldloc.1
    IL_0021:  brtrue     IL_00b3

//000296:             {
    IL_0026:  nop
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
    IL_0027:  ldarg.2
    IL_0028:  ldarg.1
    IL_0029:  callvirt   instance valuetype [System.Drawing]System.Drawing.Point [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Location()
    IL_002e:  call       valuetype [System.Drawing]System.Drawing.PointF [System.Drawing]System.Drawing.Point::op_Implicit(valuetype [System.Drawing]System.Drawing.Point)
    IL_0033:  callvirt   instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.LinedPictureBox::TranslateImageToControl(valuetype [System.Drawing]System.Drawing.PointF)
    IL_0038:  stloc.0
//000298:                 if (e.Button == MouseButtons.Left)
    IL_0039:  ldarg.1
    IL_003a:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_003f:  ldc.i4     0x100000
    IL_0044:  ceq
    IL_0046:  ldc.i4.0
    IL_0047:  ceq
    IL_0049:  stloc.1
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_004a:  ldloc.1
    IL_004b:  brtrue.s   IL_005f

//000299:                 {
    IL_004d:  nop
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
    IL_004e:  ldarg.0
    IL_004f:  ldarg.2
    IL_0050:  callvirt   instance int32 ParallelMorph.LinedPictureBox::get_ImageNumber()
    IL_0055:  ldloc.0
    IL_0056:  call       instance void ParallelMorph.MainForm::SetFoundPairAtPoint(int32,
                                                                                   valuetype [System.Drawing]System.Drawing.PointF)
    IL_005b:  nop
//000301:                 }
    IL_005c:  nop
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_005d:  br.s       IL_009a

//000303:                 {
    IL_005f:  nop
//000304:                     _lines.Add(Tuple.Create(
    IL_0060:  ldarg.0
    IL_0061:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0066:  ldloc.0
    IL_0067:  ldloc.0
    IL_0068:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                 valuetype [System.Drawing]System.Drawing.PointF)
    IL_006d:  ldloc.0
    IL_006e:  ldloc.0
    IL_006f:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                 valuetype [System.Drawing]System.Drawing.PointF)
    IL_0074:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<class ParallelMorph.Line,class ParallelMorph.Line>(!!0,
                                                                                                                                                   !!1)
    IL_0079:  callvirt   instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::Add(!0)
    IL_007e:  nop
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
    IL_007f:  ldarg.0
    IL_0080:  ldarg.2
    IL_0081:  callvirt   instance int32 ParallelMorph.LinedPictureBox::get_ImageNumber()
    IL_0086:  stfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
//000308:                     _currentLineEnd = 1;
    IL_008b:  ldarg.0
    IL_008c:  ldc.i4.1
    IL_008d:  stfld      int32 ParallelMorph.MainForm::_currentLineEnd
//000309:                     _lineCreationInProcess = true;
    IL_0092:  ldarg.0
    IL_0093:  ldc.i4.1
    IL_0094:  stfld      bool ParallelMorph.MainForm::_lineCreationInProcess
//000310:                 }
    IL_0099:  nop
//000311:                 pbStartImage.Refresh();
    IL_009a:  ldarg.0
    IL_009b:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00a0:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00a5:  nop
//000312:                 pbEndImage.Refresh();
    IL_00a6:  ldarg.0
    IL_00a7:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00ac:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00b1:  nop
//000313:             }
    IL_00b2:  nop
//000314:         }
    IL_00b3:  ret
  } // end of method MainForm::HandleMouseDown

  .method private hidebysig instance void 
          HandleMouseUp(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e,
                        class ParallelMorph.LinedPictureBox pb) cil managed
  {
    // Code size       193 (0xc1)
    .maxstack  2
    .locals init ([0] class ParallelMorph.Line line,
             [1] bool CS$4$0000,
             [2] valuetype [System.Drawing]System.Drawing.PointF CS$0$0001)
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
    IL_0000:  nop
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_000c:  brfalse.s  IL_001e

    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0014:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0019:  ldnull
    IL_001a:  ceq
    IL_001c:  br.s       IL_001f

    IL_001e:  ldc.i4.1
    IL_001f:  stloc.1
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0020:  ldloc.1
    IL_0021:  brtrue     IL_00c0

//000319:             {
    IL_0026:  nop
//000320:                 if (_lineCreationInProcess)
    IL_0027:  ldarg.0
    IL_0028:  ldfld      bool ParallelMorph.MainForm::_lineCreationInProcess
    IL_002d:  ldc.i4.0
    IL_002e:  ceq
    IL_0030:  stloc.1
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0031:  ldloc.1
    IL_0032:  brtrue.s   IL_00a0

//000321:                 {
    IL_0034:  nop
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
    IL_0035:  ldarg.0
    IL_0036:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_003b:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_0040:  ldnull
    IL_0041:  ceq
    IL_0043:  stloc.1
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0044:  ldloc.1
    IL_0045:  brtrue.s   IL_009f

//000324:                     {
    IL_0047:  nop
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
    IL_0048:  ldarg.0
    IL_0049:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_004e:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_0053:  ldarg.0
    IL_0054:  ldfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
    IL_0059:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                     int32)
    IL_005e:  stloc.0
//000326:                         if (line.Item1.Equals(line.Item2))
    IL_005f:  ldloc.0
    IL_0060:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
    IL_0065:  stloc.2
    IL_0066:  ldloca.s   CS$0$0001
    IL_0068:  ldloc.0
    IL_0069:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
    IL_006e:  box        [System.Drawing]System.Drawing.PointF
    IL_0073:  constrained. [System.Drawing]System.Drawing.PointF
    IL_0079:  callvirt   instance bool [mscorlib]System.Object::Equals(object)
    IL_007e:  ldc.i4.0
    IL_007f:  ceq
    IL_0081:  stloc.1
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0082:  ldloc.1
    IL_0083:  brtrue.s   IL_009e

//000327:                         {
    IL_0085:  nop
//000328:                             _lines.Remove(_lines.Selected);
    IL_0086:  ldarg.0
    IL_0087:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_008c:  ldarg.0
    IL_008d:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0092:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_0097:  callvirt   instance bool class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::Remove(!0)
    IL_009c:  pop
//000329:                         }
    IL_009d:  nop
//000330:                     }
    IL_009e:  nop
//000331:                 }
    IL_009f:  nop
//000332:                 _lineCreationInProcess = false;
    IL_00a0:  ldarg.0
    IL_00a1:  ldc.i4.0
    IL_00a2:  stfld      bool ParallelMorph.MainForm::_lineCreationInProcess
//000333:                 pbStartImage.Refresh();
    IL_00a7:  ldarg.0
    IL_00a8:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00ad:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00b2:  nop
//000334:                 pbEndImage.Refresh();
    IL_00b3:  ldarg.0
    IL_00b4:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00b9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00be:  nop
//000335:             }
    IL_00bf:  nop
//000336:         }
    IL_00c0:  ret
  } // end of method MainForm::HandleMouseUp

  .method private hidebysig instance void 
          HandleMouseMove(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e,
                          class ParallelMorph.LinedPictureBox pb) cil managed
  {
    // Code size       257 (0x101)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
    IL_0000:  nop
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_000c:  brfalse.s  IL_001e

    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0014:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0019:  ldnull
    IL_001a:  ceq
    IL_001c:  br.s       IL_001f

    IL_001e:  ldc.i4.1
    IL_001f:  stloc.0
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0020:  ldloc.0
    IL_0021:  brtrue     IL_0100

//000341:             {
    IL_0026:  nop
//000342:                 if (_lines.Selected != null &&
    IL_0027:  ldarg.0
    IL_0028:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_002d:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_0032:  brfalse.s  IL_0056

    IL_0034:  ldarg.1
    IL_0035:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_003a:  ldc.i4     0x100000
    IL_003f:  beq.s      IL_0053

    IL_0041:  ldarg.1
    IL_0042:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.MouseButtons [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Button()
    IL_0047:  ldc.i4     0x200000
    IL_004c:  ceq
    IL_004e:  ldc.i4.0
    IL_004f:  ceq
    IL_0051:  br.s       IL_0054

    IL_0053:  ldc.i4.0
    IL_0054:  br.s       IL_0057

    IL_0056:  ldc.i4.1
    IL_0057:  stloc.0
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0058:  ldloc.0
    IL_0059:  brtrue     IL_00e7

//000344:                 {
    IL_005e:  nop
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
    IL_005f:  ldarg.0
    IL_0060:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0065:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_006a:  ldarg.0
    IL_006b:  ldfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
    IL_0070:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                     int32)
    IL_0075:  ldarg.0
    IL_0076:  ldfld      int32 ParallelMorph.MainForm::_currentLineEnd
    IL_007b:  ldarg.2
    IL_007c:  ldarg.1
    IL_007d:  callvirt   instance valuetype [System.Drawing]System.Drawing.Point [System.Windows.Forms]System.Windows.Forms.MouseEventArgs::get_Location()
    IL_0082:  call       valuetype [System.Drawing]System.Drawing.PointF [System.Drawing]System.Drawing.Point::op_Implicit(valuetype [System.Drawing]System.Drawing.Point)
    IL_0087:  callvirt   instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.LinedPictureBox::TranslateImageToControl(valuetype [System.Drawing]System.Drawing.PointF)
    IL_008c:  callvirt   instance void class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::set_Item(int32,
                                                                                                                             !0)
    IL_0091:  nop
//000346:                     if (_lineCreationInProcess)
    IL_0092:  ldarg.0
    IL_0093:  ldfld      bool ParallelMorph.MainForm::_lineCreationInProcess
    IL_0098:  ldc.i4.0
    IL_0099:  ceq
    IL_009b:  stloc.0
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_009c:  ldloc.0
    IL_009d:  brtrue.s   IL_00e6

//000347:                     {
    IL_009f:  nop
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
    IL_00a0:  ldarg.0
    IL_00a1:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_00a6:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_00ab:  ldarg.0
    IL_00ac:  ldfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
    IL_00b1:  ldc.i4.1
    IL_00b2:  xor
    IL_00b3:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                     int32)
    IL_00b8:  ldarg.0
    IL_00b9:  ldfld      int32 ParallelMorph.MainForm::_currentLineEnd
    IL_00be:  ldarg.0
    IL_00bf:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_00c4:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    IL_00c9:  ldarg.0
    IL_00ca:  ldfld      int32 ParallelMorph.MainForm::_currentLineImageNumber
    IL_00cf:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                     int32)
    IL_00d4:  ldarg.0
    IL_00d5:  ldfld      int32 ParallelMorph.MainForm::_currentLineEnd
    IL_00da:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item(int32)
    IL_00df:  callvirt   instance void class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::set_Item(int32,
                                                                                                                             !0)
    IL_00e4:  nop
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
    IL_00e5:  nop
//000352:                 }
    IL_00e6:  nop
//000353:                 pbStartImage.Refresh();
    IL_00e7:  ldarg.0
    IL_00e8:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_00ed:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00f2:  nop
//000354:                 pbEndImage.Refresh();
    IL_00f3:  ldarg.0
    IL_00f4:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_00f9:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::Refresh()
    IL_00fe:  nop
//000355:             }
    IL_00ff:  nop
//000356:         }
    IL_0100:  ret
  } // end of method MainForm::HandleMouseMove

  .method private hidebysig instance void 
          pbAnyImage_MouseDown(object sender,
                               class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
    IL_0000:  nop
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.2
    IL_0003:  ldarg.1
    IL_0004:  castclass  ParallelMorph.LinedPictureBox
    IL_0009:  call       instance void ParallelMorph.MainForm::HandleMouseDown(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs,
                                                                               class ParallelMorph.LinedPictureBox)
    IL_000e:  nop
//000361:         }
    IL_000f:  ret
  } // end of method MainForm::pbAnyImage_MouseDown

  .method private hidebysig instance void 
          pbAnyImage_MouseMove(object sender,
                               class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
    IL_0000:  nop
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.2
    IL_0003:  ldarg.1
    IL_0004:  castclass  ParallelMorph.LinedPictureBox
    IL_0009:  call       instance void ParallelMorph.MainForm::HandleMouseMove(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs,
                                                                               class ParallelMorph.LinedPictureBox)
    IL_000e:  nop
//000366:         }
    IL_000f:  ret
  } // end of method MainForm::pbAnyImage_MouseMove

  .method private hidebysig instance void 
          pbAnyImage_MouseUp(object sender,
                             class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
    IL_0000:  nop
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.2
    IL_0003:  ldarg.1
    IL_0004:  castclass  ParallelMorph.LinedPictureBox
    IL_0009:  call       instance void ParallelMorph.MainForm::HandleMouseUp(class [System.Windows.Forms]System.Windows.Forms.MouseEventArgs,
                                                                             class ParallelMorph.LinedPictureBox)
    IL_000e:  nop
//000371:         }
    IL_000f:  ret
  } // end of method MainForm::pbAnyImage_MouseUp

  .method private hidebysig instance void 
          autoSizeToolStripMenuItem_Click(object sender,
                                          class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       80 (0x50)
    .maxstack  2
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
    IL_0000:  nop
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  ldc.i4.2
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_000d:  nop
//000376:             pbStartImage.Dock = DockStyle.None;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0014:  ldc.i4.0
    IL_0015:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_001a:  nop
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0021:  ldc.i4.2
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0027:  nop
//000378:             pbEndImage.Dock = DockStyle.None;
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_002e:  ldc.i4.0
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0034:  nop
//000379:             autoSizeToolStripMenuItem.Checked = true;
    IL_0035:  ldarg.0
    IL_0036:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_003b:  ldc.i4.1
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0041:  nop
//000380:             zoomToolStripMenuItem.Checked = false;
    IL_0042:  ldarg.0
    IL_0043:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0048:  ldc.i4.0
    IL_0049:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_004e:  nop
//000381:         }
    IL_004f:  ret
  } // end of method MainForm::autoSizeToolStripMenuItem_Click

  .method private hidebysig instance void 
          zoomToolStripMenuItem_Click(object sender,
                                      class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       80 (0x50)
    .maxstack  2
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
    IL_0000:  nop
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  ldc.i4.4
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_000d:  nop
//000386:             pbStartImage.Dock = DockStyle.Fill;
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0014:  ldc.i4.5
    IL_0015:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_001a:  nop
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0021:  ldc.i4.4
    IL_0022:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_SizeMode(valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode)
    IL_0027:  nop
//000388:             pbEndImage.Dock = DockStyle.Fill;
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_002e:  ldc.i4.5
    IL_002f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_0034:  nop
//000389:             autoSizeToolStripMenuItem.Checked = false;
    IL_0035:  ldarg.0
    IL_0036:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::autoSizeToolStripMenuItem
    IL_003b:  ldc.i4.0
    IL_003c:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0041:  nop
//000390:             zoomToolStripMenuItem.Checked = true;
    IL_0042:  ldarg.0
    IL_0043:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::zoomToolStripMenuItem
    IL_0048:  ldc.i4.1
    IL_0049:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_004e:  nop
//000391:         }
    IL_004f:  ret
  } // end of method MainForm::zoomToolStripMenuItem_Click

  .method private hidebysig instance void 
          optionsToolStripMenuItem_Click(object sender,
                                         class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  2
    .locals init ([0] class ParallelMorph.EditSettings es,
             [1] bool CS$4$0000)
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
    IL_0000:  nop
//000395:             using (EditSettings es = new EditSettings())
    IL_0001:  newobj     instance void ParallelMorph.EditSettings::.ctor()
    IL_0006:  stloc.0
//000396:             {
    .try
    {
      IL_0007:  nop
//000397:                 es.Settings = _morphSettings;
      IL_0008:  ldloc.0
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class ParallelMorph.UiSettings ParallelMorph.MainForm::_morphSettings
      IL_000f:  callvirt   instance void ParallelMorph.EditSettings::set_Settings(class ParallelMorph.UiSettings)
      IL_0014:  nop
//000398:                 es.ShowDialog(this);
      IL_0015:  ldloc.0
      IL_0016:  ldarg.0
      IL_0017:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.Form::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
      IL_001c:  pop
//000399:             }
      IL_001d:  nop
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_001e:  leave.s    IL_0030

    }  // end .try
    finally
    {
      IL_0020:  ldloc.0
      IL_0021:  ldnull
      IL_0022:  ceq
      IL_0024:  stloc.1
      IL_0025:  ldloc.1
      IL_0026:  brtrue.s   IL_002f

      IL_0028:  ldloc.0
      IL_0029:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_002e:  nop
      IL_002f:  endfinally
    }  // end handler
    IL_0030:  nop
//000400:         }
    IL_0031:  ret
  } // end of method MainForm::optionsToolStripMenuItem_Click

  .method private hidebysig instance void 
          exitToolStripMenuItem_Click(object sender,
                                      class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
    IL_0000:  nop
//000404:             Application.Exit();
    IL_0001:  call       void [System.Windows.Forms]System.Windows.Forms.Application::Exit()
    IL_0006:  nop
//000405:         }
    IL_0007:  ret
  } // end of method MainForm::exitToolStripMenuItem_Click

  .method private hidebysig instance void 
          newToolStripMenuItem_Click(object sender,
                                     class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       40 (0x28)
    .maxstack  8
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
    IL_0000:  nop
//000409:             this.Text = "Parallel Morph";
    IL_0001:  ldarg.0
    IL_0002:  ldstr      "Parallel Morph"
    IL_0007:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_000c:  nop
//000410:             _lines = new LinePairCollection();
    IL_000d:  ldarg.0
    IL_000e:  newobj     instance void ParallelMorph.LinePairCollection::.ctor()
    IL_0013:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
//000411:             ConfigurePictureBoxes(_lines, null, null);
    IL_0018:  ldarg.0
    IL_0019:  ldarg.0
    IL_001a:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_001f:  ldnull
    IL_0020:  ldnull
    IL_0021:  call       instance void ParallelMorph.MainForm::ConfigurePictureBoxes(class ParallelMorph.LinePairCollection,
                                                                                     class [System.Drawing]System.Drawing.Image,
                                                                                     class [System.Drawing]System.Drawing.Image)
    IL_0026:  nop
//000412:         }
    IL_0027:  ret
  } // end of method MainForm::newToolStripMenuItem_Click

  .method private hidebysig instance void 
          openToolStripMenuItem_Click(object sender,
                                      class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       175 (0xaf)
    .maxstack  4
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog ofd,
             [1] class [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter formatter,
             [2] class [mscorlib]System.IO.Stream fileStream,
             [3] class ParallelMorph.SavedSettings ss,
             [4] bool CS$4$0000)
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
    IL_0000:  nop
//000416:             _lines.Selected = null;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0007:  ldnull
    IL_0008:  callvirt   instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
    IL_000d:  nop
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
    IL_000e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.OpenFileDialog::.ctor()
    IL_0013:  stloc.0
//000418:             {
    .try
    {
      IL_0014:  nop
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
      IL_0015:  ldloc.0
      IL_0016:  ldstr      "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*"
      IL_001b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
      IL_0020:  nop
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
      IL_0021:  ldloc.0
      IL_0022:  ldarg.0
      IL_0023:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
      IL_0028:  ldc.i4.1
      IL_0029:  ceq
      IL_002b:  ldc.i4.0
      IL_002c:  ceq
      IL_002e:  stloc.s    CS$4$0000
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0030:  ldloc.s    CS$4$0000
      IL_0032:  brtrue.s   IL_0098

//000421:                 {
      IL_0034:  nop
//000422:                     var formatter = new BinaryFormatter();
      IL_0035:  newobj     instance void [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::.ctor()
      IL_003a:  stloc.1
//000423:                     using (Stream fileStream = ofd.OpenFile())
      IL_003b:  ldloc.0
      IL_003c:  callvirt   instance class [mscorlib]System.IO.Stream [System.Windows.Forms]System.Windows.Forms.OpenFileDialog::OpenFile()
      IL_0041:  stloc.2
//000424:                     {
      .try
      {
        IL_0042:  nop
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
        IL_0043:  ldloc.1
        IL_0044:  ldloc.2
        IL_0045:  callvirt   instance object [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::Deserialize(class [mscorlib]System.IO.Stream)
        IL_004a:  castclass  ParallelMorph.SavedSettings
        IL_004f:  stloc.3
//000426:                         _lines = ss.Lines;
        IL_0050:  ldarg.0
        IL_0051:  ldloc.3
        IL_0052:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.SavedSettings::Lines
        IL_0057:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
//000427:                         _morphSettings = ss.Settings;
        IL_005c:  ldarg.0
        IL_005d:  ldloc.3
        IL_005e:  ldfld      class ParallelMorph.UiSettings ParallelMorph.SavedSettings::Settings
        IL_0063:  stfld      class ParallelMorph.UiSettings ParallelMorph.MainForm::_morphSettings
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
        IL_0068:  ldarg.0
        IL_0069:  ldarg.0
        IL_006a:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
        IL_006f:  ldloc.3
        IL_0070:  ldfld      class [System.Drawing]System.Drawing.Image ParallelMorph.SavedSettings::FirstImage
        IL_0075:  ldloc.3
        IL_0076:  ldfld      class [System.Drawing]System.Drawing.Image ParallelMorph.SavedSettings::SecondImage
        IL_007b:  call       instance void ParallelMorph.MainForm::ConfigurePictureBoxes(class ParallelMorph.LinePairCollection,
                                                                                         class [System.Drawing]System.Drawing.Image,
                                                                                         class [System.Drawing]System.Drawing.Image)
        IL_0080:  nop
//000429:                     }
        IL_0081:  nop
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
        IL_0082:  leave.s    IL_0096

      }  // end .try
      finally
      {
        IL_0084:  ldloc.2
        IL_0085:  ldnull
        IL_0086:  ceq
        IL_0088:  stloc.s    CS$4$0000
        IL_008a:  ldloc.s    CS$4$0000
        IL_008c:  brtrue.s   IL_0095

        IL_008e:  ldloc.2
        IL_008f:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_0094:  nop
        IL_0095:  endfinally
      }  // end handler
      IL_0096:  nop
//000430:                 }
      IL_0097:  nop
//000431:             }
      IL_0098:  nop
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0099:  leave.s    IL_00ad

    }  // end .try
    finally
    {
      IL_009b:  ldloc.0
      IL_009c:  ldnull
      IL_009d:  ceq
      IL_009f:  stloc.s    CS$4$0000
      IL_00a1:  ldloc.s    CS$4$0000
      IL_00a3:  brtrue.s   IL_00ac

      IL_00a5:  ldloc.0
      IL_00a6:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00ab:  nop
      IL_00ac:  endfinally
    }  // end handler
    IL_00ad:  nop
//000432:         }
    IL_00ae:  ret
  } // end of method MainForm::openToolStripMenuItem_Click

  .method private hidebysig instance void 
          saveToolStripMenuItem_Click(object sender,
                                      class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       194 (0xc2)
    .maxstack  3
    .locals init ([0] class ParallelMorph.SavedSettings ss,
             [1] class [System.Windows.Forms]System.Windows.Forms.SaveFileDialog sfd,
             [2] class [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter formatter,
             [3] class [mscorlib]System.IO.Stream fileStream,
             [4] class ParallelMorph.SavedSettings '<>g__initLocal11',
             [5] bool CS$4$0000)
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
    IL_0000:  nop
//000436:             _lines.Selected = null;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0007:  ldnull
    IL_0008:  callvirt   instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
    IL_000d:  nop
//000437:             SavedSettings ss = new SavedSettings
    IL_000e:  newobj     instance void ParallelMorph.SavedSettings::.ctor()
    IL_0013:  stloc.s    '<>g__initLocal11'
    IL_0015:  ldloc.s    '<>g__initLocal11'
    IL_0017:  ldarg.0
    IL_0018:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_001d:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0022:  stfld      class [System.Drawing]System.Drawing.Image ParallelMorph.SavedSettings::FirstImage
    IL_0027:  ldloc.s    '<>g__initLocal11'
    IL_0029:  ldarg.0
    IL_002a:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_002f:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0034:  stfld      class [System.Drawing]System.Drawing.Image ParallelMorph.SavedSettings::SecondImage
    IL_0039:  ldloc.s    '<>g__initLocal11'
    IL_003b:  ldarg.0
    IL_003c:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0041:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.SavedSettings::Lines
    IL_0046:  ldloc.s    '<>g__initLocal11'
    IL_0048:  ldarg.0
    IL_0049:  ldfld      class ParallelMorph.UiSettings ParallelMorph.MainForm::_morphSettings
    IL_004e:  stfld      class ParallelMorph.UiSettings ParallelMorph.SavedSettings::Settings
    IL_0053:  ldloc.s    '<>g__initLocal11'
    IL_0055:  stloc.0
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
    IL_0056:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.SaveFileDialog::.ctor()
    IL_005b:  stloc.1
//000445:             {
    .try
    {
      IL_005c:  nop
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
      IL_005d:  ldloc.1
      IL_005e:  ldstr      "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*"
      IL_0063:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
      IL_0068:  nop
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
      IL_0069:  ldloc.1
      IL_006a:  ldarg.0
      IL_006b:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
      IL_0070:  ldc.i4.1
      IL_0071:  ceq
      IL_0073:  ldc.i4.0
      IL_0074:  ceq
      IL_0076:  stloc.s    CS$4$0000
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_0078:  ldloc.s    CS$4$0000
      IL_007a:  brtrue.s   IL_00ab

//000448:                 {
      IL_007c:  nop
//000449:                     var formatter = new BinaryFormatter();
      IL_007d:  newobj     instance void [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::.ctor()
      IL_0082:  stloc.2
//000450:                     using (Stream fileStream = sfd.OpenFile())
      IL_0083:  ldloc.1
      IL_0084:  callvirt   instance class [mscorlib]System.IO.Stream [System.Windows.Forms]System.Windows.Forms.SaveFileDialog::OpenFile()
      IL_0089:  stloc.3
//000451:                     {
      .try
      {
        IL_008a:  nop
//000452:                         formatter.Serialize(fileStream, ss);
        IL_008b:  ldloc.2
        IL_008c:  ldloc.3
        IL_008d:  ldloc.0
        IL_008e:  callvirt   instance void [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::Serialize(class [mscorlib]System.IO.Stream,
                                                                                                                               object)
        IL_0093:  nop
//000453:                     }
        IL_0094:  nop
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
        IL_0095:  leave.s    IL_00a9

      }  // end .try
      finally
      {
        IL_0097:  ldloc.3
        IL_0098:  ldnull
        IL_0099:  ceq
        IL_009b:  stloc.s    CS$4$0000
        IL_009d:  ldloc.s    CS$4$0000
        IL_009f:  brtrue.s   IL_00a8

        IL_00a1:  ldloc.3
        IL_00a2:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_00a7:  nop
        IL_00a8:  endfinally
      }  // end handler
      IL_00a9:  nop
//000454:                 }
      IL_00aa:  nop
//000455:             }
      IL_00ab:  nop
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_00ac:  leave.s    IL_00c0

    }  // end .try
    finally
    {
      IL_00ae:  ldloc.1
      IL_00af:  ldnull
      IL_00b0:  ceq
      IL_00b2:  stloc.s    CS$4$0000
      IL_00b4:  ldloc.s    CS$4$0000
      IL_00b6:  brtrue.s   IL_00bf

      IL_00b8:  ldloc.1
      IL_00b9:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00be:  nop
      IL_00bf:  endfinally
    }  // end handler
    IL_00c0:  nop
//000456:         }
    IL_00c1:  ret
  } // end of method MainForm::saveToolStripMenuItem_Click

  .method private hidebysig instance void 
          LoadPictureBoxImage(object sender,
                              class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       143 (0x8f)
    .maxstack  3
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.OpenFileDialog ofd,
             [1] bool CS$4$0000)
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
    IL_0000:  nop
//000460:             _lines.Selected = null;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_0007:  ldnull
    IL_0008:  callvirt   instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
    IL_000d:  nop
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
    IL_000e:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.OpenFileDialog::.ctor()
    IL_0013:  stloc.0
//000462:             {
    .try
    {
      IL_0014:  nop
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
      IL_0015:  ldloc.0
      IL_0016:  ldstr      "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*"
      IL_001b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.FileDialog::set_Filter(string)
      IL_0020:  nop
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
      IL_0021:  ldloc.0
      IL_0022:  ldarg.0
      IL_0023:  callvirt   instance valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.CommonDialog::ShowDialog(class [System.Windows.Forms]System.Windows.Forms.IWin32Window)
      IL_0028:  ldc.i4.1
      IL_0029:  ceq
      IL_002b:  ldc.i4.0
      IL_002c:  ceq
      IL_002e:  stloc.1
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_002f:  ldloc.1
      IL_0030:  brtrue.s   IL_004b

//000465:                 {
      IL_0032:  nop
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
      IL_0033:  ldarg.1
      IL_0034:  castclass  [System.Windows.Forms]System.Windows.Forms.PictureBox
      IL_0039:  ldloc.0
      IL_003a:  callvirt   instance string [System.Windows.Forms]System.Windows.Forms.FileDialog::get_FileName()
      IL_003f:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(string)
      IL_0044:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::set_Image(class [System.Drawing]System.Drawing.Image)
      IL_0049:  nop
//000467:                 }
      IL_004a:  nop
//000468:             }
      IL_004b:  nop
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
      IL_004c:  leave.s    IL_005e

    }  // end .try
    finally
    {
      IL_004e:  ldloc.0
      IL_004f:  ldnull
      IL_0050:  ceq
      IL_0052:  stloc.1
      IL_0053:  ldloc.1
      IL_0054:  brtrue.s   IL_005d

      IL_0056:  ldloc.0
      IL_0057:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_005c:  nop
      IL_005d:  endfinally
    }  // end handler
    IL_005e:  nop
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
    IL_005f:  ldarg.0
    IL_0060:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0065:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_006a:  brfalse.s  IL_007c

    IL_006c:  ldarg.0
    IL_006d:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0072:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0077:  ldnull
    IL_0078:  ceq
    IL_007a:  br.s       IL_007d

    IL_007c:  ldc.i4.1
    IL_007d:  stloc.1
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_007e:  ldloc.1
    IL_007f:  brtrue.s   IL_008e

//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
    IL_0081:  ldarg.0
    IL_0082:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnMorph
    IL_0087:  ldc.i4.1
    IL_0088:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_008d:  nop
//000470:         }
    IL_008e:  ret
  } // end of method MainForm::LoadPictureBoxImage

  .method private hidebysig instance void 
          splitContainer1_Panel1_DoubleClick(object sender,
                                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
    IL_0000:  nop
//000474:             LoadPictureBoxImage(pbStartImage, e);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0008:  ldarg.2
    IL_0009:  call       instance void ParallelMorph.MainForm::LoadPictureBoxImage(object,
                                                                                   class [mscorlib]System.EventArgs)
    IL_000e:  nop
//000475:         }
    IL_000f:  ret
  } // end of method MainForm::splitContainer1_Panel1_DoubleClick

  .method private hidebysig instance void 
          splitContainer1_Panel2_DoubleClick(object sender,
                                             class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       16 (0x10)
    .maxstack  8
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
    IL_0000:  nop
//000479:             LoadPictureBoxImage(pbEndImage, e);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbEndImage
    IL_0008:  ldarg.2
    IL_0009:  call       instance void ParallelMorph.MainForm::LoadPictureBoxImage(object,
                                                                                   class [mscorlib]System.EventArgs)
    IL_000e:  nop
//000480:         }
    IL_000f:  ret
  } // end of method MainForm::splitContainer1_Panel2_DoubleClick

  .method private hidebysig instance void 
          btnCancel_Click(object sender,
                          class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       40 (0x28)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
    IL_0000:  nop
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource ParallelMorph.MainForm::_currentCancellationSource
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.0
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_000b:  ldloc.0
    IL_000c:  brtrue.s   IL_001a

//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
    IL_000e:  ldarg.0
    IL_000f:  ldfld      class [mscorlib]System.Threading.CancellationTokenSource ParallelMorph.MainForm::_currentCancellationSource
    IL_0014:  callvirt   instance void [mscorlib]System.Threading.CancellationTokenSource::Cancel()
    IL_0019:  nop
//000485:             btnCancel.Enabled = false;
    IL_001a:  ldarg.0
    IL_001b:  ldfld      class [System.Windows.Forms]System.Windows.Forms.Button ParallelMorph.MainForm::btnCancel
    IL_0020:  ldc.i4.0
    IL_0021:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Enabled(bool)
    IL_0026:  nop
//000486:         }
    IL_0027:  ret
  } // end of method MainForm::btnCancel_Click

  .method private hidebysig instance void 
          parallelModeToolStripMenuItem_Click(object sender,
                                              class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       67 (0x43)
    .maxstack  3
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem item,
             [1] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem[] CS$0$0000,
             [2] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem[] CS$6$0001,
             [3] int32 CS$7$0002,
             [4] bool CS$4$0003)
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
    IL_0000:  nop
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
    IL_0001:  nop
    IL_0002:  ldc.i4.2
    IL_0003:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldc.i4.0
    IL_000b:  ldarg.0
    IL_000c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::sequentialProcessingModeToolStripMenuItem
    IL_0011:  stelem.ref
    IL_0012:  ldloc.1
    IL_0013:  ldc.i4.1
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::parallelProcessingModeToolStripMenuItem
    IL_001a:  stelem.ref
    IL_001b:  ldloc.1
    IL_001c:  stloc.2
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_001d:  ldc.i4.0
    IL_001e:  stloc.3
    IL_001f:  br.s       IL_0036

//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
    IL_0021:  ldloc.2
    IL_0022:  ldloc.3
    IL_0023:  ldelem.ref
    IL_0024:  stloc.0
//000491:             {
    IL_0025:  nop
//000492:                 item.Checked = item == sender;
    IL_0026:  ldloc.0
    IL_0027:  ldloc.0
    IL_0028:  ldarg.1
    IL_0029:  ceq
    IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0030:  nop
//000493:             }
    IL_0031:  nop
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0032:  ldloc.3
    IL_0033:  ldc.i4.1
    IL_0034:  add
    IL_0035:  stloc.3
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
    IL_0036:  ldloc.3
    IL_0037:  ldloc.2
    IL_0038:  ldlen
    IL_0039:  conv.i4
    IL_003a:  clt
    IL_003c:  stloc.s    CS$4$0003
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_003e:  ldloc.s    CS$4$0003
    IL_0040:  brtrue.s   IL_0021

//000494:         }
    IL_0042:  ret
  } // end of method MainForm::parallelModeToolStripMenuItem_Click

  .method private hidebysig instance void 
          outputModeToolStripMenuItem_Click(object sender,
                                            class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       67 (0x43)
    .maxstack  3
    .locals init ([0] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem item,
             [1] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem[] CS$0$0000,
             [2] class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem[] CS$6$0001,
             [3] int32 CS$7$0002,
             [4] bool CS$4$0003)
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
    IL_0000:  nop
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
    IL_0001:  nop
    IL_0002:  ldc.i4.2
    IL_0003:  newarr     [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldc.i4.0
    IL_000b:  ldarg.0
    IL_000c:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::aviOutputToolStripMenuItem
    IL_0011:  stelem.ref
    IL_0012:  ldloc.1
    IL_0013:  ldc.i4.1
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem ParallelMorph.MainForm::imagesOutputToolStripMenuItem
    IL_001a:  stelem.ref
    IL_001b:  ldloc.1
    IL_001c:  stloc.2
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_001d:  ldc.i4.0
    IL_001e:  stloc.3
    IL_001f:  br.s       IL_0036

//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
    IL_0021:  ldloc.2
    IL_0022:  ldloc.3
    IL_0023:  ldelem.ref
    IL_0024:  stloc.0
//000499:             {
    IL_0025:  nop
//000500:                 item.Checked = item == sender;
    IL_0026:  ldloc.0
    IL_0027:  ldloc.0
    IL_0028:  ldarg.1
    IL_0029:  ceq
    IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.ToolStripMenuItem::set_Checked(bool)
    IL_0030:  nop
//000501:             }
    IL_0031:  nop
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_0032:  ldloc.3
    IL_0033:  ldc.i4.1
    IL_0034:  add
    IL_0035:  stloc.3
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
    IL_0036:  ldloc.3
    IL_0037:  ldloc.2
    IL_0038:  ldlen
    IL_0039:  conv.i4
    IL_003a:  clt
    IL_003c:  stloc.s    CS$4$0003
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_003e:  ldloc.s    CS$4$0003
    IL_0040:  brtrue.s   IL_0021

//000502:         }
    IL_0042:  ret
  } // end of method MainForm::outputModeToolStripMenuItem_Click

  .method private hidebysig instance void 
          morphInfoToolStripMenuItem_Click(object sender,
                                           class [mscorlib]System.EventArgs e) cil managed
  {
    // Code size       111 (0x6f)
    .maxstack  6
    .locals init ([0] class [System.Drawing]System.Drawing.Image image,
             [1] object[] CS$0$0000)
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
    IL_0000:  nop
//000506:             var image = pbStartImage.Image;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class ParallelMorph.LinedPictureBox ParallelMorph.MainForm::pbStartImage
    IL_0007:  callvirt   instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_000c:  stloc.0
//000507:             MessageBox.Show(this, 
    IL_000d:  ldarg.0
    IL_000e:  ldstr      "Lines: {1}{0}Width: {2}{0}Height: {3}{0}"
    IL_0013:  ldc.i4.4
    IL_0014:  newarr     [mscorlib]System.Object
    IL_0019:  stloc.1
    IL_001a:  ldloc.1
    IL_001b:  ldc.i4.0
    IL_001c:  call       string [mscorlib]System.Environment::get_NewLine()
    IL_0021:  stelem.ref
    IL_0022:  ldloc.1
    IL_0023:  ldc.i4.1
    IL_0024:  ldarg.0
    IL_0025:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.MainForm::_lines
    IL_002a:  callvirt   instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_002f:  box        [mscorlib]System.Int32
    IL_0034:  stelem.ref
    IL_0035:  ldloc.1
    IL_0036:  ldc.i4.2
    IL_0037:  ldloc.0
    IL_0038:  brtrue.s   IL_003d

    IL_003a:  ldc.i4.0
    IL_003b:  br.s       IL_0043

    IL_003d:  ldloc.0
    IL_003e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0043:  box        [mscorlib]System.Int32
    IL_0048:  stelem.ref
    IL_0049:  ldloc.1
    IL_004a:  ldc.i4.3
    IL_004b:  ldloc.0
    IL_004c:  brtrue.s   IL_0051

    IL_004e:  ldc.i4.0
    IL_004f:  br.s       IL_0057

    IL_0051:  ldloc.0
    IL_0052:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0057:  box        [mscorlib]System.Int32
    IL_005c:  stelem.ref
    IL_005d:  ldloc.1
    IL_005e:  call       string [mscorlib]System.String::Format(string,
                                                                object[])
    IL_0063:  ldstr      "Morph Information"
    IL_0068:  call       valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult [System.Windows.Forms]System.Windows.Forms.MessageBox::Show(class [System.Windows.Forms]System.Windows.Forms.IWin32Window,
                                                                                                                                                       string,
                                                                                                                                                       string)
    IL_006d:  pop
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
    IL_006e:  ret
  } // end of method MainForm::morphInfoToolStripMenuItem_Click

  .method private hidebysig instance void 
          '<btnMorph_Click>b__4'(object ps,
                                 class [System]System.ComponentModel.ProgressChangedEventArgs pe) cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       45 (0x2d)
    .maxstack  4
    .locals init ([0] class ParallelMorph.MainForm/'<>c__DisplayClassc' 'CS$<>8__localsd')
//000515:     }
//000516: }
    IL_0000:  newobj     instance void ParallelMorph.MainForm/'<>c__DisplayClassc'::.ctor()
    IL_0005:  stloc.0
    IL_0006:  ldloc.0
    IL_0007:  ldarg.2
    IL_0008:  stfld      class [System]System.ComponentModel.ProgressChangedEventArgs ParallelMorph.MainForm/'<>c__DisplayClassc'::pe
    IL_000d:  ldloc.0
    IL_000e:  ldarg.0
    IL_000f:  stfld      class ParallelMorph.MainForm ParallelMorph.MainForm/'<>c__DisplayClassc'::'<>4__this'
//000176:             _morpher.ProgressChanged += (ps, pe) => _uiThread.StartNew(() => pbMorphStatus.Value = pe.ProgressPercentage);
    IL_0014:  ldarg.0
    IL_0015:  ldfld      class [mscorlib]System.Threading.Tasks.TaskFactory ParallelMorph.MainForm::_uiThread
    IL_001a:  ldloc.0
    IL_001b:  ldftn      instance int32 ParallelMorph.MainForm/'<>c__DisplayClassc'::'<btnMorph_Click>b__5'()
    IL_0021:  newobj     instance void class [mscorlib]System.Func`1<int32>::.ctor(object,
                                                                                   native int)
    IL_0026:  callvirt   instance class [mscorlib]System.Threading.Tasks.Task`1<!!0> [mscorlib]System.Threading.Tasks.TaskFactory::StartNew<int32>(class [mscorlib]System.Func`1<!!0>)
    IL_002b:  pop
//000177:             Task.Factory.StartNew(() =>
//000178:             {
//000179:                 // Create an output writer based on whether we're writing to image files or to a movie file
//000180:                 using (var tempImageWriter = outputMode == OutputMode.Movie ?
//000181:                     (IImageWriter)new AviImageWriter(outputPath, settings.FramesPerSecond, startImage.Width, startImage.Height) :
//000182:                     (IImageWriter)new JpgImageWriter(outputPath, "MorphFrame"))
//000183:                 {
//000184:                     // Also display every frame to the UI
//000185:                     var imageWriter = new PassthroughImageWriter(tempImageWriter, bmp =>
//000186:                     {
//000187:                         var clonedBmp = Utilities.CreateNewBitmapFrom(bmp);
//000188:                         _uiThread.StartNew(() =>
//000189:                         {
//000190:                             Image oldImage = pbInProgressMorph.Image;
//000191:                             pbInProgressMorph.Image = clonedBmp;
//000192:                             if (oldImage != null) oldImage.Dispose();
//000193:                         });
//000194:                     });
//000195: 
//000196:                     // Run the morph synchronously
//000197:                     _morpher.Render(imageWriter, lines, startImage, endImage);
//000198:                 }
//000199: 
//000200:                 // When the morph completes, update the UI...
//000201:             }, cancellationToken).ContinueWith(t =>
//000202:             {
//000203:                 _morpher = null;
//000204:                 btnMorph.Enabled = true;
//000205:                 btnCancel.Visible = false;
//000206:                 pbMorphStatus.Visible = false;
//000207:                 splitContainer1.Visible = true;
//000208:                 menuStrip1.Enabled = true;
//000209:                 pbInProgressMorph.Visible = false;
//000210:                 if (pbInProgressMorph.Image != null)
//000211:                 {
//000212:                     Image oldImage = pbInProgressMorph.Image;
//000213:                     pbInProgressMorph.Image = null;
//000214:                     oldImage.Dispose();
//000215:                 }
//000216: 
//000217:                 this.Text = "Parallel Morph - " + t.Status + " - " + startTime.Elapsed.ToString();
//000218:                 if (t.IsFaulted) MessageBox.Show(this, t.Exception.ToString(), "Morph Error");
//000219:             }, _uiThread.Scheduler);
//000220:         }
//000221: 
//000222: 
//000223:         private void frmMainForm_KeyDown(object sender, KeyEventArgs e)
//000224:         {
//000225:             // The arrow keys allow cycling through each of the line pairs, and d/delete/back also
//000226:             // support deleting line pairs.
//000227:             switch (e.KeyCode)
//000228:             {
//000229:                 case Keys.Right: _lines.SelectNext(); break;
//000230:                 case Keys.Left: _lines.SelectPrev(); break;
//000231:                 case Keys.Up: _lines.SelectFirst(); break;
//000232:                 case Keys.Down: _lines.SelectLast(); break;
//000233:                 case Keys.Back:
//000234:                 case Keys.Delete:
//000235:                 case Keys.D:
//000236:                     if (_lines.Selected != null) _lines.Remove(_lines.Selected);
//000237:                     break;
//000238:             }
//000239:             pbStartImage.Refresh();
//000240:             pbEndImage.Refresh();
//000241:         }
//000242: 
//000243:         private void SetFoundPairAtPoint(int imageNum, PointF location)
//000244:         {
//000245:             const int radius = 6;
//000246:             int end;
//000247: 
//000248:             // First check if the selected one fits, and keep it if it does
//000249:             if (_lines.Selected != null &&
//000250:                 LineHitByPoint(_lines.Selected.Item(imageNum), location, radius, out end))
//000251:             {
//000252:                 _currentLineImageNumber = imageNum;
//000253:                 _currentLineEnd = end;
//000254:                 return;
//000255:             }
//000256: 
//000257:             // If the selected one doesn't fit reset the selected pair and try to find one that fits.
//000258:             _lines.Selected = null;
//000259:             foreach (var pair in _lines)
//000260:             {
//000261:                 Line line = pair.Item(imageNum);
//000262:                 if (LineHitByPoint(line, location, radius, out end))
//000263:                 {
//000264:                     _currentLineImageNumber = imageNum;
//000265:                     _currentLineEnd = end;
//000266:                     _lines.Selected = pair;
//000267:                     return;
//000268:                 }
//000269:             }
//000270:         }
//000271: 
//000272:         private bool LineHitByPoint(Line line, PointF location, int radius, out int end)
//000273:         {
//000274:             end = -1;
//000275:             for (int i = 0; i < 2; i++)
//000276:             {
//000277:                 PointF p = line[i];
//000278: 
//000279:                 int x = (int)(p.X - radius);
//000280:                 if (x < 0) x = 0;
//000281:                 int y = (int)(p.Y - radius);
//000282:                 if (y < 0) y = 0;
//000283: 
//000284:                 if (new RectangleF(x, y, radius * 2, radius * 2).Contains(location))
//000285:                 {
//000286:                     end = i;
//000287:                     return true;
//000288:                 }
//000289:             }
//000290:             return false;
//000291:         }
//000292: 
//000293:         private void HandleMouseDown(MouseEventArgs e, LinedPictureBox pb)
//000294:         {
//000295:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000296:             {
//000297:                 PointF point = pb.TranslateImageToControl((PointF)e.Location);
//000298:                 if (e.Button == MouseButtons.Left)
//000299:                 {
//000300:                     SetFoundPairAtPoint(pb.ImageNumber, point);
//000301:                 }
//000302:                 else
//000303:                 {
//000304:                     _lines.Add(Tuple.Create(
//000305:                         new Line(point, point),
//000306:                         new Line(point, point)));
//000307:                     _currentLineImageNumber = pb.ImageNumber;
//000308:                     _currentLineEnd = 1;
//000309:                     _lineCreationInProcess = true;
//000310:                 }
//000311:                 pbStartImage.Refresh();
//000312:                 pbEndImage.Refresh();
//000313:             }
//000314:         }
//000315: 
//000316:         private void HandleMouseUp(MouseEventArgs e, LinedPictureBox pb)
//000317:         {
//000318:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000319:             {
//000320:                 if (_lineCreationInProcess)
//000321:                 {
//000322:                     // If we're creating a new line and if the line is too small, delete it.
//000323:                     if (_lines.Selected != null)
//000324:                     {
//000325:                         var line = _lines.Selected.Item(_currentLineImageNumber);
//000326:                         if (line.Item1.Equals(line.Item2))
//000327:                         {
//000328:                             _lines.Remove(_lines.Selected);
//000329:                         }
//000330:                     }
//000331:                 }
//000332:                 _lineCreationInProcess = false;
//000333:                 pbStartImage.Refresh();
//000334:                 pbEndImage.Refresh();
//000335:             }
//000336:         }
//000337: 
//000338:         private void HandleMouseMove(MouseEventArgs e, LinedPictureBox pb)
//000339:         {
//000340:             if (pbStartImage.Image != null && pbEndImage.Image != null)
//000341:             {
//000342:                 if (_lines.Selected != null &&
//000343:                     (e.Button == MouseButtons.Left || e.Button == MouseButtons.Right))
//000344:                 {
//000345:                     _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd] = pb.TranslateImageToControl((PointF)e.Location);
//000346:                     if (_lineCreationInProcess)
//000347:                     {
//000348:                         // if we're creating the line, shape both the start and end line the same
//000349:                         _lines.Selected.Item(_currentLineImageNumber ^ 1)[_currentLineEnd] =
//000350:                             _lines.Selected.Item(_currentLineImageNumber)[_currentLineEnd];
//000351:                     }
//000352:                 }
//000353:                 pbStartImage.Refresh();
//000354:                 pbEndImage.Refresh();
//000355:             }
//000356:         }
//000357: 
//000358:         private void pbAnyImage_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
//000359:         {
//000360:             HandleMouseDown(e, (LinedPictureBox)sender);
//000361:         }
//000362: 
//000363:         private void pbAnyImage_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
//000364:         {
//000365:             HandleMouseMove(e, (LinedPictureBox)sender);
//000366:         }
//000367: 
//000368:         private void pbAnyImage_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
//000369:         {
//000370:             HandleMouseUp(e, (LinedPictureBox)sender);
//000371:         }
//000372: 
//000373:         private void autoSizeToolStripMenuItem_Click(object sender, EventArgs e)
//000374:         {
//000375:             pbStartImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000376:             pbStartImage.Dock = DockStyle.None;
//000377:             pbEndImage.SizeMode = PictureBoxSizeMode.AutoSize;
//000378:             pbEndImage.Dock = DockStyle.None;
//000379:             autoSizeToolStripMenuItem.Checked = true;
//000380:             zoomToolStripMenuItem.Checked = false;
//000381:         }
//000382: 
//000383:         private void zoomToolStripMenuItem_Click(object sender, EventArgs e)
//000384:         {
//000385:             pbStartImage.SizeMode = PictureBoxSizeMode.Zoom;
//000386:             pbStartImage.Dock = DockStyle.Fill;
//000387:             pbEndImage.SizeMode = PictureBoxSizeMode.Zoom;
//000388:             pbEndImage.Dock = DockStyle.Fill;
//000389:             autoSizeToolStripMenuItem.Checked = false;
//000390:             zoomToolStripMenuItem.Checked = true;
//000391:         }
//000392: 
//000393:         private void optionsToolStripMenuItem_Click(object sender, EventArgs e)
//000394:         {
//000395:             using (EditSettings es = new EditSettings())
//000396:             {
//000397:                 es.Settings = _morphSettings;
//000398:                 es.ShowDialog(this);
//000399:             }
//000400:         }
//000401: 
//000402:         private void exitToolStripMenuItem_Click(object sender, EventArgs e)
//000403:         {
//000404:             Application.Exit();
//000405:         }
//000406: 
//000407:         private void newToolStripMenuItem_Click(object sender, EventArgs e)
//000408:         {
//000409:             this.Text = "Parallel Morph";
//000410:             _lines = new LinePairCollection();
//000411:             ConfigurePictureBoxes(_lines, null, null);
//000412:         }
//000413: 
//000414:         private void openToolStripMenuItem_Click(object sender, EventArgs e)
//000415:         {
//000416:             _lines.Selected = null;
//000417:             using (OpenFileDialog ofd = new OpenFileDialog())
//000418:             {
//000419:                 ofd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000420:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000421:                 {
//000422:                     var formatter = new BinaryFormatter();
//000423:                     using (Stream fileStream = ofd.OpenFile())
//000424:                     {
//000425:                         SavedSettings ss = (SavedSettings)formatter.Deserialize(fileStream);
//000426:                         _lines = ss.Lines;
//000427:                         _morphSettings = ss.Settings;
//000428:                         ConfigurePictureBoxes(_lines, ss.FirstImage, ss.SecondImage);
//000429:                     }
//000430:                 }
//000431:             }
//000432:         }
//000433: 
//000434:         private void saveToolStripMenuItem_Click(object sender, EventArgs e)
//000435:         {
//000436:             _lines.Selected = null;
//000437:             SavedSettings ss = new SavedSettings
//000438:             {
//000439:                 FirstImage = pbStartImage.Image,
//000440:                 SecondImage = pbEndImage.Image,
//000441:                 Lines = _lines,
//000442:                 Settings = _morphSettings
//000443:             };
//000444:             using (SaveFileDialog sfd = new SaveFileDialog())
//000445:             {
//000446:                 sfd.Filter = "Morph Files (*.morph)|*.morph|All Files (*.*)|*.*";
//000447:                 if (sfd.ShowDialog(this) == DialogResult.OK)
//000448:                 {
//000449:                     var formatter = new BinaryFormatter();
//000450:                     using (Stream fileStream = sfd.OpenFile())
//000451:                     {
//000452:                         formatter.Serialize(fileStream, ss);
//000453:                     }
//000454:                 }
//000455:             }
//000456:         }
//000457: 
//000458:         private void LoadPictureBoxImage(object sender, EventArgs e)
//000459:         {
//000460:             _lines.Selected = null;
//000461:             using (OpenFileDialog ofd = new OpenFileDialog())
//000462:             {
//000463:                 ofd.Filter = "Image Files (*.jpg)|*.jpg|All Files (*.*)|*.*";
//000464:                 if (ofd.ShowDialog(this) == DialogResult.OK)
//000465:                 {
//000466:                     ((PictureBox)sender).Image = new Bitmap(ofd.FileName);
//000467:                 }
//000468:             }
//000469:             if (pbStartImage.Image != null && pbEndImage.Image != null) btnMorph.Enabled = true;
//000470:         }
//000471: 
//000472:         private void splitContainer1_Panel1_DoubleClick(object sender, EventArgs e)
//000473:         {
//000474:             LoadPictureBoxImage(pbStartImage, e);
//000475:         }
//000476: 
//000477:         private void splitContainer1_Panel2_DoubleClick(object sender, EventArgs e)
//000478:         {
//000479:             LoadPictureBoxImage(pbEndImage, e);
//000480:         }
//000481: 
//000482:         private void btnCancel_Click(object sender, EventArgs e)
//000483:         {
//000484:             if (_currentCancellationSource != null) _currentCancellationSource.Cancel();
//000485:             btnCancel.Enabled = false;
//000486:         }
//000487: 
//000488:         private void parallelModeToolStripMenuItem_Click(object sender, EventArgs e)
//000489:         {
//000490:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { sequentialProcessingModeToolStripMenuItem, parallelProcessingModeToolStripMenuItem })
//000491:             {
//000492:                 item.Checked = item == sender;
//000493:             }
//000494:         }
//000495: 
//000496:         private void outputModeToolStripMenuItem_Click(object sender, EventArgs e)
//000497:         {
//000498:             foreach (ToolStripMenuItem item in new ToolStripMenuItem[] { aviOutputToolStripMenuItem, imagesOutputToolStripMenuItem })
//000499:             {
//000500:                 item.Checked = item == sender;
//000501:             }
//000502:         }
//000503: 
//000504:         private void morphInfoToolStripMenuItem_Click(object sender, EventArgs e)
//000505:         {
//000506:             var image = pbStartImage.Image;
//000507:             MessageBox.Show(this, 
//000508:                 string.Format("Lines: {1}{0}Width: {2}{0}Height: {3}{0}",
//000509:                     Environment.NewLine,
//000510:                     _lines.Count, 
//000511:                     image != null ? image.Width : 0,
//000512:                     image != null ? image.Height : 0),
//000513:                 "Morph Information");
//000514:         }
//000515:     }
//000516: }
    IL_002c:  ret
  } // end of method MainForm::'<btnMorph_Click>b__4'

} // end of class ParallelMorph.MainForm

.class private auto ansi sealed beforefieldinit ParallelMorph.Properties.Settings
       extends [System]System.Configuration.ApplicationSettingsBase
{
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 4B 4D 69 63 72 6F 73 6F 66 74 2E 56 69 73   // ..KMicrosoft.Vis
                                                                                                  75 61 6C 53 74 75 64 69 6F 2E 45 64 69 74 6F 72   // ualStudio.Editor
                                                                                                  73 2E 53 65 74 74 69 6E 67 73 44 65 73 69 67 6E   // s.SettingsDesign
                                                                                                  65 72 2E 53 65 74 74 69 6E 67 73 53 69 6E 67 6C   // er.SettingsSingl
                                                                                                  65 46 69 6C 65 47 65 6E 65 72 61 74 6F 72 08 31   // eFileGenerator.1
                                                                                                  30 2E 30 2E 30 2E 30 00 00 )                      // 0.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class ParallelMorph.Properties.Settings defaultInstance
  .method public hidebysig specialname static 
          class ParallelMorph.Properties.Settings 
          get_Default() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class ParallelMorph.Properties.Settings CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Settings.Designer.cs' 
//000021:             get {
    IL_0000:  nop
//000022:                 return defaultInstance;
    IL_0001:  ldsfld     class ParallelMorph.Properties.Settings ParallelMorph.Properties.Settings::defaultInstance
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000023:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Settings::get_Default

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System]System.Configuration.ApplicationSettingsBase::.ctor()
    IL_0006:  ret
  } // end of method Settings::.ctor

  .method private hidebysig specialname rtspecialname static 
          void  .cctor() cil managed
  {
    // Code size       21 (0x15)
    .maxstack  8
//000018:         private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
    IL_0000:  newobj     instance void ParallelMorph.Properties.Settings::.ctor()
    IL_0005:  call       class [System]System.Configuration.SettingsBase [System]System.Configuration.SettingsBase::Synchronized(class [System]System.Configuration.SettingsBase)
    IL_000a:  castclass  ParallelMorph.Properties.Settings
    IL_000f:  stsfld     class ParallelMorph.Properties.Settings ParallelMorph.Properties.Settings::defaultInstance
//000019:         
//000020:         public static Settings Default {
//000021:             get {
//000022:                 return defaultInstance;
//000023:             }
//000024:         }
//000025:     }
//000026: }
    IL_0014:  ret
  } // end of method Settings::.cctor

  .property class ParallelMorph.Properties.Settings
          Default()
  {
    .get class ParallelMorph.Properties.Settings ParallelMorph.Properties.Settings::get_Default()
  } // end of property Settings::Default
} // end of class ParallelMorph.Properties.Settings

.class interface public abstract auto ansi ParallelMorph.IImageWriter
       implements [mscorlib]System.IDisposable
{
  .method public hidebysig newslot abstract virtual 
          instance void  AddFrame(class [System.Drawing]System.Drawing.Bitmap frame) cil managed
  {
  } // end of method IImageWriter::AddFrame

} // end of class ParallelMorph.IImageWriter

.class public auto ansi beforefieldinit ParallelMorph.PassthroughImageWriter
       extends [mscorlib]System.Object
       implements ParallelMorph.IImageWriter,
                  [mscorlib]System.IDisposable
{
  .field private class ParallelMorph.IImageWriter _writer
  .field private class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] _handlers
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class ParallelMorph.IImageWriter writer,
                               class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] handlers) cil managed
  {
    .param [2]
    .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       46 (0x2e)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\PassthroughImageWriter.cs' 
//000019:         public PassthroughImageWriter(IImageWriter writer, params Action<Bitmap> [] handlers)
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000020:         {
    IL_0007:  nop
//000021:             if (writer == null) throw new ArgumentNullException("writer");
    IL_0008:  ldarg.1
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.0
//000022:             _writer = writer;
//000023:             _handlers = handlers;
//000024:         }
//000025: 
//000026:         public void AddFrame(Bitmap frame)
//000027:         {
//000028:             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
//000029:             _writer.AddFrame(frame);
//000030:         }
//000031: 
//000032:         void IDisposable.Dispose() {}
//000033:     }
//000034: }
    IL_0010:  ldloc.0
    IL_0011:  brtrue.s   IL_001e

//000021:             if (writer == null) throw new ArgumentNullException("writer");
    IL_0013:  ldstr      "writer"
    IL_0018:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_001d:  throw

//000022:             _writer = writer;
    IL_001e:  ldarg.0
    IL_001f:  ldarg.1
    IL_0020:  stfld      class ParallelMorph.IImageWriter ParallelMorph.PassthroughImageWriter::_writer
//000023:             _handlers = handlers;
    IL_0025:  ldarg.0
    IL_0026:  ldarg.2
    IL_0027:  stfld      class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] ParallelMorph.PassthroughImageWriter::_handlers
//000024:         }
    IL_002c:  nop
    IL_002d:  ret
  } // end of method PassthroughImageWriter::.ctor

  .method public hidebysig newslot virtual final 
          instance void  AddFrame(class [System.Drawing]System.Drawing.Bitmap frame) cil managed
  {
    // Code size       66 (0x42)
    .maxstack  2
    .locals init ([0] class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap> 'handler',
             [1] bool CS$4$0000,
             [2] class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] CS$6$0001,
             [3] int32 CS$7$0002)
//000025: 
//000026:         public void AddFrame(Bitmap frame)
//000027:         {
    IL_0000:  nop
//000028:             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] ParallelMorph.PassthroughImageWriter::_handlers
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  stloc.1
//000029:             _writer.AddFrame(frame);
//000030:         }
//000031: 
//000032:         void IDisposable.Dispose() {}
//000033:     }
//000034: }
    IL_000b:  ldloc.1
    IL_000c:  brtrue.s   IL_0034

//000028:             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
    IL_000e:  nop
    IL_000f:  ldarg.0
    IL_0010:  ldfld      class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>[] ParallelMorph.PassthroughImageWriter::_handlers
    IL_0015:  stloc.2
//000029:             _writer.AddFrame(frame);
//000030:         }
//000031: 
//000032:         void IDisposable.Dispose() {}
//000033:     }
//000034: }
    IL_0016:  ldc.i4.0
    IL_0017:  stloc.3
    IL_0018:  br.s       IL_002a

//000028:             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
    IL_001a:  ldloc.2
    IL_001b:  ldloc.3
    IL_001c:  ldelem.ref
    IL_001d:  stloc.0
    IL_001e:  ldloc.0
    IL_001f:  ldarg.1
    IL_0020:  callvirt   instance void class [mscorlib]System.Action`1<class [System.Drawing]System.Drawing.Bitmap>::Invoke(!0)
    IL_0025:  nop
//000029:             _writer.AddFrame(frame);
//000030:         }
//000031: 
//000032:         void IDisposable.Dispose() {}
//000033:     }
//000034: }
    IL_0026:  ldloc.3
    IL_0027:  ldc.i4.1
    IL_0028:  add
    IL_0029:  stloc.3
//000028:             if (_handlers != null) foreach (var handler in _handlers) handler(frame);
    IL_002a:  ldloc.3
    IL_002b:  ldloc.2
    IL_002c:  ldlen
    IL_002d:  conv.i4
    IL_002e:  clt
    IL_0030:  stloc.1
//000029:             _writer.AddFrame(frame);
//000030:         }
//000031: 
//000032:         void IDisposable.Dispose() {}
//000033:     }
//000034: }
    IL_0031:  ldloc.1
    IL_0032:  brtrue.s   IL_001a

//000029:             _writer.AddFrame(frame);
    IL_0034:  ldarg.0
    IL_0035:  ldfld      class ParallelMorph.IImageWriter ParallelMorph.PassthroughImageWriter::_writer
    IL_003a:  ldarg.1
    IL_003b:  callvirt   instance void ParallelMorph.IImageWriter::AddFrame(class [System.Drawing]System.Drawing.Bitmap)
    IL_0040:  nop
//000030:         }
    IL_0041:  ret
  } // end of method PassthroughImageWriter::AddFrame

  .method private hidebysig newslot virtual final 
          instance void  System.IDisposable.Dispose() cil managed
  {
    .override [mscorlib]System.IDisposable::Dispose
    // Code size       2 (0x2)
    .maxstack  8
//000031: 
//000032:         void IDisposable.Dispose() {}
    IL_0000:  nop
    IL_0001:  ret
  } // end of method PassthroughImageWriter::System.IDisposable.Dispose

} // end of class ParallelMorph.PassthroughImageWriter

.class public auto ansi beforefieldinit ParallelMorph.JpgImageWriter
       extends [mscorlib]System.Object
       implements ParallelMorph.IImageWriter,
                  [mscorlib]System.IDisposable
{
  .field private string _imageFilePrefix
  .field private string _directoryPath
  .field private int32 _frameNum
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(string directoryPath,
                               string imageFilePrefix) cil managed
  {
    // Code size       103 (0x67)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\JpgImageWriter.cs' 
//000020:         private int _frameNum = 0;
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.0
    IL_0002:  stfld      int32 ParallelMorph.JpgImageWriter::_frameNum
//000021: 
//000022:         public JpgImageWriter(string directoryPath, string imageFilePrefix)
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
    IL_000d:  nop
//000023:         {
    IL_000e:  nop
//000024:             if (directoryPath == null) throw new ArgumentNullException("directoryPath");
    IL_000f:  ldarg.1
    IL_0010:  ldnull
    IL_0011:  ceq
    IL_0013:  ldc.i4.0
    IL_0014:  ceq
    IL_0016:  stloc.0
//000025:             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
//000026:             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
//000027:             _directoryPath = directoryPath;
//000028:             _imageFilePrefix = imageFilePrefix;
//000029:         }
//000030: 
//000031:         public void AddFrame(Bitmap frame)
//000032:         {
//000033:             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
//000034:         }
//000035: 
//000036:         public void Dispose() { }
//000037:     }
//000038: }
    IL_0017:  ldloc.0
    IL_0018:  brtrue.s   IL_0025

//000024:             if (directoryPath == null) throw new ArgumentNullException("directoryPath");
    IL_001a:  ldstr      "directoryPath"
    IL_001f:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0024:  throw

//000025:             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
    IL_0025:  ldarg.2
    IL_0026:  ldnull
    IL_0027:  ceq
    IL_0029:  ldc.i4.0
    IL_002a:  ceq
    IL_002c:  stloc.0
//000026:             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
//000027:             _directoryPath = directoryPath;
//000028:             _imageFilePrefix = imageFilePrefix;
//000029:         }
//000030: 
//000031:         public void AddFrame(Bitmap frame)
//000032:         {
//000033:             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
//000034:         }
//000035: 
//000036:         public void Dispose() { }
//000037:     }
//000038: }
    IL_002d:  ldloc.0
    IL_002e:  brtrue.s   IL_003b

//000025:             if (imageFilePrefix == null) throw new ArgumentNullException("imageFilePrefix");
    IL_0030:  ldstr      "imageFilePrefix"
    IL_0035:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_003a:  throw

//000026:             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
    IL_003b:  ldarg.1
    IL_003c:  ldstr      "\\"
    IL_0041:  callvirt   instance bool [mscorlib]System.String::EndsWith(string)
    IL_0046:  stloc.0
//000027:             _directoryPath = directoryPath;
//000028:             _imageFilePrefix = imageFilePrefix;
//000029:         }
//000030: 
//000031:         public void AddFrame(Bitmap frame)
//000032:         {
//000033:             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
//000034:         }
//000035: 
//000036:         public void Dispose() { }
//000037:     }
//000038: }
    IL_0047:  ldloc.0
    IL_0048:  brtrue.s   IL_0057

//000026:             if (!directoryPath.EndsWith("\\")) directoryPath += "\\";
    IL_004a:  ldarg.1
    IL_004b:  ldstr      "\\"
    IL_0050:  call       string [mscorlib]System.String::Concat(string,
                                                                string)
    IL_0055:  starg.s    directoryPath
//000027:             _directoryPath = directoryPath;
    IL_0057:  ldarg.0
    IL_0058:  ldarg.1
    IL_0059:  stfld      string ParallelMorph.JpgImageWriter::_directoryPath
//000028:             _imageFilePrefix = imageFilePrefix;
    IL_005e:  ldarg.0
    IL_005f:  ldarg.2
    IL_0060:  stfld      string ParallelMorph.JpgImageWriter::_imageFilePrefix
//000029:         }
    IL_0065:  nop
    IL_0066:  ret
  } // end of method JpgImageWriter::.ctor

  .method public hidebysig newslot virtual final 
          instance void  AddFrame(class [System.Drawing]System.Drawing.Bitmap frame) cil managed
  {
    // Code size       86 (0x56)
    .maxstack  6
    .locals init ([0] object[] CS$0$0000,
             [1] int32 CS$0$0001)
//000030: 
//000031:         public void AddFrame(Bitmap frame)
//000032:         {
    IL_0000:  nop
//000033:             frame.Save(_directoryPath + _imageFilePrefix + "_" + _frameNum++ + ".jpg", ImageFormat.Jpeg);
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.5
    IL_0003:  newarr     [mscorlib]System.Object
    IL_0008:  stloc.0
    IL_0009:  ldloc.0
    IL_000a:  ldc.i4.0
    IL_000b:  ldarg.0
    IL_000c:  ldfld      string ParallelMorph.JpgImageWriter::_directoryPath
    IL_0011:  stelem.ref
    IL_0012:  ldloc.0
    IL_0013:  ldc.i4.1
    IL_0014:  ldarg.0
    IL_0015:  ldfld      string ParallelMorph.JpgImageWriter::_imageFilePrefix
    IL_001a:  stelem.ref
    IL_001b:  ldloc.0
    IL_001c:  ldc.i4.2
    IL_001d:  ldstr      "_"
    IL_0022:  stelem.ref
    IL_0023:  ldloc.0
    IL_0024:  ldc.i4.3
    IL_0025:  ldarg.0
    IL_0026:  dup
    IL_0027:  ldfld      int32 ParallelMorph.JpgImageWriter::_frameNum
    IL_002c:  dup
    IL_002d:  stloc.1
    IL_002e:  ldc.i4.1
    IL_002f:  add
    IL_0030:  stfld      int32 ParallelMorph.JpgImageWriter::_frameNum
    IL_0035:  ldloc.1
    IL_0036:  box        [mscorlib]System.Int32
    IL_003b:  stelem.ref
    IL_003c:  ldloc.0
    IL_003d:  ldc.i4.4
    IL_003e:  ldstr      ".jpg"
    IL_0043:  stelem.ref
    IL_0044:  ldloc.0
    IL_0045:  call       string [mscorlib]System.String::Concat(object[])
    IL_004a:  call       class [System.Drawing]System.Drawing.Imaging.ImageFormat [System.Drawing]System.Drawing.Imaging.ImageFormat::get_Jpeg()
    IL_004f:  callvirt   instance void [System.Drawing]System.Drawing.Image::Save(string,
                                                                                  class [System.Drawing]System.Drawing.Imaging.ImageFormat)
    IL_0054:  nop
//000034:         }
    IL_0055:  ret
  } // end of method JpgImageWriter::AddFrame

  .method public hidebysig newslot virtual final 
          instance void  Dispose() cil managed
  {
    // Code size       2 (0x2)
    .maxstack  8
//000035: 
//000036:         public void Dispose() { }
    IL_0000:  nop
    IL_0001:  ret
  } // end of method JpgImageWriter::Dispose

} // end of class ParallelMorph.JpgImageWriter

.class public auto ansi sealed beforefieldinit ParallelMorph.ComputeMorph
       extends [mscorlib]System.Object
{
  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass2'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 width
    .field public int32 height
    .field public class ParallelMorph.ComputeMorph '<>4__this'
    .field public class Microsoft.Drawing.FastBitmap bmp
    .field public class ParallelMorph.LinePairCollection pairs
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass2'::.ctor

  } // end of class '<>c__DisplayClass2'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass5'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' 'CS$<>8__locals3'
    .field public class Microsoft.Drawing.FastBitmap fastOut
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass5'::.ctor

    .method public hidebysig instance void 
            '<ComputePreimage>b__1'(int32 j,
                                    class [mscorlib]System.Threading.Tasks.ParallelLoopState loop) cil managed
    {
      // Code size       205 (0xcd)
      .maxstack  5
      .locals init ([0] int32 i,
               [1] valuetype [System.Drawing]System.Drawing.PointF pf,
               [2] valuetype [System.Drawing]System.Drawing.Point p,
               [3] valuetype Microsoft.Drawing.PixelData* inPixel,
               [4] valuetype Microsoft.Drawing.PixelData* outPixel,
               [5] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorph.cs' 
//000257:                     {
      IL_0000:  nop
//000258:                         for (int i = 0; i < width; i++)
      IL_0001:  ldc.i4.0
      IL_0002:  stloc.0
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0003:  br         IL_00b5

//000259:                         {
      IL_0008:  nop
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_000f:  ldfld      class ParallelMorph.ComputeMorph ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::'<>4__this'
      IL_0014:  ldloc.0
      IL_0015:  conv.r4
      IL_0016:  ldarg.1
      IL_0017:  conv.r4
      IL_0018:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_001d:  ldarg.0
      IL_001e:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_0023:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::pairs
      IL_0028:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::GetPreimageLocation(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                                    class ParallelMorph.LinePairCollection)
      IL_002d:  stloc.1
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
      IL_002e:  ldarg.0
      IL_002f:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_0034:  ldfld      class ParallelMorph.ComputeMorph ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::'<>4__this'
      IL_0039:  ldloc.1
      IL_003a:  ldarg.0
      IL_003b:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_0040:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
      IL_0045:  ldarg.0
      IL_0046:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_004b:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
      IL_0050:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_0055:  call       instance valuetype [System.Drawing]System.Drawing.Point ParallelMorph.ComputeMorph::ClampPoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.Size)
      IL_005a:  stloc.2
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
      IL_005b:  ldarg.0
      IL_005c:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_0061:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::bmp
      IL_0066:  ldloca.s   p
      IL_0068:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
      IL_006d:  ldloca.s   p
      IL_006f:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
      IL_0074:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_0079:  stloc.3
//000263:                             PixelData* outPixel = fastOut[i, j];
      IL_007a:  ldarg.0
      IL_007b:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::fastOut
      IL_0080:  ldloc.0
      IL_0081:  ldarg.1
      IL_0082:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_0087:  stloc.s    outPixel
//000264:                             outPixel->R = inPixel->R;
      IL_0089:  ldloc.s    outPixel
      IL_008b:  ldloc.3
      IL_008c:  ldfld      uint8 Microsoft.Drawing.PixelData::R
      IL_0091:  stfld      uint8 Microsoft.Drawing.PixelData::R
//000265:                             outPixel->G = inPixel->G;
      IL_0096:  ldloc.s    outPixel
      IL_0098:  ldloc.3
      IL_0099:  ldfld      uint8 Microsoft.Drawing.PixelData::G
      IL_009e:  stfld      uint8 Microsoft.Drawing.PixelData::G
//000266:                             outPixel->B = inPixel->B;
      IL_00a3:  ldloc.s    outPixel
      IL_00a5:  ldloc.3
      IL_00a6:  ldfld      uint8 Microsoft.Drawing.PixelData::B
      IL_00ab:  stfld      uint8 Microsoft.Drawing.PixelData::B
//000267:                         }
      IL_00b0:  nop
//000258:                         for (int i = 0; i < width; i++)
      IL_00b1:  ldloc.0
      IL_00b2:  ldc.i4.1
      IL_00b3:  add
      IL_00b4:  stloc.0
      IL_00b5:  ldloc.0
      IL_00b6:  ldarg.0
      IL_00b7:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
      IL_00bc:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
      IL_00c1:  clt
      IL_00c3:  stloc.s    CS$4$0000
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_00c5:  ldloc.s    CS$4$0000
      IL_00c7:  brtrue     IL_0008

      IL_00cc:  ret
    } // end of method '<>c__DisplayClass5'::'<ComputePreimage>b__1'

  } // end of class '<>c__DisplayClass5'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClass8'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public int32 height
    .field public float64 blend
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClass8'::.ctor

  } // end of class '<>c__DisplayClass8'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassa'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Microsoft.Drawing.FastBitmap fastOut
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassa'::.ctor

  } // end of class '<>c__DisplayClassa'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassc'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class Microsoft.Drawing.FastBitmap fastStart
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassc'::.ctor

  } // end of class '<>c__DisplayClassc'

  .class auto ansi sealed nested private beforefieldinit '<>c__DisplayClassf'
         extends [mscorlib]System.Object
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    .field public class ParallelMorph.ComputeMorph/'<>c__DisplayClassc' 'CS$<>8__localsd'
    .field public class ParallelMorph.ComputeMorph/'<>c__DisplayClassa' 'CS$<>8__localsb'
    .field public class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' 'CS$<>8__locals9'
    .field public class Microsoft.Drawing.FastBitmap fastEnd
    .method public hidebysig specialname rtspecialname 
            instance void  .ctor() cil managed
    {
      // Code size       7 (0x7)
      .maxstack  8
      IL_0000:  ldarg.0
      IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
      IL_0006:  ret
    } // end of method '<>c__DisplayClassf'::.ctor

    .method public hidebysig instance void 
            '<BlendImages>b__7'(int32 i) cil managed
    {
      // Code size       288 (0x120)
      .maxstack  5
      .locals init ([0] int32 j,
               [1] valuetype Microsoft.Drawing.PixelData* outPixel,
               [2] valuetype Microsoft.Drawing.PixelData* startPixel,
               [3] valuetype Microsoft.Drawing.PixelData* endPixel,
               [4] bool CS$4$0000)
//000332:                     {
      IL_0000:  nop
//000333:                         for (int j = 0; j < height; j++)
      IL_0001:  ldc.i4.0
      IL_0002:  stloc.0
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0003:  br         IL_0108

//000334:                         {
      IL_0008:  nop
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
      IL_0009:  ldarg.0
      IL_000a:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClassa' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__localsb'
      IL_000f:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::fastOut
      IL_0014:  ldarg.1
      IL_0015:  ldloc.0
      IL_0016:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_001b:  stloc.1
//000337:                             PixelData* startPixel = fastStart[i, j];
      IL_001c:  ldarg.0
      IL_001d:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClassc' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__localsd'
      IL_0022:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::fastStart
      IL_0027:  ldarg.1
      IL_0028:  ldloc.0
      IL_0029:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_002e:  stloc.2
//000338:                             PixelData* endPixel = fastEnd[i, j];
      IL_002f:  ldarg.0
      IL_0030:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::fastEnd
      IL_0035:  ldarg.1
      IL_0036:  ldloc.0
      IL_0037:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_003c:  stloc.3
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
      IL_003d:  ldloc.1
      IL_003e:  ldloc.2
      IL_003f:  ldfld      uint8 Microsoft.Drawing.PixelData::R
      IL_0044:  conv.r8
      IL_0045:  ldarg.0
      IL_0046:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_004b:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_0050:  mul
      IL_0051:  ldc.r8     0.5
      IL_005a:  add
      IL_005b:  ldloc.3
      IL_005c:  ldfld      uint8 Microsoft.Drawing.PixelData::R
      IL_0061:  conv.r8
      IL_0062:  ldc.r8     1.
      IL_006b:  ldarg.0
      IL_006c:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_0071:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_0076:  sub
      IL_0077:  mul
      IL_0078:  add
      IL_0079:  conv.u1
      IL_007a:  stfld      uint8 Microsoft.Drawing.PixelData::R
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
      IL_007f:  ldloc.1
      IL_0080:  ldloc.2
      IL_0081:  ldfld      uint8 Microsoft.Drawing.PixelData::G
      IL_0086:  conv.r8
      IL_0087:  ldarg.0
      IL_0088:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_008d:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_0092:  mul
      IL_0093:  ldc.r8     0.5
      IL_009c:  add
      IL_009d:  ldloc.3
      IL_009e:  ldfld      uint8 Microsoft.Drawing.PixelData::G
      IL_00a3:  conv.r8
      IL_00a4:  ldc.r8     1.
      IL_00ad:  ldarg.0
      IL_00ae:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_00b3:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_00b8:  sub
      IL_00b9:  mul
      IL_00ba:  add
      IL_00bb:  conv.u1
      IL_00bc:  stfld      uint8 Microsoft.Drawing.PixelData::G
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
      IL_00c1:  ldloc.1
      IL_00c2:  ldloc.2
      IL_00c3:  ldfld      uint8 Microsoft.Drawing.PixelData::B
      IL_00c8:  conv.r8
      IL_00c9:  ldarg.0
      IL_00ca:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_00cf:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_00d4:  mul
      IL_00d5:  ldc.r8     0.5
      IL_00de:  add
      IL_00df:  ldloc.3
      IL_00e0:  ldfld      uint8 Microsoft.Drawing.PixelData::B
      IL_00e5:  conv.r8
      IL_00e6:  ldc.r8     1.
      IL_00ef:  ldarg.0
      IL_00f0:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_00f5:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
      IL_00fa:  sub
      IL_00fb:  mul
      IL_00fc:  add
      IL_00fd:  conv.u1
      IL_00fe:  stfld      uint8 Microsoft.Drawing.PixelData::B
//000344:                         }
      IL_0103:  nop
//000333:                         for (int j = 0; j < height; j++)
      IL_0104:  ldloc.0
      IL_0105:  ldc.i4.1
      IL_0106:  add
      IL_0107:  stloc.0
      IL_0108:  ldloc.0
      IL_0109:  ldarg.0
      IL_010a:  ldfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
      IL_010f:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::height
      IL_0114:  clt
      IL_0116:  stloc.s    CS$4$0000
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0118:  ldloc.s    CS$4$0000
      IL_011a:  brtrue     IL_0008

      IL_011f:  ret
    } // end of method '<>c__DisplayClassf'::'<BlendImages>b__7'

  } // end of class '<>c__DisplayClassf'

  .field private class ParallelMorph.ComputeMorphOptions _options
  .field private int32 _curFrame
  .field private valuetype [mscorlib]System.Threading.CancellationToken _cancellationToken
  .field private bool _useParallelism
  .field private class [System]System.ComponentModel.ProgressChangedEventHandler ProgressChanged
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class ParallelMorph.ComputeMorphOptions options,
                               bool useParallelism,
                               valuetype [mscorlib]System.Threading.CancellationToken cancellationToken) cil managed
  {
    // Code size       60 (0x3c)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000022: 		private int _curFrame = 0;
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.0
    IL_0002:  stfld      int32 ParallelMorph.ComputeMorph::_curFrame
//000023:         private CancellationToken _cancellationToken;
//000024:         private bool _useParallelism;
//000025: 
//000026:         public ComputeMorph(ComputeMorphOptions options, bool useParallelism, CancellationToken cancellationToken)
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [mscorlib]System.Object::.ctor()
    IL_000d:  nop
//000027:         {
    IL_000e:  nop
//000028:             if (options == null) throw new ArgumentNullException("options");
    IL_000f:  ldarg.1
    IL_0010:  ldnull
    IL_0011:  ceq
    IL_0013:  ldc.i4.0
    IL_0014:  ceq
    IL_0016:  stloc.0
//000029:             _options = options;
//000030:             _useParallelism = useParallelism;
//000031:             _cancellationToken = cancellationToken;
//000032:         }
//000033: 
//000034:         public event ProgressChangedEventHandler ProgressChanged;
//000035: 
//000036:         private void UpdateProgressChanged()
//000037:         {
//000038:             ProgressChangedEventHandler handler = ProgressChanged;
//000039:             if (handler != null)
//000040:             {
//000041:                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
//000042:                 handler(this, new ProgressChangedEventArgs((int)progress, null));
//000043:             }
//000044:         }
//000045: 
//000046:         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
//000047:         {
//000048:             using (FastBitmap fastStartImage = new FastBitmap(startImage))
//000049:             using (FastBitmap fastEndImage = new FastBitmap(endImage))
//000050:             {
//000051:                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
//000052:             }
//000053:         }
//000054: 
//000055:         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
//000056:         {
//000057:             var forwardsAndBackwards = InterpolateLines(lines, percent);
//000058:             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
//000059:             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
//000060:                 return BlendImages(forward, backward, 1 - percent);
//000061:         }
//000062: 
//000063: 		/// <summary>Create the morphed images and video.</summary>
//000064:         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
//000065:         {
//000066:             _curFrame = 0;
//000067:             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
//000068: 
//000069:             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
//000070:             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
//000071:             {
//000072:                 // Write out the starting picture
//000073:                 imageWriter.AddFrame(clonedStart);
//000074:                 _curFrame = 1;
//000075:                 UpdateProgressChanged();
//000076: 
//000077:                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
//000078:                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
//000079:                 {
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0017:  ldloc.0
    IL_0018:  brtrue.s   IL_0025

//000028:             if (options == null) throw new ArgumentNullException("options");
    IL_001a:  ldstr      "options"
    IL_001f:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0024:  throw

//000029:             _options = options;
    IL_0025:  ldarg.0
    IL_0026:  ldarg.1
    IL_0027:  stfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
//000030:             _useParallelism = useParallelism;
    IL_002c:  ldarg.0
    IL_002d:  ldarg.2
    IL_002e:  stfld      bool ParallelMorph.ComputeMorph::_useParallelism
//000031:             _cancellationToken = cancellationToken;
    IL_0033:  ldarg.0
    IL_0034:  ldarg.3
    IL_0035:  stfld      valuetype [mscorlib]System.Threading.CancellationToken ParallelMorph.ComputeMorph::_cancellationToken
//000032:         }
    IL_003a:  nop
    IL_003b:  ret
  } // end of method ComputeMorph::.ctor

  .method public hidebysig specialname instance void 
          add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [System]System.ComponentModel.ProgressChangedEventHandler V_0,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_1,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler ParallelMorph.ComputeMorph::ProgressChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate,
                                                                                            class [mscorlib]System.Delegate)
    IL_0010:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [System]System.ComponentModel.ProgressChangedEventHandler ParallelMorph.ComputeMorph::ProgressChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [System]System.ComponentModel.ProgressChangedEventHandler>(!!0&,
                                                                                                                                                      !!0,
                                                                                                                                                      !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ComputeMorph::add_ProgressChanged

  .method public hidebysig specialname instance void 
          remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler 'value') cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init (class [System]System.ComponentModel.ProgressChangedEventHandler V_0,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_1,
             class [System]System.ComponentModel.ProgressChangedEventHandler V_2,
             bool V_3)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler ParallelMorph.ComputeMorph::ProgressChanged
    IL_0006:  stloc.0
    IL_0007:  ldloc.0
    IL_0008:  stloc.1
    IL_0009:  ldloc.1
    IL_000a:  ldarg.1
    IL_000b:  call       class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate,
                                                                                           class [mscorlib]System.Delegate)
    IL_0010:  castclass  [System]System.ComponentModel.ProgressChangedEventHandler
    IL_0015:  stloc.2
    IL_0016:  ldarg.0
    IL_0017:  ldflda     class [System]System.ComponentModel.ProgressChangedEventHandler ParallelMorph.ComputeMorph::ProgressChanged
    IL_001c:  ldloc.2
    IL_001d:  ldloc.1
    IL_001e:  call       !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [System]System.ComponentModel.ProgressChangedEventHandler>(!!0&,
                                                                                                                                                      !!0,
                                                                                                                                                      !!0)
    IL_0023:  stloc.0
    IL_0024:  ldloc.0
    IL_0025:  ldloc.1
    IL_0026:  ceq
    IL_0028:  ldc.i4.0
    IL_0029:  ceq
    IL_002b:  stloc.3
    IL_002c:  ldloc.3
    IL_002d:  brtrue.s   IL_0007

    IL_002f:  ret
  } // end of method ComputeMorph::remove_ProgressChanged

  .method private hidebysig instance void 
          UpdateProgressChanged() cil managed
  {
    // Code size       66 (0x42)
    .maxstack  5
    .locals init ([0] class [System]System.ComponentModel.ProgressChangedEventHandler 'handler',
             [1] float64 progress,
             [2] bool CS$4$0000)
//000033: 
//000034:         public event ProgressChangedEventHandler ProgressChanged;
//000035: 
//000036:         private void UpdateProgressChanged()
//000037:         {
    IL_0000:  nop
//000038:             ProgressChangedEventHandler handler = ProgressChanged;
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System]System.ComponentModel.ProgressChangedEventHandler ParallelMorph.ComputeMorph::ProgressChanged
    IL_0007:  stloc.0
//000039:             if (handler != null)
    IL_0008:  ldloc.0
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  stloc.2
//000040:             {
//000041:                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
//000042:                 handler(this, new ProgressChangedEventArgs((int)progress, null));
//000043:             }
//000044:         }
//000045: 
//000046:         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
//000047:         {
//000048:             using (FastBitmap fastStartImage = new FastBitmap(startImage))
//000049:             using (FastBitmap fastEndImage = new FastBitmap(endImage))
//000050:             {
//000051:                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
//000052:             }
//000053:         }
//000054: 
//000055:         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
//000056:         {
//000057:             var forwardsAndBackwards = InterpolateLines(lines, percent);
//000058:             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
//000059:             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
//000060:                 return BlendImages(forward, backward, 1 - percent);
//000061:         }
//000062: 
//000063: 		/// <summary>Create the morphed images and video.</summary>
//000064:         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
//000065:         {
//000066:             _curFrame = 0;
//000067:             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
//000068: 
//000069:             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
//000070:             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
//000071:             {
//000072:                 // Write out the starting picture
//000073:                 imageWriter.AddFrame(clonedStart);
//000074:                 _curFrame = 1;
//000075:                 UpdateProgressChanged();
//000076: 
//000077:                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
//000078:                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
//000079:                 {
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_000d:  ldloc.2
    IL_000e:  brtrue.s   IL_0041

//000040:             {
    IL_0010:  nop
//000041:                 double progress = _curFrame * 100.0 / _options.NumberOfOutputFrames;
    IL_0011:  ldarg.0
    IL_0012:  ldfld      int32 ParallelMorph.ComputeMorph::_curFrame
    IL_0017:  conv.r8
    IL_0018:  ldc.r8     100.
    IL_0021:  mul
    IL_0022:  ldarg.0
    IL_0023:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
    IL_0028:  callvirt   instance int32 ParallelMorph.ComputeMorphOptions::get_NumberOfOutputFrames()
    IL_002d:  conv.r8
    IL_002e:  div
    IL_002f:  stloc.1
//000042:                 handler(this, new ProgressChangedEventArgs((int)progress, null));
    IL_0030:  ldloc.0
    IL_0031:  ldarg.0
    IL_0032:  ldloc.1
    IL_0033:  conv.i4
    IL_0034:  ldnull
    IL_0035:  newobj     instance void [System]System.ComponentModel.ProgressChangedEventArgs::.ctor(int32,
                                                                                                     object)
    IL_003a:  callvirt   instance void [System]System.ComponentModel.ProgressChangedEventHandler::Invoke(object,
                                                                                                         class [System]System.ComponentModel.ProgressChangedEventArgs)
    IL_003f:  nop
//000043:             }
    IL_0040:  nop
//000044:         }
    IL_0041:  ret
  } // end of method ComputeMorph::UpdateProgressChanged

  .method public hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          RenderFrame(class ParallelMorph.LinePairCollection lines,
                      class [System.Drawing]System.Drawing.Bitmap startImage,
                      class [System.Drawing]System.Drawing.Bitmap endImage,
                      float64 percent) cil managed
  {
    // Code size       65 (0x41)
    .maxstack  5
    .locals init ([0] class Microsoft.Drawing.FastBitmap fastStartImage,
             [1] class Microsoft.Drawing.FastBitmap fastEndImage,
             [2] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [3] bool CS$4$0001)
//000045: 
//000046:         public Bitmap RenderFrame(LinePairCollection lines, Bitmap startImage, Bitmap endImage, double percent)
//000047:         {
    IL_0000:  nop
//000048:             using (FastBitmap fastStartImage = new FastBitmap(startImage))
    IL_0001:  ldarg.2
    IL_0002:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_0007:  stloc.0
//000049:             using (FastBitmap fastEndImage = new FastBitmap(endImage))
    .try
    {
      IL_0008:  ldarg.3
      IL_0009:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
      IL_000e:  stloc.1
//000050:             {
      .try
      {
        IL_000f:  nop
//000051:                 return RenderFrame(lines, fastStartImage, fastEndImage, percent);
        IL_0010:  ldarg.0
        IL_0011:  ldarg.1
        IL_0012:  ldloc.0
        IL_0013:  ldloc.1
        IL_0014:  ldarg.s    percent
        IL_0016:  call       instance class [System.Drawing]System.Drawing.Bitmap ParallelMorph.ComputeMorph::RenderFrame(class ParallelMorph.LinePairCollection,
                                                                                                                          class Microsoft.Drawing.FastBitmap,
                                                                                                                          class Microsoft.Drawing.FastBitmap,
                                                                                                                          float64)
        IL_001b:  stloc.2
        IL_001c:  leave.s    IL_003e

//000052:             }
//000053:         }
//000054: 
//000055:         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
//000056:         {
//000057:             var forwardsAndBackwards = InterpolateLines(lines, percent);
//000058:             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
//000059:             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
//000060:                 return BlendImages(forward, backward, 1 - percent);
//000061:         }
//000062: 
//000063: 		/// <summary>Create the morphed images and video.</summary>
//000064:         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
//000065:         {
//000066:             _curFrame = 0;
//000067:             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
//000068: 
//000069:             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
//000070:             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
//000071:             {
//000072:                 // Write out the starting picture
//000073:                 imageWriter.AddFrame(clonedStart);
//000074:                 _curFrame = 1;
//000075:                 UpdateProgressChanged();
//000076: 
//000077:                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
//000078:                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
//000079:                 {
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      }  // end .try
      finally
      {
        IL_001e:  ldloc.1
        IL_001f:  ldnull
        IL_0020:  ceq
        IL_0022:  stloc.3
        IL_0023:  ldloc.3
        IL_0024:  brtrue.s   IL_002d

        IL_0026:  ldloc.1
        IL_0027:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_002c:  nop
        IL_002d:  endfinally
      }  // end handler
    }  // end .try
    finally
    {
      IL_002e:  ldloc.0
      IL_002f:  ldnull
      IL_0030:  ceq
      IL_0032:  stloc.3
      IL_0033:  ldloc.3
      IL_0034:  brtrue.s   IL_003d

      IL_0036:  ldloc.0
      IL_0037:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_003c:  nop
      IL_003d:  endfinally
    }  // end handler
    IL_003e:  nop
//000053:         }
    IL_003f:  ldloc.2
    IL_0040:  ret
  } // end of method ComputeMorph::RenderFrame

  .method private hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          RenderFrame(class ParallelMorph.LinePairCollection lines,
                      class Microsoft.Drawing.FastBitmap startImage,
                      class Microsoft.Drawing.FastBitmap endImage,
                      float64 percent) cil managed
  {
    // Code size       101 (0x65)
    .maxstack  5
    .locals init ([0] class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection> forwardsAndBackwards,
             [1] class [System.Drawing]System.Drawing.Bitmap forward,
             [2] class [System.Drawing]System.Drawing.Bitmap backward,
             [3] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [4] bool CS$4$0001)
//000054: 
//000055:         private Bitmap RenderFrame(LinePairCollection lines, FastBitmap startImage, FastBitmap endImage, double percent)
//000056:         {
    IL_0000:  nop
//000057:             var forwardsAndBackwards = InterpolateLines(lines, percent);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.s    percent
    IL_0005:  call       instance class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection> ParallelMorph.ComputeMorph::InterpolateLines(class ParallelMorph.LinePairCollection,
                                                                                                                                                                                             float64)
    IL_000a:  stloc.0
//000058:             using (Bitmap forward = ComputePreimage( startImage,  forwardsAndBackwards.Item1))
    IL_000b:  ldarg.0
    IL_000c:  ldarg.2
    IL_000d:  ldloc.0
    IL_000e:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection>::get_Item1()
    IL_0013:  call       instance class [System.Drawing]System.Drawing.Bitmap ParallelMorph.ComputeMorph::ComputePreimage(class Microsoft.Drawing.FastBitmap,
                                                                                                                          class ParallelMorph.LinePairCollection)
    IL_0018:  stloc.1
//000059:             using (Bitmap backward = ComputePreimage( endImage, forwardsAndBackwards.Item2))
    .try
    {
      IL_0019:  ldarg.0
      IL_001a:  ldarg.3
      IL_001b:  ldloc.0
      IL_001c:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection>::get_Item2()
      IL_0021:  call       instance class [System.Drawing]System.Drawing.Bitmap ParallelMorph.ComputeMorph::ComputePreimage(class Microsoft.Drawing.FastBitmap,
                                                                                                                            class ParallelMorph.LinePairCollection)
      IL_0026:  stloc.2
//000060:                 return BlendImages(forward, backward, 1 - percent);
      .try
      {
        IL_0027:  ldarg.0
        IL_0028:  ldloc.1
        IL_0029:  ldloc.2
        IL_002a:  ldc.r8     1.
        IL_0033:  ldarg.s    percent
        IL_0035:  sub
        IL_0036:  call       instance class [System.Drawing]System.Drawing.Bitmap ParallelMorph.ComputeMorph::BlendImages(class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                          class [System.Drawing]System.Drawing.Bitmap,
                                                                                                                          float64)
        IL_003b:  stloc.3
        IL_003c:  leave.s    IL_0062

//000061:         }
//000062: 
//000063: 		/// <summary>Create the morphed images and video.</summary>
//000064:         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
//000065:         {
//000066:             _curFrame = 0;
//000067:             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
//000068: 
//000069:             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
//000070:             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
//000071:             {
//000072:                 // Write out the starting picture
//000073:                 imageWriter.AddFrame(clonedStart);
//000074:                 _curFrame = 1;
//000075:                 UpdateProgressChanged();
//000076: 
//000077:                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
//000078:                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
//000079:                 {
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      }  // end .try
      finally
      {
        IL_003e:  ldloc.2
        IL_003f:  ldnull
        IL_0040:  ceq
        IL_0042:  stloc.s    CS$4$0001
        IL_0044:  ldloc.s    CS$4$0001
        IL_0046:  brtrue.s   IL_004f

        IL_0048:  ldloc.2
        IL_0049:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_004e:  nop
        IL_004f:  endfinally
      }  // end handler
    }  // end .try
    finally
    {
      IL_0050:  ldloc.1
      IL_0051:  ldnull
      IL_0052:  ceq
      IL_0054:  stloc.s    CS$4$0001
      IL_0056:  ldloc.s    CS$4$0001
      IL_0058:  brtrue.s   IL_0061

      IL_005a:  ldloc.1
      IL_005b:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0060:  nop
      IL_0061:  endfinally
    }  // end handler
    IL_0062:  nop
//000061:         }
    IL_0063:  ldloc.3
    IL_0064:  ret
  } // end of method ComputeMorph::RenderFrame

  .method public hidebysig instance void 
          Render(class ParallelMorph.IImageWriter imageWriter,
                 class ParallelMorph.LinePairCollection lines,
                 class [System.Drawing]System.Drawing.Bitmap startImageBmp,
                 class [System.Drawing]System.Drawing.Bitmap endImageBmp) cil managed
  {
    // Code size       326 (0x146)
    .maxstack  6
    .locals init ([0] float64 percentagePerFrame,
             [1] class [System.Drawing]System.Drawing.Bitmap clonedStart,
             [2] class [System.Drawing]System.Drawing.Bitmap clonedEnd,
             [3] class Microsoft.Drawing.FastBitmap startImage,
             [4] class Microsoft.Drawing.FastBitmap endImage,
             [5] int32 i,
             [6] class [System.Drawing]System.Drawing.Bitmap frame,
             [7] bool CS$4$0000)
//000062: 
//000063: 		/// <summary>Create the morphed images and video.</summary>
//000064:         public void Render(IImageWriter imageWriter, LinePairCollection lines, Bitmap startImageBmp, Bitmap endImageBmp)
//000065:         {
    IL_0000:  nop
//000066:             _curFrame = 0;
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4.0
    IL_0003:  stfld      int32 ParallelMorph.ComputeMorph::_curFrame
//000067:             double percentagePerFrame = 1.0 / (_options.NumberOfOutputFrames - 1);
    IL_0008:  ldc.r8     1.
    IL_0011:  ldarg.0
    IL_0012:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
    IL_0017:  callvirt   instance int32 ParallelMorph.ComputeMorphOptions::get_NumberOfOutputFrames()
    IL_001c:  ldc.i4.1
    IL_001d:  sub
    IL_001e:  conv.r8
    IL_001f:  div
    IL_0020:  stloc.0
//000068: 
//000069:             using (Bitmap clonedStart = Utilities.CreateNewBitmapFrom(startImageBmp))
    IL_0021:  ldarg.3
    IL_0022:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image)
    IL_0027:  stloc.1
//000070:             using (Bitmap clonedEnd = Utilities.CreateNewBitmapFrom(endImageBmp))
    .try
    {
      IL_0028:  ldarg.s    endImageBmp
      IL_002a:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image)
      IL_002f:  stloc.2
//000071:             {
      .try
      {
        IL_0030:  nop
//000072:                 // Write out the starting picture
//000073:                 imageWriter.AddFrame(clonedStart);
        IL_0031:  ldarg.1
        IL_0032:  ldloc.1
        IL_0033:  callvirt   instance void ParallelMorph.IImageWriter::AddFrame(class [System.Drawing]System.Drawing.Bitmap)
        IL_0038:  nop
//000074:                 _curFrame = 1;
        IL_0039:  ldarg.0
        IL_003a:  ldc.i4.1
        IL_003b:  stfld      int32 ParallelMorph.ComputeMorph::_curFrame
//000075:                 UpdateProgressChanged();
        IL_0040:  ldarg.0
        IL_0041:  call       instance void ParallelMorph.ComputeMorph::UpdateProgressChanged()
        IL_0046:  nop
//000076: 
//000077:                 using (FastBitmap startImage = new FastBitmap(startImageBmp))
        IL_0047:  ldarg.3
        IL_0048:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
        IL_004d:  stloc.3
//000078:                 using (FastBitmap endImage = new FastBitmap(endImageBmp))
        .try
        {
          IL_004e:  ldarg.s    endImageBmp
          IL_0050:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
          IL_0055:  stloc.s    endImage
//000079:                 {
          .try
          {
            IL_0057:  nop
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
            IL_0058:  ldc.i4.1
            IL_0059:  stloc.s    i
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
            IL_005b:  br.s       IL_00b9

//000081:                     {
            IL_005d:  nop
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
            IL_005e:  ldarg.0
            IL_005f:  ldflda     valuetype [mscorlib]System.Threading.CancellationToken ParallelMorph.ComputeMorph::_cancellationToken
            IL_0064:  call       instance void [mscorlib]System.Threading.CancellationToken::ThrowIfCancellationRequested()
            IL_0069:  nop
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
            IL_006a:  ldarg.0
            IL_006b:  ldarg.2
            IL_006c:  ldloc.3
            IL_006d:  ldloc.s    endImage
            IL_006f:  ldloc.0
            IL_0070:  ldloc.s    i
            IL_0072:  conv.r8
            IL_0073:  mul
            IL_0074:  call       instance class [System.Drawing]System.Drawing.Bitmap ParallelMorph.ComputeMorph::RenderFrame(class ParallelMorph.LinePairCollection,
                                                                                                                              class Microsoft.Drawing.FastBitmap,
                                                                                                                              class Microsoft.Drawing.FastBitmap,
                                                                                                                              float64)
            IL_0079:  stloc.s    frame
//000084:                         {
            .try
            {
              IL_007b:  nop
//000085:                             imageWriter.AddFrame(frame);
              IL_007c:  ldarg.1
              IL_007d:  ldloc.s    frame
              IL_007f:  callvirt   instance void ParallelMorph.IImageWriter::AddFrame(class [System.Drawing]System.Drawing.Bitmap)
              IL_0084:  nop
//000086:                         }
              IL_0085:  nop
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
              IL_0086:  leave.s    IL_009c

            }  // end .try
            finally
            {
              IL_0088:  ldloc.s    frame
              IL_008a:  ldnull
              IL_008b:  ceq
              IL_008d:  stloc.s    CS$4$0000
              IL_008f:  ldloc.s    CS$4$0000
              IL_0091:  brtrue.s   IL_009b

              IL_0093:  ldloc.s    frame
              IL_0095:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
              IL_009a:  nop
              IL_009b:  endfinally
            }  // end handler
            IL_009c:  nop
//000087:                         _curFrame++;
            IL_009d:  ldarg.0
            IL_009e:  dup
            IL_009f:  ldfld      int32 ParallelMorph.ComputeMorph::_curFrame
            IL_00a4:  ldc.i4.1
            IL_00a5:  add
            IL_00a6:  stfld      int32 ParallelMorph.ComputeMorph::_curFrame
//000088:                         UpdateProgressChanged();
            IL_00ab:  ldarg.0
            IL_00ac:  call       instance void ParallelMorph.ComputeMorph::UpdateProgressChanged()
            IL_00b1:  nop
//000089:                     }
            IL_00b2:  nop
//000080:                     for (int i = 1; i < _options.NumberOfOutputFrames - 1; i++)
            IL_00b3:  ldloc.s    i
            IL_00b5:  ldc.i4.1
            IL_00b6:  add
            IL_00b7:  stloc.s    i
            IL_00b9:  ldloc.s    i
            IL_00bb:  ldarg.0
            IL_00bc:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
            IL_00c1:  callvirt   instance int32 ParallelMorph.ComputeMorphOptions::get_NumberOfOutputFrames()
            IL_00c6:  ldc.i4.1
            IL_00c7:  sub
            IL_00c8:  clt
            IL_00ca:  stloc.s    CS$4$0000
//000081:                     {
//000082:                         _cancellationToken.ThrowIfCancellationRequested();
//000083:                         using (Bitmap frame = RenderFrame(lines, startImage, endImage, percentagePerFrame * i))
//000084:                         {
//000085:                             imageWriter.AddFrame(frame);
//000086:                         }
//000087:                         _curFrame++;
//000088:                         UpdateProgressChanged();
//000089:                     }
//000090:                 }
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
            IL_00cc:  ldloc.s    CS$4$0000
            IL_00ce:  brtrue.s   IL_005d

//000090:                 }
            IL_00d0:  nop
//000091: 
//000092:                 imageWriter.AddFrame(clonedEnd);
//000093:                 _curFrame++;
//000094:                 UpdateProgressChanged();
//000095:             }
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
            IL_00d1:  leave.s    IL_00e7

          }  // end .try
          finally
          {
            IL_00d3:  ldloc.s    endImage
            IL_00d5:  ldnull
            IL_00d6:  ceq
            IL_00d8:  stloc.s    CS$4$0000
            IL_00da:  ldloc.s    CS$4$0000
            IL_00dc:  brtrue.s   IL_00e6

            IL_00de:  ldloc.s    endImage
            IL_00e0:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
            IL_00e5:  nop
            IL_00e6:  endfinally
          }  // end handler
          IL_00e7:  nop
          IL_00e8:  leave.s    IL_00fc

        }  // end .try
        finally
        {
          IL_00ea:  ldloc.3
          IL_00eb:  ldnull
          IL_00ec:  ceq
          IL_00ee:  stloc.s    CS$4$0000
          IL_00f0:  ldloc.s    CS$4$0000
          IL_00f2:  brtrue.s   IL_00fb

          IL_00f4:  ldloc.3
          IL_00f5:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
          IL_00fa:  nop
          IL_00fb:  endfinally
        }  // end handler
        IL_00fc:  nop
//000092:                 imageWriter.AddFrame(clonedEnd);
        IL_00fd:  ldarg.1
        IL_00fe:  ldloc.2
        IL_00ff:  callvirt   instance void ParallelMorph.IImageWriter::AddFrame(class [System.Drawing]System.Drawing.Bitmap)
        IL_0104:  nop
//000093:                 _curFrame++;
        IL_0105:  ldarg.0
        IL_0106:  dup
        IL_0107:  ldfld      int32 ParallelMorph.ComputeMorph::_curFrame
        IL_010c:  ldc.i4.1
        IL_010d:  add
        IL_010e:  stfld      int32 ParallelMorph.ComputeMorph::_curFrame
//000094:                 UpdateProgressChanged();
        IL_0113:  ldarg.0
        IL_0114:  call       instance void ParallelMorph.ComputeMorph::UpdateProgressChanged()
        IL_0119:  nop
//000095:             }
        IL_011a:  nop
//000096:         }
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
//000107:             foreach (Tuple<Line,Line> pair in pairs)
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
        IL_011b:  leave.s    IL_012f

      }  // end .try
      finally
      {
        IL_011d:  ldloc.2
        IL_011e:  ldnull
        IL_011f:  ceq
        IL_0121:  stloc.s    CS$4$0000
        IL_0123:  ldloc.s    CS$4$0000
        IL_0125:  brtrue.s   IL_012e

        IL_0127:  ldloc.2
        IL_0128:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_012d:  nop
        IL_012e:  endfinally
      }  // end handler
      IL_012f:  nop
      IL_0130:  leave.s    IL_0144

    }  // end .try
    finally
    {
      IL_0132:  ldloc.1
      IL_0133:  ldnull
      IL_0134:  ceq
      IL_0136:  stloc.s    CS$4$0000
      IL_0138:  ldloc.s    CS$4$0000
      IL_013a:  brtrue.s   IL_0143

      IL_013c:  ldloc.1
      IL_013d:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0142:  nop
      IL_0143:  endfinally
    }  // end handler
    IL_0144:  nop
//000096:         }
    IL_0145:  ret
  } // end of method ComputeMorph::Render

  .method private hidebysig instance class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection> 
          InterpolateLines(class ParallelMorph.LinePairCollection pairs,
                           float64 percent) cil managed
  {
    // Code size       306 (0x132)
    .maxstack  8
    .locals init ([0] class ParallelMorph.LinePairCollection interpolatedForwards,
             [1] class ParallelMorph.LinePairCollection interpolatedBackwards,
             [2] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> pair,
             [3] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> newPair,
             [4] class [mscorlib]System.Tuple`2<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection> CS$1$0000,
             [5] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> CS$5$0001,
             [6] bool CS$4$0002)
//000097: 
//000098: 		/// <summary>Interpolates between the starting and ending morph lines.</summary>
//000099: 		/// <param name="pairs">The morph lines to interpolate.</param>
//000100: 		/// <param name="percent">The percent of the way through the morph.</param>
//000101: 		/// <param name="interpolatedForwards">Resulting interpolated lines for the starting image.</param>
//000102: 		/// <param name="interpolatedBackwards">Resulting interpolated lines for the ending image.</param>
//000103: 		private Tuple<LinePairCollection,LinePairCollection> InterpolateLines(
//000104: 			LinePairCollection pairs, double percent)
//000105: 		{
    IL_0000:  nop
//000106:             LinePairCollection interpolatedForwards = new LinePairCollection(), interpolatedBackwards = new LinePairCollection();
    IL_0001:  newobj     instance void ParallelMorph.LinePairCollection::.ctor()
    IL_0006:  stloc.0
    IL_0007:  newobj     instance void ParallelMorph.LinePairCollection::.ctor()
    IL_000c:  stloc.1
//000107:             foreach (Tuple<Line,Line> pair in pairs)
    IL_000d:  nop
    IL_000e:  ldarg.1
    IL_000f:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::GetEnumerator()
    IL_0014:  stloc.s    CS$5$0001
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    .try
    {
      IL_0016:  br         IL_00fd

//000107:             foreach (Tuple<Line,Line> pair in pairs)
      IL_001b:  ldloc.s    CS$5$0001
      IL_001d:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Current()
      IL_0022:  stloc.2
//000108: 		    {
      IL_0023:  nop
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
      IL_0024:  ldloc.2
      IL_0025:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_002a:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_002f:  ldloc.2
      IL_0030:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0035:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_003a:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_003f:  ldarg.0
      IL_0040:  ldloc.2
      IL_0041:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0046:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_004b:  ldarg.0
      IL_004c:  ldarg.0
      IL_004d:  ldloc.2
      IL_004e:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_0053:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0058:  ldloc.2
      IL_0059:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_005e:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0063:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_0068:  ldarg.2
      IL_0069:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                           float64)
      IL_006e:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_0073:  ldarg.0
      IL_0074:  ldloc.2
      IL_0075:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_007a:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_007f:  ldarg.0
      IL_0080:  ldarg.0
      IL_0081:  ldloc.2
      IL_0082:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_0087:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_008c:  ldloc.2
      IL_008d:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_0092:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_0097:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_009c:  ldarg.2
      IL_009d:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                           float64)
      IL_00a2:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_00a7:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00ac:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<class ParallelMorph.Line,class ParallelMorph.Line>(!!0,
                                                                                                                                                     !!1)
      IL_00b1:  stloc.3
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
      IL_00b2:  ldloc.0
      IL_00b3:  ldloc.3
      IL_00b4:  callvirt   instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::Add(!0)
      IL_00b9:  nop
//000118:                 interpolatedBackwards.Add(Tuple.Create(
      IL_00ba:  ldloc.1
      IL_00bb:  ldloc.2
      IL_00bc:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00c1:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_00c6:  ldloc.2
      IL_00c7:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00cc:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_00d1:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00d6:  ldloc.3
      IL_00d7:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00dc:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_00e1:  ldloc.3
      IL_00e2:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_00e7:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_00ec:  newobj     instance void ParallelMorph.Line::.ctor(valuetype [System.Drawing]System.Drawing.PointF,
                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00f1:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<class ParallelMorph.Line,class ParallelMorph.Line>(!!0,
                                                                                                                                                     !!1)
      IL_00f6:  callvirt   instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::Add(!0)
      IL_00fb:  nop
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
      IL_00fc:  nop
//000107:             foreach (Tuple<Line,Line> pair in pairs)
      IL_00fd:  ldloc.s    CS$5$0001
      IL_00ff:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_0104:  stloc.s    CS$4$0002
//000108: 		    {
//000109:                 // Source line is the same as the original; dest line is the interpolated line
//000110: 				// Add the new pair to the forwards list and the inverse to the backwards list.
//000111:                 var newPair = Tuple.Create(
//000112:                     new Line(pair.Item1.Item1, pair.Item1.Item2),
//000113:                     new Line(
//000114:                         AddPoints(pair.Item1.Item1, ScalePoint(SubPoints(pair.Item2.Item1, pair.Item1.Item1), percent)),
//000115:                         AddPoints(pair.Item1.Item2, ScalePoint(SubPoints(pair.Item2.Item2, pair.Item1.Item2), percent))
//000116:                     ));
//000117:                 interpolatedForwards.Add(newPair);
//000118:                 interpolatedBackwards.Add(Tuple.Create(
//000119:                     new Line(pair.Item2.Item1, pair.Item2.Item2),
//000120:                     new Line(newPair.Item2.Item1, newPair.Item2.Item2)));
//000121: 			}
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
//000123: 		}
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
//000132: 		}
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
//000141: 		}
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
//000150: 		}
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
//000158: 		}
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
//000167: 		}
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
//000174: 			return new PointF(p.Y*-1, p.X);
//000175: 		}
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
//000183:             if (pairs.Count == 0) return p;
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0106:  ldloc.s    CS$4$0002
      IL_0108:  brtrue     IL_001b

      IL_010d:  leave.s    IL_0123

    }  // end .try
    finally
    {
      IL_010f:  ldloc.s    CS$5$0001
      IL_0111:  ldnull
      IL_0112:  ceq
      IL_0114:  stloc.s    CS$4$0002
      IL_0116:  ldloc.s    CS$4$0002
      IL_0118:  brtrue.s   IL_0122

      IL_011a:  ldloc.s    CS$5$0001
      IL_011c:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0121:  nop
      IL_0122:  endfinally
    }  // end handler
    IL_0123:  nop
//000122:             return Tuple.Create(interpolatedForwards, interpolatedBackwards);
    IL_0124:  ldloc.0
    IL_0125:  ldloc.1
    IL_0126:  call       class [mscorlib]System.Tuple`2<!!0,!!1> [mscorlib]System.Tuple::Create<class ParallelMorph.LinePairCollection,class ParallelMorph.LinePairCollection>(!!0,
                                                                                                                                                                               !!1)
    IL_012b:  stloc.s    CS$1$0000
    IL_012d:  br.s       IL_012f

//000123: 		}
    IL_012f:  ldloc.s    CS$1$0000
    IL_0131:  ret
  } // end of method ComputeMorph::InterpolateLines

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          AddPoints(valuetype [System.Drawing]System.Drawing.PointF p1,
                    valuetype [System.Drawing]System.Drawing.PointF p2) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000)
//000124: 
//000125: 		/// <summary>Add two points.</summary>
//000126: 		/// <param name="p1">The first point.</param>
//000127: 		/// <param name="p2">The second point.</param>
//000128: 		/// <returns>p1 + p2</returns>
//000129: 		private PointF AddPoints(PointF p1, PointF p2)
//000130: 		{
    IL_0000:  nop
//000131: 			return new PointF(p1.X+p2.X, p1.Y+p2.Y);
    IL_0001:  ldarga.s   p1
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  ldarga.s   p2
    IL_000a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_000f:  add
    IL_0010:  ldarga.s   p1
    IL_0012:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0017:  ldarga.s   p2
    IL_0019:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_001e:  add
    IL_001f:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_0024:  stloc.0
    IL_0025:  br.s       IL_0027

//000132: 		}
    IL_0027:  ldloc.0
    IL_0028:  ret
  } // end of method ComputeMorph::AddPoints

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          SubPoints(valuetype [System.Drawing]System.Drawing.PointF p1,
                    valuetype [System.Drawing]System.Drawing.PointF p2) cil managed
  {
    // Code size       41 (0x29)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000)
//000133: 
//000134: 		/// <summary>Subtract two points.</summary>
//000135: 		/// <param name="p1">The first point.</param>
//000136: 		/// <param name="p2">The second point.</param>
//000137: 		/// <returns>p1 - p2</returns>
//000138: 		private PointF SubPoints(PointF p1, PointF p2)
//000139: 		{
    IL_0000:  nop
//000140: 			return new PointF(p1.X-p2.X, p1.Y-p2.Y);
    IL_0001:  ldarga.s   p1
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  ldarga.s   p2
    IL_000a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_000f:  sub
    IL_0010:  ldarga.s   p1
    IL_0012:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0017:  ldarga.s   p2
    IL_0019:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_001e:  sub
    IL_001f:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_0024:  stloc.0
    IL_0025:  br.s       IL_0027

//000141: 		}
    IL_0027:  ldloc.0
    IL_0028:  ret
  } // end of method ComputeMorph::SubPoints

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          ScalePoint(valuetype [System.Drawing]System.Drawing.PointF p,
                     float64 scale) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000)
//000142: 
//000143: 		/// <summary>Scales a point/</summary>
//000144: 		/// <param name="p">The point to be scaled.</param>
//000145: 		/// <param name="scale">The scaled value.</param>
//000146: 		/// <returns>p * scale.</returns>
//000147: 		private PointF ScalePoint(PointF p, double scale)
//000148: 		{
    IL_0000:  nop
//000149: 			return new PointF(p.X*(float)scale, p.Y*(float)scale);
    IL_0001:  ldarga.s   p
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  ldarg.2
    IL_0009:  conv.r4
    IL_000a:  mul
    IL_000b:  ldarga.s   p
    IL_000d:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0012:  ldarg.2
    IL_0013:  conv.r4
    IL_0014:  mul
    IL_0015:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_001a:  stloc.0
    IL_001b:  br.s       IL_001d

//000150: 		}
    IL_001d:  ldloc.0
    IL_001e:  ret
  } // end of method ComputeMorph::ScalePoint

  .method private hidebysig instance float64 
          NormalizePoint(valuetype [System.Drawing]System.Drawing.PointF p) cil managed
  {
    // Code size       43 (0x2b)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000151: 
//000152: 		/// <summary>Normalizes the point as a vector.</summary>
//000153: 		/// <param name="p">The point.</param>
//000154: 		/// <returns>sqrt(p.x^2 + p.y^2)</returns>
//000155: 		private double NormalizePoint(PointF p)
//000156: 		{
    IL_0000:  nop
//000157: 			return Math.Sqrt(p.X*p.X + p.Y*p.Y);
    IL_0001:  ldarga.s   p
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  ldarga.s   p
    IL_000a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_000f:  mul
    IL_0010:  ldarga.s   p
    IL_0012:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0017:  ldarga.s   p
    IL_0019:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_001e:  mul
    IL_001f:  add
    IL_0020:  conv.r8
    IL_0021:  call       float64 [mscorlib]System.Math::Sqrt(float64)
    IL_0026:  stloc.0
    IL_0027:  br.s       IL_0029

//000158: 		}
    IL_0029:  ldloc.0
    IL_002a:  ret
  } // end of method ComputeMorph::NormalizePoint

  .method private hidebysig instance float64 
          DotProduct(valuetype [System.Drawing]System.Drawing.PointF p1,
                     valuetype [System.Drawing]System.Drawing.PointF p2) cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] float64 CS$1$0000)
//000159: 
//000160: 		/// <summary>Computes the dot product of two points.</summary>
//000161: 		/// <param name="p1">The first point.</param>
//000162: 		/// <param name="p2">The second point.</param>
//000163: 		/// <returns>p1 . p2</returns>
//000164: 		private double DotProduct(PointF p1, PointF p2)
//000165: 		{
    IL_0000:  nop
//000166: 			return p1.X*p2.X + p1.Y*p2.Y;
    IL_0001:  ldarga.s   p1
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  ldarga.s   p2
    IL_000a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_000f:  mul
    IL_0010:  ldarga.s   p1
    IL_0012:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0017:  ldarga.s   p2
    IL_0019:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_001e:  mul
    IL_001f:  add
    IL_0020:  conv.r8
    IL_0021:  stloc.0
    IL_0022:  br.s       IL_0024

//000167: 		}
    IL_0024:  ldloc.0
    IL_0025:  ret
  } // end of method ComputeMorph::DotProduct

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          FlipPerpendicular(valuetype [System.Drawing]System.Drawing.PointF p) cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000)
//000168: 
//000169: 		/// <summary>Mirros a point.</summary>
//000170: 		/// <param name="p">The point.</param>
//000171: 		/// <returns>The point flipped perpendicularlly.</returns>
//000172: 		private PointF FlipPerpendicular(PointF p)
//000173: 		{
    IL_0000:  nop
//000174: 			return new PointF(p.Y*-1, p.X);
    IL_0001:  ldarga.s   p
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0008:  ldc.r4     -1.
    IL_000d:  mul
    IL_000e:  ldarga.s   p
    IL_0010:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0015:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_001a:  stloc.0
    IL_001b:  br.s       IL_001d

//000175: 		}
    IL_001d:  ldloc.0
    IL_001e:  ret
  } // end of method ComputeMorph::FlipPerpendicular

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          GetPreimageLocation(valuetype [System.Drawing]System.Drawing.PointF p,
                              class ParallelMorph.LinePairCollection pairs) cil managed
  {
    // Code size       572 (0x23c)
    .maxstack  7
    .locals init ([0] float64 constA,
             [1] float64 constB,
             [2] float64 constP,
             [3] valuetype [System.Drawing]System.Drawing.PointF dSum,
             [4] float64 weightSum,
             [5] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> pair,
             [6] valuetype [System.Drawing]System.Drawing.PointF srcStart,
             [7] valuetype [System.Drawing]System.Drawing.PointF srcEnd,
             [8] valuetype [System.Drawing]System.Drawing.PointF destStart,
             [9] valuetype [System.Drawing]System.Drawing.PointF destEnd,
             [10] valuetype [System.Drawing]System.Drawing.PointF PQ,
             [11] float64 length,
             [12] valuetype [System.Drawing]System.Drawing.PointF PpQp,
             [13] valuetype [System.Drawing]System.Drawing.PointF PX,
             [14] float64 u,
             [15] float64 v,
             [16] valuetype [System.Drawing]System.Drawing.PointF Xp,
             [17] float64 dist,
             [18] float64 strength,
             [19] float64 weight,
             [20] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000,
             [21] bool CS$4$0001,
             [22] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> CS$5$0002)
//000176: 
//000177:         /// <summary>Gets the X location of a point in the source image for a point X' in the target image.</summary>
//000178:         /// <param name="p">The point whose preimage location we need.</param>
//000179:         /// <param name="pairs">The morph line pairs used to translate the point.</param>
//000180:         /// <returns>The point in the original image.</returns>
//000181:         private PointF GetPreimageLocation(PointF p, LinePairCollection pairs)
//000182:         {
    IL_0000:  nop
//000183:             if (pairs.Count == 0) return p;
    IL_0001:  ldarg.2
    IL_0002:  callvirt   instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.s    CS$4$0001
//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
//000187:             double constB = _options.ConstB;
//000188:             double constP = _options.ConstP;
//000189: 
//000190:             PointF dSum = PointF.Empty;
//000191:             double weightSum = 0;
//000192: 
//000193:             foreach (var pair in pairs)
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_000f:  ldloc.s    CS$4$0001
    IL_0011:  brtrue.s   IL_001b

//000183:             if (pairs.Count == 0) return p;
    IL_0013:  ldarg.1
    IL_0014:  stloc.s    CS$1$0000
    IL_0016:  br         IL_0239

//000184: 
//000185:             // Grab settings
//000186:             double constA = _options.ConstA;
    IL_001b:  ldarg.0
    IL_001c:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
    IL_0021:  callvirt   instance float64 ParallelMorph.ComputeMorphOptions::get_ConstA()
    IL_0026:  stloc.0
//000187:             double constB = _options.ConstB;
    IL_0027:  ldarg.0
    IL_0028:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
    IL_002d:  callvirt   instance float64 ParallelMorph.ComputeMorphOptions::get_ConstB()
    IL_0032:  stloc.1
//000188:             double constP = _options.ConstP;
    IL_0033:  ldarg.0
    IL_0034:  ldfld      class ParallelMorph.ComputeMorphOptions ParallelMorph.ComputeMorph::_options
    IL_0039:  callvirt   instance float64 ParallelMorph.ComputeMorphOptions::get_ConstP()
    IL_003e:  stloc.2
//000189: 
//000190:             PointF dSum = PointF.Empty;
    IL_003f:  ldsfld     valuetype [System.Drawing]System.Drawing.PointF [System.Drawing]System.Drawing.PointF::Empty
    IL_0044:  stloc.3
//000191:             double weightSum = 0;
    IL_0045:  ldc.r8     0.0
    IL_004e:  stloc.s    weightSum
//000192: 
//000193:             foreach (var pair in pairs)
    IL_0050:  nop
    IL_0051:  ldarg.2
    IL_0052:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::GetEnumerator()
    IL_0057:  stloc.s    CS$5$0002
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    .try
    {
      IL_0059:  br         IL_01f4

//000193:             foreach (var pair in pairs)
      IL_005e:  ldloc.s    CS$5$0002
      IL_0060:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Current()
      IL_0065:  stloc.s    pair
//000194:             {
      IL_0067:  nop
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
      IL_0068:  ldloc.s    pair
      IL_006a:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_006f:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0074:  stloc.s    srcStart
      IL_0076:  ldloc.s    pair
      IL_0078:  callvirt   instance !0 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item1()
      IL_007d:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_0082:  stloc.s    srcEnd
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
      IL_0084:  ldloc.s    pair
      IL_0086:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_008b:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item1()
      IL_0090:  stloc.s    destStart
      IL_0092:  ldloc.s    pair
      IL_0094:  callvirt   instance !1 class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>::get_Item2()
      IL_0099:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item2()
      IL_009e:  stloc.s    destEnd
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
      IL_00a0:  ldloc.s    srcStart
      IL_00a2:  ldloc.s    srcEnd
      IL_00a4:  call       bool [System.Drawing]System.Drawing.PointF::op_Equality(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00a9:  brtrue.s   IL_00b9

      IL_00ab:  ldloc.s    destStart
      IL_00ad:  ldloc.s    destEnd
      IL_00af:  call       bool [System.Drawing]System.Drawing.PointF::op_Equality(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00b4:  ldc.i4.0
      IL_00b5:  ceq
      IL_00b7:  br.s       IL_00ba

      IL_00b9:  ldc.i4.0
      IL_00ba:  stloc.s    CS$4$0001
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_00bc:  ldloc.s    CS$4$0001
      IL_00be:  brtrue.s   IL_00c5

//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
      IL_00c0:  br         IL_01f4

//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
      IL_00c5:  ldarg.0
      IL_00c6:  ldloc.s    destEnd
      IL_00c8:  ldloc.s    destStart
      IL_00ca:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_00cf:  stloc.s    PQ
//000200:                 double length = NormalizePoint(PQ);
      IL_00d1:  ldarg.0
      IL_00d2:  ldloc.s    PQ
      IL_00d4:  call       instance float64 ParallelMorph.ComputeMorph::NormalizePoint(valuetype [System.Drawing]System.Drawing.PointF)
      IL_00d9:  stloc.s    length
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
      IL_00db:  ldarg.0
      IL_00dc:  ldloc.s    srcEnd
      IL_00de:  ldloc.s    srcStart
      IL_00e0:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_00e5:  stloc.s    PpQp
//000202:                 PointF PX = SubPoints(p, destStart);
      IL_00e7:  ldarg.0
      IL_00e8:  ldarg.1
      IL_00e9:  ldloc.s    destStart
      IL_00eb:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_00f0:  stloc.s    PX
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
      IL_00f2:  ldarg.0
      IL_00f3:  ldloc.s    PX
      IL_00f5:  ldloc.s    PQ
      IL_00f7:  call       instance float64 ParallelMorph.ComputeMorph::DotProduct(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_00fc:  ldloc.s    length
      IL_00fe:  ldloc.s    length
      IL_0100:  mul
      IL_0101:  div
      IL_0102:  stloc.s    u
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
      IL_0104:  ldarg.0
      IL_0105:  ldloc.s    PX
      IL_0107:  ldarg.0
      IL_0108:  ldloc.s    PQ
      IL_010a:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::FlipPerpendicular(valuetype [System.Drawing]System.Drawing.PointF)
      IL_010f:  call       instance float64 ParallelMorph.ComputeMorph::DotProduct(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                   valuetype [System.Drawing]System.Drawing.PointF)
      IL_0114:  ldloc.s    length
      IL_0116:  div
      IL_0117:  stloc.s    v
//000206: 
//000207:                 PointF Xp = AddPoints(
      IL_0119:  ldarg.0
      IL_011a:  ldarg.0
      IL_011b:  ldloc.s    srcStart
      IL_011d:  ldarg.0
      IL_011e:  ldloc.s    PpQp
      IL_0120:  ldloc.s    u
      IL_0122:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                           float64)
      IL_0127:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_012c:  ldarg.0
      IL_012d:  ldarg.0
      IL_012e:  ldloc.s    PpQp
      IL_0130:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::FlipPerpendicular(valuetype [System.Drawing]System.Drawing.PointF)
      IL_0135:  ldloc.s    v
      IL_0137:  ldarg.0
      IL_0138:  ldloc.s    PpQp
      IL_013a:  call       instance float64 ParallelMorph.ComputeMorph::NormalizePoint(valuetype [System.Drawing]System.Drawing.PointF)
      IL_013f:  div
      IL_0140:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                           float64)
      IL_0145:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_014a:  stloc.s    Xp
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
      IL_014c:  ldloc.s    u
      IL_014e:  ldc.r8     0.0
      IL_0157:  clt
      IL_0159:  ldc.i4.0
      IL_015a:  ceq
      IL_015c:  stloc.s    CS$4$0001
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_015e:  ldloc.s    CS$4$0001
      IL_0160:  brtrue.s   IL_0175

//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
      IL_0162:  ldarg.0
      IL_0163:  ldarg.0
      IL_0164:  ldarg.1
      IL_0165:  ldloc.s    destStart
      IL_0167:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_016c:  call       instance float64 ParallelMorph.ComputeMorph::NormalizePoint(valuetype [System.Drawing]System.Drawing.PointF)
      IL_0171:  stloc.s    dist
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0173:  br.s       IL_01a7

//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
      IL_0175:  ldloc.s    u
      IL_0177:  ldc.r8     1.
      IL_0180:  cgt
      IL_0182:  ldc.i4.0
      IL_0183:  ceq
      IL_0185:  stloc.s    CS$4$0001
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0187:  ldloc.s    CS$4$0001
      IL_0189:  brtrue.s   IL_019e

//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
      IL_018b:  ldarg.0
      IL_018c:  ldarg.0
      IL_018d:  ldarg.1
      IL_018e:  ldloc.s    destEnd
      IL_0190:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_0195:  call       instance float64 ParallelMorph.ComputeMorph::NormalizePoint(valuetype [System.Drawing]System.Drawing.PointF)
      IL_019a:  stloc.s    dist
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_019c:  br.s       IL_01a7

//000215:                 else dist = Math.Abs(v);
      IL_019e:  ldloc.s    v
      IL_01a0:  call       float64 [mscorlib]System.Math::Abs(float64)
      IL_01a5:  stloc.s    dist
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
      IL_01a7:  ldloc.s    length
      IL_01a9:  ldloc.2
      IL_01aa:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                              float64)
      IL_01af:  ldloc.0
      IL_01b0:  ldloc.s    dist
      IL_01b2:  add
      IL_01b3:  div
      IL_01b4:  stloc.s    strength
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
      IL_01b6:  ldloc.1
      IL_01b7:  ldc.r8     2.
      IL_01c0:  beq.s      IL_01cc

      IL_01c2:  ldloc.s    strength
      IL_01c4:  ldloc.1
      IL_01c5:  call       float64 [mscorlib]System.Math::Pow(float64,
                                                              float64)
      IL_01ca:  br.s       IL_01d1

      IL_01cc:  ldloc.s    strength
      IL_01ce:  ldloc.s    strength
      IL_01d0:  mul
      IL_01d1:  stloc.s    weight
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
      IL_01d3:  ldarg.0
      IL_01d4:  ldloc.3
      IL_01d5:  ldarg.0
      IL_01d6:  ldarg.0
      IL_01d7:  ldloc.s    Xp
      IL_01d9:  ldarg.1
      IL_01da:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::SubPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_01df:  ldloc.s    weight
      IL_01e1:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                           float64)
      IL_01e6:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.PointF)
      IL_01eb:  stloc.3
//000220:                 weightSum += weight;
      IL_01ec:  ldloc.s    weightSum
      IL_01ee:  ldloc.s    weight
      IL_01f0:  add
      IL_01f1:  stloc.s    weightSum
//000221:             }
      IL_01f3:  nop
//000193:             foreach (var pair in pairs)
      IL_01f4:  ldloc.s    CS$5$0002
      IL_01f6:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_01fb:  stloc.s    CS$4$0001
//000194:             {
//000195:                 PointF srcStart = pair.Item1.Item1, srcEnd = pair.Item1.Item2;
//000196:                 PointF destStart = pair.Item2.Item1, destEnd = pair.Item2.Item2;
//000197:                 if (srcStart == srcEnd || destStart == destEnd) continue;
//000198: 
//000199:                 PointF PQ = SubPoints(destEnd, destStart);
//000200:                 double length = NormalizePoint(PQ);
//000201:                 PointF PpQp = SubPoints(srcEnd, srcStart);
//000202:                 PointF PX = SubPoints(p, destStart);
//000203: 
//000204:                 double u = DotProduct(PX, PQ) / (length * length);
//000205:                 double v = DotProduct(PX, FlipPerpendicular(PQ)) / length;
//000206: 
//000207:                 PointF Xp = AddPoints(
//000208:                    AddPoints(srcStart, ScalePoint(PpQp, u)),
//000209:                    ScalePoint(FlipPerpendicular(PpQp), v / NormalizePoint(PpQp)));
//000210: 
//000211:                 // Compute shortest distance from X to the line segment PQ
//000212:                 double dist;
//000213:                 if (u < 0) dist = NormalizePoint(SubPoints(p, destStart));
//000214:                 else if (u > 1) dist = NormalizePoint(SubPoints(p, destEnd));
//000215:                 else dist = Math.Abs(v);
//000216: 
//000217:                 double strength = Math.Pow(length, constP) / (constA + dist);
//000218:                 double weight = (constB == 2.0) ? strength * strength : Math.Pow(strength, constB);
//000219:                 dSum = AddPoints(dSum, ScalePoint(SubPoints(Xp, p), weight));
//000220:                 weightSum += weight;
//000221:             }
//000222: 
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
//000224:         }
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_01fd:  ldloc.s    CS$4$0001
      IL_01ff:  brtrue     IL_005e

      IL_0204:  leave.s    IL_021a

    }  // end .try
    finally
    {
      IL_0206:  ldloc.s    CS$5$0002
      IL_0208:  ldnull
      IL_0209:  ceq
      IL_020b:  stloc.s    CS$4$0001
      IL_020d:  ldloc.s    CS$4$0001
      IL_020f:  brtrue.s   IL_0219

      IL_0211:  ldloc.s    CS$5$0002
      IL_0213:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0218:  nop
      IL_0219:  endfinally
    }  // end handler
    IL_021a:  nop
//000223:             return AddPoints(p, ScalePoint(dSum, 1.0 / weightSum));
    IL_021b:  ldarg.0
    IL_021c:  ldarg.1
    IL_021d:  ldarg.0
    IL_021e:  ldloc.3
    IL_021f:  ldc.r8     1.
    IL_0228:  ldloc.s    weightSum
    IL_022a:  div
    IL_022b:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::ScalePoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                         float64)
    IL_0230:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::AddPoints(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                        valuetype [System.Drawing]System.Drawing.PointF)
    IL_0235:  stloc.s    CS$1$0000
    IL_0237:  br.s       IL_0239

//000224:         }
    IL_0239:  ldloc.s    CS$1$0000
    IL_023b:  ret
  } // end of method ComputeMorph::GetPreimageLocation

  .method private hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          ComputePreimage(class Microsoft.Drawing.FastBitmap bmp,
                          class ParallelMorph.LinePairCollection pairs) cil managed
  {
    // Code size       477 (0x1dd)
    .maxstack  6
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap output,
             [1] int32 j,
             [2] int32 i,
             [3] valuetype [System.Drawing]System.Drawing.PointF pf,
             [4] valuetype [System.Drawing]System.Drawing.Point p,
             [5] valuetype Microsoft.Drawing.PixelData* inPixel,
             [6] valuetype Microsoft.Drawing.PixelData* outPixel,
             [7] class [mscorlib]System.Threading.Tasks.ParallelOptions '<>g__initLocal0',
             [8] class [mscorlib]System.Action`2<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState> 'CS$<>9__CachedAnonymousMethodDelegate4',
             [9] class ParallelMorph.ComputeMorph/'<>c__DisplayClass5' 'CS$<>8__locals6',
             [10] class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' 'CS$<>8__locals3',
             [11] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [12] valuetype [System.Drawing]System.Drawing.Size CS$0$0001,
             [13] bool CS$4$0002)
//000225: 
//000226: 		/// <summary>Generates the output image for a source image and a collection of morph lines.</summary>
//000227: 		/// <param name="bmp">The input image.</param>
//000228: 		/// <param name="pairs">The lines used to skew the image.</param>
//000229: 		/// <returns>The computed image.</returns>
//000230:         private unsafe Bitmap ComputePreimage(FastBitmap bmp, LinePairCollection pairs)
//000231:         {
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
//000233:             Bitmap output = new Bitmap(width, height);
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0000:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::.ctor()
    IL_0005:  stloc.s    'CS$<>8__locals3'
    IL_0007:  ldloc.s    'CS$<>8__locals3'
    IL_0009:  ldarg.1
    IL_000a:  stfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::bmp
    IL_000f:  ldloc.s    'CS$<>8__locals3'
    IL_0011:  ldarg.2
    IL_0012:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::pairs
    IL_0017:  ldloc.s    'CS$<>8__locals3'
    IL_0019:  ldarg.0
    IL_001a:  stfld      class ParallelMorph.ComputeMorph ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::'<>4__this'
//000231:         {
    IL_001f:  nop
//000232:             int width = bmp.Size.Width, height = bmp.Size.Height;
    IL_0020:  ldloc.s    'CS$<>8__locals3'
    IL_0022:  ldloc.s    'CS$<>8__locals3'
    IL_0024:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::bmp
    IL_0029:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size Microsoft.Drawing.FastBitmap::get_Size()
    IL_002e:  stloc.s    CS$0$0001
    IL_0030:  ldloca.s   CS$0$0001
    IL_0032:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0037:  stfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
    IL_003c:  ldloc.s    'CS$<>8__locals3'
    IL_003e:  ldloc.s    'CS$<>8__locals3'
    IL_0040:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::bmp
    IL_0045:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size Microsoft.Drawing.FastBitmap::get_Size()
    IL_004a:  stloc.s    CS$0$0001
    IL_004c:  ldloca.s   CS$0$0001
    IL_004e:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0053:  stfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
//000233:             Bitmap output = new Bitmap(width, height);
    IL_0058:  ldloc.s    'CS$<>8__locals3'
    IL_005a:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
    IL_005f:  ldloc.s    'CS$<>8__locals3'
    IL_0061:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
    IL_0066:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32)
    IL_006b:  stloc.0
//000234: 
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
//000236:             {
//000237:                 if (!_useParallelism)
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_006c:  ldnull
    IL_006d:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate4'
    IL_006f:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::.ctor()
    IL_0074:  stloc.s    'CS$<>8__locals6'
    IL_0076:  ldloc.s    'CS$<>8__locals6'
    IL_0078:  ldloc.s    'CS$<>8__locals3'
    IL_007a:  stfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass2' ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'CS$<>8__locals3'
//000235:             using (FastBitmap fastOut = new FastBitmap(output))
    IL_007f:  ldloc.s    'CS$<>8__locals6'
    IL_0081:  ldloc.0
    IL_0082:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_0087:  stfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::fastOut
//000236:             {
    .try
    {
      IL_008c:  nop
//000237:                 if (!_useParallelism)
      IL_008d:  ldarg.0
      IL_008e:  ldfld      bool ParallelMorph.ComputeMorph::_useParallelism
      IL_0093:  stloc.s    CS$4$0002
//000238:                 {
//000239:                     for (int j = 0; j < height; j++)
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0095:  ldloc.s    CS$4$0002
      IL_0097:  brtrue     IL_0175

//000238:                 {
      IL_009c:  nop
//000239:                     for (int j = 0; j < height; j++)
      IL_009d:  ldc.i4.0
      IL_009e:  stloc.1
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_009f:  br         IL_015f

//000240:                     {
      IL_00a4:  nop
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
      IL_00a5:  ldarg.0
      IL_00a6:  ldflda     valuetype [mscorlib]System.Threading.CancellationToken ParallelMorph.ComputeMorph::_cancellationToken
      IL_00ab:  call       instance void [mscorlib]System.Threading.CancellationToken::ThrowIfCancellationRequested()
      IL_00b0:  nop
//000242:                         for (int i = 0; i < width; i++)
      IL_00b1:  ldc.i4.0
      IL_00b2:  stloc.2
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_00b3:  br         IL_0147

//000243:                         {
      IL_00b8:  nop
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
      IL_00b9:  ldarg.0
      IL_00ba:  ldloc.2
      IL_00bb:  conv.r4
      IL_00bc:  ldloc.1
      IL_00bd:  conv.r4
      IL_00be:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                      float32)
      IL_00c3:  ldloc.s    'CS$<>8__locals3'
      IL_00c5:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::pairs
      IL_00ca:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.ComputeMorph::GetPreimageLocation(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                                    class ParallelMorph.LinePairCollection)
      IL_00cf:  stloc.3
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
      IL_00d0:  ldarg.0
      IL_00d1:  ldloc.3
      IL_00d2:  ldloc.s    'CS$<>8__locals3'
      IL_00d4:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
      IL_00d9:  ldloc.s    'CS$<>8__locals3'
      IL_00db:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
      IL_00e0:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                    int32)
      IL_00e5:  call       instance valuetype [System.Drawing]System.Drawing.Point ParallelMorph.ComputeMorph::ClampPoint(valuetype [System.Drawing]System.Drawing.PointF,
                                                                                                                          valuetype [System.Drawing]System.Drawing.Size)
      IL_00ea:  stloc.s    p
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
      IL_00ec:  ldloc.s    'CS$<>8__locals3'
      IL_00ee:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::bmp
      IL_00f3:  ldloca.s   p
      IL_00f5:  call       instance int32 [System.Drawing]System.Drawing.Point::get_X()
      IL_00fa:  ldloca.s   p
      IL_00fc:  call       instance int32 [System.Drawing]System.Drawing.Point::get_Y()
      IL_0101:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_0106:  stloc.s    inPixel
//000247:                             PixelData* outPixel = fastOut[i, j];
      IL_0108:  ldloc.s    'CS$<>8__locals6'
      IL_010a:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::fastOut
      IL_010f:  ldloc.2
      IL_0110:  ldloc.1
      IL_0111:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                  int32)
      IL_0116:  stloc.s    outPixel
//000248:                             outPixel->R = inPixel->R;
      IL_0118:  ldloc.s    outPixel
      IL_011a:  ldloc.s    inPixel
      IL_011c:  ldfld      uint8 Microsoft.Drawing.PixelData::R
      IL_0121:  stfld      uint8 Microsoft.Drawing.PixelData::R
//000249:                             outPixel->G = inPixel->G;
      IL_0126:  ldloc.s    outPixel
      IL_0128:  ldloc.s    inPixel
      IL_012a:  ldfld      uint8 Microsoft.Drawing.PixelData::G
      IL_012f:  stfld      uint8 Microsoft.Drawing.PixelData::G
//000250:                             outPixel->B = inPixel->B;
      IL_0134:  ldloc.s    outPixel
      IL_0136:  ldloc.s    inPixel
      IL_0138:  ldfld      uint8 Microsoft.Drawing.PixelData::B
      IL_013d:  stfld      uint8 Microsoft.Drawing.PixelData::B
//000251:                         }
      IL_0142:  nop
//000242:                         for (int i = 0; i < width; i++)
      IL_0143:  ldloc.2
      IL_0144:  ldc.i4.1
      IL_0145:  add
      IL_0146:  stloc.2
      IL_0147:  ldloc.2
      IL_0148:  ldloc.s    'CS$<>8__locals3'
      IL_014a:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::width
      IL_014f:  clt
      IL_0151:  stloc.s    CS$4$0002
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0153:  ldloc.s    CS$4$0002
      IL_0155:  brtrue     IL_00b8

//000252:                     }
      IL_015a:  nop
//000239:                     for (int j = 0; j < height; j++)
      IL_015b:  ldloc.1
      IL_015c:  ldc.i4.1
      IL_015d:  add
      IL_015e:  stloc.1
      IL_015f:  ldloc.1
      IL_0160:  ldloc.s    'CS$<>8__locals3'
      IL_0162:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
      IL_0167:  clt
      IL_0169:  stloc.s    CS$4$0002
//000240:                     {
//000241:                         _cancellationToken.ThrowIfCancellationRequested();
//000242:                         for (int i = 0; i < width; i++)
//000243:                         {
//000244:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000245:                             Point p = ClampPoint(pf, new Size(width, height));
//000246:                             PixelData* inPixel = bmp[p.X, p.Y];
//000247:                             PixelData* outPixel = fastOut[i, j];
//000248:                             outPixel->R = inPixel->R;
//000249:                             outPixel->G = inPixel->G;
//000250:                             outPixel->B = inPixel->B;
//000251:                         }
//000252:                     }
//000253:                 }
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_016b:  ldloc.s    CS$4$0002
      IL_016d:  brtrue     IL_00a4

//000253:                 }
      IL_0172:  nop
//000254:                 else
//000255:                 {
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
//000270:             }
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_0173:  br.s       IL_01b3

//000255:                 {
      IL_0175:  nop
//000256:                     Parallel.For(0, height, new ParallelOptions { CancellationToken=_cancellationToken }, (j, loop) =>
      IL_0176:  ldc.i4.0
      IL_0177:  ldloc.s    'CS$<>8__locals3'
      IL_0179:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass2'::height
      IL_017e:  newobj     instance void [mscorlib]System.Threading.Tasks.ParallelOptions::.ctor()
      IL_0183:  stloc.s    '<>g__initLocal0'
      IL_0185:  ldloc.s    '<>g__initLocal0'
      IL_0187:  ldarg.0
      IL_0188:  ldfld      valuetype [mscorlib]System.Threading.CancellationToken ParallelMorph.ComputeMorph::_cancellationToken
      IL_018d:  callvirt   instance void [mscorlib]System.Threading.Tasks.ParallelOptions::set_CancellationToken(valuetype [mscorlib]System.Threading.CancellationToken)
      IL_0192:  nop
      IL_0193:  ldloc.s    '<>g__initLocal0'
      IL_0195:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate4'
      IL_0197:  brtrue.s   IL_01aa

      IL_0199:  ldloc.s    'CS$<>8__locals6'
      IL_019b:  ldftn      instance void ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::'<ComputePreimage>b__1'(int32,
                                                                                                                  class [mscorlib]System.Threading.Tasks.ParallelLoopState)
      IL_01a1:  newobj     instance void class [mscorlib]System.Action`2<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState>::.ctor(object,
                                                                                                                                                native int)
      IL_01a6:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegate4'
      IL_01a8:  br.s       IL_01aa

      IL_01aa:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegate4'
      IL_01ac:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                        int32,
                                                                                                                                        class [mscorlib]System.Threading.Tasks.ParallelOptions,
                                                                                                                                        class [mscorlib]System.Action`2<int32,class [mscorlib]System.Threading.Tasks.ParallelLoopState>)
      IL_01b1:  pop
//000257:                     {
//000258:                         for (int i = 0; i < width; i++)
//000259:                         {
//000260:                             PointF pf = GetPreimageLocation(new PointF(i, j), pairs);
//000261:                             Point p = ClampPoint(pf, new Size(width, height));
//000262:                             PixelData* inPixel = bmp[p.X, p.Y];
//000263:                             PixelData* outPixel = fastOut[i, j];
//000264:                             outPixel->R = inPixel->R;
//000265:                             outPixel->G = inPixel->G;
//000266:                             outPixel->B = inPixel->B;
//000267:                         }
//000268:                     });
//000269:                 }
      IL_01b2:  nop
//000270:             }
      IL_01b3:  nop
//000271:             
//000272:             return output;
//000273:         }
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
//000281:             int x = (int)p.X, y = (int)p.Y;
//000282: 
//000283: 			if (x < 0) x = 0;
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      IL_01b4:  leave.s    IL_01d4

    }  // end .try
    finally
    {
      IL_01b6:  ldloc.s    'CS$<>8__locals6'
      IL_01b8:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::fastOut
      IL_01bd:  ldnull
      IL_01be:  ceq
      IL_01c0:  stloc.s    CS$4$0002
      IL_01c2:  ldloc.s    CS$4$0002
      IL_01c4:  brtrue.s   IL_01d3

      IL_01c6:  ldloc.s    'CS$<>8__locals6'
      IL_01c8:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClass5'::fastOut
      IL_01cd:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_01d2:  nop
      IL_01d3:  endfinally
    }  // end handler
    IL_01d4:  nop
//000272:             return output;
    IL_01d5:  ldloc.0
    IL_01d6:  stloc.s    CS$1$0000
    IL_01d8:  br.s       IL_01da

//000273:         }
    IL_01da:  ldloc.s    CS$1$0000
    IL_01dc:  ret
  } // end of method ComputeMorph::ComputePreimage

  .method private hidebysig instance valuetype [System.Drawing]System.Drawing.Point 
          ClampPoint(valuetype [System.Drawing]System.Drawing.PointF p,
                     valuetype [System.Drawing]System.Drawing.Size s) cil managed
  {
    // Code size       109 (0x6d)
    .maxstack  3
    .locals init ([0] int32 x,
             [1] int32 y,
             [2] valuetype [System.Drawing]System.Drawing.Point CS$1$0000,
             [3] bool CS$4$0001)
//000274: 
//000275: 		/// <summary>Ensures that a point is within a set boundary.</summary>
//000276: 		/// <param name="p">The point to clamp.</param>
//000277: 		/// <param name="s">The boundaries.</param>
//000278: 		/// <returns>The clamped point.</returns>
//000279: 		private Point ClampPoint(PointF p, Size s)
//000280: 		{
    IL_0000:  nop
//000281:             int x = (int)p.X, y = (int)p.Y;
    IL_0001:  ldarga.s   p
    IL_0003:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0008:  conv.i4
    IL_0009:  stloc.0
    IL_000a:  ldarga.s   p
    IL_000c:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0011:  conv.i4
    IL_0012:  stloc.1
//000282: 
//000283: 			if (x < 0) x = 0;
    IL_0013:  ldloc.0
    IL_0014:  ldc.i4.0
    IL_0015:  clt
    IL_0017:  ldc.i4.0
    IL_0018:  ceq
    IL_001a:  stloc.3
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_001b:  ldloc.3
    IL_001c:  brtrue.s   IL_0022

//000283: 			if (x < 0) x = 0;
    IL_001e:  ldc.i4.0
    IL_001f:  stloc.0
//000284: 			else if (x >= s.Width) x = s.Width-1;
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0020:  br.s       IL_003a

//000284: 			else if (x >= s.Width) x = s.Width-1;
    IL_0022:  ldloc.0
    IL_0023:  ldarga.s   s
    IL_0025:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_002a:  clt
    IL_002c:  stloc.3
//000285: 
//000286: 			if (y < 0) y = 0;
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_002d:  ldloc.3
    IL_002e:  brtrue.s   IL_003a

//000284: 			else if (x >= s.Width) x = s.Width-1;
    IL_0030:  ldarga.s   s
    IL_0032:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0037:  ldc.i4.1
    IL_0038:  sub
    IL_0039:  stloc.0
//000285: 
//000286: 			if (y < 0) y = 0;
    IL_003a:  ldloc.1
    IL_003b:  ldc.i4.0
    IL_003c:  clt
    IL_003e:  ldc.i4.0
    IL_003f:  ceq
    IL_0041:  stloc.3
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0042:  ldloc.3
    IL_0043:  brtrue.s   IL_0049

//000286: 			if (y < 0) y = 0;
    IL_0045:  ldc.i4.0
    IL_0046:  stloc.1
//000287: 			else if (y >= s.Height) y = s.Height-1;
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0047:  br.s       IL_0061

//000287: 			else if (y >= s.Height) y = s.Height-1;
    IL_0049:  ldloc.1
    IL_004a:  ldarga.s   s
    IL_004c:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0051:  clt
    IL_0053:  stloc.3
//000288: 
//000289:             return new Point(x, y);
//000290: 		}
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0054:  ldloc.3
    IL_0055:  brtrue.s   IL_0061

//000287: 			else if (y >= s.Height) y = s.Height-1;
    IL_0057:  ldarga.s   s
    IL_0059:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_005e:  ldc.i4.1
    IL_005f:  sub
    IL_0060:  stloc.1
//000288: 
//000289:             return new Point(x, y);
    IL_0061:  ldloc.0
    IL_0062:  ldloc.1
    IL_0063:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_0068:  stloc.2
    IL_0069:  br.s       IL_006b

//000290: 		}
    IL_006b:  ldloc.2
    IL_006c:  ret
  } // end of method ComputeMorph::ClampPoint

  .method private hidebysig instance class [System.Drawing]System.Drawing.Bitmap 
          BlendImages(class [System.Drawing]System.Drawing.Bitmap start,
                      class [System.Drawing]System.Drawing.Bitmap end,
                      float64 blend) cil managed
  {
    // Code size       714 (0x2ca)
    .maxstack  5
    .locals init ([0] int32 width,
             [1] class [System.Drawing]System.Drawing.Bitmap output,
             [2] int32 i,
             [3] int32 j,
             [4] valuetype Microsoft.Drawing.PixelData* outPixel,
             [5] valuetype Microsoft.Drawing.PixelData* startPixel,
             [6] valuetype Microsoft.Drawing.PixelData* endPixel,
             [7] class [mscorlib]System.Action`1<int32> 'CS$<>9__CachedAnonymousMethodDelegatee',
             [8] class ParallelMorph.ComputeMorph/'<>c__DisplayClassf' 'CS$<>8__locals10',
             [9] class ParallelMorph.ComputeMorph/'<>c__DisplayClassc' 'CS$<>8__localsd',
             [10] class ParallelMorph.ComputeMorph/'<>c__DisplayClassa' 'CS$<>8__localsb',
             [11] class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' 'CS$<>8__locals9',
             [12] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [13] bool CS$4$0001)
//000291: 
//000292: 		/// <summary>Blends two images.</summary>
//000293: 		/// <param name="start">The first image.</param>
//000294: 		/// <param name="end">The second image.</param>
//000295: 		/// <param name="blend">The percentage of the alpha blend for the first image.</param>
//000296: 		/// <returns>The blended image.</returns>
//000297:         private unsafe Bitmap BlendImages(Bitmap start, Bitmap end, double blend)
//000298:         {
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0000:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::.ctor()
    IL_0005:  stloc.s    'CS$<>8__locals9'
    IL_0007:  ldloc.s    'CS$<>8__locals9'
    IL_0009:  ldarg.3
    IL_000a:  stfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
//000298:         {
    IL_000f:  nop
//000299:             // Validate parameters
//000300:             if (start.Width != end.Width ||
    IL_0010:  ldarg.1
    IL_0011:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0016:  ldarg.2
    IL_0017:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_001c:  bne.un.s   IL_002e

    IL_001e:  ldarg.1
    IL_001f:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0024:  ldarg.2
    IL_0025:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_002a:  ceq
    IL_002c:  br.s       IL_002f

    IL_002e:  ldc.i4.0
    IL_002f:  stloc.s    CS$4$0001
//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_0031:  ldloc.s    CS$4$0001
    IL_0033:  brtrue.s   IL_0040

//000301:                 start.Height != end.Height) throw new ArgumentException("The sizes of images do not match.");
    IL_0035:  ldstr      "The sizes of images do not match."
    IL_003a:  newobj     instance void [mscorlib]System.ArgumentException::.ctor(string)
    IL_003f:  throw

//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
    IL_0040:  ldloc.s    'CS$<>8__locals9'
    IL_0042:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
    IL_0047:  ldc.r8     0.0
    IL_0050:  blt.s      IL_0069

    IL_0052:  ldloc.s    'CS$<>8__locals9'
    IL_0054:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
    IL_0059:  ldc.r8     1.
    IL_0062:  cgt
    IL_0064:  ldc.i4.0
    IL_0065:  ceq
    IL_0067:  br.s       IL_006a

    IL_0069:  ldc.i4.0
    IL_006a:  stloc.s    CS$4$0001
//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
//000306:             Bitmap output = new Bitmap(width, height);
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_006c:  ldloc.s    CS$4$0001
    IL_006e:  brtrue.s   IL_008c

//000302:             if (blend < 0 || blend > 1) throw new ArgumentOutOfRangeException("blend", blend, "Must be in the range [0.0,1.1].");
    IL_0070:  ldstr      "blend"
    IL_0075:  ldloc.s    'CS$<>8__locals9'
    IL_0077:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
    IL_007c:  box        [mscorlib]System.Double
    IL_0081:  ldstr      "Must be in the range [0.0,1.1]."
    IL_0086:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_008b:  throw

//000303: 
//000304:             // Blend the images
//000305:             int width = start.Width, height = start.Height;
    IL_008c:  ldarg.1
    IL_008d:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0092:  stloc.0
    IL_0093:  ldloc.s    'CS$<>8__locals9'
    IL_0095:  ldarg.1
    IL_0096:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_009b:  stfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::height
//000306:             Bitmap output = new Bitmap(width, height);
    IL_00a0:  ldloc.0
    IL_00a1:  ldloc.s    'CS$<>8__locals9'
    IL_00a3:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::height
    IL_00a8:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32)
    IL_00ad:  stloc.1
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    IL_00ae:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::.ctor()
    IL_00b3:  stloc.s    'CS$<>8__localsb'
//000307:             using (FastBitmap fastOut = new FastBitmap(output))
    IL_00b5:  ldloc.s    'CS$<>8__localsb'
    IL_00b7:  ldloc.1
    IL_00b8:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
    IL_00bd:  stfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::fastOut
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
    .try
    {
      IL_00c2:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::.ctor()
      IL_00c7:  stloc.s    'CS$<>8__localsd'
//000308:             using (FastBitmap fastStart = new FastBitmap(start))
      IL_00c9:  ldloc.s    'CS$<>8__localsd'
      IL_00cb:  ldarg.1
      IL_00cc:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
      IL_00d1:  stfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::fastStart
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
//000310:             {
//000311:                 if (!_useParallelism)
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
      .try
      {
        IL_00d6:  ldnull
        IL_00d7:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
        IL_00d9:  newobj     instance void ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::.ctor()
        IL_00de:  stloc.s    'CS$<>8__locals10'
        IL_00e0:  ldloc.s    'CS$<>8__locals10'
        IL_00e2:  ldloc.s    'CS$<>8__localsd'
        IL_00e4:  stfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClassc' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__localsd'
        IL_00e9:  ldloc.s    'CS$<>8__locals10'
        IL_00eb:  ldloc.s    'CS$<>8__localsb'
        IL_00ed:  stfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClassa' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__localsb'
        IL_00f2:  ldloc.s    'CS$<>8__locals10'
        IL_00f4:  ldloc.s    'CS$<>8__locals9'
        IL_00f6:  stfld      class ParallelMorph.ComputeMorph/'<>c__DisplayClass8' ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'CS$<>8__locals9'
//000309:             using (FastBitmap fastEnd = new FastBitmap(end))
        IL_00fb:  ldloc.s    'CS$<>8__locals10'
        IL_00fd:  ldarg.2
        IL_00fe:  newobj     instance void Microsoft.Drawing.FastBitmap::.ctor(class [System.Drawing]System.Drawing.Bitmap)
        IL_0103:  stfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::fastEnd
//000310:             {
        .try
        {
          IL_0108:  nop
//000311:                 if (!_useParallelism)
          IL_0109:  ldarg.0
          IL_010a:  ldfld      bool ParallelMorph.ComputeMorph::_useParallelism
          IL_010f:  stloc.s    CS$4$0001
//000312:                 {
//000313:                     for (int i = 0; i < width; i++)
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_0111:  ldloc.s    CS$4$0001
          IL_0113:  brtrue     IL_023d

//000312:                 {
          IL_0118:  nop
//000313:                     for (int i = 0; i < width; i++)
          IL_0119:  ldc.i4.0
          IL_011a:  stloc.2
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_011b:  br         IL_022d

//000314:                     {
          IL_0120:  nop
//000315:                         for (int j = 0; j < height; j++)
          IL_0121:  ldc.i4.0
          IL_0122:  stloc.3
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_0123:  br         IL_0215

//000316:                         {
          IL_0128:  nop
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
          IL_0129:  ldloc.s    'CS$<>8__localsb'
          IL_012b:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::fastOut
          IL_0130:  ldloc.2
          IL_0131:  ldloc.3
          IL_0132:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                      int32)
          IL_0137:  stloc.s    outPixel
//000319:                             PixelData* startPixel = fastStart[i, j];
          IL_0139:  ldloc.s    'CS$<>8__localsd'
          IL_013b:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::fastStart
          IL_0140:  ldloc.2
          IL_0141:  ldloc.3
          IL_0142:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                      int32)
          IL_0147:  stloc.s    startPixel
//000320:                             PixelData* endPixel = fastEnd[i, j];
          IL_0149:  ldloc.s    'CS$<>8__locals10'
          IL_014b:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::fastEnd
          IL_0150:  ldloc.2
          IL_0151:  ldloc.3
          IL_0152:  callvirt   instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                      int32)
          IL_0157:  stloc.s    endPixel
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
          IL_0159:  ldloc.s    outPixel
          IL_015b:  ldloc.s    startPixel
          IL_015d:  ldfld      uint8 Microsoft.Drawing.PixelData::R
          IL_0162:  conv.r8
          IL_0163:  ldloc.s    'CS$<>8__locals9'
          IL_0165:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_016a:  mul
          IL_016b:  ldc.r8     0.5
          IL_0174:  add
          IL_0175:  ldloc.s    endPixel
          IL_0177:  ldfld      uint8 Microsoft.Drawing.PixelData::R
          IL_017c:  conv.r8
          IL_017d:  ldc.r8     1.
          IL_0186:  ldloc.s    'CS$<>8__locals9'
          IL_0188:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_018d:  sub
          IL_018e:  mul
          IL_018f:  add
          IL_0190:  conv.u1
          IL_0191:  stfld      uint8 Microsoft.Drawing.PixelData::R
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
          IL_0196:  ldloc.s    outPixel
          IL_0198:  ldloc.s    startPixel
          IL_019a:  ldfld      uint8 Microsoft.Drawing.PixelData::G
          IL_019f:  conv.r8
          IL_01a0:  ldloc.s    'CS$<>8__locals9'
          IL_01a2:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_01a7:  mul
          IL_01a8:  ldc.r8     0.5
          IL_01b1:  add
          IL_01b2:  ldloc.s    endPixel
          IL_01b4:  ldfld      uint8 Microsoft.Drawing.PixelData::G
          IL_01b9:  conv.r8
          IL_01ba:  ldc.r8     1.
          IL_01c3:  ldloc.s    'CS$<>8__locals9'
          IL_01c5:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_01ca:  sub
          IL_01cb:  mul
          IL_01cc:  add
          IL_01cd:  conv.u1
          IL_01ce:  stfld      uint8 Microsoft.Drawing.PixelData::G
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
          IL_01d3:  ldloc.s    outPixel
          IL_01d5:  ldloc.s    startPixel
          IL_01d7:  ldfld      uint8 Microsoft.Drawing.PixelData::B
          IL_01dc:  conv.r8
          IL_01dd:  ldloc.s    'CS$<>8__locals9'
          IL_01df:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_01e4:  mul
          IL_01e5:  ldc.r8     0.5
          IL_01ee:  add
          IL_01ef:  ldloc.s    endPixel
          IL_01f1:  ldfld      uint8 Microsoft.Drawing.PixelData::B
          IL_01f6:  conv.r8
          IL_01f7:  ldc.r8     1.
          IL_0200:  ldloc.s    'CS$<>8__locals9'
          IL_0202:  ldfld      float64 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::blend
          IL_0207:  sub
          IL_0208:  mul
          IL_0209:  add
          IL_020a:  conv.u1
          IL_020b:  stfld      uint8 Microsoft.Drawing.PixelData::B
//000326:                         }
          IL_0210:  nop
//000315:                         for (int j = 0; j < height; j++)
          IL_0211:  ldloc.3
          IL_0212:  ldc.i4.1
          IL_0213:  add
          IL_0214:  stloc.3
          IL_0215:  ldloc.3
          IL_0216:  ldloc.s    'CS$<>8__locals9'
          IL_0218:  ldfld      int32 ParallelMorph.ComputeMorph/'<>c__DisplayClass8'::height
          IL_021d:  clt
          IL_021f:  stloc.s    CS$4$0001
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_0221:  ldloc.s    CS$4$0001
          IL_0223:  brtrue     IL_0128

//000327:                     }
          IL_0228:  nop
//000313:                     for (int i = 0; i < width; i++)
          IL_0229:  ldloc.2
          IL_022a:  ldc.i4.1
          IL_022b:  add
          IL_022c:  stloc.2
          IL_022d:  ldloc.2
          IL_022e:  ldloc.0
          IL_022f:  clt
          IL_0231:  stloc.s    CS$4$0001
//000314:                     {
//000315:                         for (int j = 0; j < height; j++)
//000316:                         {
//000317:                             // Get the pixels for the starting, ending, and output images
//000318:                             PixelData* outPixel = fastOut[i, j];
//000319:                             PixelData* startPixel = fastStart[i, j];
//000320:                             PixelData* endPixel = fastEnd[i, j];
//000321: 
//000322:                             // Blend the input pixels into the output pixel
//000323:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000324:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000325:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000326:                         }
//000327:                     }
//000328:                 }
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_0233:  ldloc.s    CS$4$0001
          IL_0235:  brtrue     IL_0120

//000328:                 }
          IL_023a:  nop
//000329:                 else
//000330:                 {
//000331:                     Parallel.For(0, width, i =>
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
//000347:             }
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_023b:  br.s       IL_025e

//000330:                 {
          IL_023d:  nop
//000331:                     Parallel.For(0, width, i =>
          IL_023e:  ldc.i4.0
          IL_023f:  ldloc.0
          IL_0240:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
          IL_0242:  brtrue.s   IL_0255

          IL_0244:  ldloc.s    'CS$<>8__locals10'
          IL_0246:  ldftn      instance void ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::'<BlendImages>b__7'(int32)
          IL_024c:  newobj     instance void class [mscorlib]System.Action`1<int32>::.ctor(object,
                                                                                           native int)
          IL_0251:  stloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
          IL_0253:  br.s       IL_0255

          IL_0255:  ldloc.s    'CS$<>9__CachedAnonymousMethodDelegatee'
          IL_0257:  call       valuetype [mscorlib]System.Threading.Tasks.ParallelLoopResult [mscorlib]System.Threading.Tasks.Parallel::For(int32,
                                                                                                                                            int32,
                                                                                                                                            class [mscorlib]System.Action`1<int32>)
          IL_025c:  pop
//000332:                     {
//000333:                         for (int j = 0; j < height; j++)
//000334:                         {
//000335:                             // Get the pixels for the starting, ending, and output images
//000336:                             PixelData* outPixel = fastOut[i, j];
//000337:                             PixelData* startPixel = fastStart[i, j];
//000338:                             PixelData* endPixel = fastEnd[i, j];
//000339: 
//000340:                             // Blend the input pixels into the output pixel
//000341:                             outPixel->R = (byte)((startPixel->R * blend) + .5 + (endPixel->R * (1 - blend))); // .5 for rounding
//000342:                             outPixel->G = (byte)((startPixel->G * blend) + .5 + (endPixel->G * (1 - blend)));
//000343:                             outPixel->B = (byte)((startPixel->B * blend) + .5 + (endPixel->B * (1 - blend)));
//000344:                         }
//000345:                     });
//000346:                 }
          IL_025d:  nop
//000347:             }
          IL_025e:  nop
//000348:             return output;
//000349:         }
//000350: 	}
//000351: }
          IL_025f:  leave.s    IL_027f

        }  // end .try
        finally
        {
          IL_0261:  ldloc.s    'CS$<>8__locals10'
          IL_0263:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::fastEnd
          IL_0268:  ldnull
          IL_0269:  ceq
          IL_026b:  stloc.s    CS$4$0001
          IL_026d:  ldloc.s    CS$4$0001
          IL_026f:  brtrue.s   IL_027e

          IL_0271:  ldloc.s    'CS$<>8__locals10'
          IL_0273:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassf'::fastEnd
          IL_0278:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
          IL_027d:  nop
          IL_027e:  endfinally
        }  // end handler
        IL_027f:  nop
        IL_0280:  leave.s    IL_02a0

      }  // end .try
      finally
      {
        IL_0282:  ldloc.s    'CS$<>8__localsd'
        IL_0284:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::fastStart
        IL_0289:  ldnull
        IL_028a:  ceq
        IL_028c:  stloc.s    CS$4$0001
        IL_028e:  ldloc.s    CS$4$0001
        IL_0290:  brtrue.s   IL_029f

        IL_0292:  ldloc.s    'CS$<>8__localsd'
        IL_0294:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassc'::fastStart
        IL_0299:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
        IL_029e:  nop
        IL_029f:  endfinally
      }  // end handler
      IL_02a0:  nop
      IL_02a1:  leave.s    IL_02c1

    }  // end .try
    finally
    {
      IL_02a3:  ldloc.s    'CS$<>8__localsb'
      IL_02a5:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::fastOut
      IL_02aa:  ldnull
      IL_02ab:  ceq
      IL_02ad:  stloc.s    CS$4$0001
      IL_02af:  ldloc.s    CS$4$0001
      IL_02b1:  brtrue.s   IL_02c0

      IL_02b3:  ldloc.s    'CS$<>8__localsb'
      IL_02b5:  ldfld      class Microsoft.Drawing.FastBitmap ParallelMorph.ComputeMorph/'<>c__DisplayClassa'::fastOut
      IL_02ba:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_02bf:  nop
      IL_02c0:  endfinally
    }  // end handler
    IL_02c1:  nop
    IL_02c2:  ldloc.1
    IL_02c3:  stloc.s    CS$1$0000
    IL_02c5:  br.s       IL_02c7

    IL_02c7:  ldloc.s    CS$1$0000
    IL_02c9:  ret
  } // end of method ComputeMorph::BlendImages

  .event [System]System.ComponentModel.ProgressChangedEventHandler ProgressChanged
  {
    .addon instance void ParallelMorph.ComputeMorph::add_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
    .removeon instance void ParallelMorph.ComputeMorph::remove_ProgressChanged(class [System]System.ComponentModel.ProgressChangedEventHandler)
  } // end of event ComputeMorph::ProgressChanged
} // end of class ParallelMorph.ComputeMorph

.class public auto ansi sealed ParallelMorph.OutputMode
       extends [mscorlib]System.Enum
{
  .field public specialname rtspecialname int32 value__
  .field public static literal valuetype ParallelMorph.OutputMode Movie = int32(0x00000000)
  .field public static literal valuetype ParallelMorph.OutputMode ImageSequence = int32(0x00000001)
} // end of class ParallelMorph.OutputMode

.class public auto ansi serializable beforefieldinit ParallelMorph.SavedSettings
       extends [mscorlib]System.Object
{
  .field public class [System.Drawing]System.Drawing.Image FirstImage
  .field public class [System.Drawing]System.Drawing.Image SecondImage
  .field public class ParallelMorph.LinePairCollection Lines
  .field public class ParallelMorph.UiSettings Settings
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       7 (0x7)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  ret
  } // end of method SavedSettings::.ctor

} // end of class ParallelMorph.SavedSettings

.class public auto ansi serializable beforefieldinit ParallelMorph.ComputeMorphOptions
       extends [mscorlib]System.Object
{
  .field private int32 _numberOfOutputFrames
  .field private float64 _constA
  .field private float64 _constB
  .field private float64 _constP
  .method public hidebysig specialname instance int32 
          get_NumberOfOutputFrames() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] int32 CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\ComputeMorphOptions.cs' 
//000028: 			get { return _numberOfOutputFrames; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      int32 ParallelMorph.ComputeMorphOptions::_numberOfOutputFrames
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method ComputeMorphOptions::get_NumberOfOutputFrames

  .method public hidebysig specialname instance void 
          set_NumberOfOutputFrames(int32 'value') cil managed
  {
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000029: 			set 
//000030: 			{ 
    IL_0000:  nop
//000031: 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.3
    IL_0003:  clt
    IL_0005:  ldc.i4.0
    IL_0006:  ceq
    IL_0008:  stloc.0
//000032: 				_numberOfOutputFrames = value; 
//000033: 			} 
//000034: 		}
//000035: 
//000036: 		/// <summary>
//000037: 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
//000038: 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
//000039: 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
//000040: 		/// warping, but with less precise control.
//000041: 		/// </summary>
//000042:         [Description(
//000043:             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
//000044: 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
//000045: 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
//000046: 		    "warping, but with less precise control.")]
//000047:         [Category("Algorithm")]
//000048:         public double ConstA 
//000049: 		{ 
//000050: 			get { return _constA; } 
//000051: 			set 
//000052: 			{ 
//000053: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
//000054: 				_constA = value; 
//000055: 			} 
//000056: 		}
//000057: 		
//000058: 		/// <summary>
//000059: 		/// The variable b determines how the relative strength of different lines falls off with distance. 
//000060: 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
//000061: 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
//000062: 		/// most useful.
//000063: 		/// </summary>
//000064:         [Description(
//000065:             "The variable b determines how the relative strength of different lines falls off with distance. "+
//000066: 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
//000067: 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
//000068: 		    "most useful.")]
//000069:         [Category("Algorithm")]
//000070:         public double ConstB 
//000071: 		{ 
//000072: 			get { return _constB; } 
//000073: 			set 
//000074: 			{ 
//000075: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
//000076: 				_constB = value; 
//000077: 			} 
//000078: 		}
//000079: 		
//000080: 		/// <summary>
//000081: 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
//000082: 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
//000083: 		/// </summary>
//000084:         [Description(
//000085:             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
//000086:             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
//000087:         [Category("Algorithm")]
//000088:         public double ConstP 
//000089: 		{ 
//000090: 			get { return _constP; } 
//000091: 			set 
//000092: 			{ 
//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
//000094: 				_constP = value; 
//000095: 			} 
//000096: 		}
//000097:     }
//000098: }
    IL_0009:  ldloc.0
    IL_000a:  brtrue.s   IL_0022

//000031: 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
    IL_000c:  ldstr      "NumberOfFrames"
    IL_0011:  ldarg.1
    IL_0012:  box        [mscorlib]System.Int32
    IL_0017:  ldstr      "There must be at least three output frames."
    IL_001c:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0021:  throw

//000032: 				_numberOfOutputFrames = value; 
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  stfld      int32 ParallelMorph.ComputeMorphOptions::_numberOfOutputFrames
//000033: 			} 
    IL_0029:  ret
  } // end of method ComputeMorphOptions::set_NumberOfOutputFrames

  .method public hidebysig specialname instance float64 
          get_ConstA() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000034: 		}
//000035: 
//000036: 		/// <summary>
//000037: 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
//000038: 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
//000039: 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
//000040: 		/// warping, but with less precise control.
//000041: 		/// </summary>
//000042:         [Description(
//000043:             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
//000044: 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
//000045: 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
//000046: 		    "warping, but with less precise control.")]
//000047:         [Category("Algorithm")]
//000048:         public double ConstA 
//000049: 		{ 
//000050: 			get { return _constA; } 
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 ParallelMorph.ComputeMorphOptions::_constA
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method ComputeMorphOptions::get_ConstA

  .method public hidebysig specialname instance void 
          set_ConstA(float64 'value') cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000051: 			set 
//000052: 			{ 
    IL_0000:  nop
//000053: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
    IL_0001:  ldarg.1
    IL_0002:  ldc.r8     0.0
    IL_000b:  clt
    IL_000d:  ldc.i4.0
    IL_000e:  ceq
    IL_0010:  stloc.0
//000054: 				_constA = value; 
//000055: 			} 
//000056: 		}
//000057: 		
//000058: 		/// <summary>
//000059: 		/// The variable b determines how the relative strength of different lines falls off with distance. 
//000060: 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
//000061: 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
//000062: 		/// most useful.
//000063: 		/// </summary>
//000064:         [Description(
//000065:             "The variable b determines how the relative strength of different lines falls off with distance. "+
//000066: 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
//000067: 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
//000068: 		    "most useful.")]
//000069:         [Category("Algorithm")]
//000070:         public double ConstB 
//000071: 		{ 
//000072: 			get { return _constB; } 
//000073: 			set 
//000074: 			{ 
//000075: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
//000076: 				_constB = value; 
//000077: 			} 
//000078: 		}
//000079: 		
//000080: 		/// <summary>
//000081: 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
//000082: 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
//000083: 		/// </summary>
//000084:         [Description(
//000085:             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
//000086:             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
//000087:         [Category("Algorithm")]
//000088:         public double ConstP 
//000089: 		{ 
//000090: 			get { return _constP; } 
//000091: 			set 
//000092: 			{ 
//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
//000094: 				_constP = value; 
//000095: 			} 
//000096: 		}
//000097:     }
//000098: }
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_002a

//000053: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
    IL_0014:  ldstr      "ConstA"
    IL_0019:  ldarg.1
    IL_001a:  box        [mscorlib]System.Double
    IL_001f:  ldstr      "Must not be negative."
    IL_0024:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0029:  throw

//000054: 				_constA = value; 
    IL_002a:  ldarg.0
    IL_002b:  ldarg.1
    IL_002c:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constA
//000055: 			} 
    IL_0031:  ret
  } // end of method ComputeMorphOptions::set_ConstA

  .method public hidebysig specialname instance float64 
          get_ConstB() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000056: 		}
//000057: 		
//000058: 		/// <summary>
//000059: 		/// The variable b determines how the relative strength of different lines falls off with distance. 
//000060: 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
//000061: 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
//000062: 		/// most useful.
//000063: 		/// </summary>
//000064:         [Description(
//000065:             "The variable b determines how the relative strength of different lines falls off with distance. "+
//000066: 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
//000067: 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
//000068: 		    "most useful.")]
//000069:         [Category("Algorithm")]
//000070:         public double ConstB 
//000071: 		{ 
//000072: 			get { return _constB; } 
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 ParallelMorph.ComputeMorphOptions::_constB
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method ComputeMorphOptions::get_ConstB

  .method public hidebysig specialname instance void 
          set_ConstB(float64 'value') cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000073: 			set 
//000074: 			{ 
    IL_0000:  nop
//000075: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
    IL_0001:  ldarg.1
    IL_0002:  ldc.r8     0.0
    IL_000b:  clt
    IL_000d:  ldc.i4.0
    IL_000e:  ceq
    IL_0010:  stloc.0
//000076: 				_constB = value; 
//000077: 			} 
//000078: 		}
//000079: 		
//000080: 		/// <summary>
//000081: 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
//000082: 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
//000083: 		/// </summary>
//000084:         [Description(
//000085:             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
//000086:             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
//000087:         [Category("Algorithm")]
//000088:         public double ConstP 
//000089: 		{ 
//000090: 			get { return _constP; } 
//000091: 			set 
//000092: 			{ 
//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
//000094: 				_constP = value; 
//000095: 			} 
//000096: 		}
//000097:     }
//000098: }
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_002a

//000075: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
    IL_0014:  ldstr      "ConstB"
    IL_0019:  ldarg.1
    IL_001a:  box        [mscorlib]System.Double
    IL_001f:  ldstr      "Must not be negative."
    IL_0024:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0029:  throw

//000076: 				_constB = value; 
    IL_002a:  ldarg.0
    IL_002b:  ldarg.1
    IL_002c:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constB
//000077: 			} 
    IL_0031:  ret
  } // end of method ComputeMorphOptions::set_ConstB

  .method public hidebysig specialname instance float64 
          get_ConstP() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] float64 CS$1$0000)
//000078: 		}
//000079: 		
//000080: 		/// <summary>
//000081: 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
//000082: 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
//000083: 		/// </summary>
//000084:         [Description(
//000085:             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
//000086:             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
//000087:         [Category("Algorithm")]
//000088:         public double ConstP 
//000089: 		{ 
//000090: 			get { return _constP; } 
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      float64 ParallelMorph.ComputeMorphOptions::_constP
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method ComputeMorphOptions::get_ConstP

  .method public hidebysig specialname instance void 
          set_ConstP(float64 'value') cil managed
  {
    // Code size       50 (0x32)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000091: 			set 
//000092: 			{ 
    IL_0000:  nop
//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
    IL_0001:  ldarg.1
    IL_0002:  ldc.r8     0.0
    IL_000b:  clt
    IL_000d:  ldc.i4.0
    IL_000e:  ceq
    IL_0010:  stloc.0
//000094: 				_constP = value; 
//000095: 			} 
//000096: 		}
//000097:     }
//000098: }
    IL_0011:  ldloc.0
    IL_0012:  brtrue.s   IL_002a

//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
    IL_0014:  ldstr      "ConstP"
    IL_0019:  ldarg.1
    IL_001a:  box        [mscorlib]System.Double
    IL_001f:  ldstr      "Must not be negative."
    IL_0024:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0029:  throw

//000094: 				_constP = value; 
    IL_002a:  ldarg.0
    IL_002b:  ldarg.1
    IL_002c:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constP
//000095: 			} 
    IL_0031:  ret
  } // end of method ComputeMorphOptions::set_ConstP

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       61 (0x3d)
    .maxstack  8
//000018: 		private int _numberOfOutputFrames = 48;
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.s   48
    IL_0003:  stfld      int32 ParallelMorph.ComputeMorphOptions::_numberOfOutputFrames
//000019:         private double _constA = 2.0;
    IL_0008:  ldarg.0
    IL_0009:  ldc.r8     2.
    IL_0012:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constA
//000020: 		private double _constB = 2.0;
    IL_0017:  ldarg.0
    IL_0018:  ldc.r8     2.
    IL_0021:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constB
//000021: 		private double _constP = .25;
    IL_0026:  ldarg.0
    IL_0027:  ldc.r8     0.25
    IL_0030:  stfld      float64 ParallelMorph.ComputeMorphOptions::_constP
//000022: 
//000023: 		/// <summary>Gets or sets the number of output frames to generate.</summary>
//000024:         [Description("The number of output frames to generate.")]
//000025:         [Category("Algorithm")]
//000026: 		public int NumberOfOutputFrames 
//000027: 		{ 
//000028: 			get { return _numberOfOutputFrames; }
//000029: 			set 
//000030: 			{ 
//000031: 				if (value < 3) throw new ArgumentOutOfRangeException("NumberOfFrames", value, "There must be at least three output frames.");
//000032: 				_numberOfOutputFrames = value; 
//000033: 			} 
//000034: 		}
//000035: 
//000036: 		/// <summary>
//000037: 		/// If a is barely greater than zero, then if the distance from the line to the pixel is zero, 
//000038: 		/// the strength is nearly infinite. With this value for a, the user knows that pixels on the 
//000039: 		/// line will go exactly where he wants them. Values larger than that will yield a more smooth 
//000040: 		/// warping, but with less precise control.
//000041: 		/// </summary>
//000042:         [Description(
//000043:             "If a is barely greater than zero, then if the distance from the line to the pixel is zero, "+
//000044: 		    "the strength is nearly infinite. With this value for a, the user knows that pixels on the "+
//000045: 		    "line will go exactly where he wants them. Values larger than that will yield a more smooth "+
//000046: 		    "warping, but with less precise control.")]
//000047:         [Category("Algorithm")]
//000048:         public double ConstA 
//000049: 		{ 
//000050: 			get { return _constA; } 
//000051: 			set 
//000052: 			{ 
//000053: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstA", value, "Must not be negative.");
//000054: 				_constA = value; 
//000055: 			} 
//000056: 		}
//000057: 		
//000058: 		/// <summary>
//000059: 		/// The variable b determines how the relative strength of different lines falls off with distance. 
//000060: 		/// If it is large, then every pixel will be affected only by the line nearest it. If b is zero, 
//000061: 		/// then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the 
//000062: 		/// most useful.
//000063: 		/// </summary>
//000064:         [Description(
//000065:             "The variable b determines how the relative strength of different lines falls off with distance. "+
//000066: 		    "If it is large, then every pixel will be affected only by the line nearest it. If b is zero, "+
//000067: 		    "then each pixel will be affected by all lines equally. Values of b in the range [0.5, 2] are the"+ 
//000068: 		    "most useful.")]
//000069:         [Category("Algorithm")]
//000070:         public double ConstB 
//000071: 		{ 
//000072: 			get { return _constB; } 
//000073: 			set 
//000074: 			{ 
//000075: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstB", value, "Must not be negative.");
//000076: 				_constB = value; 
//000077: 			} 
//000078: 		}
//000079: 		
//000080: 		/// <summary>
//000081: 		/// The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;
//000082: 		/// if it is one, then longer lines have a greater relative weight than shorter lines.
//000083: 		/// </summary>
//000084:         [Description(
//000085:             "The value of p is typically in the range [0, 1]. If it is zero, then all lines have the same weight;"+
//000086:             "if it is one, then longer lines have a greater relative weight than shorter lines.")]
//000087:         [Category("Algorithm")]
//000088:         public double ConstP 
//000089: 		{ 
//000090: 			get { return _constP; } 
//000091: 			set 
//000092: 			{ 
//000093: 				if (value < 0) throw new ArgumentOutOfRangeException("ConstP", value, "Must not be negative.");
//000094: 				_constP = value; 
//000095: 			} 
//000096: 		}
//000097:     }
//000098: }
    IL_0035:  ldarg.0
    IL_0036:  call       instance void [mscorlib]System.Object::.ctor()
    IL_003b:  nop
    IL_003c:  ret
  } // end of method ComputeMorphOptions::.ctor

  .property instance int32 NumberOfOutputFrames()
  {
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 09 41 6C 67 6F 72 69 74 68 6D 00 00 )       // ...Algorithm..
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 28 54 68 65 20 6E 75 6D 62 65 72 20 6F 66   // ..(The number of
                                                                                                20 6F 75 74 70 75 74 20 66 72 61 6D 65 73 20 74   //  output frames t
                                                                                                6F 20 67 65 6E 65 72 61 74 65 2E 00 00 )          // o generate...
    .get instance int32 ParallelMorph.ComputeMorphOptions::get_NumberOfOutputFrames()
    .set instance void ParallelMorph.ComputeMorphOptions::set_NumberOfOutputFrames(int32)
  } // end of property ComputeMorphOptions::NumberOfOutputFrames
  .property instance float64 ConstA()
  {
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 81 37 49 66 20 61 20 69 73 20 62 61 72 65   // ...7If a is bare
                                                                                                6C 79 20 67 72 65 61 74 65 72 20 74 68 61 6E 20   // ly greater than 
                                                                                                7A 65 72 6F 2C 20 74 68 65 6E 20 69 66 20 74 68   // zero, then if th
                                                                                                65 20 64 69 73 74 61 6E 63 65 20 66 72 6F 6D 20   // e distance from 
                                                                                                74 68 65 20 6C 69 6E 65 20 74 6F 20 74 68 65 20   // the line to the 
                                                                                                70 69 78 65 6C 20 69 73 20 7A 65 72 6F 2C 20 74   // pixel is zero, t
                                                                                                68 65 20 73 74 72 65 6E 67 74 68 20 69 73 20 6E   // he strength is n
                                                                                                65 61 72 6C 79 20 69 6E 66 69 6E 69 74 65 2E 20   // early infinite. 
                                                                                                57 69 74 68 20 74 68 69 73 20 76 61 6C 75 65 20   // With this value 
                                                                                                66 6F 72 20 61 2C 20 74 68 65 20 75 73 65 72 20   // for a, the user 
                                                                                                6B 6E 6F 77 73 20 74 68 61 74 20 70 69 78 65 6C   // knows that pixel
                                                                                                73 20 6F 6E 20 74 68 65 20 6C 69 6E 65 20 77 69   // s on the line wi
                                                                                                6C 6C 20 67 6F 20 65 78 61 63 74 6C 79 20 77 68   // ll go exactly wh
                                                                                                65 72 65 20 68 65 20 77 61 6E 74 73 20 74 68 65   // ere he wants the
                                                                                                6D 2E 20 56 61 6C 75 65 73 20 6C 61 72 67 65 72   // m. Values larger
                                                                                                20 74 68 61 6E 20 74 68 61 74 20 77 69 6C 6C 20   //  than that will 
                                                                                                79 69 65 6C 64 20 61 20 6D 6F 72 65 20 73 6D 6F   // yield a more smo
                                                                                                6F 74 68 20 77 61 72 70 69 6E 67 2C 20 62 75 74   // oth warping, but
                                                                                                20 77 69 74 68 20 6C 65 73 73 20 70 72 65 63 69   //  with less preci
                                                                                                73 65 20 63 6F 6E 74 72 6F 6C 2E 00 00 )          // se control...
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 09 41 6C 67 6F 72 69 74 68 6D 00 00 )       // ...Algorithm..
    .get instance float64 ParallelMorph.ComputeMorphOptions::get_ConstA()
    .set instance void ParallelMorph.ComputeMorphOptions::set_ConstA(float64)
  } // end of property ComputeMorphOptions::ConstA
  .property instance float64 ConstB()
  {
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 81 29 54 68 65 20 76 61 72 69 61 62 6C 65   // ...)The variable
                                                                                                20 62 20 64 65 74 65 72 6D 69 6E 65 73 20 68 6F   //  b determines ho
                                                                                                77 20 74 68 65 20 72 65 6C 61 74 69 76 65 20 73   // w the relative s
                                                                                                74 72 65 6E 67 74 68 20 6F 66 20 64 69 66 66 65   // trength of diffe
                                                                                                72 65 6E 74 20 6C 69 6E 65 73 20 66 61 6C 6C 73   // rent lines falls
                                                                                                20 6F 66 66 20 77 69 74 68 20 64 69 73 74 61 6E   //  off with distan
                                                                                                63 65 2E 20 49 66 20 69 74 20 69 73 20 6C 61 72   // ce. If it is lar
                                                                                                67 65 2C 20 74 68 65 6E 20 65 76 65 72 79 20 70   // ge, then every p
                                                                                                69 78 65 6C 20 77 69 6C 6C 20 62 65 20 61 66 66   // ixel will be aff
                                                                                                65 63 74 65 64 20 6F 6E 6C 79 20 62 79 20 74 68   // ected only by th
                                                                                                65 20 6C 69 6E 65 20 6E 65 61 72 65 73 74 20 69   // e line nearest i
                                                                                                74 2E 20 49 66 20 62 20 69 73 20 7A 65 72 6F 2C   // t. If b is zero,
                                                                                                20 74 68 65 6E 20 65 61 63 68 20 70 69 78 65 6C   //  then each pixel
                                                                                                20 77 69 6C 6C 20 62 65 20 61 66 66 65 63 74 65   //  will be affecte
                                                                                                64 20 62 79 20 61 6C 6C 20 6C 69 6E 65 73 20 65   // d by all lines e
                                                                                                71 75 61 6C 6C 79 2E 20 56 61 6C 75 65 73 20 6F   // qually. Values o
                                                                                                66 20 62 20 69 6E 20 74 68 65 20 72 61 6E 67 65   // f b in the range
                                                                                                20 5B 30 2E 35 2C 20 32 5D 20 61 72 65 20 74 68   //  [0.5, 2] are th
                                                                                                65 6D 6F 73 74 20 75 73 65 66 75 6C 2E 00 00 )    // emost useful...
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 09 41 6C 67 6F 72 69 74 68 6D 00 00 )       // ...Algorithm..
    .get instance float64 ParallelMorph.ComputeMorphOptions::get_ConstB()
    .set instance void ParallelMorph.ComputeMorphOptions::set_ConstB(float64)
  } // end of property ComputeMorphOptions::ConstB
  .property instance float64 ConstP()
  {
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 09 41 6C 67 6F 72 69 74 68 6D 00 00 )       // ...Algorithm..
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 80 B6 54 68 65 20 76 61 6C 75 65 20 6F 66   // ....The value of
                                                                                                20 70 20 69 73 20 74 79 70 69 63 61 6C 6C 79 20   //  p is typically 
                                                                                                69 6E 20 74 68 65 20 72 61 6E 67 65 20 5B 30 2C   // in the range [0,
                                                                                                20 31 5D 2E 20 49 66 20 69 74 20 69 73 20 7A 65   //  1]. If it is ze
                                                                                                72 6F 2C 20 74 68 65 6E 20 61 6C 6C 20 6C 69 6E   // ro, then all lin
                                                                                                65 73 20 68 61 76 65 20 74 68 65 20 73 61 6D 65   // es have the same
                                                                                                20 77 65 69 67 68 74 3B 69 66 20 69 74 20 69 73   //  weight;if it is
                                                                                                20 6F 6E 65 2C 20 74 68 65 6E 20 6C 6F 6E 67 65   //  one, then longe
                                                                                                72 20 6C 69 6E 65 73 20 68 61 76 65 20 61 20 67   // r lines have a g
                                                                                                72 65 61 74 65 72 20 72 65 6C 61 74 69 76 65 20   // reater relative 
                                                                                                77 65 69 67 68 74 20 74 68 61 6E 20 73 68 6F 72   // weight than shor
                                                                                                74 65 72 20 6C 69 6E 65 73 2E 00 00 )             // ter lines...
    .get instance float64 ParallelMorph.ComputeMorphOptions::get_ConstP()
    .set instance void ParallelMorph.ComputeMorphOptions::set_ConstP(float64)
  } // end of property ComputeMorphOptions::ConstP
} // end of class ParallelMorph.ComputeMorphOptions

.class public auto ansi serializable beforefieldinit ParallelMorph.UiSettings
       extends ParallelMorph.ComputeMorphOptions
{
  .field private int32 _framesPerSecond
  .field private string _fourcc
  .method public hidebysig specialname instance int32 
          get_FramesPerSecond() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] int32 CS$1$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\UiSettings.cs' 
//000050: 			get { return _framesPerSecond; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      int32 ParallelMorph.UiSettings::_framesPerSecond
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method UiSettings::get_FramesPerSecond

  .method public hidebysig specialname instance void 
          set_FramesPerSecond(int32 'value') cil managed
  {
    // Code size       42 (0x2a)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000051: 			set
//000052: 			{
    IL_0000:  nop
//000053: 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.1
    IL_0003:  clt
    IL_0005:  ldc.i4.0
    IL_0006:  ceq
    IL_0008:  stloc.0
//000054: 				_framesPerSecond = value;
//000055: 			}
//000056: 		}
//000057: 
//000058: 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
//000059:         [Description("The FOURCC compression code to use for an output AVI movie.")]
//000060:         [Category("Movie")]
//000061:         public string FourCC
//000062: 		{
//000063: 			get { return _fourcc; }
//000064: 			set 
//000065: 			{
//000066: 				if (string.IsNullOrEmpty(value) || value.Length != 4)
//000067: 				{
//000068: 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
//000069: 				}
//000070: 				_fourcc = value; 
//000071: 			}
//000072: 		}
//000073:     }
//000074: }
    IL_0009:  ldloc.0
    IL_000a:  brtrue.s   IL_0022

//000053: 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
    IL_000c:  ldstr      "FramesPerSecond"
    IL_0011:  ldarg.1
    IL_0012:  box        [mscorlib]System.Int32
    IL_0017:  ldstr      "Must be at least one frame per second."
    IL_001c:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0021:  throw

//000054: 				_framesPerSecond = value;
    IL_0022:  ldarg.0
    IL_0023:  ldarg.1
    IL_0024:  stfld      int32 ParallelMorph.UiSettings::_framesPerSecond
//000055: 			}
    IL_0029:  ret
  } // end of method UiSettings::set_FramesPerSecond

  .method public hidebysig specialname instance string 
          get_FourCC() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] string CS$1$0000)
//000056: 		}
//000057: 
//000058: 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
//000059:         [Description("The FOURCC compression code to use for an output AVI movie.")]
//000060:         [Category("Movie")]
//000061:         public string FourCC
//000062: 		{
//000063: 			get { return _fourcc; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      string ParallelMorph.UiSettings::_fourcc
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method UiSettings::get_FourCC

  .method public hidebysig specialname instance void 
          set_FourCC(string 'value') cil managed
  {
    // Code size       51 (0x33)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000064: 			set 
//000065: 			{
    IL_0000:  nop
//000066: 				if (string.IsNullOrEmpty(value) || value.Length != 4)
    IL_0001:  ldarg.1
    IL_0002:  call       bool [mscorlib]System.String::IsNullOrEmpty(string)
    IL_0007:  brtrue.s   IL_0014

    IL_0009:  ldarg.1
    IL_000a:  callvirt   instance int32 [mscorlib]System.String::get_Length()
    IL_000f:  ldc.i4.4
    IL_0010:  ceq
    IL_0012:  br.s       IL_0015

    IL_0014:  ldc.i4.0
    IL_0015:  stloc.0
//000067: 				{
//000068: 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
//000069: 				}
//000070: 				_fourcc = value; 
//000071: 			}
//000072: 		}
//000073:     }
//000074: }
    IL_0016:  ldloc.0
    IL_0017:  brtrue.s   IL_002b

//000067: 				{
    IL_0019:  nop
//000068: 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
    IL_001a:  ldstr      "FourCC"
    IL_001f:  ldarg.1
    IL_0020:  ldstr      "A FourCC value must be four characters in length."
    IL_0025:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_002a:  throw

//000069: 				}
//000070: 				_fourcc = value; 
    IL_002b:  ldarg.0
    IL_002c:  ldarg.1
    IL_002d:  stfld      string ParallelMorph.UiSettings::_fourcc
//000071: 			}
    IL_0032:  ret
  } // end of method UiSettings::set_FourCC

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       27 (0x1b)
    .maxstack  8
//000042:         private int _framesPerSecond = 24;
    IL_0000:  ldarg.0
    IL_0001:  ldc.i4.s   24
    IL_0003:  stfld      int32 ParallelMorph.UiSettings::_framesPerSecond
//000043:         private string _fourcc = String.Empty;
    IL_0008:  ldarg.0
    IL_0009:  ldsfld     string [mscorlib]System.String::Empty
    IL_000e:  stfld      string ParallelMorph.UiSettings::_fourcc
//000044: 
//000045: 		/// <summary>Gets or sets the number of frames per second for the output AVI.</summary>
//000046:         [Description("The number of frames per second for an output AVI movie.")]
//000047:         [Category("Movie")]
//000048: 		public int FramesPerSecond
//000049: 		{
//000050: 			get { return _framesPerSecond; }
//000051: 			set
//000052: 			{
//000053: 				if (value < 1) throw new ArgumentOutOfRangeException("FramesPerSecond", value, "Must be at least one frame per second.");
//000054: 				_framesPerSecond = value;
//000055: 			}
//000056: 		}
//000057: 
//000058: 		/// <summary>Gets or sets the FOURCC compression code for the output AVI.</summary>
//000059:         [Description("The FOURCC compression code to use for an output AVI movie.")]
//000060:         [Category("Movie")]
//000061:         public string FourCC
//000062: 		{
//000063: 			get { return _fourcc; }
//000064: 			set 
//000065: 			{
//000066: 				if (string.IsNullOrEmpty(value) || value.Length != 4)
//000067: 				{
//000068: 					throw new ArgumentOutOfRangeException("FourCC", value, "A FourCC value must be four characters in length.");
//000069: 				}
//000070: 				_fourcc = value; 
//000071: 			}
//000072: 		}
//000073:     }
//000074: }
    IL_0013:  ldarg.0
    IL_0014:  call       instance void ParallelMorph.ComputeMorphOptions::.ctor()
    IL_0019:  nop
    IL_001a:  ret
  } // end of method UiSettings::.ctor

  .property instance int32 FramesPerSecond()
  {
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 38 54 68 65 20 6E 75 6D 62 65 72 20 6F 66   // ..8The number of
                                                                                                20 66 72 61 6D 65 73 20 70 65 72 20 73 65 63 6F   //  frames per seco
                                                                                                6E 64 20 66 6F 72 20 61 6E 20 6F 75 74 70 75 74   // nd for an output
                                                                                                20 41 56 49 20 6D 6F 76 69 65 2E 00 00 )          //  AVI movie...
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 05 4D 6F 76 69 65 00 00 )                   // ...Movie..
    .get instance int32 ParallelMorph.UiSettings::get_FramesPerSecond()
    .set instance void ParallelMorph.UiSettings::set_FramesPerSecond(int32)
  } // end of property UiSettings::FramesPerSecond
  .property instance string FourCC()
  {
    .custom instance void [System]System.ComponentModel.DescriptionAttribute::.ctor(string) = ( 01 00 3B 54 68 65 20 46 4F 55 52 43 43 20 63 6F   // ..;The FOURCC co
                                                                                                6D 70 72 65 73 73 69 6F 6E 20 63 6F 64 65 20 74   // mpression code t
                                                                                                6F 20 75 73 65 20 66 6F 72 20 61 6E 20 6F 75 74   // o use for an out
                                                                                                70 75 74 20 41 56 49 20 6D 6F 76 69 65 2E 00 00 ) // put AVI movie...
    .custom instance void [System]System.ComponentModel.CategoryAttribute::.ctor(string) = ( 01 00 05 4D 6F 76 69 65 00 00 )                   // ...Movie..
    .get instance string ParallelMorph.UiSettings::get_FourCC()
    .set instance void ParallelMorph.UiSettings::set_FourCC(string)
  } // end of property UiSettings::FourCC
} // end of class ParallelMorph.UiSettings

.class private auto ansi beforefieldinit ParallelMorph.Properties.Resources
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Diagnostics.DebuggerNonUserCodeAttribute::.ctor() = ( 01 00 00 00 ) 
  .custom instance void [System]System.CodeDom.Compiler.GeneratedCodeAttribute::.ctor(string,
                                                                                      string) = ( 01 00 33 53 79 73 74 65 6D 2E 52 65 73 6F 75 72   // ..3System.Resour
                                                                                                  63 65 73 2E 54 6F 6F 6C 73 2E 53 74 72 6F 6E 67   // ces.Tools.Strong
                                                                                                  6C 79 54 79 70 65 64 52 65 73 6F 75 72 63 65 42   // lyTypedResourceB
                                                                                                  75 69 6C 64 65 72 07 34 2E 30 2E 30 2E 30 00 00 ) // uilder.4.0.0.0..
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private static class [mscorlib]System.Resources.ResourceManager resourceMan
  .field private static class [mscorlib]System.Globalization.CultureInfo resourceCulture
  .method assembly hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Properties\Resources.Designer.cs' 
//000031:         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000032:         internal Resources() {
    IL_0007:  nop
//000033:         }
    IL_0008:  nop
    IL_0009:  ret
  } // end of method Resources::.ctor

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Resources.ResourceManager 
          get_ResourceManager() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.Resources.ResourceManager temp,
             [1] class [mscorlib]System.Resources.ResourceManager CS$1$0000,
             [2] bool CS$4$0001)
//000034:         
//000035:         /// <summary>
//000036:         ///   Returns the cached ResourceManager instance used by this class.
//000037:         /// </summary>
//000038:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000039:         internal static global::System.Resources.ResourceManager ResourceManager {
//000040:             get {
    IL_0000:  nop
//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0001:  ldsfld     class [mscorlib]System.Resources.ResourceManager ParallelMorph.Properties.Resources::resourceMan
    IL_0006:  ldnull
    IL_0007:  call       bool [mscorlib]System.Object::ReferenceEquals(object,
                                                                       object)
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.2
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ParallelMorph.Properties.Resources", typeof(Resources).Assembly);
//000043:                     resourceMan = temp;
//000044:                 }
//000045:                 return resourceMan;
//000046:             }
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
//000056:                 return resourceCulture;
//000057:             }
//000058:             set {
//000059:                 resourceCulture = value;
//000060:             }
//000061:         }
//000062:     }
//000063: }
    IL_0010:  ldloc.2
    IL_0011:  brtrue.s   IL_0035

//000041:                 if (object.ReferenceEquals(resourceMan, null)) {
    IL_0013:  nop
//000042:                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("ParallelMorph.Properties.Resources", typeof(Resources).Assembly);
    IL_0014:  ldstr      "ParallelMorph.Properties.Resources"
    IL_0019:  ldtoken    ParallelMorph.Properties.Resources
    IL_001e:  call       class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
    IL_0023:  callvirt   instance class [mscorlib]System.Reflection.Assembly [mscorlib]System.Type::get_Assembly()
    IL_0028:  newobj     instance void [mscorlib]System.Resources.ResourceManager::.ctor(string,
                                                                                         class [mscorlib]System.Reflection.Assembly)
    IL_002d:  stloc.0
//000043:                     resourceMan = temp;
    IL_002e:  ldloc.0
    IL_002f:  stsfld     class [mscorlib]System.Resources.ResourceManager ParallelMorph.Properties.Resources::resourceMan
//000044:                 }
    IL_0034:  nop
//000045:                 return resourceMan;
    IL_0035:  ldsfld     class [mscorlib]System.Resources.ResourceManager ParallelMorph.Properties.Resources::resourceMan
    IL_003a:  stloc.1
    IL_003b:  br.s       IL_003d

//000046:             }
    IL_003d:  ldloc.1
    IL_003e:  ret
  } // end of method Resources::get_ResourceManager

  .method assembly hidebysig specialname static 
          class [mscorlib]System.Globalization.CultureInfo 
          get_Culture() cil managed
  {
    // Code size       11 (0xb)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Globalization.CultureInfo CS$1$0000)
//000047:         }
//000048:         
//000049:         /// <summary>
//000050:         ///   Overrides the current thread's CurrentUICulture property for all
//000051:         ///   resource lookups using this strongly typed resource class.
//000052:         /// </summary>
//000053:         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
//000054:         internal static global::System.Globalization.CultureInfo Culture {
//000055:             get {
    IL_0000:  nop
//000056:                 return resourceCulture;
    IL_0001:  ldsfld     class [mscorlib]System.Globalization.CultureInfo ParallelMorph.Properties.Resources::resourceCulture
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

//000057:             }
    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Resources::get_Culture

  .method assembly hidebysig specialname static 
          void  set_Culture(class [mscorlib]System.Globalization.CultureInfo 'value') cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
//000058:             set {
    IL_0000:  nop
//000059:                 resourceCulture = value;
    IL_0001:  ldarg.0
    IL_0002:  stsfld     class [mscorlib]System.Globalization.CultureInfo ParallelMorph.Properties.Resources::resourceCulture
//000060:             }
    IL_0007:  ret
  } // end of method Resources::set_Culture

  .property class [mscorlib]System.Resources.ResourceManager
          ResourceManager()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .get class [mscorlib]System.Resources.ResourceManager ParallelMorph.Properties.Resources::get_ResourceManager()
  } // end of property Resources::ResourceManager
  .property class [mscorlib]System.Globalization.CultureInfo
          Culture()
  {
    .custom instance void [System]System.ComponentModel.EditorBrowsableAttribute::.ctor(valuetype [System]System.ComponentModel.EditorBrowsableState) = ( 01 00 02 00 00 00 00 00 ) 
    .set void ParallelMorph.Properties.Resources::set_Culture(class [mscorlib]System.Globalization.CultureInfo)
    .get class [mscorlib]System.Globalization.CultureInfo ParallelMorph.Properties.Resources::get_Culture()
  } // end of property Resources::Culture
} // end of class ParallelMorph.Properties.Resources

.class public auto ansi beforefieldinit ParallelMorph.EditSettings
       extends [System.Windows.Forms]System.Windows.Forms.Form
{
  .field private class [System.Windows.Forms]System.Windows.Forms.PropertyGrid pgSettings
  .field private class [System]System.ComponentModel.Container components
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       24 (0x18)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\EditSettings.cs' 
//000020: 		private System.ComponentModel.Container components = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System]System.ComponentModel.Container ParallelMorph.EditSettings::components
//000021: 
//000022: 		public EditSettings()
    IL_0007:  ldarg.0
    IL_0008:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::.ctor()
    IL_000d:  nop
//000023: 		{
    IL_000e:  nop
//000024: 			InitializeComponent();
    IL_000f:  ldarg.0
    IL_0010:  call       instance void ParallelMorph.EditSettings::InitializeComponent()
    IL_0015:  nop
//000025: 		}
    IL_0016:  nop
    IL_0017:  ret
  } // end of method EditSettings::.ctor

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       47 (0x2f)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000026: 
//000027: 		/// <summary>
//000028: 		/// Clean up any resources being used.
//000029: 		/// </summary>
//000030: 		protected override void Dispose( bool disposing )
//000031: 		{
    IL_0000:  nop
//000032: 			if( disposing )
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.0
    IL_0003:  ceq
    IL_0005:  stloc.0
//000033: 			{
//000034: 				if(components != null)
//000035: 				{
//000036: 					components.Dispose();
//000037: 				}
//000038: 			}
//000039: 			base.Dispose( disposing );
//000040: 		}
//000041: 
//000042: 		#region Windows Form Designer generated code
//000043: 		/// <summary>
//000044: 		/// Required method for Designer support - do not modify
//000045: 		/// the contents of this method with the code editor.
//000046: 		/// </summary>
//000047: 		private void InitializeComponent()
//000048: 		{
//000049:             this.pgSettings = new System.Windows.Forms.PropertyGrid();
//000050:             this.SuspendLayout();
//000051:             // 
//000052:             // pgSettings
//000053:             // 
//000054:             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
//000055:             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
//000056:             this.pgSettings.Location = new System.Drawing.Point(0, 0);
//000057:             this.pgSettings.Name = "pgSettings";
//000058:             this.pgSettings.Size = new System.Drawing.Size(300, 237);
//000059:             this.pgSettings.TabIndex = 0;
//000060:             this.pgSettings.ToolbarVisible = false;
//000061:             // 
//000062:             // EditSettings
//000063:             // 
//000064:             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
//000065:             this.ClientSize = new System.Drawing.Size(300, 237);
//000066:             this.Controls.Add(this.pgSettings);
//000067:             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
//000068:             this.Name = "EditSettings";
//000069:             this.Opacity = 0.97D;
//000070:             this.ShowInTaskbar = false;
//000071:             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
//000072:             this.Text = "Edit Settings";
//000073:             this.ResumeLayout(false);
//000074: 
//000075: 		}
//000076: 		#endregion
//000077: 
//000078: 		// ==========================================================================================
//000079: 		// ==========================================================================================
//000080: 		// ==========================================================================================
//000081: 
//000082: 		/// <summary>Gets or sets the settings being edited.</summary>
//000083: 		public UiSettings Settings
//000084: 		{
//000085: 			get { return (UiSettings)pgSettings.SelectedObject; }
//000086: 			set { pgSettings.SelectedObject = value; }
//000087: 		}
//000088: 	}
//000089: }
    IL_0006:  ldloc.0
    IL_0007:  brtrue.s   IL_0026

//000033: 			{
    IL_0009:  nop
//000034: 				if(components != null)
    IL_000a:  ldarg.0
    IL_000b:  ldfld      class [System]System.ComponentModel.Container ParallelMorph.EditSettings::components
    IL_0010:  ldnull
    IL_0011:  ceq
    IL_0013:  stloc.0
//000035: 				{
//000036: 					components.Dispose();
//000037: 				}
//000038: 			}
//000039: 			base.Dispose( disposing );
//000040: 		}
//000041: 
//000042: 		#region Windows Form Designer generated code
//000043: 		/// <summary>
//000044: 		/// Required method for Designer support - do not modify
//000045: 		/// the contents of this method with the code editor.
//000046: 		/// </summary>
//000047: 		private void InitializeComponent()
//000048: 		{
//000049:             this.pgSettings = new System.Windows.Forms.PropertyGrid();
//000050:             this.SuspendLayout();
//000051:             // 
//000052:             // pgSettings
//000053:             // 
//000054:             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
//000055:             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
//000056:             this.pgSettings.Location = new System.Drawing.Point(0, 0);
//000057:             this.pgSettings.Name = "pgSettings";
//000058:             this.pgSettings.Size = new System.Drawing.Size(300, 237);
//000059:             this.pgSettings.TabIndex = 0;
//000060:             this.pgSettings.ToolbarVisible = false;
//000061:             // 
//000062:             // EditSettings
//000063:             // 
//000064:             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
//000065:             this.ClientSize = new System.Drawing.Size(300, 237);
//000066:             this.Controls.Add(this.pgSettings);
//000067:             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
//000068:             this.Name = "EditSettings";
//000069:             this.Opacity = 0.97D;
//000070:             this.ShowInTaskbar = false;
//000071:             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
//000072:             this.Text = "Edit Settings";
//000073:             this.ResumeLayout(false);
//000074: 
//000075: 		}
//000076: 		#endregion
//000077: 
//000078: 		// ==========================================================================================
//000079: 		// ==========================================================================================
//000080: 		// ==========================================================================================
//000081: 
//000082: 		/// <summary>Gets or sets the settings being edited.</summary>
//000083: 		public UiSettings Settings
//000084: 		{
//000085: 			get { return (UiSettings)pgSettings.SelectedObject; }
//000086: 			set { pgSettings.SelectedObject = value; }
//000087: 		}
//000088: 	}
//000089: }
    IL_0014:  ldloc.0
    IL_0015:  brtrue.s   IL_0025

//000035: 				{
    IL_0017:  nop
//000036: 					components.Dispose();
    IL_0018:  ldarg.0
    IL_0019:  ldfld      class [System]System.ComponentModel.Container ParallelMorph.EditSettings::components
    IL_001e:  callvirt   instance void [System]System.ComponentModel.Container::Dispose()
    IL_0023:  nop
//000037: 				}
    IL_0024:  nop
//000038: 			}
    IL_0025:  nop
//000039: 			base.Dispose( disposing );
    IL_0026:  ldarg.0
    IL_0027:  ldarg.1
    IL_0028:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::Dispose(bool)
    IL_002d:  nop
//000040: 		}
    IL_002e:  ret
  } // end of method EditSettings::Dispose

  .method private hidebysig instance void 
          InitializeComponent() cil managed
  {
    // Code size       266 (0x10a)
    .maxstack  4
//000041: 
//000042: 		#region Windows Form Designer generated code
//000043: 		/// <summary>
//000044: 		/// Required method for Designer support - do not modify
//000045: 		/// the contents of this method with the code editor.
//000046: 		/// </summary>
//000047: 		private void InitializeComponent()
//000048: 		{
    IL_0000:  nop
//000049:             this.pgSettings = new System.Windows.Forms.PropertyGrid();
    IL_0001:  ldarg.0
    IL_0002:  newobj     instance void [System.Windows.Forms]System.Windows.Forms.PropertyGrid::.ctor()
    IL_0007:  stfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
//000050:             this.SuspendLayout();
    IL_000c:  ldarg.0
    IL_000d:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::SuspendLayout()
    IL_0012:  nop
//000051:             // 
//000052:             // pgSettings
//000053:             // 
//000054:             this.pgSettings.Dock = System.Windows.Forms.DockStyle.Fill;
    IL_0013:  ldarg.0
    IL_0014:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0019:  ldc.i4.5
    IL_001a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Dock(valuetype [System.Windows.Forms]System.Windows.Forms.DockStyle)
    IL_001f:  nop
//000055:             this.pgSettings.LineColor = System.Drawing.SystemColors.ScrollBar;
    IL_0020:  ldarg.0
    IL_0021:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0026:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.SystemColors::get_ScrollBar()
    IL_002b:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PropertyGrid::set_LineColor(valuetype [System.Drawing]System.Drawing.Color)
    IL_0030:  nop
//000056:             this.pgSettings.Location = new System.Drawing.Point(0, 0);
    IL_0031:  ldarg.0
    IL_0032:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0037:  ldc.i4.0
    IL_0038:  ldc.i4.0
    IL_0039:  newobj     instance void [System.Drawing]System.Drawing.Point::.ctor(int32,
                                                                                   int32)
    IL_003e:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Location(valuetype [System.Drawing]System.Drawing.Point)
    IL_0043:  nop
//000057:             this.pgSettings.Name = "pgSettings";
    IL_0044:  ldarg.0
    IL_0045:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_004a:  ldstr      "pgSettings"
    IL_004f:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_0054:  nop
//000058:             this.pgSettings.Size = new System.Drawing.Size(300, 237);
    IL_0055:  ldarg.0
    IL_0056:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_005b:  ldc.i4     0x12c
    IL_0060:  ldc.i4     0xed
    IL_0065:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_006a:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_006f:  nop
//000059:             this.pgSettings.TabIndex = 0;
    IL_0070:  ldarg.0
    IL_0071:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0076:  ldc.i4.0
    IL_0077:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_TabIndex(int32)
    IL_007c:  nop
//000060:             this.pgSettings.ToolbarVisible = false;
    IL_007d:  ldarg.0
    IL_007e:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0083:  ldc.i4.0
    IL_0084:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PropertyGrid::set_ToolbarVisible(bool)
    IL_0089:  nop
//000061:             // 
//000062:             // EditSettings
//000063:             // 
//000064:             this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
    IL_008a:  ldarg.0
    IL_008b:  ldc.i4.5
    IL_008c:  ldc.i4.s   13
    IL_008e:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0093:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Form::set_AutoScaleBaseSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_0098:  nop
//000065:             this.ClientSize = new System.Drawing.Size(300, 237);
    IL_0099:  ldarg.0
    IL_009a:  ldc.i4     0x12c
    IL_009f:  ldc.i4     0xed
    IL_00a4:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_00a9:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ClientSize(valuetype [System.Drawing]System.Drawing.Size)
    IL_00ae:  nop
//000066:             this.Controls.Add(this.pgSettings);
    IL_00af:  ldarg.0
    IL_00b0:  call       instance class [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection [System.Windows.Forms]System.Windows.Forms.Control::get_Controls()
    IL_00b5:  ldarg.0
    IL_00b6:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_00bb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control/ControlCollection::Add(class [System.Windows.Forms]System.Windows.Forms.Control)
    IL_00c0:  nop
//000067:             this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.SizableToolWindow;
    IL_00c1:  ldarg.0
    IL_00c2:  ldc.i4.6
    IL_00c3:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_FormBorderStyle(valuetype [System.Windows.Forms]System.Windows.Forms.FormBorderStyle)
    IL_00c8:  nop
//000068:             this.Name = "EditSettings";
    IL_00c9:  ldarg.0
    IL_00ca:  ldstr      "EditSettings"
    IL_00cf:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Name(string)
    IL_00d4:  nop
//000069:             this.Opacity = 0.97D;
    IL_00d5:  ldarg.0
    IL_00d6:  ldc.r8     0.96999999999999997
    IL_00df:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_Opacity(float64)
    IL_00e4:  nop
//000070:             this.ShowInTaskbar = false;
    IL_00e5:  ldarg.0
    IL_00e6:  ldc.i4.0
    IL_00e7:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_ShowInTaskbar(bool)
    IL_00ec:  nop
//000071:             this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
    IL_00ed:  ldarg.0
    IL_00ee:  ldc.i4.4
    IL_00ef:  call       instance void [System.Windows.Forms]System.Windows.Forms.Form::set_StartPosition(valuetype [System.Windows.Forms]System.Windows.Forms.FormStartPosition)
    IL_00f4:  nop
//000072:             this.Text = "Edit Settings";
    IL_00f5:  ldarg.0
    IL_00f6:  ldstr      "Edit Settings"
    IL_00fb:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.Control::set_Text(string)
    IL_0100:  nop
//000073:             this.ResumeLayout(false);
    IL_0101:  ldarg.0
    IL_0102:  ldc.i4.0
    IL_0103:  call       instance void [System.Windows.Forms]System.Windows.Forms.Control::ResumeLayout(bool)
    IL_0108:  nop
//000074: 
//000075: 		}
    IL_0109:  ret
  } // end of method EditSettings::InitializeComponent

  .method public hidebysig specialname instance class ParallelMorph.UiSettings 
          get_Settings() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  1
    .locals init ([0] class ParallelMorph.UiSettings CS$1$0000)
//000076: 		#endregion
//000077: 
//000078: 		// ==========================================================================================
//000079: 		// ==========================================================================================
//000080: 		// ==========================================================================================
//000081: 
//000082: 		/// <summary>Gets or sets the settings being edited.</summary>
//000083: 		public UiSettings Settings
//000084: 		{
//000085: 			get { return (UiSettings)pgSettings.SelectedObject; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0007:  callvirt   instance object [System.Windows.Forms]System.Windows.Forms.PropertyGrid::get_SelectedObject()
    IL_000c:  castclass  ParallelMorph.UiSettings
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method EditSettings::get_Settings

  .method public hidebysig specialname instance void 
          set_Settings(class ParallelMorph.UiSettings 'value') cil managed
  {
    // Code size       15 (0xf)
    .maxstack  8
//000086: 			set { pgSettings.SelectedObject = value; }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [System.Windows.Forms]System.Windows.Forms.PropertyGrid ParallelMorph.EditSettings::pgSettings
    IL_0007:  ldarg.1
    IL_0008:  callvirt   instance void [System.Windows.Forms]System.Windows.Forms.PropertyGrid::set_SelectedObject(object)
    IL_000d:  nop
    IL_000e:  ret
  } // end of method EditSettings::set_Settings

  .property instance class ParallelMorph.UiSettings
          Settings()
  {
    .get instance class ParallelMorph.UiSettings ParallelMorph.EditSettings::get_Settings()
    .set instance void ParallelMorph.EditSettings::set_Settings(class ParallelMorph.UiSettings)
  } // end of property EditSettings::Settings
} // end of class ParallelMorph.EditSettings

.class public auto ansi beforefieldinit ParallelMorph.AviImageWriter
       extends [mscorlib]System.Object
       implements ParallelMorph.IImageWriter,
                  [mscorlib]System.IDisposable
{
  .class sequential ansi sealed nested private beforefieldinit RECT
         extends [mscorlib]System.ValueType
  {
    .field public int32 left
    .field public int32 top
    .field public int32 right
    .field public int32 bottom
  } // end of class RECT

  .class sequential ansi sealed nested private beforefieldinit AVISTREAMINFOW
         extends [mscorlib]System.ValueType
  {
    .pack 1
    .size 0
    .field public uint32 fccType
    .field public uint32 fccHandler
    .field public uint32 dwFlags
    .field public uint32 dwCaps
    .field public uint16 wPriority
    .field public uint16 wLanguage
    .field public uint32 dwScale
    .field public uint32 dwRate
    .field public uint32 dwStart
    .field public uint32 dwLength
    .field public uint32 dwInitialFrames
    .field public uint32 dwSuggestedBufferSize
    .field public uint32 dwQuality
    .field public uint32 dwSampleSize
    .field public valuetype ParallelMorph.AviImageWriter/RECT rcFrame
    .field public uint32 dwEditCount
    .field public uint32 dwFormatChangeCount
    .field public  marshal( fixed sysstring [64]) string szName
  } // end of class AVISTREAMINFOW

  .class sequential ansi sealed nested private beforefieldinit AVICOMPRESSOPTIONS
         extends [mscorlib]System.ValueType
  {
    .pack 1
    .size 0
    .field public uint32 fccType
    .field public uint32 fccHandler
    .field public uint32 dwKeyFrameEvery
    .field public uint32 dwQuality
    .field public uint32 dwBytesPerSecond
    .field public uint32 dwFlags
    .field public native int lpFormat
    .field public uint32 cbFormat
    .field public native int lpParms
    .field public uint32 cbParms
    .field public uint32 dwInterleaveEvery
  } // end of class AVICOMPRESSOPTIONS

  .class sequential ansi sealed nested private beforefieldinit BITMAPINFOHEADER
         extends [mscorlib]System.ValueType
  {
    .pack 1
    .size 0
    .field public uint32 biSize
    .field public int32 biWidth
    .field public int32 biHeight
    .field public int16 biPlanes
    .field public int16 biBitCount
    .field public uint32 biCompression
    .field public uint32 biSizeImage
    .field public int32 biXPelsPerMeter
    .field public int32 biYPelsPerMeter
    .field public uint32 biClrUsed
    .field public uint32 biClrImportant
  } // end of class BITMAPINFOHEADER

  .class auto ansi sealed nested private AviErrors
         extends [mscorlib]System.Enum
  {
    .field public specialname rtspecialname uint32 value__
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors Unsupported = uint32(0x80044065)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BadFormat = uint32(0x80044066)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors Memory = uint32(0x80044067)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors Internal = uint32(0x80044068)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BadFlags = uint32(0x80044069)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BadParam = uint32(0x8004406A)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BadSize = uint32(0x8004406B)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BadHandle = uint32(0x8004406C)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors FileRead = uint32(0x8004406D)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors FileWrite = uint32(0x8004406E)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors FileOpen = uint32(0x8004406F)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors Compressor = uint32(0x80044070)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors NoCompressor = uint32(0x80044071)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors ReadOnly = uint32(0x80044072)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors NoData = uint32(0x80044073)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors BufferTooSmall = uint32(0x80044074)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors CanNotCompress = uint32(0x80044075)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors UserAbort = uint32(0x800440C6)
    .field public static literal valuetype ParallelMorph.AviImageWriter/AviErrors Error = uint32(0x800440C7)
  } // end of class AviErrors

  .field private static literal int32 AVI_OPEN_MODE_CREATEWRITE = int32(0x00001001)
  .field private native int _aviFile
  .field private native int _aviStream
  .field private int32 _frameCount
  .field private int32 _width
  .field private int32 _height
  .field private uint32 _stride
  .field private bool _disposed
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(string path,
                               int32 frameRate,
                               int32 width,
                               int32 height) cil managed
  {
    // Code size       647 (0x287)
    .maxstack  6
    .locals init ([0] uint32 fccType,
             [1] class [System.Drawing]System.Drawing.Bitmap bmp,
             [2] class [System.Drawing]System.Drawing.Imaging.BitmapData bmpData,
             [3] int32 rv,
             [4] valuetype ParallelMorph.AviImageWriter/AVISTREAMINFOW aviStreamInfo,
             [5] valuetype ParallelMorph.AviImageWriter/BITMAPINFOHEADER streamFormat,
             [6] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\OutputGeneration\AviImageWriter.cs' 
//000042: 		public AviImageWriter(string path, int frameRate, int width, int height)
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
//000043: 		{
    IL_0007:  nop
//000044: 			// Validate parameters
//000045: 			if (path == null) throw new ArgumentNullException("path");
    IL_0008:  ldarg.1
    IL_0009:  ldnull
    IL_000a:  ceq
    IL_000c:  ldc.i4.0
    IL_000d:  ceq
    IL_000f:  stloc.s    CS$4$0000
//000046: 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
//000047: 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
//000048: 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
//000049: 
//000050: 			// Store parameters
//000051: 			uint fccType = GetFourCc("vids");
//000052: 			_width = width;
//000053: 			_height = height;
//000054: 
//000055: 			_disposed = false;
//000056: 
//000057: 			// Get the stride information by creating a new bitmap and querying it
//000058: 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
//000059: 			{
//000060: 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000061: 				_stride = (uint)bmpData.Stride;
//000062: 				bmp.UnlockBits(bmpData);
//000063: 			}
//000064: 
//000065: 			try
//000066: 			{
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0011:  ldloc.s    CS$4$0000
    IL_0013:  brtrue.s   IL_0020

//000045: 			if (path == null) throw new ArgumentNullException("path");
    IL_0015:  ldstr      "path"
    IL_001a:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_001f:  throw

//000046: 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
    IL_0020:  ldarg.2
    IL_0021:  ldc.i4.0
    IL_0022:  cgt
    IL_0024:  stloc.s    CS$4$0000
//000047: 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
//000048: 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
//000049: 
//000050: 			// Store parameters
//000051: 			uint fccType = GetFourCc("vids");
//000052: 			_width = width;
//000053: 			_height = height;
//000054: 
//000055: 			_disposed = false;
//000056: 
//000057: 			// Get the stride information by creating a new bitmap and querying it
//000058: 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
//000059: 			{
//000060: 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000061: 				_stride = (uint)bmpData.Stride;
//000062: 				bmp.UnlockBits(bmpData);
//000063: 			}
//000064: 
//000065: 			try
//000066: 			{
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0026:  ldloc.s    CS$4$0000
    IL_0028:  brtrue.s   IL_0040

//000046: 			if (frameRate <= 0) throw new ArgumentOutOfRangeException("frameRate", frameRate, "The frame rate must be at least 1 frame per second.");
    IL_002a:  ldstr      "frameRate"
    IL_002f:  ldarg.2
    IL_0030:  box        [mscorlib]System.Int32
    IL_0035:  ldstr      "The frame rate must be at least 1 frame per second."
    IL_003a:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_003f:  throw

//000047: 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
    IL_0040:  ldarg.3
    IL_0041:  ldc.i4.0
    IL_0042:  cgt
    IL_0044:  stloc.s    CS$4$0000
//000048: 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
//000049: 
//000050: 			// Store parameters
//000051: 			uint fccType = GetFourCc("vids");
//000052: 			_width = width;
//000053: 			_height = height;
//000054: 
//000055: 			_disposed = false;
//000056: 
//000057: 			// Get the stride information by creating a new bitmap and querying it
//000058: 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
//000059: 			{
//000060: 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000061: 				_stride = (uint)bmpData.Stride;
//000062: 				bmp.UnlockBits(bmpData);
//000063: 			}
//000064: 
//000065: 			try
//000066: 			{
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0046:  ldloc.s    CS$4$0000
    IL_0048:  brtrue.s   IL_0060

//000047: 			if (width <= 0) throw new ArgumentOutOfRangeException("width", width, "The width must be at least 1.");
    IL_004a:  ldstr      "width"
    IL_004f:  ldarg.3
    IL_0050:  box        [mscorlib]System.Int32
    IL_0055:  ldstr      "The width must be at least 1."
    IL_005a:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_005f:  throw

//000048: 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
    IL_0060:  ldarg.s    height
    IL_0062:  ldc.i4.0
    IL_0063:  cgt
    IL_0065:  stloc.s    CS$4$0000
//000049: 
//000050: 			// Store parameters
//000051: 			uint fccType = GetFourCc("vids");
//000052: 			_width = width;
//000053: 			_height = height;
//000054: 
//000055: 			_disposed = false;
//000056: 
//000057: 			// Get the stride information by creating a new bitmap and querying it
//000058: 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
//000059: 			{
//000060: 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000061: 				_stride = (uint)bmpData.Stride;
//000062: 				bmp.UnlockBits(bmpData);
//000063: 			}
//000064: 
//000065: 			try
//000066: 			{
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0067:  ldloc.s    CS$4$0000
    IL_0069:  brtrue.s   IL_0082

//000048: 			if (height <= 0) throw new ArgumentOutOfRangeException("height", height, "The height must be at least 1.");
    IL_006b:  ldstr      "height"
    IL_0070:  ldarg.s    height
    IL_0072:  box        [mscorlib]System.Int32
    IL_0077:  ldstr      "The height must be at least 1."
    IL_007c:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0081:  throw

//000049: 
//000050: 			// Store parameters
//000051: 			uint fccType = GetFourCc("vids");
    IL_0082:  ldarg.0
    IL_0083:  ldstr      "vids"
    IL_0088:  call       instance uint32 ParallelMorph.AviImageWriter::GetFourCc(string)
    IL_008d:  stloc.0
//000052: 			_width = width;
    IL_008e:  ldarg.0
    IL_008f:  ldarg.3
    IL_0090:  stfld      int32 ParallelMorph.AviImageWriter::_width
//000053: 			_height = height;
    IL_0095:  ldarg.0
    IL_0096:  ldarg.s    height
    IL_0098:  stfld      int32 ParallelMorph.AviImageWriter::_height
//000054: 
//000055: 			_disposed = false;
    IL_009d:  ldarg.0
    IL_009e:  ldc.i4.0
    IL_009f:  stfld      bool ParallelMorph.AviImageWriter::_disposed
//000056: 
//000057: 			// Get the stride information by creating a new bitmap and querying it
//000058: 			using (Bitmap bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb))
    IL_00a4:  ldarg.3
    IL_00a5:  ldarg.s    height
    IL_00a7:  ldc.i4     0x21808
    IL_00ac:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32,
                                                                                    valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_00b1:  stloc.1
//000059: 			{
    .try
    {
      IL_00b2:  nop
//000060: 				BitmapData bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
      IL_00b3:  ldloc.1
      IL_00b4:  ldc.i4.0
      IL_00b5:  ldc.i4.0
      IL_00b6:  ldarg.3
      IL_00b7:  ldarg.s    height
      IL_00b9:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                         int32,
                                                                                         int32,
                                                                                         int32)
      IL_00be:  ldc.i4.1
      IL_00bf:  ldc.i4     0x21808
      IL_00c4:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_00c9:  stloc.2
//000061: 				_stride = (uint)bmpData.Stride;
      IL_00ca:  ldarg.0
      IL_00cb:  ldloc.2
      IL_00cc:  callvirt   instance int32 [System.Drawing]System.Drawing.Imaging.BitmapData::get_Stride()
      IL_00d1:  stfld      uint32 ParallelMorph.AviImageWriter::_stride
//000062: 				bmp.UnlockBits(bmpData);
      IL_00d6:  ldloc.1
      IL_00d7:  ldloc.2
      IL_00d8:  callvirt   instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
      IL_00dd:  nop
//000063: 			}
      IL_00de:  nop
//000064: 
//000065: 			try
//000066: 			{
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_00df:  leave.s    IL_00f3

    }  // end .try
    finally
    {
      IL_00e1:  ldloc.1
      IL_00e2:  ldnull
      IL_00e3:  ceq
      IL_00e5:  stloc.s    CS$4$0000
      IL_00e7:  ldloc.s    CS$4$0000
      IL_00e9:  brtrue.s   IL_00f2

      IL_00eb:  ldloc.1
      IL_00ec:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00f1:  nop
      IL_00f2:  endfinally
    }  // end handler
    IL_00f3:  nop
//000066: 			{
    .try
    {
      IL_00f4:  nop
//000067: 				// Initialize the AVI library
//000068: 				AVIFileInit();
      IL_00f5:  call       void ParallelMorph.AviImageWriter::AVIFileInit()
      IL_00fa:  nop
//000069: 
//000070: 				// Open the output AVI file
//000071: 				int rv = AVIFileOpenW(ref _aviFile, path, AVI_OPEN_MODE_CREATEWRITE, 0);
      IL_00fb:  ldarg.0
      IL_00fc:  ldflda     native int ParallelMorph.AviImageWriter::_aviFile
      IL_0101:  ldarg.1
      IL_0102:  ldc.i4     0x1001
      IL_0107:  ldc.i4.0
      IL_0108:  call       int32 ParallelMorph.AviImageWriter::AVIFileOpenW(native int&,
                                                                            string,
                                                                            int32,
                                                                            int32)
      IL_010d:  stloc.3
//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
      IL_010e:  ldloc.3
      IL_010f:  ldc.i4.0
      IL_0110:  ceq
      IL_0112:  stloc.s    CS$4$0000
//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
//000076: 				aviStreamInfo.fccType = fccType;
//000077: 				aviStreamInfo.fccHandler = 0;
//000078: 				aviStreamInfo.dwScale = 1;
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
//000082: 				aviStreamInfo.rcFrame = new RECT();
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
//000084: 				aviStreamInfo.rcFrame.right = _width;
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_0114:  ldloc.s    CS$4$0000
      IL_0116:  brtrue.s   IL_0129

//000072:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
      IL_0118:  ldloc.3
      IL_0119:  box        ParallelMorph.AviImageWriter/AviErrors
      IL_011e:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0123:  newobj     instance void [System]System.ComponentModel.Win32Exception::.ctor(string)
      IL_0128:  throw

//000073: 
//000074: 				// Create a new stream in the avi file
//000075: 				AVISTREAMINFOW aviStreamInfo = new AVISTREAMINFOW();
      IL_0129:  ldloca.s   aviStreamInfo
      IL_012b:  initobj    ParallelMorph.AviImageWriter/AVISTREAMINFOW
//000076: 				aviStreamInfo.fccType = fccType;
      IL_0131:  ldloca.s   aviStreamInfo
      IL_0133:  ldloc.0
      IL_0134:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::fccType
//000077: 				aviStreamInfo.fccHandler = 0;
      IL_0139:  ldloca.s   aviStreamInfo
      IL_013b:  ldc.i4.0
      IL_013c:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::fccHandler
//000078: 				aviStreamInfo.dwScale = 1;
      IL_0141:  ldloca.s   aviStreamInfo
      IL_0143:  ldc.i4.1
      IL_0144:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::dwScale
//000079: 				aviStreamInfo.dwRate = (uint)frameRate;
      IL_0149:  ldloca.s   aviStreamInfo
      IL_014b:  ldarg.2
      IL_014c:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::dwRate
//000080: 				aviStreamInfo.dwSuggestedBufferSize = (uint)(_height * _stride);
      IL_0151:  ldloca.s   aviStreamInfo
      IL_0153:  ldarg.0
      IL_0154:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_0159:  conv.i8
      IL_015a:  ldarg.0
      IL_015b:  ldfld      uint32 ParallelMorph.AviImageWriter::_stride
      IL_0160:  conv.u8
      IL_0161:  mul
      IL_0162:  conv.u4
      IL_0163:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::dwSuggestedBufferSize
//000081: 				aviStreamInfo.dwQuality = 0xffffffff;
      IL_0168:  ldloca.s   aviStreamInfo
      IL_016a:  ldc.i4.m1
      IL_016b:  stfld      uint32 ParallelMorph.AviImageWriter/AVISTREAMINFOW::dwQuality
//000082: 				aviStreamInfo.rcFrame = new RECT();
      IL_0170:  ldloca.s   aviStreamInfo
      IL_0172:  ldflda     valuetype ParallelMorph.AviImageWriter/RECT ParallelMorph.AviImageWriter/AVISTREAMINFOW::rcFrame
      IL_0177:  initobj    ParallelMorph.AviImageWriter/RECT
//000083: 				aviStreamInfo.rcFrame.bottom = _height;
      IL_017d:  ldloca.s   aviStreamInfo
      IL_017f:  ldflda     valuetype ParallelMorph.AviImageWriter/RECT ParallelMorph.AviImageWriter/AVISTREAMINFOW::rcFrame
      IL_0184:  ldarg.0
      IL_0185:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_018a:  stfld      int32 ParallelMorph.AviImageWriter/RECT::bottom
//000084: 				aviStreamInfo.rcFrame.right = _width;
      IL_018f:  ldloca.s   aviStreamInfo
      IL_0191:  ldflda     valuetype ParallelMorph.AviImageWriter/RECT ParallelMorph.AviImageWriter/AVISTREAMINFOW::rcFrame
      IL_0196:  ldarg.0
      IL_0197:  ldfld      int32 ParallelMorph.AviImageWriter::_width
      IL_019c:  stfld      int32 ParallelMorph.AviImageWriter/RECT::right
//000085: 
//000086: 				rv = AVIFileCreateStream(_aviFile, out _aviStream, ref aviStreamInfo);
      IL_01a1:  ldarg.0
      IL_01a2:  ldfld      native int ParallelMorph.AviImageWriter::_aviFile
      IL_01a7:  ldarg.0
      IL_01a8:  ldflda     native int ParallelMorph.AviImageWriter::_aviStream
      IL_01ad:  ldloca.s   aviStreamInfo
      IL_01af:  call       int32 ParallelMorph.AviImageWriter::AVIFileCreateStream(native int,
                                                                                   native int&,
                                                                                   valuetype ParallelMorph.AviImageWriter/AVISTREAMINFOW&)
      IL_01b4:  stloc.3
//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
      IL_01b5:  ldloc.3
      IL_01b6:  ldc.i4.0
      IL_01b7:  ceq
      IL_01b9:  stloc.s    CS$4$0000
//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
//000091: 				streamFormat.biSize      = 40;
//000092: 				streamFormat.biWidth     = _width;
//000093: 				streamFormat.biHeight    = _height;
//000094: 				streamFormat.biPlanes    = 1;
//000095: 				streamFormat.biBitCount  = 24;
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_01bb:  ldloc.s    CS$4$0000
      IL_01bd:  brtrue.s   IL_01d0

//000087: 				if(rv != 0) throw new Win32Exception(((AviErrors)rv).ToString());
      IL_01bf:  ldloc.3
      IL_01c0:  box        ParallelMorph.AviImageWriter/AviErrors
      IL_01c5:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_01ca:  newobj     instance void [System]System.ComponentModel.Win32Exception::.ctor(string)
      IL_01cf:  throw

//000088: 
//000089: 				// Configure the compressed stream
//000090: 				BITMAPINFOHEADER streamFormat = new BITMAPINFOHEADER();
      IL_01d0:  ldloca.s   streamFormat
      IL_01d2:  initobj    ParallelMorph.AviImageWriter/BITMAPINFOHEADER
//000091: 				streamFormat.biSize      = 40;
      IL_01d8:  ldloca.s   streamFormat
      IL_01da:  ldc.i4.s   40
      IL_01dc:  stfld      uint32 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biSize
//000092: 				streamFormat.biWidth     = _width;
      IL_01e1:  ldloca.s   streamFormat
      IL_01e3:  ldarg.0
      IL_01e4:  ldfld      int32 ParallelMorph.AviImageWriter::_width
      IL_01e9:  stfld      int32 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biWidth
//000093: 				streamFormat.biHeight    = _height;
      IL_01ee:  ldloca.s   streamFormat
      IL_01f0:  ldarg.0
      IL_01f1:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_01f6:  stfld      int32 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biHeight
//000094: 				streamFormat.biPlanes    = 1;
      IL_01fb:  ldloca.s   streamFormat
      IL_01fd:  ldc.i4.1
      IL_01fe:  stfld      int16 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biPlanes
//000095: 				streamFormat.biBitCount  = 24;
      IL_0203:  ldloca.s   streamFormat
      IL_0205:  ldc.i4.s   24
      IL_0207:  stfld      int16 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biBitCount
//000096: 				streamFormat.biSizeImage = (uint)(_stride * _height);
      IL_020c:  ldloca.s   streamFormat
      IL_020e:  ldarg.0
      IL_020f:  ldfld      uint32 ParallelMorph.AviImageWriter::_stride
      IL_0214:  conv.u8
      IL_0215:  ldarg.0
      IL_0216:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_021b:  conv.i8
      IL_021c:  mul
      IL_021d:  conv.u4
      IL_021e:  stfld      uint32 ParallelMorph.AviImageWriter/BITMAPINFOHEADER::biSizeImage
//000097: 
//000098:                 rv = AVIStreamSetFormat(_aviStream, 0, ref streamFormat, 40);
      IL_0223:  ldarg.0
      IL_0224:  ldfld      native int ParallelMorph.AviImageWriter::_aviStream
      IL_0229:  ldc.i4.0
      IL_022a:  ldloca.s   streamFormat
      IL_022c:  ldc.i4.s   40
      IL_022e:  call       int32 ParallelMorph.AviImageWriter::AVIStreamSetFormat(native int,
                                                                                  int32,
                                                                                  valuetype ParallelMorph.AviImageWriter/BITMAPINFOHEADER&,
                                                                                  int32)
      IL_0233:  stloc.3
//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
      IL_0234:  ldloc.3
      IL_0235:  ldc.i4.0
      IL_0236:  ceq
      IL_0238:  stloc.s    CS$4$0000
//000100: 			}
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_023a:  ldloc.s    CS$4$0000
      IL_023c:  brtrue.s   IL_024f

//000099:                 if (rv != 0) throw new Win32Exception(((AviErrors)rv).ToString()); //, "Unable to set the AVI stream format.");
      IL_023e:  ldloc.3
      IL_023f:  box        ParallelMorph.AviImageWriter/AviErrors
      IL_0244:  callvirt   instance string [mscorlib]System.Object::ToString()
      IL_0249:  newobj     instance void [System]System.ComponentModel.Win32Exception::.ctor(string)
      IL_024e:  throw

//000100: 			}
      IL_024f:  nop
//000101: 			catch
//000102: 			{
//000103: 				// Clean up
//000104: 				Dispose(false);
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_0250:  leave.s    IL_0284

//000101: 			catch
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_0252:  pop
//000102: 			{
      IL_0253:  nop
//000103: 				// Clean up
//000104: 				Dispose(false);
      IL_0254:  ldarg.0
      IL_0255:  ldc.i4.0
      IL_0256:  call       instance void ParallelMorph.AviImageWriter::Dispose(bool)
      IL_025b:  nop
//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
      .try
      {
        IL_025c:  nop
        IL_025d:  ldarg.1
        IL_025e:  brfalse.s  IL_026b

        IL_0260:  ldarg.1
        IL_0261:  call       bool [mscorlib]System.IO.File::Exists(string)
        IL_0266:  ldc.i4.0
        IL_0267:  ceq
        IL_0269:  br.s       IL_026c

        IL_026b:  ldc.i4.1
        IL_026c:  stloc.s    CS$4$0000
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_026e:  ldloc.s    CS$4$0000
        IL_0270:  brtrue.s   IL_0279

//000105: 				try { if (path != null && File.Exists(path)) File.Delete(path); }
        IL_0272:  ldarg.1
        IL_0273:  call       void [mscorlib]System.IO.File::Delete(string)
        IL_0278:  nop
        IL_0279:  nop
//000106: 				catch{}
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_027a:  leave.s    IL_0281

//000106: 				catch{}
      }  // end .try
      catch [mscorlib]System.Object 
      {
        IL_027c:  pop
        IL_027d:  nop
        IL_027e:  nop
//000107: 				throw;
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_027f:  leave.s    IL_0281

      }  // end handler
      IL_0281:  nop
//000107: 				throw;
      IL_0282:  rethrow
//000108: 			}
//000109: 		}
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    }  // end handler
    IL_0284:  nop
//000109: 		}
    IL_0285:  nop
    IL_0286:  ret
  } // end of method AviImageWriter::.ctor

  .method private hidebysig instance uint32 
          GetFourCc(string fcc) cil managed
  {
    // Code size       122 (0x7a)
    .maxstack  4
    .locals init ([0] uint32 CS$1$0000,
             [1] bool CS$4$0001)
//000110: 
//000111: 		private uint GetFourCc(string fcc)
//000112: 		{
    IL_0000:  nop
//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
    IL_0001:  ldarg.1
    IL_0002:  ldnull
    IL_0003:  ceq
    IL_0005:  ldc.i4.0
    IL_0006:  ceq
    IL_0008:  stloc.1
//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0009:  ldloc.1
    IL_000a:  brtrue.s   IL_0017

//000113:             if (fcc == null) throw new ArgumentNullException("fcc");
    IL_000c:  ldstr      "fcc"
    IL_0011:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0016:  throw

//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
    IL_0017:  ldarg.1
    IL_0018:  callvirt   instance int32 [mscorlib]System.String::get_Length()
    IL_001d:  ldc.i4.4
    IL_001e:  ceq
    IL_0020:  stloc.1
//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
//000116: 		}
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
//000121: 			Dispose(false);
//000122: 		}
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0021:  ldloc.1
    IL_0022:  brtrue.s   IL_0035

//000114: 			if (fcc.Length != 4) throw new ArgumentOutOfRangeException("fcc", fcc, "FOURCC codes must be four characters in length.");
    IL_0024:  ldstr      "fcc"
    IL_0029:  ldarg.1
    IL_002a:  ldstr      "FOURCC codes must be four characters in length."
    IL_002f:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string,
                                                                                           object,
                                                                                           string)
    IL_0034:  throw

//000115: 			return Convert.ToUInt32(Char.ToLower(fcc[0]) | Char.ToLower(fcc[1]) << 8 | Char.ToLower(fcc[2]) << 16 | Char.ToLower(fcc[3]) << 24);
    IL_0035:  ldarg.1
    IL_0036:  ldc.i4.0
    IL_0037:  callvirt   instance char [mscorlib]System.String::get_Chars(int32)
    IL_003c:  call       char [mscorlib]System.Char::ToLower(char)
    IL_0041:  ldarg.1
    IL_0042:  ldc.i4.1
    IL_0043:  callvirt   instance char [mscorlib]System.String::get_Chars(int32)
    IL_0048:  call       char [mscorlib]System.Char::ToLower(char)
    IL_004d:  ldc.i4.8
    IL_004e:  shl
    IL_004f:  or
    IL_0050:  ldarg.1
    IL_0051:  ldc.i4.2
    IL_0052:  callvirt   instance char [mscorlib]System.String::get_Chars(int32)
    IL_0057:  call       char [mscorlib]System.Char::ToLower(char)
    IL_005c:  ldc.i4.s   16
    IL_005e:  shl
    IL_005f:  or
    IL_0060:  ldarg.1
    IL_0061:  ldc.i4.3
    IL_0062:  callvirt   instance char [mscorlib]System.String::get_Chars(int32)
    IL_0067:  call       char [mscorlib]System.Char::ToLower(char)
    IL_006c:  ldc.i4.s   24
    IL_006e:  shl
    IL_006f:  or
    IL_0070:  call       uint32 [mscorlib]System.Convert::ToUInt32(int32)
    IL_0075:  stloc.0
    IL_0076:  br.s       IL_0078

//000116: 		}
    IL_0078:  ldloc.0
    IL_0079:  ret
  } // end of method AviImageWriter::GetFourCc

  .method family hidebysig virtual instance void 
          Finalize() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  2
//000117: 
//000118: 		/// <summary>Clean up the AviFile.</summary>
//000119: 		~AviImageWriter()
//000120: 		{
    .try
    {
      IL_0000:  nop
//000121: 			Dispose(false);
      IL_0001:  ldarg.0
      IL_0002:  ldc.i4.0
      IL_0003:  call       instance void ParallelMorph.AviImageWriter::Dispose(bool)
      IL_0008:  nop
//000122: 		}
      IL_0009:  nop
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_000a:  leave.s    IL_0014

//000122: 		}
    }  // end .try
    finally
    {
      IL_000c:  ldarg.0
      IL_000d:  call       instance void [mscorlib]System.Object::Finalize()
      IL_0012:  nop
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
//000128: 			if (!_disposed)
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_0013:  endfinally
    }  // end handler
    IL_0014:  nop
//000122: 		}
    IL_0015:  ret
  } // end of method AviImageWriter::Finalize

  .method family hidebysig instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       138 (0x8a)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000123: 
//000124: 		/// <summary>Clean up the AviFile.</summary>
//000125: 		/// <param name="disposing">Whether this is being called from Dispose or from the finalizer.</param>
//000126: 		protected void Dispose(bool disposing)
//000127: 		{
    IL_0000:  nop
//000128: 			if (!_disposed)
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool ParallelMorph.AviImageWriter::_disposed
    IL_0007:  stloc.0
//000129: 			{
//000130: 				_disposed = true;
//000131:                 if (disposing) GC.SuppressFinalize(this);
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0008:  ldloc.0
    IL_0009:  brtrue.s   IL_0089

//000129: 			{
    IL_000b:  nop
//000130: 				_disposed = true;
    IL_000c:  ldarg.0
    IL_000d:  ldc.i4.1
    IL_000e:  stfld      bool ParallelMorph.AviImageWriter::_disposed
//000131:                 if (disposing) GC.SuppressFinalize(this);
    IL_0013:  ldarg.1
    IL_0014:  ldc.i4.0
    IL_0015:  ceq
    IL_0017:  stloc.0
//000132: 				if (_aviStream != IntPtr.Zero)
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0018:  ldloc.0
    IL_0019:  brtrue.s   IL_0022

//000131:                 if (disposing) GC.SuppressFinalize(this);
    IL_001b:  ldarg.0
    IL_001c:  call       void [mscorlib]System.GC::SuppressFinalize(object)
    IL_0021:  nop
//000132: 				if (_aviStream != IntPtr.Zero)
    IL_0022:  ldarg.0
    IL_0023:  ldfld      native int ParallelMorph.AviImageWriter::_aviStream
    IL_0028:  ldsfld     native int [mscorlib]System.IntPtr::Zero
    IL_002d:  call       bool [mscorlib]System.IntPtr::op_Inequality(native int,
                                                                     native int)
    IL_0032:  ldc.i4.0
    IL_0033:  ceq
    IL_0035:  stloc.0
//000133: 				{
//000134: 					AVIStreamRelease(_aviStream);
//000135: 					_aviStream = IntPtr.Zero;
//000136: 				}
//000137: 				if (_aviFile != IntPtr.Zero) 
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0036:  ldloc.0
    IL_0037:  brtrue.s   IL_0052

//000133: 				{
    IL_0039:  nop
//000134: 					AVIStreamRelease(_aviStream);
    IL_003a:  ldarg.0
    IL_003b:  ldfld      native int ParallelMorph.AviImageWriter::_aviStream
    IL_0040:  call       int32 ParallelMorph.AviImageWriter::AVIStreamRelease(native int)
    IL_0045:  pop
//000135: 					_aviStream = IntPtr.Zero;
    IL_0046:  ldarg.0
    IL_0047:  ldsfld     native int [mscorlib]System.IntPtr::Zero
    IL_004c:  stfld      native int ParallelMorph.AviImageWriter::_aviStream
//000136: 				}
    IL_0051:  nop
//000137: 				if (_aviFile != IntPtr.Zero) 
    IL_0052:  ldarg.0
    IL_0053:  ldfld      native int ParallelMorph.AviImageWriter::_aviFile
    IL_0058:  ldsfld     native int [mscorlib]System.IntPtr::Zero
    IL_005d:  call       bool [mscorlib]System.IntPtr::op_Inequality(native int,
                                                                     native int)
    IL_0062:  ldc.i4.0
    IL_0063:  ceq
    IL_0065:  stloc.0
//000138: 				{
//000139: 					AVIFileRelease(_aviFile);
//000140:                     _aviFile = IntPtr.Zero;
//000141: 				}
//000142: 				AVIFileExit();
//000143: 			}
//000144: 		}
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0066:  ldloc.0
    IL_0067:  brtrue.s   IL_0082

//000138: 				{
    IL_0069:  nop
//000139: 					AVIFileRelease(_aviFile);
    IL_006a:  ldarg.0
    IL_006b:  ldfld      native int ParallelMorph.AviImageWriter::_aviFile
    IL_0070:  call       int32 ParallelMorph.AviImageWriter::AVIFileRelease(native int)
    IL_0075:  pop
//000140:                     _aviFile = IntPtr.Zero;
    IL_0076:  ldarg.0
    IL_0077:  ldsfld     native int [mscorlib]System.IntPtr::Zero
    IL_007c:  stfld      native int ParallelMorph.AviImageWriter::_aviFile
//000141: 				}
    IL_0081:  nop
//000142: 				AVIFileExit();
    IL_0082:  call       void ParallelMorph.AviImageWriter::AVIFileExit()
    IL_0087:  nop
//000143: 			}
    IL_0088:  nop
//000144: 		}
    IL_0089:  ret
  } // end of method AviImageWriter::Dispose

  .method public hidebysig newslot virtual final 
          instance void  Dispose() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000145: 
//000146: 		/// <summary>Clean up the AviFile.</summary>
//000147: 		public void Dispose() { Dispose(true); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4.1
    IL_0003:  call       instance void ParallelMorph.AviImageWriter::Dispose(bool)
    IL_0008:  nop
    IL_0009:  ret
  } // end of method AviImageWriter::Dispose

  .method public hidebysig newslot virtual final 
          instance void  AddFrame(class [System.Drawing]System.Drawing.Bitmap frame) cil managed
  {
    // Code size       268 (0x10c)
    .maxstack  8
    .locals init ([0] class [System.Drawing]System.Drawing.Imaging.BitmapData frameData,
             [1] int32 rv,
             [2] bool CS$4$0000)
//000148: 
//000149: 		/// <summary>Adds a Bitmap to the end of the AviFile video sequence.</summary>
//000150: 		/// <param name="frame">The frame to be added.</param>
//000151: 		public void AddFrame(Bitmap frame)
//000152: 		{
    IL_0000:  nop
//000153: 			// Validate the bitmap
//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool ParallelMorph.AviImageWriter::_disposed
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  stloc.2
//000155: 			if (frame == null) throw new ArgumentNullException("frame");
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_000b:  ldloc.2
    IL_000c:  brtrue.s   IL_001f

//000154: 			if (_disposed) throw new ObjectDisposedException(GetType().Name);
    IL_000e:  ldarg.0
    IL_000f:  call       instance class [mscorlib]System.Type [mscorlib]System.Object::GetType()
    IL_0014:  callvirt   instance string [mscorlib]System.Reflection.MemberInfo::get_Name()
    IL_0019:  newobj     instance void [mscorlib]System.ObjectDisposedException::.ctor(string)
    IL_001e:  throw

//000155: 			if (frame == null) throw new ArgumentNullException("frame");
    IL_001f:  ldarg.1
    IL_0020:  ldnull
    IL_0021:  ceq
    IL_0023:  ldc.i4.0
    IL_0024:  ceq
    IL_0026:  stloc.2
//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0027:  ldloc.2
    IL_0028:  brtrue.s   IL_0035

//000155: 			if (frame == null) throw new ArgumentNullException("frame");
    IL_002a:  ldstr      "frame"
    IL_002f:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_0034:  throw

//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
    IL_0035:  ldarg.1
    IL_0036:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_003b:  ldarg.0
    IL_003c:  ldfld      int32 ParallelMorph.AviImageWriter::_width
    IL_0041:  bne.un.s   IL_0053

    IL_0043:  ldarg.1
    IL_0044:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0049:  ldarg.0
    IL_004a:  ldfld      int32 ParallelMorph.AviImageWriter::_height
    IL_004f:  ceq
    IL_0051:  br.s       IL_0054

    IL_0053:  ldc.i4.0
    IL_0054:  stloc.2
//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
//000160: 			BitmapData frameData = null;
//000161: 			try
//000162: 			{
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    IL_0055:  ldloc.2
    IL_0056:  brtrue.s   IL_0068

//000156: 			if (frame.Width != _width || frame.Height != _height) throw new ArgumentException("The frame bitmap is the incorrect size for this video.", "frame");
    IL_0058:  ldstr      "The frame bitmap is the incorrect size for this vi"
    + "deo."
    IL_005d:  ldstr      "frame"
    IL_0062:  newobj     instance void [mscorlib]System.ArgumentException::.ctor(string,
                                                                                 string)
    IL_0067:  throw

//000157: 
//000158: 			// Write the frame to the file
//000159: 			frame.RotateFlip(RotateFlipType.RotateNoneFlipY);
    IL_0068:  ldarg.1
    IL_0069:  ldc.i4.6
    IL_006a:  callvirt   instance void [System.Drawing]System.Drawing.Image::RotateFlip(valuetype [System.Drawing]System.Drawing.RotateFlipType)
    IL_006f:  nop
//000160: 			BitmapData frameData = null;
    IL_0070:  ldnull
    IL_0071:  stloc.0
//000161: 			try
//000162: 			{
    .try
    {
      IL_0072:  nop
//000163: 				frameData = frame.LockBits(new Rectangle(0, 0, _width, _height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
      IL_0073:  ldarg.1
      IL_0074:  ldc.i4.0
      IL_0075:  ldc.i4.0
      IL_0076:  ldarg.0
      IL_0077:  ldfld      int32 ParallelMorph.AviImageWriter::_width
      IL_007c:  ldarg.0
      IL_007d:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_0082:  newobj     instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                         int32,
                                                                                         int32,
                                                                                         int32)
      IL_0087:  ldc.i4.1
      IL_0088:  ldc.i4     0x21808
      IL_008d:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                            valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
      IL_0092:  stloc.0
//000164: 				int rv = AVIStreamWrite(_aviStream, _frameCount, 1, frameData.Scan0, (int)(_stride * _height), 0, IntPtr.Zero, IntPtr.Zero);
      IL_0093:  ldarg.0
      IL_0094:  ldfld      native int ParallelMorph.AviImageWriter::_aviStream
      IL_0099:  ldarg.0
      IL_009a:  ldfld      int32 ParallelMorph.AviImageWriter::_frameCount
      IL_009f:  ldc.i4.1
      IL_00a0:  ldloc.0
      IL_00a1:  callvirt   instance native int [System.Drawing]System.Drawing.Imaging.BitmapData::get_Scan0()
      IL_00a6:  ldarg.0
      IL_00a7:  ldfld      uint32 ParallelMorph.AviImageWriter::_stride
      IL_00ac:  conv.u8
      IL_00ad:  ldarg.0
      IL_00ae:  ldfld      int32 ParallelMorph.AviImageWriter::_height
      IL_00b3:  conv.i8
      IL_00b4:  mul
      IL_00b5:  conv.i4
      IL_00b6:  ldc.i4.0
      IL_00b7:  ldsfld     native int [mscorlib]System.IntPtr::Zero
      IL_00bc:  ldsfld     native int [mscorlib]System.IntPtr::Zero
      IL_00c1:  call       int32 ParallelMorph.AviImageWriter::AVIStreamWrite(native int,
                                                                              int32,
                                                                              int32,
                                                                              native int,
                                                                              int32,
                                                                              int32,
                                                                              native int,
                                                                              native int)
      IL_00c6:  stloc.1
//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
      IL_00c7:  ldloc.1
      IL_00c8:  ldc.i4.0
      IL_00c9:  ceq
      IL_00cb:  stloc.2
//000166: 			} 
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_00cc:  ldloc.2
      IL_00cd:  brtrue.s   IL_00db

//000165: 				if(rv != 0) throw new Win32Exception(rv, "Unable to write the frame to the AVI.");
      IL_00cf:  ldloc.1
      IL_00d0:  ldstr      "Unable to write the frame to the AVI."
      IL_00d5:  newobj     instance void [System]System.ComponentModel.Win32Exception::.ctor(int32,
                                                                                             string)
      IL_00da:  throw

//000166: 			} 
      IL_00db:  nop
//000167: 			catch
//000168: 			{
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
      IL_00dc:  leave.s    IL_00fc

//000167: 			catch
    }  // end .try
    catch [mscorlib]System.Object 
    {
      IL_00de:  pop
//000168: 			{
      IL_00df:  nop
//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
      .try
      {
        IL_00e0:  nop
        IL_00e1:  ldloc.0
        IL_00e2:  ldnull
        IL_00e3:  ceq
        IL_00e5:  stloc.2
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_00e6:  ldloc.2
        IL_00e7:  brtrue.s   IL_00f1

//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
        IL_00e9:  ldarg.1
        IL_00ea:  ldloc.0
        IL_00eb:  callvirt   instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
        IL_00f0:  nop
        IL_00f1:  nop
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_00f2:  leave.s    IL_00f9

//000169: 				try { if (frameData != null) frame.UnlockBits(frameData); } catch{}
      }  // end .try
      catch [mscorlib]System.Object 
      {
        IL_00f4:  pop
        IL_00f5:  nop
        IL_00f6:  nop
//000170: 				throw;
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
        IL_00f7:  leave.s    IL_00f9

      }  // end handler
      IL_00f9:  nop
//000170: 				throw;
      IL_00fa:  rethrow
//000171: 			}
//000172: 			_frameCount++;
//000173: 		}
//000174: 
//000175: 		/// <summary>The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.</summary>
//000176: 		[StructLayout(LayoutKind.Sequential)]
//000177: 		private struct RECT
//000178: 		{
//000179: 			/// <summary>Specifies the x-coordinate of the upper-left corner of the rectangle.</summary>
//000180: 			public int left;
//000181: 			/// <summary>Specifies the y-coordinate of the upper-left corner of the rectangle.</summary>
//000182: 			public int top;
//000183: 			/// <summary>Specifies the x-coordinate of the lower-right corner of the rectangle.</summary>
//000184: 			public int right;
//000185: 			/// <summary>Specifies the y-coordinate of the lower-right corner of the rectangle.</summary>
//000186: 			public int bottom;
//000187: 		}
//000188: 
//000189: 		/// <summary>The AVISTREAMINFO structure contains information for a single stream.</summary>
//000190: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000191: 		private struct AVISTREAMINFOW 
//000192: 		{
//000193: 			/// <summary>Four-character code indicating the stream type.</summary>
//000194: 			public UInt32 fccType;
//000195: 			/// <summary>Four-character code of the compressor handler that will compress this video stream when it is saved.</summary>
//000196: 			public UInt32 fccHandler;
//000197: 			/// <summary>Applicable flags for the stream.</summary>
//000198: 			public UInt32 dwFlags;
//000199: 			/// <summary>Capability flags; currently unused.</summary>
//000200: 			public UInt32 dwCaps;
//000201: 			/// <summary>Priority of the stream.</summary>
//000202: 			public UInt16 wPriority;
//000203: 			/// <summary>Language of the stream.</summary>
//000204: 			public UInt16 wLanguage;
//000205: 			/// <summary>Time scale applicable for the stream.</summary>
//000206: 			public UInt32 dwScale;
//000207: 			/// <summary>Rate in an integer format.</summary>
//000208: 			public UInt32 dwRate;
//000209: 			/// <summary>Sample number of the first frame of the AVI file.</summary>
//000210: 			public UInt32 dwStart;
//000211: 			/// <summary>Length of this stream.</summary>
//000212: 			public UInt32 dwLength;
//000213: 			/// <summary>Audio skew.  Specifies how much to skew the audio data ahead of the video frames in interleaved files.</summary>
//000214: 			public UInt32 dwInitialFrames;
//000215: 			/// <summary>Recommended buffer size, in bytes, for the stream.</summary>
//000216: 			public UInt32 dwSuggestedBufferSize;
//000217: 			/// <summary>Quality indicator of the video data in the stream. Quality is represented as a number between 0 and 10,000.</summary>
//000218: 			public UInt32 dwQuality;
//000219: 			/// <summary>Size, in bytes, of a single data sample.</summary>
//000220: 			public UInt32 dwSampleSize;
//000221: 			/// <summary>Dimensions of the video destination rectangle.</summary>
//000222: 			public RECT rcFrame;
//000223: 			/// <summary>Number of times the stream has been edited.</summary>
//000224: 			public UInt32 dwEditCount;
//000225: 			/// <summary>Number of times the stream format has changed.</summary>
//000226: 			public UInt32 dwFormatChangeCount;
//000227:             /// <summary>Null-terminated string containing a description of the stream.</summary>
//000228:             [MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)] 
//000229:             public String szName;
//000230: 		}
//000231: 
//000232: 		/// <summary>The AVICOMPRESSOPTIONS structure contains information about a stream and how it is compressed and saved.</summary>
//000233: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000234: 		private struct AVICOMPRESSOPTIONS 
//000235: 		{
//000236: 			/// <summary>Four-character code indicating the stream type.</summary>
//000237: 			public uint fccType;
//000238: 			/// <summary>Four-character code for the compressor handler that will compress this video stream when it is saved.</summary>
//000239: 			public uint fccHandler;
//000240: 			/// <summary>Maximum period between video key frames.</summary>
//000241: 			public uint dwKeyFrameEvery;
//000242: 			/// <summary>Quality value passed to a video compressor.</summary>
//000243: 			public uint dwQuality;
//000244: 			/// <summary>Video compressor data rate.</summary>
//000245: 			public uint dwBytesPerSecond;
//000246: 			/// <summary>Flags used for compression.</summary>
//000247: 			public uint dwFlags;
//000248: 			/// <summary>Pointer to a structure defining the data format.</summary>
//000249: 			public IntPtr lpFormat;
//000250: 			/// <summary>Size, in bytes, of the data referenced by lpFormat.</summary>
//000251: 			public uint cbFormat;
//000252: 			/// <summary>Video-compressor-specific data; used internally.</summary>
//000253: 			public IntPtr lpParms;
//000254: 			/// <summary>Size, in bytes, of the data referenced by lpParms.</summary>
//000255: 			public uint cbParms;
//000256: 			/// <summary>Interleave factor for interspersing stream data with data from the first stream.</summary>
//000257: 			public uint dwInterleaveEvery;
//000258: 		}
//000259: 
//000260: 		/// <summary>The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB.</summary>
//000261: 		[StructLayout(LayoutKind.Sequential, Pack=1)]
//000262: 		private struct BITMAPINFOHEADER 
//000263: 		{
//000264: 			/// <summary>Specifies the number of bytes required by the structure.</summary>
//000265: 			public uint biSize;
//000266: 			/// <summary>Specifies the width of the bitmap, in pixels.</summary>
//000267: 			public int biWidth;
//000268: 			/// <summary>Specifies the height of the bitmap, in pixels.</summary>
//000269: 			public int biHeight;
//000270: 			/// <summary>Specifies the number of planes for the target device. This value must be set to 1.</summary>
//000271: 			public short biPlanes;
//000272: 			/// <summary>Specifies the number of bits-per-pixel.</summary>
//000273: 			public short biBitCount;
//000274: 			/// <summary>Specifies the type of compression for a compressed bottom-up bitmap.</summary>
//000275: 			public uint biCompression;
//000276: 			/// <summary>Specifies the size, in bytes, of the image.</summary>
//000277: 			public uint biSizeImage;
//000278: 			/// <summary>Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000279: 			public int biXPelsPerMeter;
//000280: 			/// <summary>Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap.</summary>
//000281: 			public int biYPelsPerMeter;
//000282: 			/// <summary>Specifies the number of color indexes in the color table that are actually used by the bitmap.</summary>
//000283: 			public uint biClrUsed;
//000284: 			/// <summary>Specifies the number of color indexes that are required for displaying the bitmap.</summary>
//000285: 			public uint biClrImportant;
//000286: 		}
//000287: 
//000288: 		/// <summary>Open mode value for AVIs to create and write to the file.</summary>
//000289: 		private const int AVI_OPEN_MODE_CREATEWRITE = 0x00001000 | 0x00000001;
//000290: 
//000291: 		/// <summary>The AVIFileInit function initializes the AVIFile library.</summary>
//000292: 		[DllImport("avifil32.dll")]
//000293: 		private static extern void AVIFileInit();
//000294: 
//000295: 		/// <summary>The AVIFileOpen function opens an AVI file and returns the address of a file interface used to access it.</summary>
//000296: 		/// <param name="ppfile">Pointer to a buffer that receives the new IAVIFile interface pointer.</param>
//000297: 		/// <param name="szFile">Null-terminated string containing the name of the file to open.</param>
//000298: 		/// <param name="uMode">Access mode to use when opening the file.</param>
//000299: 		/// <param name="pclsidHandler">Pointer to a class identifier of the standard or custom handler you want to use.</param>
//000300: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000301: 		[DllImport("avifil32.dll")]
//000302:         private static extern int AVIFileOpenW(ref IntPtr ppfile, [MarshalAs(UnmanagedType.LPTStr)]string szFile, int uMode, int pclsidHandler);
//000303: 
//000304: 		/// <summary>The AVIFileCreateStream function creates a new stream in an existing file and creates an interface to the new stream.</summary>
//000305: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000306: 		/// <param name="ppavi">Pointer to the new stream interface.</param>
//000307: 		/// <param name="psi">Pointer to a structure containing information about the new stream, including the stream type and its sample rate.</param>
//000308: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000309: 		[DllImport("avifil32.dll")]
//000310:         private static extern int AVIFileCreateStream(IntPtr pfile, out IntPtr ppavi, ref AVISTREAMINFOW psi); 
//000311: 
//000312: 		/// <summary>The AVIMakeCompressedStream function creates a compressed stream from an uncompressed stream and a compression filter, and returns the address of a pointer to the compressed stream.</summary>
//000313: 		/// <param name="ppsCompressed">Pointer to a buffer that receives the compressed stream pointer.</param>
//000314: 		/// <param name="ppsSource">Pointer to the stream to be compressed.</param>
//000315: 		/// <param name="lpOptions">Pointer to a structure that identifies the type of compression to use and the options to apply.</param>
//000316: 		/// <param name="pclsidHandler">Pointer to a class identifier used to create the stream.</param>
//000317: 		/// <returns></returns>
//000318: 		[DllImport("avifil32.dll")]
//000319: 		private static extern int AVIMakeCompressedStream(out IntPtr ppsCompressed, IntPtr ppsSource, ref AVICOMPRESSOPTIONS lpOptions, int pclsidHandler);
//000320: 
//000321: 		/// <summary>The AVIStreamSetFormat function sets the format of a stream at the specified position.</summary>
//000322: 		/// <param name="pavi">Handle to an open stream.</param>
//000323: 		/// <param name="lPos">Position in the stream to receive the format.</param>
//000324: 		/// <param name="lpFormat">Pointer to a structure containing the new format.</param>
//000325: 		/// <param name="cbFormat">Pointer to a structure containing the new format.</param>
//000326: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000327: 		[DllImport("avifil32.dll")]
//000328: 		private static extern int AVIStreamSetFormat(IntPtr pavi, Int32 lPos, ref BITMAPINFOHEADER lpFormat, Int32 cbFormat);
//000329: 
//000330: 		/// <summary>The AVIStreamWrite function writes data to a stream.</summary>
//000331: 		/// <param name="pavi">Handle to an open stream.</param>
//000332: 		/// <param name="lStart">First sample to write.</param>
//000333: 		/// <param name="lSamples">Number of samples to write.</param>
//000334: 		/// <param name="lpBuffer">Pointer to a buffer containing the data to write.</param>
//000335: 		/// <param name="cbBuffer">Size of the buffer referenced by lpBuffer.</param>
//000336: 		/// <param name="dwFlags">Flag associated with this data.</param>
//000337: 		/// <param name="plSampWritten">Pointer to a buffer that receives the number of samples written.</param>
//000338: 		/// <param name="plBytesWritten">Pointer to a buffer that receives the number of bytes written.</param>
//000339: 		/// <returns>Returns zero if successful or an error otherwise.</returns>
//000340: 		[DllImport("avifil32.dll")]
//000341:         private static extern int AVIStreamWrite(IntPtr pavi, Int32 lStart, Int32 lSamples, IntPtr lpBuffer, Int32 cbBuffer, Int32 dwFlags, IntPtr plSampWritten, IntPtr plBytesWritten);
//000342: 
//000343: 		/// <summary>The AVIStreamRelease function decrements the reference count of an AVI stream interface handle, and closes the stream if the count reaches zero.</summary>
//000344: 		/// <param name="pavi">Handle to an open stream.</param>
//000345: 		/// <returns>Returns the current reference count of the stream.</returns>
//000346: 		[DllImport("avifil32.dll")]
//000347: 		private static extern int AVIStreamRelease(IntPtr pavi);
//000348: 
//000349: 		/// <summary>The AVIFileRelease function decrements the reference count of an AVI file interface handle and closes the file if the count reaches zero.</summary>
//000350: 		/// <param name="pfile">Handle to an open AVI file.</param>
//000351: 		/// <returns>Returns the reference count of the file.</returns>
//000352: 		[DllImport("avifil32.dll")]
//000353:         private static extern int AVIFileRelease(IntPtr pfile);
//000354: 
//000355: 		/// <summary>The AVIFileExit function exits the AVIFile library and decrements the reference count for the library.</summary>
//000356: 		[DllImport("avifil32.dll")]
//000357: 		private static extern void AVIFileExit();
//000358: 
//000359:         /// <summary>AVI error codes</summary>
//000360:         private enum AviErrors : uint
//000361:         {
//000362:             Unsupported = 0x80044065,
//000363:             BadFormat = 0x80044066,
//000364:             Memory = 0x80044067,
//000365:             Internal = 0x80044068,
//000366:             BadFlags = 0x80044069,
//000367:             BadParam = 0x8004406A,
//000368:             BadSize = 0x8004406B,
//000369:             BadHandle = 0x8004406C,
//000370:             FileRead = 0x8004406D,
//000371:             FileWrite = 0x8004406E,
//000372:             FileOpen = 0x8004406F,
//000373:             Compressor = 0x80044070,
//000374:             NoCompressor = 0x80044071,
//000375:             ReadOnly = 0x80044072,
//000376:             NoData = 0x80044073,
//000377:             BufferTooSmall = 0x80044074,
//000378:             CanNotCompress = 0x80044075,
//000379:             UserAbort = 0x800440C6,
//000380:             Error = 0x800440C7
//000381:         }
//000382: 	}
//000383: }
    }  // end handler
    IL_00fc:  nop
//000172: 			_frameCount++;
    IL_00fd:  ldarg.0
    IL_00fe:  dup
    IL_00ff:  ldfld      int32 ParallelMorph.AviImageWriter::_frameCount
    IL_0104:  ldc.i4.1
    IL_0105:  add
    IL_0106:  stfld      int32 ParallelMorph.AviImageWriter::_frameCount
//000173: 		}
    IL_010b:  ret
  } // end of method AviImageWriter::AddFrame

  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          void  AVIFileInit() cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIFileOpenW(native int& ppfile,
                              string  marshal( lptstr) szFile,
                              int32 uMode,
                              int32 pclsidHandler) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIFileCreateStream(native int pfile,
                                     [out] native int& ppavi,
                                     valuetype ParallelMorph.AviImageWriter/AVISTREAMINFOW& psi) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIMakeCompressedStream([out] native int& ppsCompressed,
                                         native int ppsSource,
                                         valuetype ParallelMorph.AviImageWriter/AVICOMPRESSOPTIONS& lpOptions,
                                         int32 pclsidHandler) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIStreamSetFormat(native int pavi,
                                    int32 lPos,
                                    valuetype ParallelMorph.AviImageWriter/BITMAPINFOHEADER& lpFormat,
                                    int32 cbFormat) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIStreamWrite(native int pavi,
                                int32 lStart,
                                int32 lSamples,
                                native int lpBuffer,
                                int32 cbBuffer,
                                int32 dwFlags,
                                native int plSampWritten,
                                native int plBytesWritten) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIStreamRelease(native int pavi) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          int32  AVIFileRelease(native int pfile) cil managed preservesig
  {
  }
  .method private hidebysig static pinvokeimpl("avifil32.dll" winapi) 
          void  AVIFileExit() cil managed preservesig
  {
  }
} // end of class ParallelMorph.AviImageWriter

.class public abstract auto ansi sealed beforefieldinit ParallelMorph.Utilities
       extends [mscorlib]System.Object
{
  .custom instance void [System.Core]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig static !!T  DeepClone<class T>(!!T source) cil managed
  {
    // Code size       71 (0x47)
    .maxstack  3
    .locals init ([0] class [mscorlib]System.IO.MemoryStream ms,
             [1] class [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter formatter,
             [2] !!T CS$1$0000,
             [3] bool CS$4$0001)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Utilities.cs' 
//000025:         {
    IL_0000:  nop
//000026:             using (MemoryStream ms = new MemoryStream())
    IL_0001:  newobj     instance void [mscorlib]System.IO.MemoryStream::.ctor()
    IL_0006:  stloc.0
//000027:             {
    .try
    {
      IL_0007:  nop
//000028:                 var formatter = new BinaryFormatter();
      IL_0008:  newobj     instance void [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::.ctor()
      IL_000d:  stloc.1
//000029:                 formatter.Serialize(ms, source);
      IL_000e:  ldloc.1
      IL_000f:  ldloc.0
      IL_0010:  ldarg.0
      IL_0011:  box        !!T
      IL_0016:  callvirt   instance void [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::Serialize(class [mscorlib]System.IO.Stream,
                                                                                                                             object)
      IL_001b:  nop
//000030:                 ms.Position = 0;
      IL_001c:  ldloc.0
      IL_001d:  ldc.i4.0
      IL_001e:  conv.i8
      IL_001f:  callvirt   instance void [mscorlib]System.IO.Stream::set_Position(int64)
      IL_0024:  nop
//000031:                 return (T)formatter.Deserialize(ms);
      IL_0025:  ldloc.1
      IL_0026:  ldloc.0
      IL_0027:  callvirt   instance object [mscorlib]System.Runtime.Serialization.Formatters.Binary.BinaryFormatter::Deserialize(class [mscorlib]System.IO.Stream)
      IL_002c:  unbox.any  !!T
      IL_0031:  stloc.2
      IL_0032:  leave.s    IL_0044

//000032:             }
//000033:         }
//000034: 
//000035:         /// <summary>Clones an image into a new Bitmap.</summary>
//000036:         /// <param name="source">The source image.</param>
//000037:         /// <returns>The new Bitmap.</returns>
//000038:         public static Bitmap CreateNewBitmapFrom(Image source) 
//000039:         { 
//000040:             return CreateNewBitmapFrom(source, 1); 
//000041:         }
//000042: 
//000043:         /// <summary>Creates a copy of the source image by scaling it with the specified scale value.</summary>
//000044:         /// <param name="source">The source image.</param>
//000045:         /// <param name="scalingFactor">The scaling factor to use when generating the target image.</param>
//000046:         /// <returns>The new Bitmap.</returns>
//000047:         public static Bitmap CreateNewBitmapFrom(Image source, float scalingFactor)
//000048:         {
//000049:             return CreateNewBitmapFrom(source, (int)(source.Width*scalingFactor), (int)(source.Height*scalingFactor));
//000050:         }
//000051: 
//000052:         /// <summary>Creates a copy of the source image using the specified target width and height.</summary>
//000053:         /// <param name="source">The source image.</param>
//000054:         /// <param name="targetWidth">The target width for the generated image.</param>
//000055:         /// <param name="targetHeight">The target height for the generated image.</param>
//000056:         /// <returns>The new Bitmap.</returns>
//000057:         public static Bitmap CreateNewBitmapFrom(Image source, int targetWidth, int targetHeight)
//000058:         {
//000059:             var newBmp = new Bitmap(targetWidth, targetHeight, PixelFormat.Format32bppArgb);
//000060:             using (var g = Graphics.FromImage(newBmp)) g.DrawImage(source, 0, 0, newBmp.Width, newBmp.Height);
//000061:             return newBmp;
//000062:         }
//000063: 
//000064:         /// <summary>Retrieves an element from a Tuple by item number.</summary>
//000065:         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
//000066:         /// <param name="tuple">The tuple.</param>
//000067:         /// <param name="itemNumber">The item number.</param>
//000068:         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
//000069:         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
//000070:         {
//000071:             switch (itemNumber)
//000072:             {
//000073:                 case 0: return tuple.Item1;
//000074:                 case 1: return tuple.Item2;
//000075:                 default: throw new ArgumentOutOfRangeException("itemNumber");
//000076:             }
//000077:         }
//000078:     }
//000079: }
    }  // end .try
    finally
    {
      IL_0034:  ldloc.0
      IL_0035:  ldnull
      IL_0036:  ceq
      IL_0038:  stloc.3
      IL_0039:  ldloc.3
      IL_003a:  brtrue.s   IL_0043

      IL_003c:  ldloc.0
      IL_003d:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_0042:  nop
      IL_0043:  endfinally
    }  // end handler
    IL_0044:  nop
//000033:         }
    IL_0045:  ldloc.2
    IL_0046:  ret
  } // end of method Utilities::DeepClone

  .method public hidebysig static class [System.Drawing]System.Drawing.Bitmap 
          CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image source) cil managed
  {
    // Code size       17 (0x11)
    .maxstack  2
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000034: 
//000035:         /// <summary>Clones an image into a new Bitmap.</summary>
//000036:         /// <param name="source">The source image.</param>
//000037:         /// <returns>The new Bitmap.</returns>
//000038:         public static Bitmap CreateNewBitmapFrom(Image source) 
//000039:         { 
    IL_0000:  nop
//000040:             return CreateNewBitmapFrom(source, 1); 
    IL_0001:  ldarg.0
    IL_0002:  ldc.r4     1.
    IL_0007:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image,
                                                                                                                  float32)
    IL_000c:  stloc.0
    IL_000d:  br.s       IL_000f

//000041:         }
    IL_000f:  ldloc.0
    IL_0010:  ret
  } // end of method Utilities::CreateNewBitmapFrom

  .method public hidebysig static class [System.Drawing]System.Drawing.Bitmap 
          CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image source,
                              float32 scalingFactor) cil managed
  {
    // Code size       32 (0x20)
    .maxstack  4
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap CS$1$0000)
//000042: 
//000043:         /// <summary>Creates a copy of the source image by scaling it with the specified scale value.</summary>
//000044:         /// <param name="source">The source image.</param>
//000045:         /// <param name="scalingFactor">The scaling factor to use when generating the target image.</param>
//000046:         /// <returns>The new Bitmap.</returns>
//000047:         public static Bitmap CreateNewBitmapFrom(Image source, float scalingFactor)
//000048:         {
    IL_0000:  nop
//000049:             return CreateNewBitmapFrom(source, (int)(source.Width*scalingFactor), (int)(source.Height*scalingFactor));
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0008:  conv.r4
    IL_0009:  ldarg.1
    IL_000a:  mul
    IL_000b:  conv.i4
    IL_000c:  ldarg.0
    IL_000d:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0012:  conv.r4
    IL_0013:  ldarg.1
    IL_0014:  mul
    IL_0015:  conv.i4
    IL_0016:  call       class [System.Drawing]System.Drawing.Bitmap ParallelMorph.Utilities::CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image,
                                                                                                                  int32,
                                                                                                                  int32)
    IL_001b:  stloc.0
    IL_001c:  br.s       IL_001e

//000050:         }
    IL_001e:  ldloc.0
    IL_001f:  ret
  } // end of method Utilities::CreateNewBitmapFrom

  .method public hidebysig static class [System.Drawing]System.Drawing.Bitmap 
          CreateNewBitmapFrom(class [System.Drawing]System.Drawing.Image source,
                              int32 targetWidth,
                              int32 targetHeight) cil managed
  {
    // Code size       68 (0x44)
    .maxstack  6
    .locals init ([0] class [System.Drawing]System.Drawing.Bitmap newBmp,
             [1] class [System.Drawing]System.Drawing.Graphics g,
             [2] class [System.Drawing]System.Drawing.Bitmap CS$1$0000,
             [3] bool CS$4$0001)
//000051: 
//000052:         /// <summary>Creates a copy of the source image using the specified target width and height.</summary>
//000053:         /// <param name="source">The source image.</param>
//000054:         /// <param name="targetWidth">The target width for the generated image.</param>
//000055:         /// <param name="targetHeight">The target height for the generated image.</param>
//000056:         /// <returns>The new Bitmap.</returns>
//000057:         public static Bitmap CreateNewBitmapFrom(Image source, int targetWidth, int targetHeight)
//000058:         {
    IL_0000:  nop
//000059:             var newBmp = new Bitmap(targetWidth, targetHeight, PixelFormat.Format32bppArgb);
    IL_0001:  ldarg.1
    IL_0002:  ldarg.2
    IL_0003:  ldc.i4     0x26200a
    IL_0008:  newobj     instance void [System.Drawing]System.Drawing.Bitmap::.ctor(int32,
                                                                                    int32,
                                                                                    valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_000d:  stloc.0
//000060:             using (var g = Graphics.FromImage(newBmp)) g.DrawImage(source, 0, 0, newBmp.Width, newBmp.Height);
    IL_000e:  ldloc.0
    IL_000f:  call       class [System.Drawing]System.Drawing.Graphics [System.Drawing]System.Drawing.Graphics::FromImage(class [System.Drawing]System.Drawing.Image)
    IL_0014:  stloc.1
    .try
    {
      IL_0015:  ldloc.1
      IL_0016:  ldarg.0
      IL_0017:  ldc.i4.0
      IL_0018:  ldc.i4.0
      IL_0019:  ldloc.0
      IL_001a:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
      IL_001f:  ldloc.0
      IL_0020:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
      IL_0025:  callvirt   instance void [System.Drawing]System.Drawing.Graphics::DrawImage(class [System.Drawing]System.Drawing.Image,
                                                                                            int32,
                                                                                            int32,
                                                                                            int32,
                                                                                            int32)
      IL_002a:  nop
//000061:             return newBmp;
//000062:         }
//000063: 
//000064:         /// <summary>Retrieves an element from a Tuple by item number.</summary>
//000065:         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
//000066:         /// <param name="tuple">The tuple.</param>
//000067:         /// <param name="itemNumber">The item number.</param>
//000068:         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
//000069:         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
//000070:         {
//000071:             switch (itemNumber)
//000072:             {
//000073:                 case 0: return tuple.Item1;
//000074:                 case 1: return tuple.Item2;
//000075:                 default: throw new ArgumentOutOfRangeException("itemNumber");
//000076:             }
//000077:         }
//000078:     }
//000079: }
      IL_002b:  leave.s    IL_003d

    }  // end .try
    finally
    {
      IL_002d:  ldloc.1
      IL_002e:  ldnull
      IL_002f:  ceq
      IL_0031:  stloc.3
      IL_0032:  ldloc.3
      IL_0033:  brtrue.s   IL_003c

      IL_0035:  ldloc.1
      IL_0036:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_003b:  nop
      IL_003c:  endfinally
    }  // end handler
    IL_003d:  nop
//000061:             return newBmp;
    IL_003e:  ldloc.0
    IL_003f:  stloc.2
    IL_0040:  br.s       IL_0042

//000062:         }
    IL_0042:  ldloc.2
    IL_0043:  ret
  } // end of method Utilities::CreateNewBitmapFrom

  .method public hidebysig static !!T  Item<T>(class [mscorlib]System.Tuple`2<!!T,!!T> tuple,
                                               int32 itemNumber) cil managed
  {
    .custom instance void [System.Core]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       50 (0x32)
    .maxstack  2
    .locals init ([0] !!T CS$1$0000,
             [1] int32 CS$4$0001)
//000063: 
//000064:         /// <summary>Retrieves an element from a Tuple by item number.</summary>
//000065:         /// <typeparam name="T">Specifies the type of data contained in the tuple.</typeparam>
//000066:         /// <param name="tuple">The tuple.</param>
//000067:         /// <param name="itemNumber">The item number.</param>
//000068:         /// <returns>Item1 if itemNumber is 0, otherwise Item2 if itemNumber is 1.</returns>
//000069:         public static T Item<T>(this Tuple<T, T> tuple, int itemNumber)
//000070:         {
    IL_0000:  nop
//000071:             switch (itemNumber)
    IL_0001:  ldarg.1
    IL_0002:  stloc.1
//000072:             {
//000073:                 case 0: return tuple.Item1;
//000074:                 case 1: return tuple.Item2;
//000075:                 default: throw new ArgumentOutOfRangeException("itemNumber");
//000076:             }
//000077:         }
//000078:     }
//000079: }
    IL_0003:  ldloc.1
    IL_0004:  switch     ( 
                          IL_0013,
                          IL_001c)
    IL_0011:  br.s       IL_0025

//000073:                 case 0: return tuple.Item1;
    IL_0013:  ldarg.0
    IL_0014:  callvirt   instance !0 class [mscorlib]System.Tuple`2<!!T,!!T>::get_Item1()
    IL_0019:  stloc.0
    IL_001a:  br.s       IL_0030

//000074:                 case 1: return tuple.Item2;
    IL_001c:  ldarg.0
    IL_001d:  callvirt   instance !1 class [mscorlib]System.Tuple`2<!!T,!!T>::get_Item2()
    IL_0022:  stloc.0
    IL_0023:  br.s       IL_0030

//000075:                 default: throw new ArgumentOutOfRangeException("itemNumber");
    IL_0025:  ldstr      "itemNumber"
    IL_002a:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_002f:  throw

//000076:             }
//000077:         }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Utilities::Item

} // end of class ParallelMorph.Utilities

.class public auto ansi serializable beforefieldinit ParallelMorph.LinePairCollection
       extends class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>
{
  .field private notserialized class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> _selected
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LinePairCollection.cs' 
//000021:         public LinePairCollection() {}
    IL_0000:  ldarg.0
    IL_0001:  call       instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  ret
  } // end of method LinePairCollection::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class [mscorlib]System.Collections.Generic.IList`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> source) cil managed
  {
    // Code size       11 (0xb)
    .maxstack  8
//000022:         public LinePairCollection(IList<Tuple<Line, Line>> source) : base(source) { }
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  call       instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::.ctor(class [mscorlib]System.Collections.Generic.IList`1<!0>)
    IL_0007:  nop
    IL_0008:  nop
    IL_0009:  nop
    IL_000a:  ret
  } // end of method LinePairCollection::.ctor

  .method family hidebysig virtual instance void 
          InsertItem(int32 index,
                     class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> item) cil managed
  {
    // Code size       18 (0x12)
    .maxstack  8
//000023: 
//000024:         protected override void InsertItem(int index, Tuple<Line, Line> item)
//000025:         {
    IL_0000:  nop
//000026:             base.InsertItem(index, item);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  call       instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::InsertItem(int32,
                                                                                                                                                                                                  !0)
    IL_0009:  nop
//000027:             _selected = item;
    IL_000a:  ldarg.0
    IL_000b:  ldarg.2
    IL_000c:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000028:         }
    IL_0011:  ret
  } // end of method LinePairCollection::InsertItem

  .method family hidebysig virtual instance void 
          RemoveItem(int32 index) cil managed
  {
    // Code size       48 (0x30)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000029: 
//000030:         protected override void RemoveItem(int index)
//000031:         {
    IL_0000:  nop
//000032:             base.RemoveItem(index);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::RemoveItem(int32)
    IL_0008:  nop
//000033:             if (Count > 0) _selected = this[0];
    IL_0009:  ldarg.0
    IL_000a:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_000f:  ldc.i4.0
    IL_0010:  cgt
    IL_0012:  ldc.i4.0
    IL_0013:  ceq
    IL_0015:  stloc.0
//000034:             else _selected = null;
//000035:         }
//000036: 
//000037:         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
//000038: 
//000039: 		public void SelectFirst()
//000040: 		{
//000041: 			if (Count > 0) _selected = this[0];
//000042: 		}
//000043: 
//000044: 		public void SelectLast()
//000045: 		{
//000046:             if (Count > 0) _selected = this[Count - 1];
//000047: 		}
//000048: 
//000049: 		public void SelectNext()
//000050: 		{
//000051: 			MoveToNextLine(1);
//000052: 		}
//000053: 
//000054: 		public void SelectPrev()
//000055: 		{
//000056: 			MoveToNextLine(-1);
//000057: 		}
//000058: 
//000059: 		private void MoveToNextLine(int skip)
//000060: 		{
//000061: 			if (Count > 0) 
//000062: 			{
//000063: 				if (_selected == null) SelectFirst();
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0016:  ldloc.0
    IL_0017:  brtrue.s   IL_0028

//000033:             if (Count > 0) _selected = this[0];
    IL_0019:  ldarg.0
    IL_001a:  ldarg.0
    IL_001b:  ldc.i4.0
    IL_001c:  call       instance !0 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Item(int32)
    IL_0021:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000034:             else _selected = null;
//000035:         }
//000036: 
//000037:         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
//000038: 
//000039: 		public void SelectFirst()
//000040: 		{
//000041: 			if (Count > 0) _selected = this[0];
//000042: 		}
//000043: 
//000044: 		public void SelectLast()
//000045: 		{
//000046:             if (Count > 0) _selected = this[Count - 1];
//000047: 		}
//000048: 
//000049: 		public void SelectNext()
//000050: 		{
//000051: 			MoveToNextLine(1);
//000052: 		}
//000053: 
//000054: 		public void SelectPrev()
//000055: 		{
//000056: 			MoveToNextLine(-1);
//000057: 		}
//000058: 
//000059: 		private void MoveToNextLine(int skip)
//000060: 		{
//000061: 			if (Count > 0) 
//000062: 			{
//000063: 				if (_selected == null) SelectFirst();
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0026:  br.s       IL_002f

//000034:             else _selected = null;
    IL_0028:  ldarg.0
    IL_0029:  ldnull
    IL_002a:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000035:         }
    IL_002f:  ret
  } // end of method LinePairCollection::RemoveItem

  .method public hidebysig specialname instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> 
          get_Selected() cil managed
  {
    // Code size       12 (0xc)
    .maxstack  1
    .locals init ([0] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> CS$1$0000)
//000036: 
//000037:         public Tuple<Line, Line> Selected { get { return _selected; } set { _selected = value; } }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
    IL_0007:  stloc.0
    IL_0008:  br.s       IL_000a

    IL_000a:  ldloc.0
    IL_000b:  ret
  } // end of method LinePairCollection::get_Selected

  .method public hidebysig specialname instance void 
          set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> 'value') cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
    IL_0008:  ret
  } // end of method LinePairCollection::set_Selected

  .method public hidebysig instance void 
          SelectFirst() cil managed
  {
    // Code size       31 (0x1f)
    .maxstack  3
    .locals init ([0] bool CS$4$0000)
//000038: 
//000039: 		public void SelectFirst()
//000040: 		{
    IL_0000:  nop
//000041: 			if (Count > 0) _selected = this[0];
    IL_0001:  ldarg.0
    IL_0002:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0007:  ldc.i4.0
    IL_0008:  cgt
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.0
//000042: 		}
//000043: 
//000044: 		public void SelectLast()
//000045: 		{
//000046:             if (Count > 0) _selected = this[Count - 1];
//000047: 		}
//000048: 
//000049: 		public void SelectNext()
//000050: 		{
//000051: 			MoveToNextLine(1);
//000052: 		}
//000053: 
//000054: 		public void SelectPrev()
//000055: 		{
//000056: 			MoveToNextLine(-1);
//000057: 		}
//000058: 
//000059: 		private void MoveToNextLine(int skip)
//000060: 		{
//000061: 			if (Count > 0) 
//000062: 			{
//000063: 				if (_selected == null) SelectFirst();
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_000e:  ldloc.0
    IL_000f:  brtrue.s   IL_001e

//000041: 			if (Count > 0) _selected = this[0];
    IL_0011:  ldarg.0
    IL_0012:  ldarg.0
    IL_0013:  ldc.i4.0
    IL_0014:  call       instance !0 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Item(int32)
    IL_0019:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000042: 		}
    IL_001e:  ret
  } // end of method LinePairCollection::SelectFirst

  .method public hidebysig instance void 
          SelectLast() cil managed
  {
    // Code size       38 (0x26)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
//000043: 
//000044: 		public void SelectLast()
//000045: 		{
    IL_0000:  nop
//000046:             if (Count > 0) _selected = this[Count - 1];
    IL_0001:  ldarg.0
    IL_0002:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0007:  ldc.i4.0
    IL_0008:  cgt
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.0
//000047: 		}
//000048: 
//000049: 		public void SelectNext()
//000050: 		{
//000051: 			MoveToNextLine(1);
//000052: 		}
//000053: 
//000054: 		public void SelectPrev()
//000055: 		{
//000056: 			MoveToNextLine(-1);
//000057: 		}
//000058: 
//000059: 		private void MoveToNextLine(int skip)
//000060: 		{
//000061: 			if (Count > 0) 
//000062: 			{
//000063: 				if (_selected == null) SelectFirst();
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_000e:  ldloc.0
    IL_000f:  brtrue.s   IL_0025

//000046:             if (Count > 0) _selected = this[Count - 1];
    IL_0011:  ldarg.0
    IL_0012:  ldarg.0
    IL_0013:  ldarg.0
    IL_0014:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0019:  ldc.i4.1
    IL_001a:  sub
    IL_001b:  call       instance !0 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Item(int32)
    IL_0020:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000047: 		}
    IL_0025:  ret
  } // end of method LinePairCollection::SelectLast

  .method public hidebysig instance void 
          SelectNext() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000048: 
//000049: 		public void SelectNext()
//000050: 		{
    IL_0000:  nop
//000051: 			MoveToNextLine(1);
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4.1
    IL_0003:  call       instance void ParallelMorph.LinePairCollection::MoveToNextLine(int32)
    IL_0008:  nop
//000052: 		}
    IL_0009:  ret
  } // end of method LinePairCollection::SelectNext

  .method public hidebysig instance void 
          SelectPrev() cil managed
  {
    // Code size       10 (0xa)
    .maxstack  8
//000053: 
//000054: 		public void SelectPrev()
//000055: 		{
    IL_0000:  nop
//000056: 			MoveToNextLine(-1);
    IL_0001:  ldarg.0
    IL_0002:  ldc.i4.m1
    IL_0003:  call       instance void ParallelMorph.LinePairCollection::MoveToNextLine(int32)
    IL_0008:  nop
//000057: 		}
    IL_0009:  ret
  } // end of method LinePairCollection::SelectPrev

  .method private hidebysig instance void 
          MoveToNextLine(int32 skip) cil managed
  {
    // Code size       124 (0x7c)
    .maxstack  3
    .locals init ([0] int32 index,
             [1] bool CS$4$0000)
//000058: 
//000059: 		private void MoveToNextLine(int skip)
//000060: 		{
    IL_0000:  nop
//000061: 			if (Count > 0) 
    IL_0001:  ldarg.0
    IL_0002:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0007:  ldc.i4.0
    IL_0008:  cgt
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.1
//000062: 			{
//000063: 				if (_selected == null) SelectFirst();
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_000e:  ldloc.1
    IL_000f:  brtrue.s   IL_007b

//000062: 			{
    IL_0011:  nop
//000063: 				if (_selected == null) SelectFirst();
    IL_0012:  ldarg.0
    IL_0013:  ldfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
    IL_0018:  ldnull
    IL_0019:  ceq
    IL_001b:  ldc.i4.0
    IL_001c:  ceq
    IL_001e:  stloc.1
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_001f:  ldloc.1
    IL_0020:  brtrue.s   IL_002b

//000063: 				if (_selected == null) SelectFirst();
    IL_0022:  ldarg.0
    IL_0023:  call       instance void ParallelMorph.LinePairCollection::SelectFirst()
    IL_0028:  nop
//000064: 				else
//000065: 				{
//000066: 					int index = IndexOf(_selected);
//000067: 					if (index >= 0) 
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0029:  br.s       IL_007a

//000065: 				{
    IL_002b:  nop
//000066: 					int index = IndexOf(_selected);
    IL_002c:  ldarg.0
    IL_002d:  ldarg.0
    IL_002e:  ldfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
    IL_0033:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::IndexOf(!0)
    IL_0038:  stloc.0
//000067: 					if (index >= 0) 
    IL_0039:  ldloc.0
    IL_003a:  ldc.i4.0
    IL_003b:  clt
    IL_003d:  stloc.1
//000068: 					{
//000069: 						index = index + skip;
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_003e:  ldloc.1
    IL_003f:  brtrue.s   IL_0072

//000068: 					{
    IL_0041:  nop
//000069: 						index = index + skip;
    IL_0042:  ldloc.0
    IL_0043:  ldarg.1
    IL_0044:  add
    IL_0045:  stloc.0
//000070:                         while(index < 0) index += Count;
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0046:  br.s       IL_0051

//000070:                         while(index < 0) index += Count;
    IL_0048:  ldloc.0
    IL_0049:  ldarg.0
    IL_004a:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_004f:  add
    IL_0050:  stloc.0
    IL_0051:  ldloc.0
    IL_0052:  ldc.i4.0
    IL_0053:  clt
    IL_0055:  stloc.1
//000071:                         index %= Count;
//000072: 						_selected = this[index];
//000073: 					}
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0056:  ldloc.1
    IL_0057:  brtrue.s   IL_0048

//000071:                         index %= Count;
    IL_0059:  ldloc.0
    IL_005a:  ldarg.0
    IL_005b:  call       instance int32 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Count()
    IL_0060:  rem
    IL_0061:  stloc.0
//000072: 						_selected = this[index];
    IL_0062:  ldarg.0
    IL_0063:  ldarg.0
    IL_0064:  ldloc.0
    IL_0065:  call       instance !0 class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Item(int32)
    IL_006a:  stfld      class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::_selected
//000073: 					}
    IL_006f:  nop
//000074: 					else SelectFirst();
//000075: 				}
//000076: 			}
//000077: 		}
//000078:     }
//000079: }
    IL_0070:  br.s       IL_0079

//000074: 					else SelectFirst();
    IL_0072:  ldarg.0
    IL_0073:  call       instance void ParallelMorph.LinePairCollection::SelectFirst()
    IL_0078:  nop
//000075: 				}
    IL_0079:  nop
//000076: 			}
    IL_007a:  nop
//000077: 		}
    IL_007b:  ret
  } // end of method LinePairCollection::MoveToNextLine

  .property instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>
          Selected()
  {
    .get instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
    .set instance void ParallelMorph.LinePairCollection::set_Selected(class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>)
  } // end of property LinePairCollection::Selected
} // end of class ParallelMorph.LinePairCollection

.class public auto ansi serializable beforefieldinit ParallelMorph.Pair`1<T>
       extends [mscorlib]System.Object
{
  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
  .field private !T '<Item1>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private !T '<Item2>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(!T item1,
                               !T item2) cil managed
  {
    // Code size       26 (0x1a)
    .maxstack  8
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\LineAndPair.cs' 
//000023:         public Pair(T item1, T item2) { this.Item1 = item1; this.Item2 = item2; }
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ldarg.0
    IL_0009:  ldarg.1
    IL_000a:  call       instance void class ParallelMorph.Pair`1<!T>::set_Item1(!0)
    IL_000f:  nop
    IL_0010:  ldarg.0
    IL_0011:  ldarg.2
    IL_0012:  call       instance void class ParallelMorph.Pair`1<!T>::set_Item2(!0)
    IL_0017:  nop
    IL_0018:  nop
    IL_0019:  ret
  } // end of method Pair`1::.ctor

  .method public hidebysig specialname instance !T 
          get_Item1() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!T V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class ParallelMorph.Pair`1<!T>::'<Item1>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Pair`1::get_Item1

  .method public hidebysig specialname instance void 
          set_Item1(!T 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      !0 class ParallelMorph.Pair`1<!T>::'<Item1>k__BackingField'
    IL_0007:  ret
  } // end of method Pair`1::set_Item1

  .method public hidebysig specialname instance !T 
          get_Item2() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (!T V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      !0 class ParallelMorph.Pair`1<!T>::'<Item2>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method Pair`1::get_Item2

  .method public hidebysig specialname instance void 
          set_Item2(!T 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      !0 class ParallelMorph.Pair`1<!T>::'<Item2>k__BackingField'
    IL_0007:  ret
  } // end of method Pair`1::set_Item2

  .method public hidebysig specialname instance !T 
          get_Item(int32 itemNumber) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  2
    .locals init ([0] !T CS$1$0000,
             [1] int32 CS$4$0001)
//000024: 
//000025:         public T Item1 { get; set; }
//000026: 
//000027:         public T Item2 { get; set; }
//000028: 
//000029:         public T this[int itemNumber]
//000030:         {
//000031:             get
//000032:             {
    IL_0000:  nop
//000033:                 switch (itemNumber)
    IL_0001:  ldarg.1
    IL_0002:  stloc.1
//000034:                 {
//000035:                     case 0: return Item1;
//000036:                     case 1: return Item2;
//000037:                     default: throw new ArgumentOutOfRangeException("itemNumber");
//000038:                 }
//000039:             }
//000040:             set
//000041:             {
//000042:                 switch (itemNumber)
//000043:                 {
//000044:                     case 0: Item1 = value; break;
//000045:                     case 1: Item2 = value; break;
//000046:                     default: throw new ArgumentOutOfRangeException("itemNumber");
//000047:                 }
//000048:             }
//000049:         }
//000050:     }
//000051: }
    IL_0003:  ldloc.1
    IL_0004:  switch     ( 
                          IL_0013,
                          IL_001c)
    IL_0011:  br.s       IL_0025

//000035:                     case 0: return Item1;
    IL_0013:  ldarg.0
    IL_0014:  call       instance !0 class ParallelMorph.Pair`1<!T>::get_Item1()
    IL_0019:  stloc.0
    IL_001a:  br.s       IL_0030

//000036:                     case 1: return Item2;
    IL_001c:  ldarg.0
    IL_001d:  call       instance !0 class ParallelMorph.Pair`1<!T>::get_Item2()
    IL_0022:  stloc.0
    IL_0023:  br.s       IL_0030

//000037:                     default: throw new ArgumentOutOfRangeException("itemNumber");
    IL_0025:  ldstr      "itemNumber"
    IL_002a:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_002f:  throw

//000038:                 }
//000039:             }
    IL_0030:  ldloc.0
    IL_0031:  ret
  } // end of method Pair`1::get_Item

  .method public hidebysig specialname instance void 
          set_Item(int32 itemNumber,
                   !T 'value') cil managed
  {
    // Code size       51 (0x33)
    .maxstack  2
    .locals init ([0] int32 CS$4$0000)
//000040:             set
//000041:             {
    IL_0000:  nop
//000042:                 switch (itemNumber)
    IL_0001:  ldarg.1
    IL_0002:  stloc.0
//000043:                 {
//000044:                     case 0: Item1 = value; break;
//000045:                     case 1: Item2 = value; break;
//000046:                     default: throw new ArgumentOutOfRangeException("itemNumber");
//000047:                 }
//000048:             }
//000049:         }
//000050:     }
//000051: }
    IL_0003:  ldloc.0
    IL_0004:  switch     ( 
                          IL_0013,
                          IL_001d)
    IL_0011:  br.s       IL_0027

//000044:                     case 0: Item1 = value; break;
    IL_0013:  ldarg.0
    IL_0014:  ldarg.2
    IL_0015:  call       instance void class ParallelMorph.Pair`1<!T>::set_Item1(!0)
    IL_001a:  nop
    IL_001b:  br.s       IL_0032

//000045:                     case 1: Item2 = value; break;
    IL_001d:  ldarg.0
    IL_001e:  ldarg.2
    IL_001f:  call       instance void class ParallelMorph.Pair`1<!T>::set_Item2(!0)
    IL_0024:  nop
    IL_0025:  br.s       IL_0032

//000046:                     default: throw new ArgumentOutOfRangeException("itemNumber");
    IL_0027:  ldstr      "itemNumber"
    IL_002c:  newobj     instance void [mscorlib]System.ArgumentOutOfRangeException::.ctor(string)
    IL_0031:  throw

//000047:                 }
//000048:             }
    IL_0032:  ret
  } // end of method Pair`1::set_Item

  .property instance !T Item1()
  {
    .get instance !T ParallelMorph.Pair`1::get_Item1()
    .set instance void ParallelMorph.Pair`1::set_Item1(!T)
  } // end of property Pair`1::Item1
  .property instance !T Item2()
  {
    .set instance void ParallelMorph.Pair`1::set_Item2(!T)
    .get instance !T ParallelMorph.Pair`1::get_Item2()
  } // end of property Pair`1::Item2
  .property instance !T Item(int32)
  {
    .get instance !T ParallelMorph.Pair`1::get_Item(int32)
    .set instance void ParallelMorph.Pair`1::set_Item(int32,
                                                      !T)
  } // end of property Pair`1::Item
} // end of class ParallelMorph.Pair`1

.class public auto ansi serializable beforefieldinit ParallelMorph.Line
       extends class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>
{
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(valuetype [System.Drawing]System.Drawing.PointF first,
                               valuetype [System.Drawing]System.Drawing.PointF second) cil managed
  {
    // Code size       12 (0xc)
    .maxstack  8
//000017:         public Line(PointF first, PointF second) : base(first, second) { }
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  ldarg.2
    IL_0003:  call       instance void class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::.ctor(!0,
                                                                                                                          !0)
    IL_0008:  nop
    IL_0009:  nop
    IL_000a:  nop
    IL_000b:  ret
  } // end of method Line::.ctor

} // end of class ParallelMorph.Line

.class public sequential ansi sealed beforefieldinit Microsoft.Drawing.PixelData
       extends [mscorlib]System.ValueType
{
  .field public uint8 B
  .field public uint8 G
  .field public uint8 R
} // end of class Microsoft.Drawing.PixelData

.class public auto ansi beforefieldinit Microsoft.Drawing.FastBitmap
       extends [mscorlib]System.Object
       implements [mscorlib]System.IDisposable
{
  .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = ( 01 00 04 49 74 65 6D 00 00 )                      // ...Item..
  .field private class [System.Drawing]System.Drawing.Bitmap _bitmap
  .field private int32 _bytesInARow
  .field private class [System.Drawing]System.Drawing.Imaging.BitmapData _bitmapData
  .field private uint8* _pBase
  .field private valuetype Microsoft.Drawing.PixelData* _pInitPixel
  .field private bool _locked
  .field private valuetype [System.Drawing]System.Drawing.Size '<Size>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(class [System.Drawing]System.Drawing.Bitmap bmp) cil managed
  {
    // Code size       100 (0x64)
    .maxstack  4
    .locals init ([0] bool CS$4$0000)
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\Imaging\FastBitmap.cs' 
//000026:         private BitmapData _bitmapData = null;
    IL_0000:  ldarg.0
    IL_0001:  ldnull
    IL_0002:  stfld      class [System.Drawing]System.Drawing.Imaging.BitmapData Microsoft.Drawing.FastBitmap::_bitmapData
//000027:         private byte* _pBase = null;
    IL_0007:  ldarg.0
    IL_0008:  ldc.i4.0
    IL_0009:  conv.u
    IL_000a:  stfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
//000028:         private PixelData* _pInitPixel = null;
    IL_000f:  ldarg.0
    IL_0010:  ldc.i4.0
    IL_0011:  conv.u
    IL_0012:  stfld      valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::_pInitPixel
//000029:         private bool _locked = false;
    IL_0017:  ldarg.0
    IL_0018:  ldc.i4.0
    IL_0019:  stfld      bool Microsoft.Drawing.FastBitmap::_locked
//000030: 
//000031:         public FastBitmap(Bitmap bmp)
    IL_001e:  ldarg.0
    IL_001f:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0024:  nop
//000032:         {
    IL_0025:  nop
//000033:             if (bmp == null) throw new ArgumentNullException("bitmap");
    IL_0026:  ldarg.1
    IL_0027:  ldnull
    IL_0028:  ceq
    IL_002a:  ldc.i4.0
    IL_002b:  ceq
    IL_002d:  stloc.0
//000034: 
//000035:             _bitmap = bmp;
//000036:             this.Size = new Size(bmp.Width, bmp.Height);
//000037: 
//000038:             LockBitmap();
//000039:         }
//000040: 
//000041:         public Size Size { get; private set; }
//000042: 
//000043:         public PixelData* GetInitialPixelForRow(int rowNumber)
//000044:         {
//000045:             return (PixelData*)(_pBase + rowNumber * _bytesInARow);
//000046:         }
//000047: 
//000048:         public PixelData* this[int x, int y]
//000049:         {
//000050:             get { return (PixelData*)(_pBase + y * _bytesInARow + x * sizeof(PixelData)); }
//000051:         }
//000052: 
//000053:         public Color GetColor(int x, int y)
//000054:         {
//000055:             PixelData* data = this[x, y];
//000056:             return Color.FromArgb(data->R, data->G, data->B);
//000057:         }
//000058: 
//000059:         public void SetColor(int x, int y, Color c)
//000060:         {
//000061:             PixelData* data = this[x, y];
//000062:             data->R = c.R;
//000063:             data->G = c.G;
//000064:             data->B = c.B;
//000065:         }
//000066: 
//000067:         private void LockBitmap()
//000068:         {
//000069:             if (_locked) throw new InvalidOperationException("Already locked");
//000070: 
//000071:             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
//000072: 
//000073:             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
//000074:             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
//000075:             // in length. 
//000076:             _bytesInARow = bounds.Width * sizeof(PixelData);
//000077:             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
//000078: 
//000079:             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
//000080: 
//000081:             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
//000082:             _locked = true;
//000083:         }
//000084: 
//000085:         private void InitCurrentPixel()
//000086:         {
//000087:             _pInitPixel = (PixelData*)_pBase;
//000088:         }
//000089: 
//000090:         private void UnlockBitmap()
//000091:         {
//000092:             if (!_locked) throw new InvalidOperationException("Not currently locked");
//000093: 
//000094:             _bitmap.UnlockBits(_bitmapData);
//000095:             _bitmapData = null;
//000096:             _pBase = null;
//000097:             _locked = false;
//000098:         }
//000099: 
//000100:         public void Dispose()
//000101:         {
//000102:             if (_locked) UnlockBitmap();
//000103:         }
//000104:     }
//000105: }
    IL_002e:  ldloc.0
    IL_002f:  brtrue.s   IL_003c

//000033:             if (bmp == null) throw new ArgumentNullException("bitmap");
    IL_0031:  ldstr      "bitmap"
    IL_0036:  newobj     instance void [mscorlib]System.ArgumentNullException::.ctor(string)
    IL_003b:  throw

//000034: 
//000035:             _bitmap = bmp;
    IL_003c:  ldarg.0
    IL_003d:  ldarg.1
    IL_003e:  stfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Drawing.FastBitmap::_bitmap
//000036:             this.Size = new Size(bmp.Width, bmp.Height);
    IL_0043:  ldarg.0
    IL_0044:  ldarg.1
    IL_0045:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_004a:  ldarg.1
    IL_004b:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0050:  newobj     instance void [System.Drawing]System.Drawing.Size::.ctor(int32,
                                                                                  int32)
    IL_0055:  call       instance void Microsoft.Drawing.FastBitmap::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_005a:  nop
//000037: 
//000038:             LockBitmap();
    IL_005b:  ldarg.0
    IL_005c:  call       instance void Microsoft.Drawing.FastBitmap::LockBitmap()
    IL_0061:  nop
//000039:         }
    IL_0062:  nop
    IL_0063:  ret
  } // end of method FastBitmap::.ctor

  .method public hidebysig specialname instance valuetype [System.Drawing]System.Drawing.Size 
          get_Size() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (valuetype [System.Drawing]System.Drawing.Size V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Drawing.FastBitmap::'<Size>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method FastBitmap::get_Size

  .method private hidebysig specialname instance void 
          set_Size(valuetype [System.Drawing]System.Drawing.Size 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      valuetype [System.Drawing]System.Drawing.Size Microsoft.Drawing.FastBitmap::'<Size>k__BackingField'
    IL_0007:  ret
  } // end of method FastBitmap::set_Size

  .method public hidebysig instance valuetype Microsoft.Drawing.PixelData* 
          GetInitialPixelForRow(int32 rowNumber) cil managed
  {
    // Code size       22 (0x16)
    .maxstack  3
    .locals init ([0] valuetype Microsoft.Drawing.PixelData* CS$1$0000)
//000040: 
//000041:         public Size Size { get; private set; }
//000042: 
//000043:         public PixelData* GetInitialPixelForRow(int rowNumber)
//000044:         {
    IL_0000:  nop
//000045:             return (PixelData*)(_pBase + rowNumber * _bytesInARow);
    IL_0001:  ldarg.0
    IL_0002:  ldfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
    IL_0007:  ldarg.1
    IL_0008:  conv.i
    IL_0009:  ldarg.0
    IL_000a:  ldfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
    IL_000f:  mul
    IL_0010:  add
    IL_0011:  stloc.0
    IL_0012:  br.s       IL_0014

//000046:         }
    IL_0014:  ldloc.0
    IL_0015:  ret
  } // end of method FastBitmap::GetInitialPixelForRow

  .method public hidebysig specialname instance valuetype Microsoft.Drawing.PixelData* 
          get_Item(int32 x,
                   int32 y) cil managed
  {
    // Code size       32 (0x20)
    .maxstack  3
    .locals init ([0] valuetype Microsoft.Drawing.PixelData* CS$1$0000)
//000047: 
//000048:         public PixelData* this[int x, int y]
//000049:         {
//000050:             get { return (PixelData*)(_pBase + y * _bytesInARow + x * sizeof(PixelData)); }
    IL_0000:  nop
    IL_0001:  ldarg.0
    IL_0002:  ldfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
    IL_0007:  ldarg.2
    IL_0008:  conv.i
    IL_0009:  ldarg.0
    IL_000a:  ldfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
    IL_000f:  mul
    IL_0010:  add
    IL_0011:  ldarg.1
    IL_0012:  conv.i
    IL_0013:  sizeof     Microsoft.Drawing.PixelData
    IL_0019:  mul
    IL_001a:  add
    IL_001b:  stloc.0
    IL_001c:  br.s       IL_001e

    IL_001e:  ldloc.0
    IL_001f:  ret
  } // end of method FastBitmap::get_Item

  .method public hidebysig instance valuetype [System.Drawing]System.Drawing.Color 
          GetColor(int32 x,
                   int32 y) cil managed
  {
    // Code size       38 (0x26)
    .maxstack  3
    .locals init ([0] valuetype Microsoft.Drawing.PixelData* data,
             [1] valuetype [System.Drawing]System.Drawing.Color CS$1$0000)
//000051:         }
//000052: 
//000053:         public Color GetColor(int x, int y)
//000054:         {
    IL_0000:  nop
//000055:             PixelData* data = this[x, y];
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  call       instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                int32)
    IL_0009:  stloc.0
//000056:             return Color.FromArgb(data->R, data->G, data->B);
    IL_000a:  ldloc.0
    IL_000b:  ldfld      uint8 Microsoft.Drawing.PixelData::R
    IL_0010:  ldloc.0
    IL_0011:  ldfld      uint8 Microsoft.Drawing.PixelData::G
    IL_0016:  ldloc.0
    IL_0017:  ldfld      uint8 Microsoft.Drawing.PixelData::B
    IL_001c:  call       valuetype [System.Drawing]System.Drawing.Color [System.Drawing]System.Drawing.Color::FromArgb(int32,
                                                                                                                       int32,
                                                                                                                       int32)
    IL_0021:  stloc.1
    IL_0022:  br.s       IL_0024

//000057:         }
    IL_0024:  ldloc.1
    IL_0025:  ret
  } // end of method FastBitmap::GetColor

  .method public hidebysig instance void 
          SetColor(int32 x,
                   int32 y,
                   valuetype [System.Drawing]System.Drawing.Color c) cil managed
  {
    // Code size       50 (0x32)
    .maxstack  3
    .locals init ([0] valuetype Microsoft.Drawing.PixelData* data)
//000058: 
//000059:         public void SetColor(int x, int y, Color c)
//000060:         {
    IL_0000:  nop
//000061:             PixelData* data = this[x, y];
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  ldarg.2
    IL_0004:  call       instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                                int32)
    IL_0009:  stloc.0
//000062:             data->R = c.R;
    IL_000a:  ldloc.0
    IL_000b:  ldarga.s   c
    IL_000d:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_R()
    IL_0012:  stfld      uint8 Microsoft.Drawing.PixelData::R
//000063:             data->G = c.G;
    IL_0017:  ldloc.0
    IL_0018:  ldarga.s   c
    IL_001a:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_G()
    IL_001f:  stfld      uint8 Microsoft.Drawing.PixelData::G
//000064:             data->B = c.B;
    IL_0024:  ldloc.0
    IL_0025:  ldarga.s   c
    IL_0027:  call       instance uint8 [System.Drawing]System.Drawing.Color::get_B()
    IL_002c:  stfld      uint8 Microsoft.Drawing.PixelData::B
//000065:         }
    IL_0031:  ret
  } // end of method FastBitmap::SetColor

  .method private hidebysig instance void 
          LockBitmap() cil managed
  {
    // Code size       167 (0xa7)
    .maxstack  5
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Rectangle bounds,
             [1] bool CS$4$0000,
             [2] native int CS$0$0001)
//000066: 
//000067:         private void LockBitmap()
//000068:         {
    IL_0000:  nop
//000069:             if (_locked) throw new InvalidOperationException("Already locked");
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool Microsoft.Drawing.FastBitmap::_locked
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  stloc.1
//000070: 
//000071:             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
//000072: 
//000073:             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
//000074:             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
//000075:             // in length. 
//000076:             _bytesInARow = bounds.Width * sizeof(PixelData);
//000077:             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
//000078: 
//000079:             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
//000080: 
//000081:             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
//000082:             _locked = true;
//000083:         }
//000084: 
//000085:         private void InitCurrentPixel()
//000086:         {
//000087:             _pInitPixel = (PixelData*)_pBase;
//000088:         }
//000089: 
//000090:         private void UnlockBitmap()
//000091:         {
//000092:             if (!_locked) throw new InvalidOperationException("Not currently locked");
//000093: 
//000094:             _bitmap.UnlockBits(_bitmapData);
//000095:             _bitmapData = null;
//000096:             _pBase = null;
//000097:             _locked = false;
//000098:         }
//000099: 
//000100:         public void Dispose()
//000101:         {
//000102:             if (_locked) UnlockBitmap();
//000103:         }
//000104:     }
//000105: }
    IL_000b:  ldloc.1
    IL_000c:  brtrue.s   IL_0019

//000069:             if (_locked) throw new InvalidOperationException("Already locked");
    IL_000e:  ldstr      "Already locked"
    IL_0013:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0018:  throw

//000070: 
//000071:             Rectangle bounds = new Rectangle(0, 0, _bitmap.Width, _bitmap.Height);
    IL_0019:  ldloca.s   bounds
    IL_001b:  ldc.i4.0
    IL_001c:  ldc.i4.0
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Drawing.FastBitmap::_bitmap
    IL_0023:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0028:  ldarg.0
    IL_0029:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Drawing.FastBitmap::_bitmap
    IL_002e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0033:  call       instance void [System.Drawing]System.Drawing.Rectangle::.ctor(int32,
                                                                                       int32,
                                                                                       int32,
                                                                                       int32)
    IL_0038:  nop
//000072: 
//000073:             // Figure out the number of bytes in a row. This is rounded up to be a multiple 
//000074:             // of 4 bytes, since a scan line in an image must always be a multiple of 4 bytes
//000075:             // in length. 
//000076:             _bytesInARow = bounds.Width * sizeof(PixelData);
    IL_0039:  ldarg.0
    IL_003a:  ldloca.s   bounds
    IL_003c:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_0041:  sizeof     Microsoft.Drawing.PixelData
    IL_0047:  mul
    IL_0048:  stfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
//000077:             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
    IL_004d:  ldarg.0
    IL_004e:  ldfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
    IL_0053:  ldc.i4.4
    IL_0054:  rem
    IL_0055:  ldc.i4.0
    IL_0056:  ceq
    IL_0058:  stloc.1
//000078: 
//000079:             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
//000080: 
//000081:             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
//000082:             _locked = true;
//000083:         }
//000084: 
//000085:         private void InitCurrentPixel()
//000086:         {
//000087:             _pInitPixel = (PixelData*)_pBase;
//000088:         }
//000089: 
//000090:         private void UnlockBitmap()
//000091:         {
//000092:             if (!_locked) throw new InvalidOperationException("Not currently locked");
//000093: 
//000094:             _bitmap.UnlockBits(_bitmapData);
//000095:             _bitmapData = null;
//000096:             _pBase = null;
//000097:             _locked = false;
//000098:         }
//000099: 
//000100:         public void Dispose()
//000101:         {
//000102:             if (_locked) UnlockBitmap();
//000103:         }
//000104:     }
//000105: }
    IL_0059:  ldloc.1
    IL_005a:  brtrue.s   IL_006e

//000077:             if (_bytesInARow % 4 != 0) _bytesInARow = 4 * (_bytesInARow / 4 + 1);
    IL_005c:  ldarg.0
    IL_005d:  ldc.i4.4
    IL_005e:  ldarg.0
    IL_005f:  ldfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
    IL_0064:  ldc.i4.4
    IL_0065:  div
    IL_0066:  ldc.i4.1
    IL_0067:  add
    IL_0068:  mul
    IL_0069:  stfld      int32 Microsoft.Drawing.FastBitmap::_bytesInARow
//000078: 
//000079:             _bitmapData = _bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
    IL_006e:  ldarg.0
    IL_006f:  ldarg.0
    IL_0070:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Drawing.FastBitmap::_bitmap
    IL_0075:  ldloc.0
    IL_0076:  ldc.i4.3
    IL_0077:  ldc.i4     0x21808
    IL_007c:  callvirt   instance class [System.Drawing]System.Drawing.Imaging.BitmapData [System.Drawing]System.Drawing.Bitmap::LockBits(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                                          valuetype [System.Drawing]System.Drawing.Imaging.ImageLockMode,
                                                                                                                                          valuetype [System.Drawing]System.Drawing.Imaging.PixelFormat)
    IL_0081:  stfld      class [System.Drawing]System.Drawing.Imaging.BitmapData Microsoft.Drawing.FastBitmap::_bitmapData
//000080: 
//000081:             _pBase = (byte*)_bitmapData.Scan0.ToPointer();
    IL_0086:  ldarg.0
    IL_0087:  ldarg.0
    IL_0088:  ldfld      class [System.Drawing]System.Drawing.Imaging.BitmapData Microsoft.Drawing.FastBitmap::_bitmapData
    IL_008d:  callvirt   instance native int [System.Drawing]System.Drawing.Imaging.BitmapData::get_Scan0()
    IL_0092:  stloc.2
    IL_0093:  ldloca.s   CS$0$0001
    IL_0095:  call       instance void* [mscorlib]System.IntPtr::ToPointer()
    IL_009a:  stfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
//000082:             _locked = true;
    IL_009f:  ldarg.0
    IL_00a0:  ldc.i4.1
    IL_00a1:  stfld      bool Microsoft.Drawing.FastBitmap::_locked
//000083:         }
    IL_00a6:  ret
  } // end of method FastBitmap::LockBitmap

  .method private hidebysig instance void 
          InitCurrentPixel() cil managed
  {
    // Code size       14 (0xe)
    .maxstack  8
//000084: 
//000085:         private void InitCurrentPixel()
//000086:         {
    IL_0000:  nop
//000087:             _pInitPixel = (PixelData*)_pBase;
    IL_0001:  ldarg.0
    IL_0002:  ldarg.0
    IL_0003:  ldfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
    IL_0008:  stfld      valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::_pInitPixel
//000088:         }
    IL_000d:  ret
  } // end of method FastBitmap::InitCurrentPixel

  .method private hidebysig instance void 
          UnlockBitmap() cil managed
  {
    // Code size       63 (0x3f)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000089: 
//000090:         private void UnlockBitmap()
//000091:         {
    IL_0000:  nop
//000092:             if (!_locked) throw new InvalidOperationException("Not currently locked");
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool Microsoft.Drawing.FastBitmap::_locked
    IL_0007:  stloc.0
//000093: 
//000094:             _bitmap.UnlockBits(_bitmapData);
//000095:             _bitmapData = null;
//000096:             _pBase = null;
//000097:             _locked = false;
//000098:         }
//000099: 
//000100:         public void Dispose()
//000101:         {
//000102:             if (_locked) UnlockBitmap();
//000103:         }
//000104:     }
//000105: }
    IL_0008:  ldloc.0
    IL_0009:  brtrue.s   IL_0016

//000092:             if (!_locked) throw new InvalidOperationException("Not currently locked");
    IL_000b:  ldstr      "Not currently locked"
    IL_0010:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor(string)
    IL_0015:  throw

//000093: 
//000094:             _bitmap.UnlockBits(_bitmapData);
    IL_0016:  ldarg.0
    IL_0017:  ldfld      class [System.Drawing]System.Drawing.Bitmap Microsoft.Drawing.FastBitmap::_bitmap
    IL_001c:  ldarg.0
    IL_001d:  ldfld      class [System.Drawing]System.Drawing.Imaging.BitmapData Microsoft.Drawing.FastBitmap::_bitmapData
    IL_0022:  callvirt   instance void [System.Drawing]System.Drawing.Bitmap::UnlockBits(class [System.Drawing]System.Drawing.Imaging.BitmapData)
    IL_0027:  nop
//000095:             _bitmapData = null;
    IL_0028:  ldarg.0
    IL_0029:  ldnull
    IL_002a:  stfld      class [System.Drawing]System.Drawing.Imaging.BitmapData Microsoft.Drawing.FastBitmap::_bitmapData
//000096:             _pBase = null;
    IL_002f:  ldarg.0
    IL_0030:  ldc.i4.0
    IL_0031:  conv.u
    IL_0032:  stfld      uint8* Microsoft.Drawing.FastBitmap::_pBase
//000097:             _locked = false;
    IL_0037:  ldarg.0
    IL_0038:  ldc.i4.0
    IL_0039:  stfld      bool Microsoft.Drawing.FastBitmap::_locked
//000098:         }
    IL_003e:  ret
  } // end of method FastBitmap::UnlockBitmap

  .method public hidebysig newslot virtual final 
          instance void  Dispose() cil managed
  {
    // Code size       22 (0x16)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000099: 
//000100:         public void Dispose()
//000101:         {
    IL_0000:  nop
//000102:             if (_locked) UnlockBitmap();
    IL_0001:  ldarg.0
    IL_0002:  ldfld      bool Microsoft.Drawing.FastBitmap::_locked
    IL_0007:  ldc.i4.0
    IL_0008:  ceq
    IL_000a:  stloc.0
//000103:         }
//000104:     }
//000105: }
    IL_000b:  ldloc.0
    IL_000c:  brtrue.s   IL_0015

//000102:             if (_locked) UnlockBitmap();
    IL_000e:  ldarg.0
    IL_000f:  call       instance void Microsoft.Drawing.FastBitmap::UnlockBitmap()
    IL_0014:  nop
//000103:         }
    IL_0015:  ret
  } // end of method FastBitmap::Dispose

  .property instance valuetype [System.Drawing]System.Drawing.Size
          Size()
  {
    .set instance void Microsoft.Drawing.FastBitmap::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    .get instance valuetype [System.Drawing]System.Drawing.Size Microsoft.Drawing.FastBitmap::get_Size()
  } // end of property FastBitmap::Size
  .property instance valuetype Microsoft.Drawing.PixelData*
          Item(int32,
               int32)
  {
    .get instance valuetype Microsoft.Drawing.PixelData* Microsoft.Drawing.FastBitmap::get_Item(int32,
                                                                                                int32)
  } // end of property FastBitmap::Item
} // end of class Microsoft.Drawing.FastBitmap

.class public auto ansi beforefieldinit ParallelMorph.LinedPictureBox
       extends [System.Windows.Forms]System.Windows.Forms.PictureBox
{
  .field private class [System.Drawing]System.Drawing.Pen _linePen
  .field private class [System.Drawing]System.Drawing.Pen _selectedLinePen
  .field private class ParallelMorph.LinePairCollection '<LinePairs>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .field private int32 '<ImageNumber>k__BackingField'
  .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       108 (0x6c)
    .maxstack  5
// Source File 'C:\Users\faa634\Desktop\book codes\couples\C#,C++,F#,VB\Morph\Morph_CSharp\UI\LinedPictureBox.cs' 
//000025: 		public LinedPictureBox()
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::.ctor()
    IL_0006:  nop
//000026: 		{
    IL_0007:  nop
//000027: 			// Create the normal line pen
//000028: 			_linePen = new Pen(Brushes.Red, 1);
    IL_0008:  ldarg.0
    IL_0009:  call       class [System.Drawing]System.Drawing.Brush [System.Drawing]System.Drawing.Brushes::get_Red()
    IL_000e:  ldc.r4     1.
    IL_0013:  newobj     instance void [System.Drawing]System.Drawing.Pen::.ctor(class [System.Drawing]System.Drawing.Brush,
                                                                                 float32)
    IL_0018:  stfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_linePen
//000029: 			_linePen.CustomEndCap = new AdjustableArrowCap(2, 2, true);
    IL_001d:  ldarg.0
    IL_001e:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_linePen
    IL_0023:  ldc.r4     2.
    IL_0028:  ldc.r4     2.
    IL_002d:  ldc.i4.1
    IL_002e:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.AdjustableArrowCap::.ctor(float32,
                                                                                                          float32,
                                                                                                          bool)
    IL_0033:  callvirt   instance void [System.Drawing]System.Drawing.Pen::set_CustomEndCap(class [System.Drawing]System.Drawing.Drawing2D.CustomLineCap)
    IL_0038:  nop
//000030: 
//000031: 			// Create the selected line pen
//000032: 			_selectedLinePen = new Pen(Brushes.Yellow, 1);
    IL_0039:  ldarg.0
    IL_003a:  call       class [System.Drawing]System.Drawing.Brush [System.Drawing]System.Drawing.Brushes::get_Yellow()
    IL_003f:  ldc.r4     1.
    IL_0044:  newobj     instance void [System.Drawing]System.Drawing.Pen::.ctor(class [System.Drawing]System.Drawing.Brush,
                                                                                 float32)
    IL_0049:  stfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_selectedLinePen
//000033: 			_selectedLinePen.CustomEndCap = new AdjustableArrowCap(2, 2, true);
    IL_004e:  ldarg.0
    IL_004f:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_selectedLinePen
    IL_0054:  ldc.r4     2.
    IL_0059:  ldc.r4     2.
    IL_005e:  ldc.i4.1
    IL_005f:  newobj     instance void [System.Drawing]System.Drawing.Drawing2D.AdjustableArrowCap::.ctor(float32,
                                                                                                          float32,
                                                                                                          bool)
    IL_0064:  callvirt   instance void [System.Drawing]System.Drawing.Pen::set_CustomEndCap(class [System.Drawing]System.Drawing.Drawing2D.CustomLineCap)
    IL_0069:  nop
//000034: 		}
    IL_006a:  nop
    IL_006b:  ret
  } // end of method LinedPictureBox::.ctor

  .method public hidebysig specialname instance class ParallelMorph.LinePairCollection 
          get_LinePairs() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (class ParallelMorph.LinePairCollection V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::'<LinePairs>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method LinedPictureBox::get_LinePairs

  .method public hidebysig specialname instance void 
          set_LinePairs(class ParallelMorph.LinePairCollection 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::'<LinePairs>k__BackingField'
    IL_0007:  ret
  } // end of method LinedPictureBox::set_LinePairs

  .method public hidebysig specialname instance int32 
          get_ImageNumber() cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       11 (0xb)
    .maxstack  1
    .locals init (int32 V_0)
    IL_0000:  ldarg.0
    IL_0001:  ldfld      int32 ParallelMorph.LinedPictureBox::'<ImageNumber>k__BackingField'
    IL_0006:  stloc.0
    IL_0007:  br.s       IL_0009

    IL_0009:  ldloc.0
    IL_000a:  ret
  } // end of method LinedPictureBox::get_ImageNumber

  .method public hidebysig specialname instance void 
          set_ImageNumber(int32 'value') cil managed
  {
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = ( 01 00 00 00 ) 
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  ldarg.1
    IL_0002:  stfld      int32 ParallelMorph.LinedPictureBox::'<ImageNumber>k__BackingField'
    IL_0007:  ret
  } // end of method LinedPictureBox::set_ImageNumber

  .method family hidebysig virtual instance void 
          Dispose(bool disposing) cil managed
  {
    // Code size       44 (0x2c)
    .maxstack  2
    .locals init ([0] bool CS$4$0000)
//000035: 
//000036: 		/// <summary>Gets or sets the morph line pairs to be drawn.</summary>
//000037:         public LinePairCollection LinePairs { get; set; }
//000038: 		/// <summary>Gets or sets the number of the morph image held by this box.</summary>
//000039: 		public int ImageNumber { get; set; }
//000040: 
//000041:         protected override void Dispose(bool disposing)
//000042:         {
    IL_0000:  nop
//000043:             if (disposing)
    IL_0001:  ldarg.1
    IL_0002:  ldc.i4.0
    IL_0003:  ceq
    IL_0005:  stloc.0
//000044:             {
//000045:                 _linePen.Dispose();
//000046:                 _selectedLinePen.Dispose();
//000047:             }
//000048:             base.Dispose(disposing);
//000049:         }
//000050: 
//000051: 		/// <summary>Renders the picture box.</summary>
//000052: 		/// <param name="e">The paint events.</param>
//000053: 		protected override void OnPaint(PaintEventArgs e)
//000054: 		{
//000055: 			// Render the base picture box (including the morph image)
//000056: 			base.OnPaint (e);
//000057: 
//000058: 			// If there are morph lines, render them.
//000059: 			if (LinePairs != null && Image != null)
//000060: 			{
//000061: 				Graphics g = e.Graphics;
//000062:                 foreach (var pair in LinePairs)
//000063: 				{
//000064:                     Line line = pair.Item(ImageNumber);
//000065: 					if (line != null)
//000066: 					{
//000067: 						g.DrawLine(
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
//000072: 				}
//000073: 			}
//000074: 		}
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
//000081:             if (Image == null) throw new InvalidOperationException();
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_0006:  ldloc.0
    IL_0007:  brtrue.s   IL_0023

//000044:             {
    IL_0009:  nop
//000045:                 _linePen.Dispose();
    IL_000a:  ldarg.0
    IL_000b:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_linePen
    IL_0010:  callvirt   instance void [System.Drawing]System.Drawing.Pen::Dispose()
    IL_0015:  nop
//000046:                 _selectedLinePen.Dispose();
    IL_0016:  ldarg.0
    IL_0017:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_selectedLinePen
    IL_001c:  callvirt   instance void [System.Drawing]System.Drawing.Pen::Dispose()
    IL_0021:  nop
//000047:             }
    IL_0022:  nop
//000048:             base.Dispose(disposing);
    IL_0023:  ldarg.0
    IL_0024:  ldarg.1
    IL_0025:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::Dispose(bool)
    IL_002a:  nop
//000049:         }
    IL_002b:  ret
  } // end of method LinedPictureBox::Dispose

  .method family hidebysig virtual instance void 
          OnPaint(class [System.Windows.Forms]System.Windows.Forms.PaintEventArgs e) cil managed
  {
    // Code size       188 (0xbc)
    .maxstack  6
    .locals init ([0] class [System.Drawing]System.Drawing.Graphics g,
             [1] class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> pair,
             [2] class ParallelMorph.Line line,
             [3] bool CS$4$0000,
             [4] class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>> CS$5$0001)
//000050: 
//000051: 		/// <summary>Renders the picture box.</summary>
//000052: 		/// <param name="e">The paint events.</param>
//000053: 		protected override void OnPaint(PaintEventArgs e)
//000054: 		{
    IL_0000:  nop
//000055: 			// Render the base picture box (including the morph image)
//000056: 			base.OnPaint (e);
    IL_0001:  ldarg.0
    IL_0002:  ldarg.1
    IL_0003:  call       instance void [System.Windows.Forms]System.Windows.Forms.PictureBox::OnPaint(class [System.Windows.Forms]System.Windows.Forms.PaintEventArgs)
    IL_0008:  nop
//000057: 
//000058: 			// If there are morph lines, render them.
//000059: 			if (LinePairs != null && Image != null)
    IL_0009:  ldarg.0
    IL_000a:  call       instance class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::get_LinePairs()
    IL_000f:  brfalse.s  IL_001c

    IL_0011:  ldarg.0
    IL_0012:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0017:  ldnull
    IL_0018:  ceq
    IL_001a:  br.s       IL_001d

    IL_001c:  ldc.i4.1
    IL_001d:  stloc.3
//000060: 			{
//000061: 				Graphics g = e.Graphics;
//000062:                 foreach (var pair in LinePairs)
//000063: 				{
//000064:                     Line line = pair.Item(ImageNumber);
//000065: 					if (line != null)
//000066: 					{
//000067: 						g.DrawLine(
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
//000072: 				}
//000073: 			}
//000074: 		}
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
//000081:             if (Image == null) throw new InvalidOperationException();
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_001e:  ldloc.3
    IL_001f:  brtrue     IL_00bb

//000060: 			{
    IL_0024:  nop
//000061: 				Graphics g = e.Graphics;
    IL_0025:  ldarg.1
    IL_0026:  callvirt   instance class [System.Drawing]System.Drawing.Graphics [System.Windows.Forms]System.Windows.Forms.PaintEventArgs::get_Graphics()
    IL_002b:  stloc.0
//000062:                 foreach (var pair in LinePairs)
    IL_002c:  nop
    IL_002d:  ldarg.0
    IL_002e:  call       instance class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::get_LinePairs()
    IL_0033:  callvirt   instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.ObjectModel.Collection`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::GetEnumerator()
    IL_0038:  stloc.s    CS$5$0001
//000063: 				{
//000064:                     Line line = pair.Item(ImageNumber);
//000065: 					if (line != null)
//000066: 					{
//000067: 						g.DrawLine(
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
//000072: 				}
//000073: 			}
//000074: 		}
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
//000081:             if (Image == null) throw new InvalidOperationException();
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    .try
    {
      IL_003a:  br.s       IL_009a

//000062:                 foreach (var pair in LinePairs)
      IL_003c:  ldloc.s    CS$5$0001
      IL_003e:  callvirt   instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line>>::get_Current()
      IL_0043:  stloc.1
//000063: 				{
      IL_0044:  nop
//000064:                     Line line = pair.Item(ImageNumber);
      IL_0045:  ldloc.1
      IL_0046:  ldarg.0
      IL_0047:  call       instance int32 ParallelMorph.LinedPictureBox::get_ImageNumber()
      IL_004c:  call       !!0 ParallelMorph.Utilities::Item<class ParallelMorph.Line>(class [mscorlib]System.Tuple`2<!!0,!!0>,
                                                                                       int32)
      IL_0051:  stloc.2
//000065: 					if (line != null)
      IL_0052:  ldloc.2
      IL_0053:  ldnull
      IL_0054:  ceq
      IL_0056:  stloc.3
//000066: 					{
//000067: 						g.DrawLine(
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
//000072: 				}
//000073: 			}
//000074: 		}
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
//000081:             if (Image == null) throw new InvalidOperationException();
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
      IL_0057:  ldloc.3
      IL_0058:  brtrue.s   IL_0099

//000066: 					{
      IL_005a:  nop
//000067: 						g.DrawLine(
      IL_005b:  ldloc.0
      IL_005c:  ldloc.1
      IL_005d:  ldarg.0
      IL_005e:  call       instance class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::get_LinePairs()
      IL_0063:  callvirt   instance class [mscorlib]System.Tuple`2<class ParallelMorph.Line,class ParallelMorph.Line> ParallelMorph.LinePairCollection::get_Selected()
      IL_0068:  beq.s      IL_0072

      IL_006a:  ldarg.0
      IL_006b:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_linePen
      IL_0070:  br.s       IL_0078

      IL_0072:  ldarg.0
      IL_0073:  ldfld      class [System.Drawing]System.Drawing.Pen ParallelMorph.LinedPictureBox::_selectedLinePen
      IL_0078:  ldarg.0
      IL_0079:  ldloc.2
      IL_007a:  ldc.i4.0
      IL_007b:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item(int32)
      IL_0080:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.LinedPictureBox::TranslateControlToImage(valuetype [System.Drawing]System.Drawing.PointF)
      IL_0085:  ldarg.0
      IL_0086:  ldloc.2
      IL_0087:  ldc.i4.1
      IL_0088:  callvirt   instance !0 class ParallelMorph.Pair`1<valuetype [System.Drawing]System.Drawing.PointF>::get_Item(int32)
      IL_008d:  call       instance valuetype [System.Drawing]System.Drawing.PointF ParallelMorph.LinedPictureBox::TranslateControlToImage(valuetype [System.Drawing]System.Drawing.PointF)
      IL_0092:  callvirt   instance void [System.Drawing]System.Drawing.Graphics::DrawLine(class [System.Drawing]System.Drawing.Pen,
                                                                                           valuetype [System.Drawing]System.Drawing.PointF,
                                                                                           valuetype [System.Drawing]System.Drawing.PointF)
      IL_0097:  nop
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
      IL_0098:  nop
//000072: 				}
      IL_0099:  nop
//000062:                 foreach (var pair in LinePairs)
      IL_009a:  ldloc.s    CS$5$0001
      IL_009c:  callvirt   instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
      IL_00a1:  stloc.3
//000063: 				{
//000064:                     Line line = pair.Item(ImageNumber);
//000065: 					if (line != null)
//000066: 					{
//000067: 						g.DrawLine(
//000068: 							pair == LinePairs.Selected ? _selectedLinePen : _linePen,
//000069:                             TranslateControlToImage(line[0]), 
//000070:                             TranslateControlToImage(line[1]));
//000071: 					}
//000072: 				}
//000073: 			}
//000074: 		}
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
//000081:             if (Image == null) throw new InvalidOperationException();
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
      IL_00a2:  ldloc.3
      IL_00a3:  brtrue.s   IL_003c

      IL_00a5:  leave.s    IL_00b9

    }  // end .try
    finally
    {
      IL_00a7:  ldloc.s    CS$5$0001
      IL_00a9:  ldnull
      IL_00aa:  ceq
      IL_00ac:  stloc.3
      IL_00ad:  ldloc.3
      IL_00ae:  brtrue.s   IL_00b8

      IL_00b0:  ldloc.s    CS$5$0001
      IL_00b2:  callvirt   instance void [mscorlib]System.IDisposable::Dispose()
      IL_00b7:  nop
      IL_00b8:  endfinally
    }  // end handler
    IL_00b9:  nop
//000073: 			}
    IL_00ba:  nop
//000074: 		}
    IL_00bb:  ret
  } // end of method LinedPictureBox::OnPaint

  .method public hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          TranslateControlToImage(valuetype [System.Drawing]System.Drawing.PointF point) cil managed
  {
    // Code size       138 (0x8a)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Rectangle targetRectangle,
             [1] valuetype [System.Drawing]System.Drawing.PointF scale,
             [2] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000,
             [3] bool CS$4$0001)
//000075: 
//000076:         /// <summary>Translates a point from control space to image space.</summary>
//000077:         /// <param name="point">The location to convert.</param>
//000078:         /// <returns>The converted location.</returns>
//000079:         public PointF TranslateControlToImage(PointF point)
//000080:         {
    IL_0000:  nop
//000081:             if (Image == null) throw new InvalidOperationException();
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.3
//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
//000085:         }
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
//000092:             if (Image == null) throw new InvalidOperationException();
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_000e:  ldloc.3
    IL_000f:  brtrue.s   IL_0017

//000081:             if (Image == null) throw new InvalidOperationException();
    IL_0011:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor()
    IL_0016:  throw

//000082:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
    IL_0017:  ldarg.0
    IL_0018:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle ParallelMorph.LinedPictureBox::ImageRectangleFromSizeMode()
    IL_001d:  stloc.0
//000083:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
    IL_001e:  ldloca.s   scale
    IL_0020:  ldloca.s   targetRectangle
    IL_0022:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_0027:  conv.r4
    IL_0028:  ldarg.0
    IL_0029:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_002e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0033:  conv.r4
    IL_0034:  div
    IL_0035:  ldloca.s   targetRectangle
    IL_0037:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_003c:  conv.r4
    IL_003d:  ldarg.0
    IL_003e:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0043:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0048:  conv.r4
    IL_0049:  div
    IL_004a:  call       instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_004f:  nop
//000084:             return new PointF(point.X * scale.X + targetRectangle.Left, point.Y * scale.Y + targetRectangle.Top);
    IL_0050:  ldarga.s   point
    IL_0052:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0057:  ldloca.s   scale
    IL_0059:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_005e:  mul
    IL_005f:  ldloca.s   targetRectangle
    IL_0061:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Left()
    IL_0066:  conv.r4
    IL_0067:  add
    IL_0068:  ldarga.s   point
    IL_006a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_006f:  ldloca.s   scale
    IL_0071:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_0076:  mul
    IL_0077:  ldloca.s   targetRectangle
    IL_0079:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Top()
    IL_007e:  conv.r4
    IL_007f:  add
    IL_0080:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_0085:  stloc.2
    IL_0086:  br.s       IL_0088

//000085:         }
    IL_0088:  ldloc.2
    IL_0089:  ret
  } // end of method LinedPictureBox::TranslateControlToImage

  .method public hidebysig instance valuetype [System.Drawing]System.Drawing.PointF 
          TranslateImageToControl(valuetype [System.Drawing]System.Drawing.PointF point) cil managed
  {
    // Code size       138 (0x8a)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Rectangle targetRectangle,
             [1] valuetype [System.Drawing]System.Drawing.PointF scale,
             [2] valuetype [System.Drawing]System.Drawing.PointF CS$1$0000,
             [3] bool CS$4$0001)
//000086: 
//000087:         /// <summary>Translates a point from image space to control space.</summary>
//000088:         /// <param name="point">The location to convert.</param>
//000089:         /// <returns>The converted location.</returns>
//000090:         public PointF TranslateImageToControl(PointF point)
//000091:         {
    IL_0000:  nop
//000092:             if (Image == null) throw new InvalidOperationException();
    IL_0001:  ldarg.0
    IL_0002:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0007:  ldnull
    IL_0008:  ceq
    IL_000a:  ldc.i4.0
    IL_000b:  ceq
    IL_000d:  stloc.3
//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
//000096:         }
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
//000100:             rect.X += padding.Left;
//000101:             rect.Y += padding.Top;
//000102:             rect.Width -= padding.Horizontal;
//000103:             rect.Height -= padding.Vertical;
//000104:             return rect;
//000105:         }
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
//000110:             if (this.Image != null)
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_000e:  ldloc.3
    IL_000f:  brtrue.s   IL_0017

//000092:             if (Image == null) throw new InvalidOperationException();
    IL_0011:  newobj     instance void [mscorlib]System.InvalidOperationException::.ctor()
    IL_0016:  throw

//000093:             Rectangle targetRectangle = ImageRectangleFromSizeMode();
    IL_0017:  ldarg.0
    IL_0018:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle ParallelMorph.LinedPictureBox::ImageRectangleFromSizeMode()
    IL_001d:  stloc.0
//000094:             PointF scale = new PointF(targetRectangle.Width / (float)Image.Width, targetRectangle.Height / (float)Image.Height);
    IL_001e:  ldloca.s   scale
    IL_0020:  ldloca.s   targetRectangle
    IL_0022:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_0027:  conv.r4
    IL_0028:  ldarg.0
    IL_0029:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_002e:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0033:  conv.r4
    IL_0034:  div
    IL_0035:  ldloca.s   targetRectangle
    IL_0037:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_003c:  conv.r4
    IL_003d:  ldarg.0
    IL_003e:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0043:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_0048:  conv.r4
    IL_0049:  div
    IL_004a:  call       instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_004f:  nop
//000095:             return new PointF((point.X - targetRectangle.Left) / scale.X, (point.Y - targetRectangle.Top) / scale.Y);
    IL_0050:  ldarga.s   point
    IL_0052:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0057:  ldloca.s   targetRectangle
    IL_0059:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Left()
    IL_005e:  conv.r4
    IL_005f:  sub
    IL_0060:  ldloca.s   scale
    IL_0062:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_X()
    IL_0067:  div
    IL_0068:  ldarga.s   point
    IL_006a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_006f:  ldloca.s   targetRectangle
    IL_0071:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Top()
    IL_0076:  conv.r4
    IL_0077:  sub
    IL_0078:  ldloca.s   scale
    IL_007a:  call       instance float32 [System.Drawing]System.Drawing.PointF::get_Y()
    IL_007f:  div
    IL_0080:  newobj     instance void [System.Drawing]System.Drawing.PointF::.ctor(float32,
                                                                                    float32)
    IL_0085:  stloc.2
    IL_0086:  br.s       IL_0088

//000096:         }
    IL_0088:  ldloc.2
    IL_0089:  ret
  } // end of method LinedPictureBox::TranslateImageToControl

  .method public hidebysig static valuetype [System.Drawing]System.Drawing.Rectangle 
          DeflateRect(valuetype [System.Drawing]System.Drawing.Rectangle rect,
                      valuetype [System.Windows.Forms]System.Windows.Forms.Padding padding) cil managed
  {
    // Code size       95 (0x5f)
    .maxstack  3
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Rectangle CS$1$0000)
//000097: 
//000098:         public static Rectangle DeflateRect(Rectangle rect, Padding padding)
//000099:         {
    IL_0000:  nop
//000100:             rect.X += padding.Left;
    IL_0001:  ldarga.s   rect
    IL_0003:  dup
    IL_0004:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_X()
    IL_0009:  ldarga.s   padding
    IL_000b:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Padding::get_Left()
    IL_0010:  add
    IL_0011:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_X(int32)
    IL_0016:  nop
//000101:             rect.Y += padding.Top;
    IL_0017:  ldarga.s   rect
    IL_0019:  dup
    IL_001a:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Y()
    IL_001f:  ldarga.s   padding
    IL_0021:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Padding::get_Top()
    IL_0026:  add
    IL_0027:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Y(int32)
    IL_002c:  nop
//000102:             rect.Width -= padding.Horizontal;
    IL_002d:  ldarga.s   rect
    IL_002f:  dup
    IL_0030:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_0035:  ldarga.s   padding
    IL_0037:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Padding::get_Horizontal()
    IL_003c:  sub
    IL_003d:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Width(int32)
    IL_0042:  nop
//000103:             rect.Height -= padding.Vertical;
    IL_0043:  ldarga.s   rect
    IL_0045:  dup
    IL_0046:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_004b:  ldarga.s   padding
    IL_004d:  call       instance int32 [System.Windows.Forms]System.Windows.Forms.Padding::get_Vertical()
    IL_0052:  sub
    IL_0053:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Height(int32)
    IL_0058:  nop
//000104:             return rect;
    IL_0059:  ldarg.0
    IL_005a:  stloc.0
    IL_005b:  br.s       IL_005d

//000105:         }
    IL_005d:  ldloc.0
    IL_005e:  ret
  } // end of method LinedPictureBox::DeflateRect

  .method public hidebysig instance valuetype [System.Drawing]System.Drawing.Rectangle 
          ImageRectangleFromSizeMode() cil managed
  {
    // Code size       394 (0x18a)
    .maxstack  4
    .locals init ([0] valuetype [System.Drawing]System.Drawing.Rectangle rectangle,
             [1] valuetype [System.Drawing]System.Drawing.Size size,
             [2] float32 num,
             [3] valuetype [System.Drawing]System.Drawing.Rectangle CS$1$0000,
             [4] bool CS$4$0001,
             [5] valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode CS$4$0002,
             [6] valuetype [System.Drawing]System.Drawing.Rectangle CS$0$0003)
//000106: 
//000107:         public Rectangle ImageRectangleFromSizeMode()
//000108:         {
    IL_0000:  nop
//000109:             Rectangle rectangle = DeflateRect(base.ClientRectangle, base.Padding);
    IL_0001:  ldarg.0
    IL_0002:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle [System.Windows.Forms]System.Windows.Forms.Control::get_ClientRectangle()
    IL_0007:  ldarg.0
    IL_0008:  call       instance valuetype [System.Windows.Forms]System.Windows.Forms.Padding [System.Windows.Forms]System.Windows.Forms.Control::get_Padding()
    IL_000d:  call       valuetype [System.Drawing]System.Drawing.Rectangle ParallelMorph.LinedPictureBox::DeflateRect(valuetype [System.Drawing]System.Drawing.Rectangle,
                                                                                                                       valuetype [System.Windows.Forms]System.Windows.Forms.Padding)
    IL_0012:  stloc.0
//000110:             if (this.Image != null)
    IL_0013:  ldarg.0
    IL_0014:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0019:  ldnull
    IL_001a:  ceq
    IL_001c:  stloc.s    CS$4$0001
//000111:             {
//000112:                 switch (this.SizeMode)
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_001e:  ldloc.s    CS$4$0001
    IL_0020:  brtrue     IL_0184

//000111:             {
    IL_0025:  nop
//000112:                 switch (this.SizeMode)
    IL_0026:  ldarg.0
    IL_0027:  call       instance valuetype [System.Windows.Forms]System.Windows.Forms.PictureBoxSizeMode [System.Windows.Forms]System.Windows.Forms.PictureBox::get_SizeMode()
    IL_002c:  stloc.s    CS$4$0002
//000113:                 {
//000114:                     case PictureBoxSizeMode.Normal:
//000115:                     case PictureBoxSizeMode.AutoSize:
//000116:                         rectangle.Size = this.Image.Size;
//000117:                         return rectangle;
//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
//000125:                         rectangle.Size = this.Image.Size;
//000126:                         return rectangle;
//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
//000131:                         rectangle.Width = (int)(size.Width * num);
//000132:                         rectangle.Height = (int)(size.Height * num);
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
//000135:                         return rectangle;
//000136:                 }
//000137:             }
//000138:             return rectangle;
//000139:         }
//000140: 	}
//000141: }
    IL_002e:  ldloc.s    CS$4$0002
    IL_0030:  switch     ( 
                          IL_004e,
                          IL_0068,
                          IL_004e,
                          IL_006f,
                          IL_00d1)
    IL_0049:  br         IL_0183

//000116:                         rectangle.Size = this.Image.Size;
    IL_004e:  ldloca.s   rectangle
    IL_0050:  ldarg.0
    IL_0051:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0056:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Drawing]System.Drawing.Image::get_Size()
    IL_005b:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_0060:  nop
//000117:                         return rectangle;
    IL_0061:  ldloc.0
    IL_0062:  stloc.3
    IL_0063:  br         IL_0188

//000118: 
//000119:                     case PictureBoxSizeMode.StretchImage:
//000120:                         return rectangle;
    IL_0068:  ldloc.0
    IL_0069:  stloc.3
    IL_006a:  br         IL_0188

//000121: 
//000122:                     case PictureBoxSizeMode.CenterImage:
//000123:                         rectangle.X += (rectangle.Width - this.Image.Width) / 2;
    IL_006f:  ldloca.s   rectangle
    IL_0071:  dup
    IL_0072:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_X()
    IL_0077:  ldloca.s   rectangle
    IL_0079:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_007e:  ldarg.0
    IL_007f:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_0084:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Width()
    IL_0089:  sub
    IL_008a:  ldc.i4.2
    IL_008b:  div
    IL_008c:  add
    IL_008d:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_X(int32)
    IL_0092:  nop
//000124:                         rectangle.Y += (rectangle.Height - this.Image.Height) / 2;
    IL_0093:  ldloca.s   rectangle
    IL_0095:  dup
    IL_0096:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Y()
    IL_009b:  ldloca.s   rectangle
    IL_009d:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_00a2:  ldarg.0
    IL_00a3:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00a8:  callvirt   instance int32 [System.Drawing]System.Drawing.Image::get_Height()
    IL_00ad:  sub
    IL_00ae:  ldc.i4.2
    IL_00af:  div
    IL_00b0:  add
    IL_00b1:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Y(int32)
    IL_00b6:  nop
//000125:                         rectangle.Size = this.Image.Size;
    IL_00b7:  ldloca.s   rectangle
    IL_00b9:  ldarg.0
    IL_00ba:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00bf:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Drawing]System.Drawing.Image::get_Size()
    IL_00c4:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Size(valuetype [System.Drawing]System.Drawing.Size)
    IL_00c9:  nop
//000126:                         return rectangle;
    IL_00ca:  ldloc.0
    IL_00cb:  stloc.3
    IL_00cc:  br         IL_0188

//000127: 
//000128:                     case PictureBoxSizeMode.Zoom:
//000129:                         Size size = this.Image.Size;
    IL_00d1:  ldarg.0
    IL_00d2:  call       instance class [System.Drawing]System.Drawing.Image [System.Windows.Forms]System.Windows.Forms.PictureBox::get_Image()
    IL_00d7:  callvirt   instance valuetype [System.Drawing]System.Drawing.Size [System.Drawing]System.Drawing.Image::get_Size()
    IL_00dc:  stloc.1
//000130:                         float num = Math.Min((float)(((float)base.ClientRectangle.Width) / ((float)size.Width)), (float)(((float)base.ClientRectangle.Height) / ((float)size.Height)));
    IL_00dd:  ldarg.0
    IL_00de:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle [System.Windows.Forms]System.Windows.Forms.Control::get_ClientRectangle()
    IL_00e3:  stloc.s    CS$0$0003
    IL_00e5:  ldloca.s   CS$0$0003
    IL_00e7:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_00ec:  conv.r4
    IL_00ed:  ldloca.s   size
    IL_00ef:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_00f4:  conv.r4
    IL_00f5:  div
    IL_00f6:  conv.r4
    IL_00f7:  ldarg.0
    IL_00f8:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle [System.Windows.Forms]System.Windows.Forms.Control::get_ClientRectangle()
    IL_00fd:  stloc.s    CS$0$0003
    IL_00ff:  ldloca.s   CS$0$0003
    IL_0101:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_0106:  conv.r4
    IL_0107:  ldloca.s   size
    IL_0109:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_010e:  conv.r4
    IL_010f:  div
    IL_0110:  conv.r4
    IL_0111:  call       float32 [mscorlib]System.Math::Min(float32,
                                                            float32)
    IL_0116:  stloc.2
//000131:                         rectangle.Width = (int)(size.Width * num);
    IL_0117:  ldloca.s   rectangle
    IL_0119:  ldloca.s   size
    IL_011b:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Width()
    IL_0120:  conv.r4
    IL_0121:  ldloc.2
    IL_0122:  mul
    IL_0123:  conv.i4
    IL_0124:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Width(int32)
    IL_0129:  nop
//000132:                         rectangle.Height = (int)(size.Height * num);
    IL_012a:  ldloca.s   rectangle
    IL_012c:  ldloca.s   size
    IL_012e:  call       instance int32 [System.Drawing]System.Drawing.Size::get_Height()
    IL_0133:  conv.r4
    IL_0134:  ldloc.2
    IL_0135:  mul
    IL_0136:  conv.i4
    IL_0137:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Height(int32)
    IL_013c:  nop
//000133:                         rectangle.X = (base.ClientRectangle.Width - rectangle.Width) / 2;
    IL_013d:  ldloca.s   rectangle
    IL_013f:  ldarg.0
    IL_0140:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle [System.Windows.Forms]System.Windows.Forms.Control::get_ClientRectangle()
    IL_0145:  stloc.s    CS$0$0003
    IL_0147:  ldloca.s   CS$0$0003
    IL_0149:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_014e:  ldloca.s   rectangle
    IL_0150:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Width()
    IL_0155:  sub
    IL_0156:  ldc.i4.2
    IL_0157:  div
    IL_0158:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_X(int32)
    IL_015d:  nop
//000134:                         rectangle.Y = (base.ClientRectangle.Height - rectangle.Height) / 2;
    IL_015e:  ldloca.s   rectangle
    IL_0160:  ldarg.0
    IL_0161:  call       instance valuetype [System.Drawing]System.Drawing.Rectangle [System.Windows.Forms]System.Windows.Forms.Control::get_ClientRectangle()
    IL_0166:  stloc.s    CS$0$0003
    IL_0168:  ldloca.s   CS$0$0003
    IL_016a:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_016f:  ldloca.s   rectangle
    IL_0171:  call       instance int32 [System.Drawing]System.Drawing.Rectangle::get_Height()
    IL_0176:  sub
    IL_0177:  ldc.i4.2
    IL_0178:  div
    IL_0179:  call       instance void [System.Drawing]System.Drawing.Rectangle::set_Y(int32)
    IL_017e:  nop
//000135:                         return rectangle;
    IL_017f:  ldloc.0
    IL_0180:  stloc.3
    IL_0181:  br.s       IL_0188

//000136:                 }
//000137:             }
    IL_0183:  nop
//000138:             return rectangle;
    IL_0184:  ldloc.0
    IL_0185:  stloc.3
    IL_0186:  br.s       IL_0188

//000139:         }
    IL_0188:  ldloc.3
    IL_0189:  ret
  } // end of method LinedPictureBox::ImageRectangleFromSizeMode

  .property instance class ParallelMorph.LinePairCollection
          LinePairs()
  {
    .get instance class ParallelMorph.LinePairCollection ParallelMorph.LinedPictureBox::get_LinePairs()
    .set instance void ParallelMorph.LinedPictureBox::set_LinePairs(class ParallelMorph.LinePairCollection)
  } // end of property LinedPictureBox::LinePairs
  .property instance int32 ImageNumber()
  {
    .get instance int32 ParallelMorph.LinedPictureBox::get_ImageNumber()
    .set instance void ParallelMorph.LinedPictureBox::set_ImageNumber(int32)
  } // end of property LinedPictureBox::ImageNumber
} // end of class ParallelMorph.LinedPictureBox


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
